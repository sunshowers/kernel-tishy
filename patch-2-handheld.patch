From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 20:54:57 +0100
Subject: [NA] add dev tools

---
 README       |  18 ---------
 README.md    |  21 +++++++++++
 localversion |   0
 sync-arch.sh |  22 +++++++++++
 sync-ko.sh   |  25 ++++++++++++
 sync.sh      | 105 +++++++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 173 insertions(+), 18 deletions(-)
 delete mode 100644 README
 create mode 100644 README.md
 create mode 100644 localversion
 create mode 100755 sync-arch.sh
 create mode 100755 sync-ko.sh
 create mode 100755 sync.sh

diff --git a/README b/README
deleted file mode 100644
index fd903645e6de..000000000000
--- a/README
+++ /dev/null
@@ -1,18 +0,0 @@
-Linux kernel
-============
-
-There are several guides for kernel developers and users. These guides can
-be rendered in a number of formats, like HTML and PDF. Please read
-Documentation/admin-guide/README.rst first.
-
-In order to build the documentation, use ``make htmldocs`` or
-``make pdfdocs``.  The formatted documentation can also be read online at:
-
-    https://www.kernel.org/doc/html/latest/
-
-There are various text files in the Documentation/ subdirectory,
-several of them using the reStructuredText markup notation.
-
-Please read the Documentation/process/changes.rst file, as it contains the
-requirements for building and running the kernel, and information about
-the problems which may result by upgrading your kernel.
diff --git a/README.md b/README.md
new file mode 100644
index 000000000000..0e73296bfb6c
--- /dev/null
+++ b/README.md
@@ -0,0 +1,21 @@
+# Bazzite Kernel patchwork
+
+Welcome to the Bazzite kernel patchwork repository. Here, you can find the patch series that is currently used on Bazzite, in addition to a tagged history of all the previous series.
+
+When parts of the Bazzite patch series are ready for upstreaming, you might see an additional temporary branch for them, starting with `upstream/`.
+
+## Generating srpm
+To generate an srpm from this repository, use one of the bazzite-* branches, then run:
+```bash
+dist=.fc42
+relver=1
+make -C redhat dist-srpm -j $(expr $(nproc) - 2) \
+        DIST=$dist DISTLOCALVERSION=.bazzite BUILD=$relver
+```
+
+## Contributing
+
+If you believe a patch is missing or a patch should be included, please open an issue with the patch or lore link in the [kernel-bazzite](https://github.com/hhd-dev/kernel-bazzite) repository.
+
+> [!WARNING]
+> Do not open Pull Requests or issues in this repository!! They will be closed.
\ No newline at end of file
diff --git a/localversion b/localversion
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/sync-arch.sh b/sync-arch.sh
new file mode 100755
index 000000000000..9a9c605bfee9
--- /dev/null
+++ b/sync-arch.sh
@@ -0,0 +1,22 @@
+# if [ -z "$1" ]; then
+#     echo "Usage: $0 <host>"
+#     exit 1
+# fi
+
+HOST=tbx
+USER=${USER:-dev}
+
+set -e
+
+rm -rf linux-*
+time PATH="/usr/lib/ccache/bin:$PATH" CCACHE_DIR=$(pwd)/../cache CCACHE_FILECLONE=1 CCACHE_MAXSIZE=30G make pacman-pkg -j $(expr $(nproc) - 2)
+
+scp linux-upstream-6*.pkg.tar.zst $HOST:/tmp
+scp linux-upstream-headers-6*.pkg.tar.zst $HOST:/tmp
+
+ssh $HOST /bin/bash << EOF
+    yay --noconfirm -U /tmp/linux-upstream-6* /tmp/linux-upstream-headers-6*
+    rm -rf /tmp/linux-upstream-6* /tmp/linux-upstream-headers-6*
+    sudo reboot
+EOF
+
diff --git a/sync-ko.sh b/sync-ko.sh
new file mode 100755
index 000000000000..5fbe0a4b1c1a
--- /dev/null
+++ b/sync-ko.sh
@@ -0,0 +1,25 @@
+if [ -z "$1" ]; then
+    echo "Usage: $0 <module> <host>"
+    exit 1
+fi
+
+set -e
+
+DHOST=$2
+DUSER=${DUSER:-bazzite}
+
+# Get directory from module
+DIR=$(dirname "$1")
+# Get module without .ko suffix
+MODULE=$(basename "$1")
+MODULE=${MODULE%.ko}
+MPATH=$1
+
+make -C /lib/modules/$(uname -r)/build M=$(pwd)/$DIR $MODULE.ko -j $(expr $(nproc) - 2)
+
+scp $MPATH $DHOST:/tmp/$MODULE.ko
+
+ssh $DHOST /bin/bash << EOF
+        sudo rmmod $MODULE || true
+        sudo insmod /tmp/$MODULE.ko
+EOF
\ No newline at end of file
diff --git a/sync.sh b/sync.sh
new file mode 100755
index 000000000000..cd6053bae417
--- /dev/null
+++ b/sync.sh
@@ -0,0 +1,105 @@
+#!/bin/bash
+
+# This script temporarily replaces the kernel in a remote Bazzite system
+# over ssh. You need to have passwordless sudo. First, it creates a hotfix
+# to be able to store the kernel modules in the image. Then, it creates
+# a UKI that is used to temporarily boot the new kernel.
+
+if [ -z "$1" ]; then
+    echo "Usage: $0 <host>"
+    exit 1
+fi
+
+set -e
+
+HOST=$1
+RSYNC="rsync -rv --exclude .git --exclude venv --exclude __pycache__'"
+USER=${USER:-bazzite}
+
+# openssl req -new -x509 -newkey rsa:2048 -keyout "key.pem" \
+#         -outform DER -out "cert.der" -nodes -days 36500 \
+#         -subj "/CN=antheas/"
+# openssl x509 -in cert.der -inform DER -outform PEM -out key.cert.pem
+
+# scp cert.der $host:/tmp/cert.der
+# sudo mokutil --import "/tmp/cert.der"
+
+# Prepare device on a hotfix overlay
+ssh -t $HOST sudo touch /usr/tst || \
+    ssh $HOST /bin/bash << EOF
+sudo rpm-ostree usroverlay --hotfix
+if [ \$? -eq 0 ]; then
+    echo "Applied overlay, rebooting..."
+    sudo reboot
+fi
+EOF
+
+# Update stock fedora config to make sure modules are compressed
+if grep -q 'CONFIG_LOCALVERSION=""' .config; then
+    cat >> .config << 'EOF'
+CONFIG_LOCALVERSION="-custom"
+CONFIG_MODULE_COMPRESS=y
+# CONFIG_MODULE_COMPRESS_GZIP is not set
+# CONFIG_MODULE_COMPRESS_XZ is not set
+CONFIG_MODULE_COMPRESS_ZSTD=y
+CONFIG_MODULE_COMPRESS_ALL=y
+CONFIG_MODULE_DECOMPRESS=y
+CONFIG_MODULE_COMPRESS_ZSTD_LEVEL=19
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_SPLIT=y
+EOF
+fi
+
+# Make kernel
+time PATH="/usr/lib/ccache/bin:$PATH" \
+    CCACHE_DIR=$(pwd)/../cache CCACHE_FILECLONE=1 \
+    CCACHE_MAXSIZE=30G CCACHE_IGNORECONFIG=1 \
+    make -j $(expr $(nproc) - 2)
+
+# Sync to out dir
+rm -rf out
+mkdir -p out
+make -j $(expr $(nproc) - 2) install INSTALL_PATH=./out/
+# sudo sbsign --key key.pem --cert key.cert.pem ./arch/x86/boot/bzImage --output vmlinuz
+make -j $(expr $(nproc) - 2) modules_install INSTALL_MOD_PATH=./out/
+
+KNAME=$(make -s kernelrelease)
+$RSYNC --rsync-path="sudo rsync" --delete out/lib/modules/$KNAME/ $HOST:/lib/modules/$KNAME/
+
+# Generate initramfs
+ssh $HOST /bin/bash << EOF
+sudo /usr/bin/dracut --hostonly --kver "$KNAME" --xz -v --add ostree -f /tmp/cinitramfs.img \
+    --omit="plymouth"
+sudo chmod 644 /tmp/cinitramfs.img
+EOF
+scp $HOST:/tmp/cinitramfs.img ./out/initramfs.img
+
+# Create UKI
+cmdline=`ssh -t $HOST 'cat /boot/loader/entries/ostree-*.conf' | \
+        grep 'options' | tac | head -n1 | sed 's/options //'`
+echo "Using cmdline: $cmdline"
+if [ -z "$cmdline" ]; then
+    echo "Failed to get cmdline"
+    exit 1
+fi
+
+ukify build --linux ./out/vmlinuz --initrd ./out/initramfs.img \
+       --cmdline "$cmdline" --output ./out/ukernel.efi
+
+scp ./out/ukernel.efi $HOST:/tmp/ukernel.efi
+ssh $HOST /bin/bash << EOF
+    sudo cp /tmp/ukernel.efi /boot/efi/EFI/ukernel.efi
+    bootnum=\$(sudo efibootmgr | grep "ukernel.efi" | awk '{print \$1}' | sed 's/Boot//;s/\*//')
+    if [ -z "\$bootnum" ]; then
+        # FIXME: This only works for nvmes
+        eval \$(findmnt -no SOURCE /boot/efi | sed -E 's#(/dev/[a-z0-9]+?)(p)([0-9]+)#DISK=\1 PART=\3#')
+        sudo efibootmgr --create-only \
+            --disk \$DISK --part \$PART \
+            --label "Custom Kernel" \
+            --loader /EFI/ukernel.efi
+    fi
+    bootnum=\$(sudo efibootmgr | grep "ukernel.efi" | awk '{print \$1}' | sed 's/Boot//;s/\*//')
+    echo "Boot entry found: \$bootnum"
+    sudo efibootmgr --bootnext \$bootnum
+    sudo reboot
+EOF
\ No newline at end of file
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Apr 2025 12:54:04 +0200
Subject: scsi: sd: remove unused warning inherited from fedora

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/scsi/sd.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 009da46e7027..ac2ac1321cae 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -121,7 +121,7 @@ static const char *sd_cache_types[] = {
 	"write back, no read (daft)"
 };
 
-static const char *sd_probe_types[] = { "async", "sync" };
+// static const char * sd_probe_types[] = { "async", "sync" };
 
 static char sd_probe_type[6] = "async";
 module_param_string(probe, sd_probe_type, sizeof(sd_probe_type),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sun, 9 Jun 2024 19:48:58 +0200
Subject: Revert "efi/x86: Set the PE/COFF header's NX compat flag
 unconditionally"

This reverts commit 891f8890a4a3663da7056542757022870b499bc1.

Revert because of compatibility issues of MS Surface devices and GRUB
with NX. In short, these devices get stuck on boot with NX advertised.
So to not advertise it, add the respective option back in.

Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: secureboot
---
 arch/x86/boot/header.S | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/x86/boot/header.S b/arch/x86/boot/header.S
index 9bea5a1e2c52..25848f886ad6 100644
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@ -111,7 +111,11 @@ extra_header_fields:
 	.long	salign				# SizeOfHeaders
 	.long	0				# CheckSum
 	.word	IMAGE_SUBSYSTEM_EFI_APPLICATION	# Subsystem (EFI application)
+#ifdef CONFIG_EFI_DXE_MEM_ATTRIBUTES
 	.word	IMAGE_DLLCHARACTERISTICS_NX_COMPAT	# DllCharacteristics
+#else
+	.word	0				# DllCharacteristics
+#endif
 #ifdef CONFIG_X86_32
 	.long	0				# SizeOfStackReserve
 	.long	0				# SizeOfStackCommit
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tsuchiya Yuto <kitakar@gmail.com>
Date: Sun, 18 Oct 2020 16:42:44 +0900
Subject: (surface3-oemb) add DMI matches for Surface 3 with broken DMI table

On some Surface 3, the DMI table gets corrupted for unknown reasons
and breaks existing DMI matching used for device-specific quirks.

This commit adds the (broken) DMI data into dmi_system_id tables used
for quirks so that each driver can enable quirks even on the affected
systems.

On affected systems, DMI data will look like this:
    $ grep . /sys/devices/virtual/dmi/id/{bios_vendor,board_name,board_vendor,\
    chassis_vendor,product_name,sys_vendor}
    /sys/devices/virtual/dmi/id/bios_vendor:American Megatrends Inc.
    /sys/devices/virtual/dmi/id/board_name:OEMB
    /sys/devices/virtual/dmi/id/board_vendor:OEMB
    /sys/devices/virtual/dmi/id/chassis_vendor:OEMB
    /sys/devices/virtual/dmi/id/product_name:OEMB
    /sys/devices/virtual/dmi/id/sys_vendor:OEMB

Expected:
    $ grep . /sys/devices/virtual/dmi/id/{bios_vendor,board_name,board_vendor,\
    chassis_vendor,product_name,sys_vendor}
    /sys/devices/virtual/dmi/id/bios_vendor:American Megatrends Inc.
    /sys/devices/virtual/dmi/id/board_name:Surface 3
    /sys/devices/virtual/dmi/id/board_vendor:Microsoft Corporation
    /sys/devices/virtual/dmi/id/chassis_vendor:Microsoft Corporation
    /sys/devices/virtual/dmi/id/product_name:Surface 3
    /sys/devices/virtual/dmi/id/sys_vendor:Microsoft Corporation

Signed-off-by: Tsuchiya Yuto <kitakar@gmail.com>
Patchset: surface3-oemb
---
 drivers/platform/surface/surface3-wmi.c           | 7 +++++++
 sound/soc/codecs/rt5645.c                         | 9 +++++++++
 sound/soc/intel/common/soc-acpi-intel-cht-match.c | 8 ++++++++
 3 files changed, 24 insertions(+)

diff --git a/drivers/platform/surface/surface3-wmi.c b/drivers/platform/surface/surface3-wmi.c
index 6c8fb7a4dde4..22797a53f4d8 100644
--- a/drivers/platform/surface/surface3-wmi.c
+++ b/drivers/platform/surface/surface3-wmi.c
@@ -37,6 +37,13 @@ static const struct dmi_system_id surface3_dmi_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Surface 3"),
 		},
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+	},
 #endif
 	{ }
 };
diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c
index 29a403526cd9..986f32132c3d 100644
--- a/sound/soc/codecs/rt5645.c
+++ b/sound/soc/codecs/rt5645.c
@@ -3792,6 +3792,15 @@ static const struct dmi_system_id dmi_platform_data[] = {
 		},
 		.driver_data = (void *)&intel_braswell_platform_data,
 	},
+	{
+		.ident = "Microsoft Surface 3",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+		.driver_data = (void *)&intel_braswell_platform_data,
+	},
 	{
 		/*
 		 * Match for the GPDwin which unfortunately uses somewhat
diff --git a/sound/soc/intel/common/soc-acpi-intel-cht-match.c b/sound/soc/intel/common/soc-acpi-intel-cht-match.c
index e4c3492a0c28..0b930c91bccb 100644
--- a/sound/soc/intel/common/soc-acpi-intel-cht-match.c
+++ b/sound/soc/intel/common/soc-acpi-intel-cht-match.c
@@ -27,6 +27,14 @@ static const struct dmi_system_id cht_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "Surface 3"),
 		},
 	},
+	{
+		.callback = cht_surface_quirk_cb,
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+	},
 	{ }
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20Dre=C3=9Fler?= <verdre@v0yd.nl>
Date: Tue, 3 Nov 2020 13:28:04 +0100
Subject: mwifiex: Add quirk resetting the PCI bridge on MS Surface devices

The most recent firmware of the 88W8897 card reports a hardcoded LTR
value to the system during initialization, probably as an (unsuccessful)
attempt of the developers to fix firmware crashes. This LTR value
prevents most of the Microsoft Surface devices from entering deep
powersaving states (either platform C-State 10 or S0ix state), because
the exit latency of that state would be higher than what the card can
tolerate.

Turns out the card works just the same (including the firmware crashes)
no matter if that hardcoded LTR value is reported or not, so it's kind
of useless and only prevents us from saving power.

To get rid of those hardcoded LTR reports, it's possible to reset the
PCI bridge device after initializing the cards firmware. I'm not exactly
sure why that works, maybe the power management subsystem of the PCH
resets its stored LTR values when doing a function level reset of the
bridge device. Doing the reset once after starting the wifi firmware
works very well, probably because the firmware only reports that LTR
value a single time during firmware startup.

Patchset: mwifiex
---
 drivers/net/wireless/marvell/mwifiex/pcie.c   | 12 +++++++++
 .../wireless/marvell/mwifiex/pcie_quirks.c    | 26 +++++++++++++------
 .../wireless/marvell/mwifiex/pcie_quirks.h    |  1 +
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/drivers/net/wireless/marvell/mwifiex/pcie.c b/drivers/net/wireless/marvell/mwifiex/pcie.c
index a760de191fce..db9b203226a8 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie.c
@@ -1702,9 +1702,21 @@ mwifiex_pcie_send_boot_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)
 static void mwifiex_pcie_init_fw_port(struct mwifiex_adapter *adapter)
 {
 	struct pcie_service_card *card = adapter->card;
+	struct pci_dev *pdev = card->dev;
+	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
 	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
 	int tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;
 
+	/* Trigger a function level reset of the PCI bridge device, this makes
+	 * the firmware of PCIe 88W8897 cards stop reporting a fixed LTR value
+	 * that prevents the system from entering package C10 and S0ix powersaving
+	 * states.
+	 * We need to do it here because it must happen after firmware
+	 * initialization and this function is called after that is done.
+	 */
+	if (card->quirks & QUIRK_DO_FLR_ON_BRIDGE)
+		pci_reset_function(parent_pdev);
+
 	/* Write the RX ring read pointer in to reg->rx_rdptr */
 	mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr | tx_wrap);
 }
diff --git a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
index dd6d21f1dbfd..f46b06f8d643 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
@@ -13,7 +13,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 4"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Pro 5",
@@ -22,7 +23,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1796"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Pro 5 (LTE)",
@@ -31,7 +33,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1807"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Pro 6",
@@ -39,7 +42,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 6"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Book 1",
@@ -47,7 +51,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Book 2",
@@ -55,7 +60,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book 2"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Laptop 1",
@@ -63,7 +69,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{
 		.ident = "Surface Laptop 2",
@@ -71,7 +78,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop 2"),
 		},
-		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_DO_FLR_ON_BRIDGE),
 	},
 	{}
 };
@@ -89,6 +97,8 @@ void mwifiex_initialize_quirks(struct pcie_service_card *card)
 		dev_info(&pdev->dev, "no quirks enabled\n");
 	if (card->quirks & QUIRK_FW_RST_D3COLD)
 		dev_info(&pdev->dev, "quirk reset_d3cold enabled\n");
+	if (card->quirks & QUIRK_DO_FLR_ON_BRIDGE)
+		dev_info(&pdev->dev, "quirk do_flr_on_bridge enabled\n");
 }
 
 static void mwifiex_pcie_set_power_d3cold(struct pci_dev *pdev)
diff --git a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
index d6ff964aec5b..5d30ae39d65e 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
+++ b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
@@ -4,6 +4,7 @@
 #include "pcie.h"
 
 #define QUIRK_FW_RST_D3COLD	BIT(0)
+#define QUIRK_DO_FLR_ON_BRIDGE	BIT(1)
 
 void mwifiex_initialize_quirks(struct pcie_service_card *card);
 int mwifiex_pcie_reset_d3cold_quirk(struct pci_dev *pdev);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tsuchiya Yuto <kitakar@gmail.com>
Date: Sun, 4 Oct 2020 00:11:49 +0900
Subject: mwifiex: pcie: disable bridge_d3 for Surface gen4+

Currently, mwifiex fw will crash after suspend on recent kernel series.
On Windows, it seems that the root port of wifi will never enter D3 state
(stay on D0 state). And on Linux, disabling the D3 state for the
bridge fixes fw crashing after suspend.

This commit disables the D3 state of root port on driver initialization
and fixes fw crashing after suspend.

Signed-off-by: Tsuchiya Yuto <kitakar@gmail.com>
Patchset: mwifiex
---
 drivers/net/wireless/marvell/mwifiex/pcie.c   |  7 +++++
 .../wireless/marvell/mwifiex/pcie_quirks.c    | 27 +++++++++++++------
 .../wireless/marvell/mwifiex/pcie_quirks.h    |  1 +
 3 files changed, 27 insertions(+), 8 deletions(-)

diff --git a/drivers/net/wireless/marvell/mwifiex/pcie.c b/drivers/net/wireless/marvell/mwifiex/pcie.c
index db9b203226a8..ffd0c1fe9223 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie.c
@@ -377,6 +377,7 @@ static int mwifiex_pcie_probe(struct pci_dev *pdev,
 					const struct pci_device_id *ent)
 {
 	struct pcie_service_card *card;
+	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
 	int ret;
 
 	pr_debug("info: vendor=0x%4.04X device=0x%4.04X rev=%d\n",
@@ -418,6 +419,12 @@ static int mwifiex_pcie_probe(struct pci_dev *pdev,
 		return -1;
 	}
 
+	/* disable bridge_d3 for Surface gen4+ devices to fix fw crashing
+	 * after suspend
+	 */
+	if (card->quirks & QUIRK_NO_BRIDGE_D3)
+		parent_pdev->bridge_d3 = false;
+
 	return 0;
 }
 
diff --git a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
index f46b06f8d643..99b024ecbade 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
@@ -14,7 +14,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 4"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Pro 5",
@@ -24,7 +25,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1796"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Pro 5 (LTE)",
@@ -34,7 +36,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1807"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Pro 6",
@@ -43,7 +46,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 6"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Book 1",
@@ -52,7 +56,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Book 2",
@@ -61,7 +66,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book 2"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Laptop 1",
@@ -70,7 +76,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{
 		.ident = "Surface Laptop 2",
@@ -79,7 +86,8 @@ static const struct dmi_system_id mwifiex_quirk_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop 2"),
 		},
 		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
-					QUIRK_DO_FLR_ON_BRIDGE),
+					QUIRK_DO_FLR_ON_BRIDGE |
+					QUIRK_NO_BRIDGE_D3),
 	},
 	{}
 };
@@ -99,6 +107,9 @@ void mwifiex_initialize_quirks(struct pcie_service_card *card)
 		dev_info(&pdev->dev, "quirk reset_d3cold enabled\n");
 	if (card->quirks & QUIRK_DO_FLR_ON_BRIDGE)
 		dev_info(&pdev->dev, "quirk do_flr_on_bridge enabled\n");
+	if (card->quirks & QUIRK_NO_BRIDGE_D3)
+		dev_info(&pdev->dev,
+			 "quirk no_brigde_d3 enabled\n");
 }
 
 static void mwifiex_pcie_set_power_d3cold(struct pci_dev *pdev)
diff --git a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
index 5d30ae39d65e..c14eb56eb911 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
+++ b/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
@@ -5,6 +5,7 @@
 
 #define QUIRK_FW_RST_D3COLD	BIT(0)
 #define QUIRK_DO_FLR_ON_BRIDGE	BIT(1)
+#define QUIRK_NO_BRIDGE_D3	BIT(2)
 
 void mwifiex_initialize_quirks(struct pcie_service_card *card);
 int mwifiex_pcie_reset_d3cold_quirk(struct pci_dev *pdev);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20Dre=C3=9Fler?= <verdre@v0yd.nl>
Date: Thu, 25 Mar 2021 11:33:02 +0100
Subject: Bluetooth: btusb: Lower passive lescan interval on Marvell 88W8897

The Marvell 88W8897 combined wifi and bluetooth card (pcie+usb version)
is used in a lot of Microsoft Surface devices, and all those devices
suffer from very low 2.4GHz wifi connection speeds while bluetooth is
enabled. The reason for that is that the default passive scanning
interval for Bluetooth Low Energy devices is quite high in Linux
(interval of 60 msec and scan window of 30 msec, see hci_core.c), and
the Marvell chip is known for its bad bt+wifi coexisting performance.

So decrease that passive scan interval and make the scan window shorter
on this particular device to allow for spending more time transmitting
wifi signals: The new scan interval is 250 msec (0x190 * 0.625 msec) and
the new scan window is 6.25 msec (0xa * 0,625 msec).

This change has a very large impact on the 2.4GHz wifi speeds and gets
it up to performance comparable with the Windows driver, which seems to
apply a similar quirk.

The interval and window length were tested and found to work very well
with a lot of Bluetooth Low Energy devices, including the Surface Pen, a
Bluetooth Speaker and two modern Bluetooth headphones. All devices were
discovered immediately after turning them on. Even lower values were
also tested, but they introduced longer delays until devices get
discovered.

Patchset: mwifiex
---
 drivers/bluetooth/btusb.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 3595a8bad6bd..e7a0c60286d5 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -66,6 +66,7 @@ static struct usb_driver btusb_driver;
 #define BTUSB_INTEL_BROKEN_INITIAL_NCMD BIT(25)
 #define BTUSB_INTEL_NO_WBS_SUPPORT	BIT(26)
 #define BTUSB_ACTIONS_SEMI		BIT(27)
+#define BTUSB_LOWER_LESCAN_INTERVAL	BIT(28)
 
 static const struct usb_device_id btusb_table[] = {
 	/* Generic Bluetooth USB device */
@@ -471,6 +472,7 @@ static const struct usb_device_id quirks_table[] = {
 	{ USB_DEVICE(0x1286, 0x2044), .driver_info = BTUSB_MARVELL },
 	{ USB_DEVICE(0x1286, 0x2046), .driver_info = BTUSB_MARVELL },
 	{ USB_DEVICE(0x1286, 0x204e), .driver_info = BTUSB_MARVELL },
+	{ USB_DEVICE(0x1286, 0x204c), .driver_info = BTUSB_LOWER_LESCAN_INTERVAL },
 
 	/* Intel Bluetooth devices */
 	{ USB_DEVICE(0x8087, 0x0025), .driver_info = BTUSB_INTEL_COMBINED },
@@ -4131,6 +4133,19 @@ static int btusb_probe(struct usb_interface *intf,
 	if (id->driver_info & BTUSB_MARVELL)
 		hdev->set_bdaddr = btusb_set_bdaddr_marvell;
 
+	/* The Marvell 88W8897 combined wifi and bluetooth card is known for
+	 * very bad bt+wifi coexisting performance.
+	 *
+	 * Decrease the passive BT Low Energy scan interval a bit
+	 * (0x0190 * 0.625 msec = 250 msec) and make the scan window shorter
+	 * (0x000a * 0,625 msec = 6.25 msec). This allows for significantly
+	 * higher wifi throughput while passively scanning for BT LE devices.
+	 */
+	if (id->driver_info & BTUSB_LOWER_LESCAN_INTERVAL) {
+		hdev->le_scan_interval = 0x0190;
+		hdev->le_scan_window = 0x000a;
+	}
+
 	if (IS_ENABLED(CONFIG_BT_HCIBTUSB_MTK) &&
 	    (id->driver_info & BTUSB_MEDIATEK)) {
 		hdev->setup = btusb_mtk_setup;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sat, 27 Feb 2021 00:45:52 +0100
Subject: ath10k: Add module parameters to override board files

Some Surface devices, specifically the Surface Go and AMD version of the
Surface Laptop 3 (wich both come with QCA6174 WiFi chips), work better
with a different board file, as it seems that the firmeware included
upstream is buggy.

As it is generally not a good idea to randomly overwrite files, let
alone doing so via packages, we add module parameters to override those
file names in the driver. This allows us to package/deploy the override
via a modprobe.d config.

Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: ath10k
---
 drivers/net/wireless/ath/ath10k/core.c | 57 ++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 6f78f1752cd6..8f7be9cf8a9d 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -42,6 +42,9 @@ static bool fw_diag_log;
 /* frame mode values are mapped as per enum ath10k_hw_txrx_mode */
 unsigned int ath10k_frame_mode = ATH10K_HW_TXRX_NATIVE_WIFI;
 
+static char *override_board = "";
+static char *override_board2 = "";
+
 unsigned long ath10k_coredump_mask = BIT(ATH10K_FW_CRASH_DUMP_REGISTERS) |
 				     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);
 
@@ -54,6 +57,9 @@ module_param(fw_diag_log, bool, 0644);
 module_param_named(frame_mode, ath10k_frame_mode, uint, 0644);
 module_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);
 
+module_param(override_board, charp, 0644);
+module_param(override_board2, charp, 0644);
+
 MODULE_PARM_DESC(debug_mask, "Debugging mask");
 MODULE_PARM_DESC(uart_print, "Uart target debugging");
 MODULE_PARM_DESC(skip_otp, "Skip otp failure for calibration in testmode");
@@ -63,6 +69,9 @@ MODULE_PARM_DESC(frame_mode,
 MODULE_PARM_DESC(coredump_mask, "Bitfield of what to include in firmware crash file");
 MODULE_PARM_DESC(fw_diag_log, "Diag based fw log debugging");
 
+MODULE_PARM_DESC(override_board, "Override for board.bin file");
+MODULE_PARM_DESC(override_board2, "Override for board-2.bin file");
+
 static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 	{
 		.id = QCA988X_HW_2_0_VERSION,
@@ -933,6 +942,42 @@ static int ath10k_init_configure_target(struct ath10k *ar)
 	return 0;
 }
 
+static const char *ath10k_override_board_fw_file(struct ath10k *ar,
+						 const char *file)
+{
+	if (strcmp(file, "board.bin") == 0) {
+		if (strcmp(override_board, "") == 0)
+			return file;
+
+		if (strcmp(override_board, "none") == 0) {
+			dev_info(ar->dev, "firmware override: pretending 'board.bin' does not exist\n");
+			return NULL;
+		}
+
+		dev_info(ar->dev, "firmware override: replacing 'board.bin' with '%s'\n",
+			 override_board);
+
+		return override_board;
+	}
+
+	if (strcmp(file, "board-2.bin") == 0) {
+		if (strcmp(override_board2, "") == 0)
+			return file;
+
+		if (strcmp(override_board2, "none") == 0) {
+			dev_info(ar->dev, "firmware override: pretending 'board-2.bin' does not exist\n");
+			return NULL;
+		}
+
+		dev_info(ar->dev, "firmware override: replacing 'board-2.bin' with '%s'\n",
+			 override_board2);
+
+		return override_board2;
+	}
+
+	return file;
+}
+
 static const struct firmware *ath10k_fetch_fw_file(struct ath10k *ar,
 						   const char *dir,
 						   const char *file)
@@ -947,6 +992,18 @@ static const struct firmware *ath10k_fetch_fw_file(struct ath10k *ar,
 	if (dir == NULL)
 		dir = ".";
 
+	/* HACK: Override board.bin and board-2.bin files if specified.
+	 *
+	 * Some Surface devices perform better with a different board
+	 * configuration. To this end, one would need to replace the board.bin
+	 * file with the modified config and remove the board-2.bin file.
+	 * Unfortunately, that's not a solution that we can easily package. So
+	 * we add module options to perform these overrides here.
+	 */
+	file = ath10k_override_board_fw_file(ar, file);
+	if (!file)
+		return ERR_PTR(-ENOENT);
+
 	if (ar->board_name) {
 		snprintf(filename, sizeof(filename), "%s/%s/%s",
 			 dir, ar->board_name, file);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dorian Stoll <dorian.stoll@tmsp.io>
Date: Thu, 30 Jul 2020 13:21:53 +0200
Subject: mei: me: Add Icelake device ID for iTouch

Signed-off-by: Dorian Stoll <dorian.stoll@tmsp.io>
Patchset: ipts
---
 drivers/misc/mei/hw-me-regs.h | 1 +
 drivers/misc/mei/pci-me.c     | 1 +
 2 files changed, 2 insertions(+)

diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h
index bc40b940ae21..45fbd856d416 100644
--- a/drivers/misc/mei/hw-me-regs.h
+++ b/drivers/misc/mei/hw-me-regs.h
@@ -92,6 +92,7 @@
 #define MEI_DEV_ID_CDF        0x18D3  /* Cedar Fork */
 
 #define MEI_DEV_ID_ICP_LP     0x34E0  /* Ice Lake Point LP */
+#define MEI_DEV_ID_ICP_LP_3   0x34E4  /* Ice Lake Point LP 3 (iTouch) */
 #define MEI_DEV_ID_ICP_N      0x38E0  /* Ice Lake Point N */
 
 #define MEI_DEV_ID_JSP_N      0x4DE0  /* Jasper Lake Point N */
diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c
index 3f9c60b579ae..853a67753333 100644
--- a/drivers/misc/mei/pci-me.c
+++ b/drivers/misc/mei/pci-me.c
@@ -97,6 +97,7 @@ static const struct pci_device_id mei_me_pci_tbl[] = {
 	{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_H_3, MEI_ME_PCH8_ITOUCH_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP, MEI_ME_PCH12_CFG)},
+	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP_3, MEI_ME_PCH12_CFG)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_N, MEI_ME_PCH12_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_LP, MEI_ME_PCH15_CFG)},
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Liban Hannan <liban.p@gmail.com>
Date: Tue, 12 Apr 2022 23:31:12 +0100
Subject: iommu: Use IOMMU passthrough mode for IPTS

Adds a quirk so that IOMMU uses passthrough mode for the IPTS device.
Otherwise, when IOMMU is enabled, IPTS produces DMAR errors like:

DMAR: [DMA Read NO_PASID] Request device [00:16.4] fault addr
0x104ea3000 [fault reason 0x06] PTE Read access is not set

This is very similar to the bug described at:
https://bugs.launchpad.net/bugs/1958004

Fixed with the following patch which this patch basically copies:
https://launchpadlibrarian.net/586396847/43255ca.diff

Signed-off-by: Dorian Stoll <dorian.stoll@tmsp.io>
Patchset: ipts
---
 drivers/iommu/intel/iommu.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index e236c7ec221f..9e31a5fe1f66 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -39,6 +39,11 @@
 #define IS_ISA_DEVICE(pdev) ((pdev->class >> 8) == PCI_CLASS_BRIDGE_ISA)
 #define IS_AZALIA(pdev) ((pdev)->vendor == 0x8086 && (pdev)->device == 0x3a3e)
 
+#define IS_IPTS(pdev) ( \
+		((pdev)->vendor == PCI_VENDOR_ID_INTEL && (pdev)->device == 0x9D3E) || \
+		((pdev)->vendor == PCI_VENDOR_ID_INTEL && (pdev)->device == 0x34E4) \
+	)
+
 #define IOAPIC_RANGE_START	(0xfee00000)
 #define IOAPIC_RANGE_END	(0xfeefffff)
 #define IOVA_START_ADDR		(0x1000)
@@ -209,12 +214,14 @@ int intel_iommu_sm = IS_ENABLED(CONFIG_INTEL_IOMMU_SCALABLE_MODE_DEFAULT_ON);
 int intel_iommu_enabled = 0;
 EXPORT_SYMBOL_GPL(intel_iommu_enabled);
 
+static int dmar_map_ipts = 1;
 static int intel_iommu_superpage = 1;
 static int iommu_identity_mapping;
 static int iommu_skip_te_disable;
 static int disable_igfx_iommu;
 
 #define IDENTMAP_AZALIA		4
+#define IDENTMAP_IPTS		16
 
 const struct iommu_ops intel_iommu_ops;
 static const struct iommu_dirty_ops intel_dirty_ops;
@@ -1879,6 +1886,9 @@ static int device_def_domain_type(struct device *dev)
 
 		if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
+
+		if ((iommu_identity_mapping & IDENTMAP_IPTS) && IS_IPTS(pdev))
+			return IOMMU_DOMAIN_IDENTITY;
 	}
 
 	return 0;
@@ -2169,6 +2179,9 @@ static int __init init_dmars(void)
 		iommu_set_root_entry(iommu);
 	}
 
+	if (!dmar_map_ipts)
+		iommu_identity_mapping |= IDENTMAP_IPTS;
+
 	check_tylersburg_isoch();
 
 	/*
@@ -4515,6 +4528,18 @@ static void quirk_iommu_igfx(struct pci_dev *dev)
 	disable_igfx_iommu = 1;
 }
 
+static void quirk_iommu_ipts(struct pci_dev *dev)
+{
+	if (!IS_IPTS(dev))
+		return;
+
+	if (risky_device(dev))
+		return;
+
+	pci_info(dev, "Disabling IOMMU for IPTS\n");
+	dmar_map_ipts = 0;
+}
+
 /* G4x/GM45 integrated gfx dmar support is totally busted. */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2a40, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e00, quirk_iommu_igfx);
@@ -4553,6 +4578,10 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1632, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163A, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163D, quirk_iommu_igfx);
 
+/* disable IPTS dmar support */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9D3E, quirk_iommu_ipts);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x34E4, quirk_iommu_ipts);
+
 static void quirk_iommu_rwbf(struct pci_dev *dev)
 {
 	if (risky_device(dev))
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dorian Stoll <dorian.stoll@tmsp.io>
Date: Sun, 11 Dec 2022 12:00:59 +0100
Subject: hid: Add support for Intel Precise Touch and Stylus

Based on linux-surface/intel-precise-touch@8abe268

Signed-off-by: Dorian Stoll <dorian.stoll@tmsp.io>
Patchset: ipts
---
 drivers/hid/Kconfig            |   2 +
 drivers/hid/Makefile           |   2 +
 drivers/hid/ipts/Kconfig       |  14 +
 drivers/hid/ipts/Makefile      |  16 ++
 drivers/hid/ipts/cmd.c         |  61 +++++
 drivers/hid/ipts/cmd.h         |  60 ++++
 drivers/hid/ipts/context.h     |  52 ++++
 drivers/hid/ipts/control.c     | 486 +++++++++++++++++++++++++++++++++
 drivers/hid/ipts/control.h     | 126 +++++++++
 drivers/hid/ipts/desc.h        |  80 ++++++
 drivers/hid/ipts/eds1.c        | 104 +++++++
 drivers/hid/ipts/eds1.h        |  35 +++
 drivers/hid/ipts/eds2.c        | 145 ++++++++++
 drivers/hid/ipts/eds2.h        |  35 +++
 drivers/hid/ipts/hid.c         | 225 +++++++++++++++
 drivers/hid/ipts/hid.h         |  24 ++
 drivers/hid/ipts/main.c        | 126 +++++++++
 drivers/hid/ipts/mei.c         | 188 +++++++++++++
 drivers/hid/ipts/mei.h         |  66 +++++
 drivers/hid/ipts/receiver.c    | 251 +++++++++++++++++
 drivers/hid/ipts/receiver.h    |  16 ++
 drivers/hid/ipts/resources.c   | 131 +++++++++
 drivers/hid/ipts/resources.h   |  41 +++
 drivers/hid/ipts/spec-data.h   | 100 +++++++
 drivers/hid/ipts/spec-device.h | 290 ++++++++++++++++++++
 drivers/hid/ipts/spec-hid.h    |  34 +++
 drivers/hid/ipts/thread.c      |  84 ++++++
 drivers/hid/ipts/thread.h      |  59 ++++
 28 files changed, 2853 insertions(+)
 create mode 100644 drivers/hid/ipts/Kconfig
 create mode 100644 drivers/hid/ipts/Makefile
 create mode 100644 drivers/hid/ipts/cmd.c
 create mode 100644 drivers/hid/ipts/cmd.h
 create mode 100644 drivers/hid/ipts/context.h
 create mode 100644 drivers/hid/ipts/control.c
 create mode 100644 drivers/hid/ipts/control.h
 create mode 100644 drivers/hid/ipts/desc.h
 create mode 100644 drivers/hid/ipts/eds1.c
 create mode 100644 drivers/hid/ipts/eds1.h
 create mode 100644 drivers/hid/ipts/eds2.c
 create mode 100644 drivers/hid/ipts/eds2.h
 create mode 100644 drivers/hid/ipts/hid.c
 create mode 100644 drivers/hid/ipts/hid.h
 create mode 100644 drivers/hid/ipts/main.c
 create mode 100644 drivers/hid/ipts/mei.c
 create mode 100644 drivers/hid/ipts/mei.h
 create mode 100644 drivers/hid/ipts/receiver.c
 create mode 100644 drivers/hid/ipts/receiver.h
 create mode 100644 drivers/hid/ipts/resources.c
 create mode 100644 drivers/hid/ipts/resources.h
 create mode 100644 drivers/hid/ipts/spec-data.h
 create mode 100644 drivers/hid/ipts/spec-device.h
 create mode 100644 drivers/hid/ipts/spec-hid.h
 create mode 100644 drivers/hid/ipts/thread.c
 create mode 100644 drivers/hid/ipts/thread.h

diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index b934523593d9..b2cc5db65f5b 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -1428,6 +1428,8 @@ source "drivers/hid/surface-hid/Kconfig"
 
 source "drivers/hid/intel-thc-hid/Kconfig"
 
+source "drivers/hid/ipts/Kconfig"
+
 endif # HID
 
 # USB support may be used with HID disabled
diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 10ae5dedbd84..7ba7d26391e9 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -175,3 +175,5 @@ obj-$(CONFIG_AMD_SFH_HID)       += amd-sfh-hid/
 obj-$(CONFIG_SURFACE_HID_CORE)  += surface-hid/
 
 obj-$(CONFIG_INTEL_THC_HID)     += intel-thc-hid/
+
+obj-$(CONFIG_HID_IPTS)          += ipts/
diff --git a/drivers/hid/ipts/Kconfig b/drivers/hid/ipts/Kconfig
new file mode 100644
index 000000000000..297401bd388d
--- /dev/null
+++ b/drivers/hid/ipts/Kconfig
@@ -0,0 +1,14 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+config HID_IPTS
+	tristate "Intel Precise Touch & Stylus"
+	depends on INTEL_MEI
+	depends on HID
+	help
+	  Say Y here if your system has a touchscreen using Intels
+	  Precise Touch & Stylus (IPTS) technology.
+
+	  If unsure say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ipts.
diff --git a/drivers/hid/ipts/Makefile b/drivers/hid/ipts/Makefile
new file mode 100644
index 000000000000..883896f68e6a
--- /dev/null
+++ b/drivers/hid/ipts/Makefile
@@ -0,0 +1,16 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Makefile for the IPTS touchscreen driver
+#
+
+obj-$(CONFIG_HID_IPTS) += ipts.o
+ipts-objs := cmd.o
+ipts-objs += control.o
+ipts-objs += eds1.o
+ipts-objs += eds2.o
+ipts-objs += hid.o
+ipts-objs += main.o
+ipts-objs += mei.o
+ipts-objs += receiver.o
+ipts-objs += resources.o
+ipts-objs += thread.o
diff --git a/drivers/hid/ipts/cmd.c b/drivers/hid/ipts/cmd.c
new file mode 100644
index 000000000000..63a4934bbc5f
--- /dev/null
+++ b/drivers/hid/ipts/cmd.c
@@ -0,0 +1,61 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#include "cmd.h"
+#include "context.h"
+#include "mei.h"
+#include "spec-device.h"
+
+int ipts_cmd_recv_timeout(struct ipts_context *ipts, enum ipts_command_code code,
+			  struct ipts_response *rsp, u64 timeout)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!rsp)
+		return -EFAULT;
+
+	/*
+	 * In a response, the command code will have the most significant bit flipped to 1.
+	 * If code is passed to ipts_mei_recv as is, no messages will be received.
+	 */
+	ret = ipts_mei_recv(&ipts->mei, code | IPTS_RSP_BIT, rsp, timeout);
+	if (ret < 0)
+		return ret;
+
+	dev_dbg(ipts->dev, "Received 0x%02X with status 0x%02X\n", code, rsp->status);
+
+	/*
+	 * Some devices will always return this error.
+	 * It is allowed to ignore it and to try continuing.
+	 */
+	if (rsp->status == IPTS_STATUS_COMPAT_CHECK_FAIL)
+		rsp->status = IPTS_STATUS_SUCCESS;
+
+	return 0;
+}
+
+int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size)
+{
+	struct ipts_command cmd = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	cmd.cmd = code;
+
+	if (data && size > 0)
+		memcpy(cmd.payload, data, size);
+
+	dev_dbg(ipts->dev, "Sending 0x%02X with %ld bytes payload\n", code, size);
+	return ipts_mei_send(&ipts->mei, &cmd, sizeof(cmd.cmd) + size);
+}
diff --git a/drivers/hid/ipts/cmd.h b/drivers/hid/ipts/cmd.h
new file mode 100644
index 000000000000..2b4079075b64
--- /dev/null
+++ b/drivers/hid/ipts/cmd.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_CMD_H
+#define IPTS_CMD_H
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-device.h"
+
+/*
+ * The default timeout for receiving responses
+ */
+#define IPTS_CMD_DEFAULT_TIMEOUT 1000
+
+/**
+ * ipts_cmd_recv_timeout() - Receives a response to a command.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command / response.
+ * @rsp: The address that the received response will be copied to.
+ * @timeout: How many milliseconds the function will wait at most.
+ *
+ * A negative timeout means to wait forever.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+ */
+int ipts_cmd_recv_timeout(struct ipts_context *ipts, enum ipts_command_code code,
+			  struct ipts_response *rsp, u64 timeout);
+
+/**
+ * ipts_cmd_recv() - Receives a response to a command.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command / response.
+ * @rsp: The address that the received response will be copied to.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+ */
+static inline int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code,
+				struct ipts_response *rsp)
+{
+	return ipts_cmd_recv_timeout(ipts, code, rsp, IPTS_CMD_DEFAULT_TIMEOUT);
+}
+
+/**
+ * ipts_cmd_send() - Executes a command on the device.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command to execute.
+ * @data: The payload containing parameters for the command.
+ * @size: The size of the payload.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
+
+#endif /* IPTS_CMD_H */
diff --git a/drivers/hid/ipts/context.h b/drivers/hid/ipts/context.h
new file mode 100644
index 000000000000..ba33259f1f7c
--- /dev/null
+++ b/drivers/hid/ipts/context.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_CONTEXT_H
+#define IPTS_CONTEXT_H
+
+#include <linux/completion.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include "mei.h"
+#include "resources.h"
+#include "spec-device.h"
+#include "thread.h"
+
+struct ipts_context {
+	struct device *dev;
+	struct ipts_mei mei;
+
+	enum ipts_mode mode;
+
+	/*
+	 * Prevents concurrent GET_FEATURE reports.
+	 */
+	struct mutex feature_lock;
+	struct completion feature_event;
+
+	/*
+	 * These are not inside of struct ipts_resources
+	 * because they don't own the memory they point to.
+	 */
+	struct ipts_buffer feature_report;
+	struct ipts_buffer descriptor;
+
+	bool hid_active;
+	struct hid_device *hid;
+
+	struct ipts_device_info info;
+	struct ipts_resources resources;
+
+	struct ipts_thread receiver_loop;
+};
+
+#endif /* IPTS_CONTEXT_H */
diff --git a/drivers/hid/ipts/control.c b/drivers/hid/ipts/control.c
new file mode 100644
index 000000000000..5360842d260b
--- /dev/null
+++ b/drivers/hid/ipts/control.c
@@ -0,0 +1,486 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/delay.h>
+#include <linux/dev_printk.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/types.h>
+
+#include "cmd.h"
+#include "context.h"
+#include "control.h"
+#include "desc.h"
+#include "hid.h"
+#include "receiver.h"
+#include "resources.h"
+#include "spec-data.h"
+#include "spec-device.h"
+
+static int ipts_control_get_device_info(struct ipts_context *ipts, struct ipts_device_info *info)
+{
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!info)
+		return -EFAULT;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_GET_DEVICE_INFO, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	memcpy(info, rsp.payload, sizeof(*info));
+	return 0;
+}
+
+static int ipts_control_set_mode(struct ipts_context *ipts, enum ipts_mode mode)
+{
+	int ret = 0;
+	struct ipts_set_mode cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	cmd.mode = mode;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_SET_MODE, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "SET_MODE: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_SET_MODE, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "SET_MODE: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "SET_MODE: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
+}
+
+static int ipts_control_set_mem_window(struct ipts_context *ipts, struct ipts_resources *res)
+{
+	int i = 0;
+	int ret = 0;
+	struct ipts_mem_window cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!res)
+		return -EFAULT;
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		cmd.data_addr_lower[i] = lower_32_bits(res->data[i].dma_address);
+		cmd.data_addr_upper[i] = upper_32_bits(res->data[i].dma_address);
+		cmd.feedback_addr_lower[i] = lower_32_bits(res->feedback[i].dma_address);
+		cmd.feedback_addr_upper[i] = upper_32_bits(res->feedback[i].dma_address);
+	}
+
+	cmd.workqueue_addr_lower = lower_32_bits(res->workqueue.dma_address);
+	cmd.workqueue_addr_upper = upper_32_bits(res->workqueue.dma_address);
+
+	cmd.doorbell_addr_lower = lower_32_bits(res->doorbell.dma_address);
+	cmd.doorbell_addr_upper = upper_32_bits(res->doorbell.dma_address);
+
+	cmd.hid2me_addr_lower = lower_32_bits(res->hid2me.dma_address);
+	cmd.hid2me_addr_upper = upper_32_bits(res->hid2me.dma_address);
+
+	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
+	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_SET_MEM_WINDOW, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
+}
+
+static int ipts_control_get_descriptor(struct ipts_context *ipts)
+{
+	int ret = 0;
+	struct ipts_data_header *header = NULL;
+	struct ipts_get_descriptor cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->resources.descriptor.address)
+		return -EFAULT;
+
+	memset(ipts->resources.descriptor.address, 0, ipts->resources.descriptor.size);
+
+	cmd.addr_lower = lower_32_bits(ipts->resources.descriptor.dma_address);
+	cmd.addr_upper = upper_32_bits(ipts->resources.descriptor.dma_address);
+	cmd.magic = 8;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_GET_DESCRIPTOR, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_GET_DESCRIPTOR, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	header = (struct ipts_data_header *)ipts->resources.descriptor.address;
+
+	if (header->type == IPTS_DATA_TYPE_DESCRIPTOR) {
+		ipts->descriptor.address = &header->data[8];
+		ipts->descriptor.size = header->size - 8;
+
+		return 0;
+	}
+
+	return -ENODATA;
+}
+
+int ipts_control_request_flush(struct ipts_context *ipts)
+{
+	int ret = 0;
+	struct ipts_quiesce_io cmd = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_QUIESCE_IO, &cmd, sizeof(cmd));
+	if (ret)
+		dev_err(ipts->dev, "QUIESCE_IO: send failed: %d\n", ret);
+
+	return ret;
+}
+
+int ipts_control_wait_flush(struct ipts_context *ipts)
+{
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_QUIESCE_IO, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "QUIESCE_IO: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status == IPTS_STATUS_TIMEOUT)
+		return -EAGAIN;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "QUIESCE_IO: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
+}
+
+int ipts_control_request_data(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+	if (ret)
+		dev_err(ipts->dev, "READY_FOR_DATA: send failed: %d\n", ret);
+
+	return ret;
+}
+
+int ipts_control_wait_data(struct ipts_context *ipts, bool shutdown)
+{
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!shutdown)
+		ret = ipts_cmd_recv_timeout(ipts, IPTS_CMD_READY_FOR_DATA, &rsp, 0);
+	else
+		ret = ipts_cmd_recv(ipts, IPTS_CMD_READY_FOR_DATA, &rsp);
+
+	if (ret) {
+		if (ret != -EAGAIN)
+			dev_err(ipts->dev, "READY_FOR_DATA: recv failed: %d\n", ret);
+
+		return ret;
+	}
+
+	/*
+	 * During shutdown, it is possible that the sensor has already been disabled.
+	 */
+	if (rsp.status == IPTS_STATUS_SENSOR_DISABLED)
+		return 0;
+
+	if (rsp.status == IPTS_STATUS_TIMEOUT)
+		return -EAGAIN;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "READY_FOR_DATA: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
+}
+
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer)
+{
+	int ret = 0;
+	struct ipts_feedback cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	cmd.buffer = buffer;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_FEEDBACK, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "FEEDBACK: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_FEEDBACK, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "FEEDBACK: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * We don't know what feedback data looks like so we are sending zeros.
+	 * See also ipts_control_refill_buffer.
+	 */
+	if (rsp.status == IPTS_STATUS_INVALID_PARAMS)
+		return 0;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "FEEDBACK: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
+}
+
+int ipts_control_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_cmd_type cmd,
+				 enum ipts_feedback_data_type type, void *data, size_t size)
+{
+	struct ipts_feedback_header *header = NULL;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->resources.hid2me.address)
+		return -EFAULT;
+
+	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
+	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
+
+	header->cmd_type = cmd;
+	header->data_type = type;
+	header->size = size;
+	header->buffer = IPTS_HID2ME_BUFFER;
+
+	if (size + sizeof(*header) > ipts->resources.hid2me.size)
+		return -EINVAL;
+
+	if (data && size > 0)
+		memcpy(header->payload, data, size);
+
+	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
+}
+
+int ipts_control_start(struct ipts_context *ipts)
+{
+	int ret = 0;
+	struct ipts_device_info info = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	dev_info(ipts->dev, "Starting IPTS\n");
+
+	ret = ipts_control_get_device_info(ipts, &info);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to get device info: %d\n", ret);
+		return ret;
+	}
+
+	ipts->info = info;
+
+	ret = ipts_resources_init(&ipts->resources, ipts->dev, info.data_size, info.feedback_size);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to allocate buffers: %d", ret);
+		return ret;
+	}
+
+	dev_info(ipts->dev, "IPTS EDS Version: %d\n", info.intf_eds);
+
+	/*
+	 * Handle newer devices
+	 */
+	if (info.intf_eds > 1) {
+		/*
+		 * Fetching the descriptor will only work on newer devices.
+		 * For older devices, a fallback descriptor will be used.
+		 */
+		ret = ipts_control_get_descriptor(ipts);
+		if (ret) {
+			dev_err(ipts->dev, "Failed to fetch HID descriptor: %d\n", ret);
+			return ret;
+		}
+
+		/*
+		 * Newer devices can be directly initialized in polling mode.
+		 */
+		ipts->mode = IPTS_MODE_POLL;
+	}
+
+	ret = ipts_control_set_mode(ipts, ipts->mode);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to set mode: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_control_set_mem_window(ipts, &ipts->resources);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to set memory window: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_receiver_start(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to start receiver: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_control_request_data(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to request data: %d\n", ret);
+		return ret;
+	}
+
+	ipts_hid_enable(ipts);
+
+	ret = ipts_hid_init(ipts, info);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to initialize HID device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int _ipts_control_stop(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	ipts_hid_disable(ipts);
+	dev_info(ipts->dev, "Stopping IPTS\n");
+
+	ret = ipts_receiver_stop(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to stop receiver: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_resources_free(&ipts->resources);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to free resources: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int ipts_control_stop(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	ret = _ipts_control_stop(ipts);
+	if (ret)
+		return ret;
+
+	ret = ipts_hid_free(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to free HID device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int ipts_control_restart(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	ret = _ipts_control_stop(ipts);
+	if (ret)
+		return ret;
+
+	/*
+	 * Wait a second to give the sensor time to fully shut down.
+	 */
+	msleep(1000);
+
+	ret = ipts_control_start(ipts);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff --git a/drivers/hid/ipts/control.h b/drivers/hid/ipts/control.h
new file mode 100644
index 000000000000..26629c5144ed
--- /dev/null
+++ b/drivers/hid/ipts/control.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_CONTROL_H
+#define IPTS_CONTROL_H
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-data.h"
+#include "spec-device.h"
+
+/**
+ * ipts_control_request_flush() - Stop the data flow.
+ * @ipts: The IPTS driver context.
+ *
+ * Runs the command to stop the data flow on the device.
+ * All outstanding data needs to be acknowledged using feedback before the command will return.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_request_flush(struct ipts_context *ipts);
+
+/**
+ * ipts_control_wait_flush() - Wait until data flow has been stopped.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_wait_flush(struct ipts_context *ipts);
+
+/**
+ * ipts_control_wait_flush() - Notify the device that the driver can receive new data.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_request_data(struct ipts_context *ipts);
+
+/**
+ * ipts_control_wait_data() - Wait until new data is available.
+ * @ipts: The IPTS driver context.
+ * @block: Whether to block execution until data is available.
+ *
+ * In poll mode, this function will never return while the data flow is active. Instead,
+ * the poll will be incremented when new data is available.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no data is available.
+ */
+int ipts_control_wait_data(struct ipts_context *ipts, bool block);
+
+/**
+ * ipts_control_send_feedback() - Submits a feedback buffer to the device.
+ * @ipts: The IPTS driver context.
+ * @buffer: The ID of the buffer containing feedback data.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer);
+
+/**
+ * ipts_control_hid2me_feedback() - Sends HID2ME feedback, a special type of feedback.
+ * @ipts: The IPTS driver context.
+ * @cmd: The command that will be run on the device.
+ * @type: The type of the payload that is sent to the device.
+ * @data: The payload of the feedback command.
+ * @size: The size of the payload.
+ *
+ * HID2ME feedback is a special type of feedback, because it allows interfacing with
+ * the HID API of the device at any moment, without requiring a buffer that has to
+ * be acknowledged.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_cmd_type cmd,
+				 enum ipts_feedback_data_type type, void *data, size_t size);
+
+/**
+ * ipts_control_refill_buffer() - Acknowledges that data in a buffer has been processed.
+ * @ipts: The IPTS driver context.
+ * @buffer: The buffer that has been processed and can be refilled.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+static inline int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer)
+{
+	/*
+	 * IPTS expects structured data in the feedback buffer matching the buffer that will be
+	 * refilled. We don't know what that data looks like, so we just keep the buffer empty.
+	 * This results in an INVALID_PARAMS error, but the buffer gets refilled without an issue.
+	 * Sending a minimal structure with the buffer ID fixes the error, but breaks refilling
+	 * the buffers on some devices.
+	 */
+
+	return ipts_control_send_feedback(ipts, buffer);
+}
+
+/**
+ * ipts_control_start() - Initialized the device and starts the data flow.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_start(struct ipts_context *ipts);
+
+/**
+ * ipts_control_stop() - Stops the data flow and resets the device.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_stop(struct ipts_context *ipts);
+
+/**
+ * ipts_control_restart() - Stops the device and starts it again.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_restart(struct ipts_context *ipts);
+
+#endif /* IPTS_CONTROL_H */
diff --git a/drivers/hid/ipts/desc.h b/drivers/hid/ipts/desc.h
new file mode 100644
index 000000000000..307438c7c80c
--- /dev/null
+++ b/drivers/hid/ipts/desc.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2022-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_DESC_H
+#define IPTS_DESC_H
+
+#include <linux/types.h>
+
+#define IPTS_HID_REPORT_SINGLETOUCH 64
+#define IPTS_HID_REPORT_DATA	    65
+#define IPTS_HID_REPORT_SET_MODE    66
+
+#define IPTS_HID_REPORT_DATA_SIZE 7485
+
+/*
+ * HID descriptor for singletouch data.
+ * This descriptor should be present on all IPTS devices.
+ */
+static const u8 ipts_singletouch_descriptor[] = {
+	0x05, 0x0D,	  /*  Usage Page (Digitizer),            */
+	0x09, 0x04,	  /*  Usage (Touchscreen),               */
+	0xA1, 0x01,	  /*  Collection (Application),          */
+	0x85, 0x40,	  /*      Report ID (64),                */
+	0x09, 0x42,	  /*      Usage (Tip Switch),            */
+	0x15, 0x00,	  /*      Logical Minimum (0),           */
+	0x25, 0x01,	  /*      Logical Maximum (1),           */
+	0x75, 0x01,	  /*      Report Size (1),               */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x95, 0x07,	  /*      Report Count (7),              */
+	0x81, 0x03,	  /*      Input (Constant, Variable),    */
+	0x05, 0x01,	  /*      Usage Page (Desktop),          */
+	0x09, 0x30,	  /*      Usage (X),                     */
+	0x75, 0x10,	  /*      Report Size (16),              */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0xA4,		  /*      Push,                          */
+	0x55, 0x0E,	  /*      Unit Exponent (14),            */
+	0x65, 0x11,	  /*      Unit (Centimeter),             */
+	0x46, 0x76, 0x0B, /*      Physical Maximum (2934),       */
+	0x26, 0xFF, 0x7F, /*      Logical Maximum (32767),       */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x09, 0x31,	  /*      Usage (Y),                     */
+	0x46, 0x74, 0x06, /*      Physical Maximum (1652),       */
+	0x26, 0xFF, 0x7F, /*      Logical Maximum (32767),       */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0xB4,		  /*      Pop,                           */
+	0xC0,		  /*  End Collection                     */
+};
+
+/*
+ * Fallback HID descriptor for older devices that do not have
+ * the ability to query their HID descriptor.
+ */
+static const u8 ipts_fallback_descriptor[] = {
+	0x05, 0x0D,	  /*  Usage Page (Digitizer),            */
+	0x09, 0x0F,	  /*  Usage (Capacitive Hm Digitizer),   */
+	0xA1, 0x01,	  /*  Collection (Application),          */
+	0x85, 0x41,	  /*      Report ID (65),                */
+	0x09, 0x56,	  /*      Usage (Scan Time),             */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0x75, 0x10,	  /*      Report Size (16),              */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x09, 0x61,	  /*      Usage (Gesture Char Quality),  */
+	0x75, 0x08,	  /*      Report Size (8),               */
+	0x96, 0x3D, 0x1D, /*      Report Count (7485),           */
+	0x81, 0x03,	  /*      Input (Constant, Variable),    */
+	0x85, 0x42,	  /*      Report ID (66),                */
+	0x06, 0x00, 0xFF, /*      Usage Page (FF00h),            */
+	0x09, 0xC8,	  /*      Usage (C8h),                   */
+	0x75, 0x08,	  /*      Report Size (8),               */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0xB1, 0x02,	  /*      Feature (Variable),            */
+	0xC0,		  /*  End Collection,                    */
+};
+
+#endif /* IPTS_DESC_H */
diff --git a/drivers/hid/ipts/eds1.c b/drivers/hid/ipts/eds1.c
new file mode 100644
index 000000000000..7b9f54388a9f
--- /dev/null
+++ b/drivers/hid/ipts/eds1.c
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/err.h>
+#include <linux/gfp.h>
+#include <linux/hid.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "desc.h"
+#include "eds1.h"
+#include "spec-device.h"
+
+int ipts_eds1_get_descriptor(struct ipts_context *ipts, u8 **desc_buffer, size_t *desc_size)
+{
+	size_t size = 0;
+	u8 *buffer = NULL;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!desc_buffer)
+		return -EFAULT;
+
+	if (!desc_size)
+		return -EFAULT;
+
+	size = sizeof(ipts_singletouch_descriptor) + sizeof(ipts_fallback_descriptor);
+
+	buffer = kzalloc(size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	memcpy(buffer, ipts_singletouch_descriptor, sizeof(ipts_singletouch_descriptor));
+	memcpy(&buffer[sizeof(ipts_singletouch_descriptor)], ipts_fallback_descriptor,
+	       sizeof(ipts_fallback_descriptor));
+
+	*desc_size = size;
+	*desc_buffer = buffer;
+
+	return 0;
+}
+
+static int ipts_eds1_switch_mode(struct ipts_context *ipts, enum ipts_mode mode)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (ipts->mode == mode)
+		return 0;
+
+	ipts->mode = mode;
+
+	ret = ipts_control_restart(ipts);
+	if (ret)
+		dev_err(ipts->dev, "Failed to switch modes: %d\n", ret);
+
+	return ret;
+}
+
+int ipts_eds1_raw_request(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+			  enum hid_report_type report_type, enum hid_class_request request_type)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buffer)
+		return -EFAULT;
+
+	if (report_id != IPTS_HID_REPORT_SET_MODE)
+		return -EIO;
+
+	if (report_type != HID_FEATURE_REPORT)
+		return -EIO;
+
+	if (size != 2)
+		return -EINVAL;
+
+	/*
+	 * Implement mode switching report for older devices without native HID support.
+	 */
+
+	if (request_type == HID_REQ_GET_REPORT) {
+		memset(buffer, 0, size);
+		buffer[0] = report_id;
+		buffer[1] = ipts->mode;
+	} else if (request_type == HID_REQ_SET_REPORT) {
+		return ipts_eds1_switch_mode(ipts, buffer[1]);
+	} else {
+		return -EIO;
+	}
+
+	return ret;
+}
diff --git a/drivers/hid/ipts/eds1.h b/drivers/hid/ipts/eds1.h
new file mode 100644
index 000000000000..eeeb6575e3e8
--- /dev/null
+++ b/drivers/hid/ipts/eds1.h
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/hid.h>
+#include <linux/types.h>
+
+#include "context.h"
+
+/**
+ * ipts_eds1_get_descriptor() - Assembles the HID descriptor of the device.
+ * @ipts: The IPTS driver context.
+ * @desc_buffer: A pointer to the location where the address of the allocated buffer is stored.
+ * @desc_size: A pointer to the location where the size of the allocated buffer is stored.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_eds1_get_descriptor(struct ipts_context *ipts, u8 **desc_buffer, size_t *desc_size);
+
+/**
+ * ipts_eds1_raw_request() - Executes an output or feature report on the device.
+ * @ipts: The IPTS driver context.
+ * @buffer: The buffer containing the report.
+ * @size: The size of the buffer.
+ * @report_id: The HID report ID.
+ * @report_type: Whether this report is an output or a feature report.
+ * @request_type: Whether this report requests or sends data.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_eds1_raw_request(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+			  enum hid_report_type report_type, enum hid_class_request request_type);
diff --git a/drivers/hid/ipts/eds2.c b/drivers/hid/ipts/eds2.c
new file mode 100644
index 000000000000..639940794615
--- /dev/null
+++ b/drivers/hid/ipts/eds2.c
@@ -0,0 +1,145 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/gfp.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "desc.h"
+#include "eds2.h"
+#include "spec-data.h"
+
+int ipts_eds2_get_descriptor(struct ipts_context *ipts, u8 **desc_buffer, size_t *desc_size)
+{
+	size_t size = 0;
+	u8 *buffer = NULL;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!desc_buffer)
+		return -EFAULT;
+
+	if (!desc_size)
+		return -EFAULT;
+
+	size = sizeof(ipts_singletouch_descriptor) + ipts->descriptor.size;
+
+	buffer = kzalloc(size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	memcpy(buffer, ipts_singletouch_descriptor, sizeof(ipts_singletouch_descriptor));
+	memcpy(&buffer[sizeof(ipts_singletouch_descriptor)], ipts->descriptor.address,
+	       ipts->descriptor.size);
+
+	*desc_size = size;
+	*desc_buffer = buffer;
+
+	return 0;
+}
+
+static int ipts_eds2_get_feature(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+				 enum ipts_feedback_data_type type)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buffer)
+		return -EFAULT;
+
+	mutex_lock(&ipts->feature_lock);
+
+	memset(buffer, 0, size);
+	buffer[0] = report_id;
+
+	memset(&ipts->feature_report, 0, sizeof(ipts->feature_report));
+	reinit_completion(&ipts->feature_event);
+
+	ret = ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_NONE, type, buffer, size);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
+		goto out;
+	}
+
+	ret = wait_for_completion_timeout(&ipts->feature_event, msecs_to_jiffies(5000));
+	if (ret == 0) {
+		dev_warn(ipts->dev, "GET_FEATURES timed out!\n");
+		ret = -EIO;
+		goto out;
+	}
+
+	if (!ipts->feature_report.address) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (ipts->feature_report.size > size) {
+		ret = -ETOOSMALL;
+		goto out;
+	}
+
+	ret = ipts->feature_report.size;
+	memcpy(buffer, ipts->feature_report.address, ipts->feature_report.size);
+
+out:
+	mutex_unlock(&ipts->feature_lock);
+	return ret;
+}
+
+static int ipts_eds2_set_feature(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+				 enum ipts_feedback_data_type type)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buffer)
+		return -EFAULT;
+
+	buffer[0] = report_id;
+
+	ret = ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_NONE, type, buffer, size);
+	if (ret)
+		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
+
+	return ret;
+}
+
+int ipts_eds2_raw_request(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+			  enum hid_report_type report_type, enum hid_class_request request_type)
+{
+	enum ipts_feedback_data_type feedback_type = IPTS_FEEDBACK_DATA_TYPE_VENDOR;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buffer)
+		return -EFAULT;
+
+	if (report_type == HID_OUTPUT_REPORT && request_type == HID_REQ_SET_REPORT)
+		feedback_type = IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT;
+	else if (report_type == HID_FEATURE_REPORT && request_type == HID_REQ_GET_REPORT)
+		feedback_type = IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES;
+	else if (report_type == HID_FEATURE_REPORT && request_type == HID_REQ_SET_REPORT)
+		feedback_type = IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES;
+	else
+		return -EIO;
+
+	if (request_type == HID_REQ_GET_REPORT)
+		return ipts_eds2_get_feature(ipts, buffer, size, report_id, feedback_type);
+	else
+		return ipts_eds2_set_feature(ipts, buffer, size, report_id, feedback_type);
+}
diff --git a/drivers/hid/ipts/eds2.h b/drivers/hid/ipts/eds2.h
new file mode 100644
index 000000000000..064e3716907a
--- /dev/null
+++ b/drivers/hid/ipts/eds2.h
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/hid.h>
+#include <linux/types.h>
+
+#include "context.h"
+
+/**
+ * ipts_eds2_get_descriptor() - Assembles the HID descriptor of the device.
+ * @ipts: The IPTS driver context.
+ * @desc_buffer: A pointer to the location where the address of the allocated buffer is stored.
+ * @desc_size: A pointer to the location where the size of the allocated buffer is stored.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_eds2_get_descriptor(struct ipts_context *ipts, u8 **desc_buffer, size_t *desc_size);
+
+/**
+ * ipts_eds2_raw_request() - Executes an output or feature report on the device.
+ * @ipts: The IPTS driver context.
+ * @buffer: The buffer containing the report.
+ * @size: The size of the buffer.
+ * @report_id: The HID report ID.
+ * @report_type: Whether this report is an output or a feature report.
+ * @request_type: Whether this report requests or sends data.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_eds2_raw_request(struct ipts_context *ipts, u8 *buffer, size_t size, u8 report_id,
+			  enum hid_report_type report_type, enum hid_class_request request_type);
diff --git a/drivers/hid/ipts/hid.c b/drivers/hid/ipts/hid.c
new file mode 100644
index 000000000000..e34a1a4f9fa7
--- /dev/null
+++ b/drivers/hid/ipts/hid.c
@@ -0,0 +1,225 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2022-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/gfp.h>
+#include <linux/hid.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "desc.h"
+#include "eds1.h"
+#include "eds2.h"
+#include "hid.h"
+#include "spec-data.h"
+#include "spec-hid.h"
+
+void ipts_hid_enable(struct ipts_context *ipts)
+{
+	WRITE_ONCE(ipts->hid_active, true);
+}
+
+void ipts_hid_disable(struct ipts_context *ipts)
+{
+	WRITE_ONCE(ipts->hid_active, false);
+}
+
+static int ipts_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ipts_hid_stop(struct hid_device *hid)
+{
+}
+
+static int ipts_hid_parse(struct hid_device *hid)
+{
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	u8 *buffer = NULL;
+	size_t size = 0;
+
+	if (!hid)
+		return -ENODEV;
+
+	ipts = hid->driver_data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!READ_ONCE(ipts->hid_active))
+		return -ENODEV;
+
+	if (ipts->info.intf_eds == 1)
+		ret = ipts_eds1_get_descriptor(ipts, &buffer, &size);
+	else
+		ret = ipts_eds2_get_descriptor(ipts, &buffer, &size);
+
+	if (ret) {
+		dev_err(ipts->dev, "Failed to allocate HID descriptor: %d\n", ret);
+		return ret;
+	}
+
+	ret = hid_parse_report(hid, buffer, size);
+	kfree(buffer);
+
+	if (ret) {
+		dev_err(ipts->dev, "Failed to parse HID descriptor: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipts_hid_raw_request(struct hid_device *hid, unsigned char report_id, __u8 *buffer,
+				size_t size, unsigned char report_type, int request_type)
+{
+	struct ipts_context *ipts = NULL;
+
+	if (!hid)
+		return -ENODEV;
+
+	ipts = hid->driver_data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!READ_ONCE(ipts->hid_active))
+		return -ENODEV;
+
+	if (ipts->info.intf_eds == 1) {
+		return ipts_eds1_raw_request(ipts, buffer, size, report_id, report_type,
+					     request_type);
+	} else {
+		return ipts_eds2_raw_request(ipts, buffer, size, report_id, report_type,
+					     request_type);
+	}
+}
+
+static struct hid_ll_driver ipts_hid_driver = {
+	.start = ipts_hid_start,
+	.stop = ipts_hid_stop,
+	.open = ipts_hid_start,
+	.close = ipts_hid_stop,
+	.parse = ipts_hid_parse,
+	.raw_request = ipts_hid_raw_request,
+};
+
+int ipts_hid_input_data(struct ipts_context *ipts, u32 buffer)
+{
+	u8 *temp = NULL;
+	struct ipts_hid_header *frame = NULL;
+	struct ipts_data_header *header = NULL;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->hid)
+		return -ENODEV;
+
+	if (!READ_ONCE(ipts->hid_active))
+		return -ENODEV;
+
+	header = (struct ipts_data_header *)ipts->resources.data[buffer].address;
+
+	temp = ipts->resources.report.address;
+	memset(temp, 0, ipts->resources.report.size);
+
+	if (!header)
+		return -EFAULT;
+
+	if (header->size == 0)
+		return 0;
+
+	if (header->type == IPTS_DATA_TYPE_HID)
+		return hid_input_report(ipts->hid, HID_INPUT_REPORT, header->data, header->size, 1);
+
+	if (header->type == IPTS_DATA_TYPE_GET_FEATURES) {
+		ipts->feature_report.address = header->data;
+		ipts->feature_report.size = header->size;
+
+		complete_all(&ipts->feature_event);
+		return 0;
+	}
+
+	if (header->type != IPTS_DATA_TYPE_FRAME)
+		return 0;
+
+	if (header->size + 3 + sizeof(struct ipts_hid_header) > IPTS_HID_REPORT_DATA_SIZE)
+		return -ERANGE;
+
+	/*
+	 * Synthesize a HID report matching the devices that natively send HID reports
+	 */
+	temp[0] = IPTS_HID_REPORT_DATA;
+
+	frame = (struct ipts_hid_header *)&temp[3];
+	frame->type = IPTS_HID_FRAME_TYPE_RAW;
+	frame->size = header->size + sizeof(*frame);
+
+	memcpy(frame->data, header->data, header->size);
+
+	return hid_input_report(ipts->hid, HID_INPUT_REPORT, temp, IPTS_HID_REPORT_DATA_SIZE, 1);
+}
+
+int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (ipts->hid)
+		return 0;
+
+	ipts->hid = hid_allocate_device();
+	if (IS_ERR(ipts->hid)) {
+		int err = PTR_ERR(ipts->hid);
+
+		dev_err(ipts->dev, "Failed to allocate HID device: %d\n", err);
+		return err;
+	}
+
+	ipts->hid->driver_data = ipts;
+	ipts->hid->dev.parent = ipts->dev;
+	ipts->hid->ll_driver = &ipts_hid_driver;
+
+	ipts->hid->vendor = info.vendor;
+	ipts->hid->product = info.product;
+	ipts->hid->group = HID_GROUP_GENERIC;
+
+	snprintf(ipts->hid->name, sizeof(ipts->hid->name), "IPTS %04X:%04X", info.vendor,
+		 info.product);
+
+	ret = hid_add_device(ipts->hid);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to add HID device: %d\n", ret);
+		ipts_hid_free(ipts);
+		return ret;
+	}
+
+	return 0;
+}
+
+int ipts_hid_free(struct ipts_context *ipts)
+{
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->hid)
+		return 0;
+
+	hid_destroy_device(ipts->hid);
+	ipts->hid = NULL;
+
+	return 0;
+}
diff --git a/drivers/hid/ipts/hid.h b/drivers/hid/ipts/hid.h
new file mode 100644
index 000000000000..1ebe77447903
--- /dev/null
+++ b/drivers/hid/ipts/hid.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2022-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_HID_H
+#define IPTS_HID_H
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-device.h"
+
+void ipts_hid_enable(struct ipts_context *ipts);
+void ipts_hid_disable(struct ipts_context *ipts);
+
+int ipts_hid_input_data(struct ipts_context *ipts, u32 buffer);
+
+int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info);
+int ipts_hid_free(struct ipts_context *ipts);
+
+#endif /* IPTS_HID_H */
diff --git a/drivers/hid/ipts/main.c b/drivers/hid/ipts/main.c
new file mode 100644
index 000000000000..fb5b5c13ee3e
--- /dev/null
+++ b/drivers/hid/ipts/main.c
@@ -0,0 +1,126 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "mei.h"
+#include "receiver.h"
+#include "spec-device.h"
+
+/*
+ * The MEI client ID for IPTS functionality.
+ */
+#define IPTS_ID UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04)
+
+static int ipts_set_dma_mask(struct mei_cl_device *cldev)
+{
+	if (!cldev)
+		return -EFAULT;
+
+	if (!dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64)))
+		return 0;
+
+	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
+}
+
+static int ipts_probe(struct mei_cl_device *cldev, const struct mei_cl_device_id *id)
+{
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev)
+		return -EFAULT;
+
+	ret = ipts_set_dma_mask(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS: %d\n", ret);
+		return ret;
+	}
+
+	ret = mei_cldev_enable(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to enable MEI device: %d\n", ret);
+		return ret;
+	}
+
+	ipts = devm_kzalloc(&cldev->dev, sizeof(*ipts), GFP_KERNEL);
+	if (!ipts) {
+		mei_cldev_disable(cldev);
+		return -ENOMEM;
+	}
+
+	ret = ipts_mei_init(&ipts->mei, cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to init MEI bus logic: %d\n", ret);
+		return ret;
+	}
+
+	ipts->dev = &cldev->dev;
+	ipts->mode = IPTS_MODE_EVENT;
+
+	mutex_init(&ipts->feature_lock);
+	init_completion(&ipts->feature_event);
+
+	mei_cldev_set_drvdata(cldev, ipts);
+
+	ret = ipts_control_start(ipts);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to start IPTS: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ipts_remove(struct mei_cl_device *cldev)
+{
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev) {
+		pr_err("MEI device is NULL!");
+		return;
+	}
+
+	ipts = mei_cldev_get_drvdata(cldev);
+
+	ret = ipts_control_stop(ipts);
+	if (ret)
+		dev_err(&cldev->dev, "Failed to stop IPTS: %d\n", ret);
+
+	mei_cldev_disable(cldev);
+}
+
+static struct mei_cl_device_id ipts_device_id_table[] = {
+	{ .uuid = IPTS_ID, .version = MEI_CL_VERSION_ANY },
+	{},
+};
+MODULE_DEVICE_TABLE(mei, ipts_device_id_table);
+
+static struct mei_cl_driver ipts_driver = {
+	.id_table = ipts_device_id_table,
+	.name = "ipts",
+	.probe = ipts_probe,
+	.remove = ipts_remove,
+};
+module_mei_cl_driver(ipts_driver);
+
+MODULE_DESCRIPTION("IPTS touchscreen driver");
+MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/ipts/mei.c b/drivers/hid/ipts/mei.c
new file mode 100644
index 000000000000..1e0395ceae4a
--- /dev/null
+++ b/drivers/hid/ipts/mei.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/jiffies.h>
+#include <linux/list.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/printk.h>
+#include <linux/rwsem.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+
+#include "context.h"
+#include "mei.h"
+
+static void locked_list_add(struct list_head *new, struct list_head *head,
+			    struct rw_semaphore *lock)
+{
+	down_write(lock);
+	list_add(new, head);
+	up_write(lock);
+}
+
+static void locked_list_del(struct list_head *entry, struct rw_semaphore *lock)
+{
+	down_write(lock);
+	list_del(entry);
+	up_write(lock);
+}
+
+static void ipts_mei_incoming(struct mei_cl_device *cldev)
+{
+	ssize_t ret = 0;
+	struct ipts_mei_message *entry = NULL;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev) {
+		pr_err("MEI device is NULL!");
+		return;
+	}
+
+	ipts = mei_cldev_get_drvdata(cldev);
+	if (!ipts) {
+		pr_err("IPTS driver context is NULL!");
+		return;
+	}
+
+	entry = devm_kzalloc(ipts->dev, sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return;
+
+	INIT_LIST_HEAD(&entry->list);
+
+	do {
+		ret = mei_cldev_recv(cldev, (u8 *)&entry->rsp, sizeof(entry->rsp));
+	} while (ret == -EINTR);
+
+	if (ret < 0) {
+		dev_err(ipts->dev, "Error while reading response: %ld\n", ret);
+		return;
+	}
+
+	if (ret == 0) {
+		dev_err(ipts->dev, "Received empty response\n");
+		return;
+	}
+
+	locked_list_add(&entry->list, &ipts->mei.messages, &ipts->mei.message_lock);
+	wake_up_all(&ipts->mei.message_queue);
+}
+
+static int ipts_mei_search(struct ipts_mei *mei, enum ipts_command_code code,
+			   struct ipts_response *rsp)
+{
+	struct ipts_mei_message *entry = NULL;
+
+	if (!mei)
+		return -EFAULT;
+
+	if (!rsp)
+		return -EFAULT;
+
+	down_read(&mei->message_lock);
+
+	/*
+	 * Iterate over the list of received messages, and check if there is one
+	 * matching the requested command code.
+	 */
+	list_for_each_entry(entry, &mei->messages, list) {
+		if (entry->rsp.cmd == code)
+			break;
+	}
+
+	up_read(&mei->message_lock);
+
+	/*
+	 * If entry is not the list head, this means that the loop above has been stopped early,
+	 * and that we found a matching element. We drop the message from the list and return it.
+	 */
+	if (!list_entry_is_head(entry, &mei->messages, list)) {
+		locked_list_del(&entry->list, &mei->message_lock);
+
+		*rsp = entry->rsp;
+		devm_kfree(&mei->cldev->dev, entry);
+
+		return 0;
+	}
+
+	return -EAGAIN;
+}
+
+int ipts_mei_recv(struct ipts_mei *mei, enum ipts_command_code code, struct ipts_response *rsp,
+		  u64 timeout)
+{
+	int ret = 0;
+
+	if (!mei)
+		return -EFAULT;
+
+	/*
+	 * A timeout of 0 means check and return immideately.
+	 */
+	if (timeout == 0)
+		return ipts_mei_search(mei, code, rsp);
+
+	/*
+	 * A timeout of less than 0 means to wait forever.
+	 */
+	if (timeout < 0) {
+		wait_event(mei->message_queue, ipts_mei_search(mei, code, rsp) == 0);
+		return 0;
+	}
+
+	ret = wait_event_timeout(mei->message_queue, ipts_mei_search(mei, code, rsp) == 0,
+				 msecs_to_jiffies(timeout));
+
+	if (ret > 0)
+		return 0;
+
+	return -EAGAIN;
+}
+
+int ipts_mei_send(struct ipts_mei *mei, void *data, size_t length)
+{
+	int ret = 0;
+
+	if (!mei)
+		return -EFAULT;
+
+	if (!mei->cldev)
+		return -EFAULT;
+
+	if (!data)
+		return -EFAULT;
+
+	do {
+		ret = mei_cldev_send(mei->cldev, (u8 *)data, length);
+	} while (ret == -EINTR);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+int ipts_mei_init(struct ipts_mei *mei, struct mei_cl_device *cldev)
+{
+	if (!mei)
+		return -EFAULT;
+
+	if (!cldev)
+		return -EFAULT;
+
+	mei->cldev = cldev;
+
+	INIT_LIST_HEAD(&mei->messages);
+	init_waitqueue_head(&mei->message_queue);
+	init_rwsem(&mei->message_lock);
+
+	mei_cldev_register_rx_cb(cldev, ipts_mei_incoming);
+
+	return 0;
+}
diff --git a/drivers/hid/ipts/mei.h b/drivers/hid/ipts/mei.h
new file mode 100644
index 000000000000..973bade6b0fd
--- /dev/null
+++ b/drivers/hid/ipts/mei.h
@@ -0,0 +1,66 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_MEI_H
+#define IPTS_MEI_H
+
+#include <linux/list.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/rwsem.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+
+#include "spec-device.h"
+
+struct ipts_mei_message {
+	struct list_head list;
+	struct ipts_response rsp;
+};
+
+struct ipts_mei {
+	struct mei_cl_device *cldev;
+
+	struct list_head messages;
+
+	wait_queue_head_t message_queue;
+	struct rw_semaphore message_lock;
+};
+
+/**
+ * ipts_mei_recv() - Receive data from a MEI device.
+ * @mei: The IPTS MEI device context.
+ * @code: The IPTS command code to look for.
+ * @rsp: The address that the received data will be copied to.
+ * @timeout: How many milliseconds the function will wait at most.
+ *
+ * A negative timeout means to wait forever.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+ */
+int ipts_mei_recv(struct ipts_mei *mei, enum ipts_command_code code, struct ipts_response *rsp,
+		  u64 timeout);
+
+/**
+ * ipts_mei_send() - Send data to a MEI device.
+ * @ipts: The IPTS MEI device context.
+ * @data: The data to send.
+ * @size: The size of the data.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_mei_send(struct ipts_mei *mei, void *data, size_t length);
+
+/**
+ * ipts_mei_init() - Initialize the MEI device context.
+ * @mei: The MEI device context to initialize.
+ * @cldev: The MEI device the context will be bound to.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_mei_init(struct ipts_mei *mei, struct mei_cl_device *cldev);
+
+#endif /* IPTS_MEI_H */
diff --git a/drivers/hid/ipts/receiver.c b/drivers/hid/ipts/receiver.c
new file mode 100644
index 000000000000..977724c728c3
--- /dev/null
+++ b/drivers/hid/ipts/receiver.c
@@ -0,0 +1,251 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/kthread.h>
+#include <linux/time64.h>
+#include <linux/timekeeping.h>
+#include <linux/types.h>
+
+#include "cmd.h"
+#include "context.h"
+#include "control.h"
+#include "hid.h"
+#include "receiver.h"
+#include "resources.h"
+#include "spec-device.h"
+#include "thread.h"
+
+static void ipts_receiver_next_doorbell(struct ipts_context *ipts)
+{
+	u32 *doorbell = (u32 *)ipts->resources.doorbell.address;
+	*doorbell = *doorbell + 1;
+}
+
+static u32 ipts_receiver_current_doorbell(struct ipts_context *ipts)
+{
+	u32 *doorbell = (u32 *)ipts->resources.doorbell.address;
+	return *doorbell;
+}
+
+static void ipts_receiver_backoff(time64_t last, u32 n)
+{
+	/*
+	 * If the last change was less than n seconds ago,
+	 * sleep for a shorter period so that new data can be
+	 * processed quickly. If there was no change for more than
+	 * n seconds, sleep longer to avoid wasting CPU cycles.
+	 */
+	if (last + n > ktime_get_seconds())
+		usleep_range(1 * USEC_PER_MSEC, 5 * USEC_PER_MSEC);
+	else
+		msleep(200);
+}
+
+static int ipts_receiver_event_loop(struct ipts_thread *thread)
+{
+	int ret = 0;
+	u32 buffer = 0;
+
+	struct ipts_context *ipts = NULL;
+	time64_t last = ktime_get_seconds();
+
+	if (!thread)
+		return -EFAULT;
+
+	ipts = thread->data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	dev_info(ipts->dev, "IPTS running in event mode\n");
+
+	while (!ipts_thread_should_stop(thread)) {
+		int i = 0;
+
+		for (i = 0; i < IPTS_BUFFERS; i++) {
+			ret = ipts_control_wait_data(ipts, false);
+			if (ret == -EAGAIN)
+				break;
+
+			if (ret) {
+				dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
+				continue;
+			}
+
+			buffer = ipts_receiver_current_doorbell(ipts) % IPTS_BUFFERS;
+			ipts_receiver_next_doorbell(ipts);
+
+			ret = ipts_hid_input_data(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to process buffer: %d\n", ret);
+
+			ret = ipts_control_refill_buffer(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to send feedback: %d\n", ret);
+
+			ret = ipts_control_request_data(ipts);
+			if (ret)
+				dev_err(ipts->dev, "Failed to request data: %d\n", ret);
+
+			last = ktime_get_seconds();
+		}
+
+		ipts_receiver_backoff(last, 5);
+	}
+
+	ret = ipts_control_request_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to request flush: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_control_wait_data(ipts, true);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
+	}
+
+	ret = ipts_control_wait_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
+	}
+
+	return 0;
+}
+
+static int ipts_receiver_poll_loop(struct ipts_thread *thread)
+{
+	int ret = 0;
+	u32 buffer = 0;
+
+	u32 doorbell = 0;
+	u32 lastdb = 0;
+
+	struct ipts_context *ipts = NULL;
+	time64_t last = ktime_get_seconds();
+
+	if (!thread)
+		return -EFAULT;
+
+	ipts = thread->data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	dev_info(ipts->dev, "IPTS running in poll mode\n");
+
+	while (true) {
+		if (ipts_thread_should_stop(thread)) {
+			ret = ipts_control_request_flush(ipts);
+			if (ret) {
+				dev_err(ipts->dev, "Failed to request flush: %d\n", ret);
+				return ret;
+			}
+		}
+
+		doorbell = ipts_receiver_current_doorbell(ipts);
+
+		/*
+		 * After filling up one of the data buffers, IPTS will increment
+		 * the doorbell. The value of the doorbell stands for the *next*
+		 * buffer that IPTS is going to fill.
+		 */
+		while (lastdb != doorbell) {
+			buffer = lastdb % IPTS_BUFFERS;
+
+			ret = ipts_hid_input_data(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to process buffer: %d\n", ret);
+
+			ret = ipts_control_refill_buffer(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to send feedback: %d\n", ret);
+
+			last = ktime_get_seconds();
+			lastdb++;
+		}
+
+		if (ipts_thread_should_stop(thread))
+			break;
+
+		ipts_receiver_backoff(last, 5);
+	}
+
+	ret = ipts_control_wait_data(ipts, true);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
+	}
+
+	ret = ipts_control_wait_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
+	}
+
+	return 0;
+}
+
+int ipts_receiver_start(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (ipts->mode == IPTS_MODE_EVENT) {
+		ret = ipts_thread_start(&ipts->receiver_loop, ipts_receiver_event_loop, ipts,
+					"ipts_event");
+	} else if (ipts->mode == IPTS_MODE_POLL) {
+		ret = ipts_thread_start(&ipts->receiver_loop, ipts_receiver_poll_loop, ipts,
+					"ipts_poll");
+	} else {
+		ret = -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(ipts->dev, "Failed to start receiver loop: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int ipts_receiver_stop(struct ipts_context *ipts)
+{
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_thread_stop(&ipts->receiver_loop);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to stop receiver loop: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
diff --git a/drivers/hid/ipts/receiver.h b/drivers/hid/ipts/receiver.h
new file mode 100644
index 000000000000..3de7da62d40c
--- /dev/null
+++ b/drivers/hid/ipts/receiver.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_RECEIVER_H
+#define IPTS_RECEIVER_H
+
+#include "context.h"
+
+int ipts_receiver_start(struct ipts_context *ipts);
+int ipts_receiver_stop(struct ipts_context *ipts);
+
+#endif /* IPTS_RECEIVER_H */
diff --git a/drivers/hid/ipts/resources.c b/drivers/hid/ipts/resources.c
new file mode 100644
index 000000000000..cc14653b2a9f
--- /dev/null
+++ b/drivers/hid/ipts/resources.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "desc.h"
+#include "resources.h"
+#include "spec-device.h"
+
+static int ipts_resources_alloc_buffer(struct ipts_buffer *buffer, struct device *dev, size_t size)
+{
+	if (!buffer)
+		return -EFAULT;
+
+	if (buffer->address)
+		return 0;
+
+	buffer->address = dma_alloc_coherent(dev, size, &buffer->dma_address, GFP_KERNEL);
+
+	if (!buffer->address)
+		return -ENOMEM;
+
+	buffer->size = size;
+	buffer->device = dev;
+
+	return 0;
+}
+
+static void ipts_resources_free_buffer(struct ipts_buffer *buffer)
+{
+	if (!buffer->address)
+		return;
+
+	dma_free_coherent(buffer->device, buffer->size, buffer->address, buffer->dma_address);
+
+	buffer->address = NULL;
+	buffer->size = 0;
+
+	buffer->dma_address = 0;
+	buffer->device = NULL;
+}
+
+int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs)
+{
+	int ret = 0;
+
+	/*
+	 * Some compilers (AOSP clang) complain about a redefined
+	 * variable when this is declared inside of the for loop.
+	 */
+	int i = 0;
+
+	if (!res)
+		return -EFAULT;
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		ret = ipts_resources_alloc_buffer(&res->data[i], dev, ds);
+		if (ret)
+			goto err;
+	}
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		ret = ipts_resources_alloc_buffer(&res->feedback[i], dev, fs);
+		if (ret)
+			goto err;
+	}
+
+	ret = ipts_resources_alloc_buffer(&res->doorbell, dev, sizeof(u32));
+	if (ret)
+		goto err;
+
+	ret = ipts_resources_alloc_buffer(&res->workqueue, dev, sizeof(u32));
+	if (ret)
+		goto err;
+
+	ret = ipts_resources_alloc_buffer(&res->hid2me, dev, fs);
+	if (ret)
+		goto err;
+
+	ret = ipts_resources_alloc_buffer(&res->descriptor, dev, ds + 8);
+	if (ret)
+		goto err;
+
+	if (!res->report.address) {
+		res->report.size = IPTS_HID_REPORT_DATA_SIZE;
+		res->report.address = kzalloc(res->report.size, GFP_KERNEL);
+
+		if (!res->report.address) {
+			ret = -ENOMEM;
+			goto err;
+		}
+	}
+
+	return 0;
+
+err:
+
+	ipts_resources_free(res);
+	return ret;
+}
+
+int ipts_resources_free(struct ipts_resources *res)
+{
+	int i = 0;
+
+	if (!res)
+		return -EFAULT;
+
+	for (i = 0; i < IPTS_BUFFERS; i++)
+		ipts_resources_free_buffer(&res->data[i]);
+
+	for (i = 0; i < IPTS_BUFFERS; i++)
+		ipts_resources_free_buffer(&res->feedback[i]);
+
+	ipts_resources_free_buffer(&res->doorbell);
+	ipts_resources_free_buffer(&res->workqueue);
+	ipts_resources_free_buffer(&res->hid2me);
+	ipts_resources_free_buffer(&res->descriptor);
+
+	kfree(res->report.address);
+	res->report.address = NULL;
+	res->report.size = 0;
+
+	return 0;
+}
diff --git a/drivers/hid/ipts/resources.h b/drivers/hid/ipts/resources.h
new file mode 100644
index 000000000000..2068e13285f0
--- /dev/null
+++ b/drivers/hid/ipts/resources.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_RESOURCES_H
+#define IPTS_RESOURCES_H
+
+#include <linux/device.h>
+#include <linux/types.h>
+
+#include "spec-device.h"
+
+struct ipts_buffer {
+	u8 *address;
+	size_t size;
+
+	dma_addr_t dma_address;
+	struct device *device;
+};
+
+struct ipts_resources {
+	struct ipts_buffer data[IPTS_BUFFERS];
+	struct ipts_buffer feedback[IPTS_BUFFERS];
+
+	struct ipts_buffer doorbell;
+	struct ipts_buffer workqueue;
+	struct ipts_buffer hid2me;
+
+	struct ipts_buffer descriptor;
+
+	// Buffer for synthesizing HID reports
+	struct ipts_buffer report;
+};
+
+int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs);
+int ipts_resources_free(struct ipts_resources *res);
+
+#endif /* IPTS_RESOURCES_H */
diff --git a/drivers/hid/ipts/spec-data.h b/drivers/hid/ipts/spec-data.h
new file mode 100644
index 000000000000..e8dd98895a7e
--- /dev/null
+++ b/drivers/hid/ipts/spec-data.h
@@ -0,0 +1,100 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_DATA_H
+#define IPTS_SPEC_DATA_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/**
+ * enum ipts_feedback_cmd_type - Commands that can be executed on the sensor through feedback.
+ */
+enum ipts_feedback_cmd_type {
+	IPTS_FEEDBACK_CMD_TYPE_NONE = 0,
+	IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET = 1,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_ARMED = 2,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SENSING = 3,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SLEEP = 4,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_DOZE = 5,
+	IPTS_FEEDBACK_CMD_TYPE_HARD_RESET = 6,
+};
+
+/**
+ * enum ipts_feedback_data_type - Defines what data a feedback buffer contains.
+ * @IPTS_FEEDBACK_DATA_TYPE_VENDOR:        The buffer contains vendor specific feedback.
+ * @IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES:  The buffer contains a HID set features report.
+ * @IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES:  The buffer contains a HID get features report.
+ * @IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT: The buffer contains a HID output report.
+ * @IPTS_FEEDBACK_DATA_TYPE_STORE_DATA:    The buffer contains calibration data for the sensor.
+ */
+enum ipts_feedback_data_type {
+	IPTS_FEEDBACK_DATA_TYPE_VENDOR = 0,
+	IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES = 1,
+	IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES = 2,
+	IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT = 3,
+	IPTS_FEEDBACK_DATA_TYPE_STORE_DATA = 4,
+};
+
+/**
+ * struct ipts_feedback_header - Header that is prefixed to the data in a feedback buffer.
+ * @cmd_type:   A command that should be executed on the sensor.
+ * @size:       The size of the payload to be written.
+ * @buffer:     The ID of the buffer that contains this feedback data.
+ * @protocol:   The protocol version of the EDS.
+ * @data_type:  The type of data that the buffer contains.
+ * @spi_offset: The offset at which to write the payload data to the sensor.
+ * @payload:    Payload for the feedback command, or 0 if no payload is sent.
+ */
+struct ipts_feedback_header {
+	enum ipts_feedback_cmd_type cmd_type;
+	u32 size;
+	u32 buffer;
+	u32 protocol;
+	enum ipts_feedback_data_type data_type;
+	u32 spi_offset;
+	u8 reserved[40];
+	u8 payload[];
+} __packed;
+
+static_assert(sizeof(struct ipts_feedback_header) == 64);
+
+/**
+ * enum ipts_data_type - Defines what type of data a buffer contains.
+ * @IPTS_DATA_TYPE_FRAME:        Raw data frame.
+ * @IPTS_DATA_TYPE_ERROR:        Error data.
+ * @IPTS_DATA_TYPE_VENDOR:       Vendor specific data.
+ * @IPTS_DATA_TYPE_HID:          A HID report.
+ * @IPTS_DATA_TYPE_GET_FEATURES: The response to a GET_FEATURES HID2ME command.
+ */
+enum ipts_data_type {
+	IPTS_DATA_TYPE_FRAME = 0x00,
+	IPTS_DATA_TYPE_ERROR = 0x01,
+	IPTS_DATA_TYPE_VENDOR = 0x02,
+	IPTS_DATA_TYPE_HID = 0x03,
+	IPTS_DATA_TYPE_GET_FEATURES = 0x04,
+	IPTS_DATA_TYPE_DESCRIPTOR = 0x05,
+};
+
+/**
+ * struct ipts_data_header - Header that is prefixed to the data in a data buffer.
+ * @type: What data the buffer contains.
+ * @size: How much data the buffer contains.
+ * @buffer: Which buffer the data is in.
+ */
+struct ipts_data_header {
+	enum ipts_data_type type;
+	u32 size;
+	u32 buffer;
+	u8 reserved[52];
+	u8 data[];
+} __packed;
+
+static_assert(sizeof(struct ipts_data_header) == 64);
+
+#endif /* IPTS_SPEC_DATA_H */
diff --git a/drivers/hid/ipts/spec-device.h b/drivers/hid/ipts/spec-device.h
new file mode 100644
index 000000000000..41845f9d9025
--- /dev/null
+++ b/drivers/hid/ipts/spec-device.h
@@ -0,0 +1,290 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_DEVICE_H
+#define IPTS_SPEC_DEVICE_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/*
+ * The amount of buffers that IPTS can use for data transfer.
+ */
+#define IPTS_BUFFERS 16
+
+/*
+ * The buffer ID that is used for HID2ME feedback
+ */
+#define IPTS_HID2ME_BUFFER IPTS_BUFFERS
+
+/**
+ * enum ipts_command - Commands that can be sent to the IPTS hardware.
+ * @IPTS_CMD_GET_DEVICE_INFO:  Retrieves vendor information from the device.
+ * @IPTS_CMD_SET_MODE:         Changes the mode that the device will operate in.
+ * @IPTS_CMD_SET_MEM_WINDOW:   Configures memory buffers for passing data between device and driver.
+ * @IPTS_CMD_QUIESCE_IO:       Stops the data flow from the device to the driver.
+ * @IPTS_CMD_READY_FOR_DATA:   Informs the device that the driver is ready to receive data.
+ * @IPTS_CMD_FEEDBACK:         Informs the device that a buffer was processed and can be refilled.
+ * @IPTS_CMD_CLEAR_MEM_WINDOW: Stops the data flow and clears the buffer addresses on the device.
+ * @IPTS_CMD_RESET_SENSOR:     Resets the sensor to its default state.
+ * @IPTS_CMD_GET_DESCRIPTOR:   Retrieves the HID descriptor of the device.
+ */
+enum ipts_command_code {
+	IPTS_CMD_GET_DEVICE_INFO = 0x01,
+	IPTS_CMD_SET_MODE = 0x02,
+	IPTS_CMD_SET_MEM_WINDOW = 0x03,
+	IPTS_CMD_QUIESCE_IO = 0x04,
+	IPTS_CMD_READY_FOR_DATA = 0x05,
+	IPTS_CMD_FEEDBACK = 0x06,
+	IPTS_CMD_CLEAR_MEM_WINDOW = 0x07,
+	IPTS_CMD_RESET_SENSOR = 0x0B,
+	IPTS_CMD_GET_DESCRIPTOR = 0x0F,
+};
+
+/**
+ * enum ipts_status - Possible status codes returned by the IPTS device.
+ * @IPTS_STATUS_SUCCESS:                 Operation completed successfully.
+ * @IPTS_STATUS_INVALID_PARAMS:          Command contained an invalid payload.
+ * @IPTS_STATUS_ACCESS_DENIED:           ME could not validate a buffer address.
+ * @IPTS_STATUS_CMD_SIZE_ERROR:          Command contains an invalid payload.
+ * @IPTS_STATUS_NOT_READY:               Buffer addresses have not been set.
+ * @IPTS_STATUS_REQUEST_OUTSTANDING:     There is an outstanding command of the same type.
+ * @IPTS_STATUS_NO_SENSOR_FOUND:         No sensor could be found.
+ * @IPTS_STATUS_OUT_OF_MEMORY:           Not enough free memory for requested operation.
+ * @IPTS_STATUS_INTERNAL_ERROR:          An unexpected error occurred.
+ * @IPTS_STATUS_SENSOR_DISABLED:         The sensor has been disabled and must be reinitialized.
+ * @IPTS_STATUS_COMPAT_CHECK_FAIL:       Compatibility revision check between sensor and ME failed.
+ *                                       The host can ignore this error and attempt to continue.
+ * @IPTS_STATUS_SENSOR_EXPECTED_RESET:   The sensor went through a reset initiated by the driver.
+ * @IPTS_STATUS_SENSOR_UNEXPECTED_RESET: The sensor went through an unexpected reset.
+ * @IPTS_STATUS_RESET_FAILED:            Requested sensor reset failed to complete.
+ * @IPTS_STATUS_TIMEOUT:                 The operation timed out.
+ * @IPTS_STATUS_TEST_MODE_FAIL:          Test mode pattern did not match expected values.
+ * @IPTS_STATUS_SENSOR_FAIL_FATAL:       The sensor reported an error during reset sequence.
+ *                                       Further progress is not possible.
+ * @IPTS_STATUS_SENSOR_FAIL_NONFATAL:    The sensor reported an error during reset sequence.
+ *                                       The driver can attempt to continue.
+ * @IPTS_STATUS_INVALID_DEVICE_CAPS:     The device reported invalid capabilities.
+ * @IPTS_STATUS_QUIESCE_IO_IN_PROGRESS:  Command cannot be completed until Quiesce IO is done.
+ */
+enum ipts_status {
+	IPTS_STATUS_SUCCESS = 0x00,
+	IPTS_STATUS_INVALID_PARAMS = 0x01,
+	IPTS_STATUS_ACCESS_DENIED = 0x02,
+	IPTS_STATUS_CMD_SIZE_ERROR = 0x03,
+	IPTS_STATUS_NOT_READY = 0x04,
+	IPTS_STATUS_REQUEST_OUTSTANDING = 0x05,
+	IPTS_STATUS_NO_SENSOR_FOUND = 0x06,
+	IPTS_STATUS_OUT_OF_MEMORY = 0x07,
+	IPTS_STATUS_INTERNAL_ERROR = 0x08,
+	IPTS_STATUS_SENSOR_DISABLED = 0x09,
+	IPTS_STATUS_COMPAT_CHECK_FAIL = 0x0A,
+	IPTS_STATUS_SENSOR_EXPECTED_RESET = 0x0B,
+	IPTS_STATUS_SENSOR_UNEXPECTED_RESET = 0x0C,
+	IPTS_STATUS_RESET_FAILED = 0x0D,
+	IPTS_STATUS_TIMEOUT = 0x0E,
+	IPTS_STATUS_TEST_MODE_FAIL = 0x0F,
+	IPTS_STATUS_SENSOR_FAIL_FATAL = 0x10,
+	IPTS_STATUS_SENSOR_FAIL_NONFATAL = 0x11,
+	IPTS_STATUS_INVALID_DEVICE_CAPS = 0x12,
+	IPTS_STATUS_QUIESCE_IO_IN_PROGRESS = 0x13,
+};
+
+/**
+ * struct ipts_command - Message that is sent to the device for calling a command.
+ * @cmd:     The command that will be called.
+ * @payload: Payload containing parameters for the called command.
+ */
+struct ipts_command {
+	enum ipts_command_code cmd;
+	u8 payload[320];
+} __packed;
+
+static_assert(sizeof(struct ipts_command) == 324);
+
+/**
+ * enum ipts_mode - Configures what data the device produces and how its sent.
+ * @IPTS_MODE_EVENT: The device will send an event once a buffer was filled.
+ *                   Older devices will return singletouch data in this mode.
+ * @IPTS_MODE_POLL:  The device will notify the driver by incrementing the doorbell value.
+ *                   Older devices will return multitouch data in this mode.
+ */
+enum ipts_mode {
+	IPTS_MODE_EVENT = 0x00,
+	IPTS_MODE_POLL = 0x01,
+};
+
+/**
+ * struct ipts_set_mode - Payload for the SET_MODE command.
+ * @mode: Changes the mode that IPTS will operate in.
+ */
+struct ipts_set_mode {
+	enum ipts_mode mode;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_set_mode) == 16);
+
+#define IPTS_WORKQUEUE_SIZE	 8192
+#define IPTS_WORKQUEUE_ITEM_SIZE 16
+
+/**
+ * struct ipts_mem_window - Payload for the SET_MEM_WINDOW command.
+ * @data_addr_lower:      Lower 32 bits of the data buffer addresses.
+ * @data_addr_upper:      Upper 32 bits of the data buffer addresses.
+ * @workqueue_addr_lower: Lower 32 bits of the workqueue buffer address.
+ * @workqueue_addr_upper: Upper 32 bits of the workqueue buffer address.
+ * @doorbell_addr_lower:  Lower 32 bits of the doorbell buffer address.
+ * @doorbell_addr_upper:  Upper 32 bits of the doorbell buffer address.
+ * @feedbackaddr_lower:   Lower 32 bits of the feedback buffer addresses.
+ * @feedbackaddr_upper:   Upper 32 bits of the feedback buffer addresses.
+ * @hid2me_addr_lower:    Lower 32 bits of the hid2me buffer address.
+ * @hid2me_addr_upper:    Upper 32 bits of the hid2me buffer address.
+ * @hid2me_size:          Size of the hid2me feedback buffer.
+ * @workqueue_item_size:  Magic value. Must be 16.
+ * @workqueue_size:       Magic value. Must be 8192.
+ *
+ * The workqueue related items in this struct are required for using
+ * GuC submission with binary processing firmware. Since this driver does
+ * not use GuC submission and instead exports raw data to userspace, these
+ * items are not actually used, but they need to be allocated and passed
+ * to the device, otherwise initialization will fail.
+ */
+struct ipts_mem_window {
+	u32 data_addr_lower[IPTS_BUFFERS];
+	u32 data_addr_upper[IPTS_BUFFERS];
+	u32 workqueue_addr_lower;
+	u32 workqueue_addr_upper;
+	u32 doorbell_addr_lower;
+	u32 doorbell_addr_upper;
+	u32 feedback_addr_lower[IPTS_BUFFERS];
+	u32 feedback_addr_upper[IPTS_BUFFERS];
+	u32 hid2me_addr_lower;
+	u32 hid2me_addr_upper;
+	u32 hid2me_size;
+	u8 reserved1;
+	u8 workqueue_item_size;
+	u16 workqueue_size;
+	u8 reserved[32];
+} __packed;
+
+static_assert(sizeof(struct ipts_mem_window) == 320);
+
+/**
+ * struct ipts_quiesce_io - Payload for the QUIESCE_IO command.
+ */
+struct ipts_quiesce_io {
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_quiesce_io) == 12);
+
+/**
+ * struct ipts_feedback - Payload for the FEEDBACK command.
+ * @buffer: The buffer that the device should refill.
+ */
+struct ipts_feedback {
+	u32 buffer;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_feedback) == 16);
+
+/**
+ * enum ipts_reset_type - Possible ways of resetting the device.
+ * @IPTS_RESET_TYPE_HARD: Perform hardware reset using GPIO pin.
+ * @IPTS_RESET_TYPE_SOFT: Perform software reset using SPI command.
+ */
+enum ipts_reset_type {
+	IPTS_RESET_TYPE_HARD = 0x00,
+	IPTS_RESET_TYPE_SOFT = 0x01,
+};
+
+/**
+ * struct ipts_reset - Payload for the RESET_SENSOR command.
+ * @type: How the device should get reset.
+ */
+struct ipts_reset_sensor {
+	enum ipts_reset_type type;
+	u8 reserved[4];
+} __packed;
+
+static_assert(sizeof(struct ipts_reset_sensor) == 8);
+
+/**
+ * struct ipts_get_descriptor - Payload for the GET_DESCRIPTOR command.
+ * @addr_lower: The lower 32 bits of the descriptor buffer address.
+ * @addr_upper: The upper 32 bits of the descriptor buffer address.
+ * @magic:      A magic value. Must be 8.
+ */
+struct ipts_get_descriptor {
+	u32 addr_lower;
+	u32 addr_upper;
+	u32 magic;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_get_descriptor) == 24);
+
+/*
+ * The type of a response is indicated by a
+ * command code, with the most significant bit flipped to 1.
+ */
+#define IPTS_RSP_BIT BIT(31)
+
+/**
+ * struct ipts_response - Data returned from the device in response to a command.
+ * @cmd:     The command that this response answers (IPTS_RSP_BIT will be 1).
+ * @status:  The return code of the command.
+ * @payload: The data that was produced by the command.
+ */
+struct ipts_response {
+	enum ipts_command_code cmd;
+	enum ipts_status status;
+	u8 payload[80];
+} __packed;
+
+static_assert(sizeof(struct ipts_response) == 88);
+
+/**
+ * struct ipts_device_info - Vendor information of the IPTS device.
+ * @vendor:         Vendor ID of this device.
+ * @product:        Product ID of this device.
+ * @hw_version:     Hardware revision of this device.
+ * @fw_version:     Firmware revision of this device.
+ * @data_size:      Requested size for a data buffer.
+ * @feedback_size:  Requested size for a feedback buffer.
+ * @mode:           Mode that the device currently operates in.
+ * @max_contacts:   Maximum amount of concurrent touches the sensor can process.
+ * @sensor_min_eds: The minimum EDS version supported by the sensor.
+ * @sensor_max_eds: The maximum EDS version supported by the sensor.
+ * @me_min_eds:     The minimum EDS version supported by the ME for communicating with the sensor.
+ * @me_max_eds:     The maximum EDS version supported by the ME for communicating with the sensor.
+ * @intf_eds:       The EDS version implemented by the interface between ME and host.
+ */
+struct ipts_device_info {
+	u16 vendor;
+	u16 product;
+	u32 hw_version;
+	u32 fw_version;
+	u32 data_size;
+	u32 feedback_size;
+	enum ipts_mode mode;
+	u8 max_contacts;
+	u8 reserved1[3];
+	u8 sensor_min_eds;
+	u8 sensor_maj_eds;
+	u8 me_min_eds;
+	u8 me_maj_eds;
+	u8 intf_eds;
+	u8 reserved2[11];
+} __packed;
+
+static_assert(sizeof(struct ipts_device_info) == 44);
+
+#endif /* IPTS_SPEC_DEVICE_H */
diff --git a/drivers/hid/ipts/spec-hid.h b/drivers/hid/ipts/spec-hid.h
new file mode 100644
index 000000000000..5a58d4a0a610
--- /dev/null
+++ b/drivers/hid/ipts/spec-hid.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2020-2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_HID_H
+#define IPTS_SPEC_HID_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/*
+ * Made-up type for passing raw IPTS data in a HID report.
+ */
+#define IPTS_HID_FRAME_TYPE_RAW 0xEE
+
+/**
+ * struct ipts_hid_frame - Header that is prefixed to raw IPTS data wrapped in a HID report.
+ * @size: Size of the data inside the report, including this header.
+ * @type: What type of data does this report contain.
+ */
+struct ipts_hid_header {
+	u32 size;
+	u8 reserved1;
+	u8 type;
+	u8 reserved2;
+	u8 data[];
+} __packed;
+
+static_assert(sizeof(struct ipts_hid_header) == 7);
+
+#endif /* IPTS_SPEC_HID_H */
diff --git a/drivers/hid/ipts/thread.c b/drivers/hid/ipts/thread.c
new file mode 100644
index 000000000000..355e92bea26f
--- /dev/null
+++ b/drivers/hid/ipts/thread.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+
+#include "thread.h"
+
+bool ipts_thread_should_stop(struct ipts_thread *thread)
+{
+	if (!thread)
+		return false;
+
+	return READ_ONCE(thread->should_stop);
+}
+
+static int ipts_thread_runner(void *data)
+{
+	int ret = 0;
+	struct ipts_thread *thread = data;
+
+	if (!thread)
+		return -EFAULT;
+
+	if (!thread->threadfn)
+		return -EFAULT;
+
+	ret = thread->threadfn(thread);
+	complete_all(&thread->done);
+
+	return ret;
+}
+
+int ipts_thread_start(struct ipts_thread *thread, int (*threadfn)(struct ipts_thread *thread),
+		      void *data, const char *name)
+{
+	if (!thread)
+		return -EFAULT;
+
+	if (!threadfn)
+		return -EFAULT;
+
+	init_completion(&thread->done);
+
+	thread->data = data;
+	thread->should_stop = false;
+	thread->threadfn = threadfn;
+
+	thread->thread = kthread_run(ipts_thread_runner, thread, name);
+	return PTR_ERR_OR_ZERO(thread->thread);
+}
+
+int ipts_thread_stop(struct ipts_thread *thread)
+{
+	int ret = 0;
+
+	if (!thread)
+		return -EFAULT;
+
+	if (!thread->thread)
+		return 0;
+
+	WRITE_ONCE(thread->should_stop, true);
+
+	/*
+	 * Make sure that the write has gone through before waiting.
+	 */
+	wmb();
+
+	wait_for_completion(&thread->done);
+	ret = kthread_stop(thread->thread);
+
+	thread->thread = NULL;
+	thread->data = NULL;
+	thread->threadfn = NULL;
+
+	return ret;
+}
diff --git a/drivers/hid/ipts/thread.h b/drivers/hid/ipts/thread.h
new file mode 100644
index 000000000000..1f966b8b32c4
--- /dev/null
+++ b/drivers/hid/ipts/thread.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2023 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_THREAD_H
+#define IPTS_THREAD_H
+
+#include <linux/completion.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+
+/*
+ * This wrapper over kthread is necessary, because calling kthread_stop makes it impossible
+ * to issue MEI commands from that thread while it shuts itself down. By using a custom
+ * boolean variable and a completion object, we can call kthread_stop only when the thread
+ * already finished all of its work and has returned.
+ */
+struct ipts_thread {
+	struct task_struct *thread;
+
+	bool should_stop;
+	struct completion done;
+
+	void *data;
+	int (*threadfn)(struct ipts_thread *thread);
+};
+
+/**
+ * ipts_thread_should_stop() - Returns true if the thread is asked to terminate.
+ * @thread: The current thread.
+ *
+ * Returns: true if the thread should stop, false if not.
+ */
+bool ipts_thread_should_stop(struct ipts_thread *thread);
+
+/**
+ * ipts_thread_start() - Starts an IPTS thread.
+ * @thread: The thread to initialize and start.
+ * @threadfn: The function to execute.
+ * @data: An argument that will be passed to threadfn.
+ * @name: The name of the new thread.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_thread_start(struct ipts_thread *thread, int (*threadfn)(struct ipts_thread *thread),
+		      void *data, const char name[]);
+
+/**
+ * ipts_thread_stop() - Asks the thread to terminate and waits until it has finished.
+ * @thread: The thread that should stop.
+ *
+ * Returns: The return value of the thread function.
+ */
+int ipts_thread_stop(struct ipts_thread *thread);
+
+#endif /* IPTS_THREAD_H */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dorian Stoll <dorian.stoll@tmsp.io>
Date: Sun, 11 Dec 2022 12:03:38 +0100
Subject: iommu: intel: Disable source id verification for ITHC

Signed-off-by: Dorian Stoll <dorian.stoll@tmsp.io>
Patchset: ithc
---
 drivers/iommu/intel/irq_remapping.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/drivers/iommu/intel/irq_remapping.c b/drivers/iommu/intel/irq_remapping.c
index 4f9b01dc91e8..e4d73e45473c 100644
--- a/drivers/iommu/intel/irq_remapping.c
+++ b/drivers/iommu/intel/irq_remapping.c
@@ -381,6 +381,22 @@ static int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 	data.busmatch_count = 0;
 	pci_for_each_dma_alias(dev, set_msi_sid_cb, &data);
 
+	/*
+	 * The Intel Touch Host Controller is at 00:10.6, but for some reason
+	 * the MSI interrupts have request id 01:05.0.
+	 * Disable id verification to work around this.
+	 * FIXME Find proper fix or turn this into a quirk.
+	 */
+	if (dev->vendor == PCI_VENDOR_ID_INTEL && (dev->class >> 8) == PCI_CLASS_INPUT_PEN) {
+		switch(dev->device) {
+		case 0x98d0: case 0x98d1: // LKF
+		case 0xa0d0: case 0xa0d1: // TGL LP
+		case 0x43d0: case 0x43d1: // TGL H
+			set_irte_sid(irte, SVT_NO_VERIFY, SQ_ALL_16, 0);
+			return 0;
+		}
+	}
+
 	/*
 	 * DMA alias provides us with a PCI device and alias.  The only case
 	 * where the it will return an alias on a different bus than the
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: quo <tuple@list.ru>
Date: Sun, 11 Dec 2022 12:10:54 +0100
Subject: hid: Add support for Intel Touch Host Controller

Based on quo/ithc-linux@34539af4726d.

Signed-off-by: Maximilian Stoll <luzmaximilian@gmail.com>
Patchset: ithc
---
 drivers/hid/Kconfig              |   2 +
 drivers/hid/Makefile             |   1 +
 drivers/hid/ithc/Kbuild          |   6 +
 drivers/hid/ithc/Kconfig         |  12 +
 drivers/hid/ithc/ithc-debug.c    | 149 ++++++++
 drivers/hid/ithc/ithc-debug.h    |   7 +
 drivers/hid/ithc/ithc-dma.c      | 312 ++++++++++++++++
 drivers/hid/ithc/ithc-dma.h      |  47 +++
 drivers/hid/ithc/ithc-hid.c      | 207 +++++++++++
 drivers/hid/ithc/ithc-hid.h      |  32 ++
 drivers/hid/ithc/ithc-legacy.c   | 254 +++++++++++++
 drivers/hid/ithc/ithc-legacy.h   |   8 +
 drivers/hid/ithc/ithc-main.c     | 431 ++++++++++++++++++++++
 drivers/hid/ithc/ithc-quickspi.c | 607 +++++++++++++++++++++++++++++++
 drivers/hid/ithc/ithc-quickspi.h |  39 ++
 drivers/hid/ithc/ithc-regs.c     | 154 ++++++++
 drivers/hid/ithc/ithc-regs.h     | 211 +++++++++++
 drivers/hid/ithc/ithc.h          |  89 +++++
 18 files changed, 2568 insertions(+)
 create mode 100644 drivers/hid/ithc/Kbuild
 create mode 100644 drivers/hid/ithc/Kconfig
 create mode 100644 drivers/hid/ithc/ithc-debug.c
 create mode 100644 drivers/hid/ithc/ithc-debug.h
 create mode 100644 drivers/hid/ithc/ithc-dma.c
 create mode 100644 drivers/hid/ithc/ithc-dma.h
 create mode 100644 drivers/hid/ithc/ithc-hid.c
 create mode 100644 drivers/hid/ithc/ithc-hid.h
 create mode 100644 drivers/hid/ithc/ithc-legacy.c
 create mode 100644 drivers/hid/ithc/ithc-legacy.h
 create mode 100644 drivers/hid/ithc/ithc-main.c
 create mode 100644 drivers/hid/ithc/ithc-quickspi.c
 create mode 100644 drivers/hid/ithc/ithc-quickspi.h
 create mode 100644 drivers/hid/ithc/ithc-regs.c
 create mode 100644 drivers/hid/ithc/ithc-regs.h
 create mode 100644 drivers/hid/ithc/ithc.h

diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index b2cc5db65f5b..707983ce6854 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -1430,6 +1430,8 @@ source "drivers/hid/intel-thc-hid/Kconfig"
 
 source "drivers/hid/ipts/Kconfig"
 
+source "drivers/hid/ithc/Kconfig"
+
 endif # HID
 
 # USB support may be used with HID disabled
diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 7ba7d26391e9..d939da7ac2e8 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -177,3 +177,4 @@ obj-$(CONFIG_SURFACE_HID_CORE)  += surface-hid/
 obj-$(CONFIG_INTEL_THC_HID)     += intel-thc-hid/
 
 obj-$(CONFIG_HID_IPTS)          += ipts/
+obj-$(CONFIG_HID_ITHC)          += ithc/
diff --git a/drivers/hid/ithc/Kbuild b/drivers/hid/ithc/Kbuild
new file mode 100644
index 000000000000..4937ba131297
--- /dev/null
+++ b/drivers/hid/ithc/Kbuild
@@ -0,0 +1,6 @@
+obj-$(CONFIG_HID_ITHC) := ithc.o
+
+ithc-objs := ithc-main.o ithc-regs.o ithc-dma.o ithc-hid.o ithc-legacy.o ithc-quickspi.o ithc-debug.o
+
+ccflags-y := -std=gnu11 -Wno-declaration-after-statement
+
diff --git a/drivers/hid/ithc/Kconfig b/drivers/hid/ithc/Kconfig
new file mode 100644
index 000000000000..ede713023609
--- /dev/null
+++ b/drivers/hid/ithc/Kconfig
@@ -0,0 +1,12 @@
+config HID_ITHC
+	tristate "Intel Touch Host Controller"
+	depends on PCI
+	depends on HID
+	help
+	  Say Y here if your system has a touchscreen using Intels
+	  Touch Host Controller (ITHC / IPTS) technology.
+
+	  If unsure say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ithc.
diff --git a/drivers/hid/ithc/ithc-debug.c b/drivers/hid/ithc/ithc-debug.c
new file mode 100644
index 000000000000..2d8c6afe9966
--- /dev/null
+++ b/drivers/hid/ithc/ithc-debug.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+void ithc_log_regs(struct ithc *ithc)
+{
+	if (!ithc->prev_regs)
+		return;
+	u32 __iomem *cur = (__iomem void *)ithc->regs;
+	u32 *prev = (void *)ithc->prev_regs;
+	for (int i = 1024; i < sizeof(*ithc->regs) / 4; i++) {
+		u32 x = readl(cur + i);
+		if (x != prev[i]) {
+			pci_info(ithc->pci, "reg %04x: %08x -> %08x\n", i * 4, prev[i], x);
+			prev[i] = x;
+		}
+	}
+}
+
+static ssize_t ithc_debugfs_cmd_write(struct file *f, const char __user *buf, size_t len,
+	loff_t *offset)
+{
+	// Debug commands consist of a single letter followed by a list of numbers (decimal or
+	// hexadecimal, space-separated).
+	struct ithc *ithc = file_inode(f)->i_private;
+	char cmd[256];
+	if (!ithc || !ithc->pci)
+		return -ENODEV;
+	if (!len)
+		return -EINVAL;
+	if (len >= sizeof(cmd))
+		return -EINVAL;
+	if (copy_from_user(cmd, buf, len))
+		return -EFAULT;
+	cmd[len] = 0;
+	if (cmd[len-1] == '\n')
+		cmd[len-1] = 0;
+	pci_info(ithc->pci, "debug command: %s\n", cmd);
+
+	// Parse the list of arguments into a u32 array.
+	u32 n = 0;
+	const char *s = cmd + 1;
+	u32 a[32];
+	while (*s && *s != '\n') {
+		if (n >= ARRAY_SIZE(a))
+			return -EINVAL;
+		if (*s++ != ' ')
+			return -EINVAL;
+		char *e;
+		a[n++] = simple_strtoul(s, &e, 0);
+		if (e == s)
+			return -EINVAL;
+		s = e;
+	}
+	ithc_log_regs(ithc);
+
+	// Execute the command.
+	switch (cmd[0]) {
+	case 'x': // reset
+		ithc_reset(ithc);
+		break;
+	case 'w': // write register: offset mask value
+		if (n != 3 || (a[0] & 3))
+			return -EINVAL;
+		pci_info(ithc->pci, "debug write 0x%04x = 0x%08x (mask 0x%08x)\n",
+			a[0], a[2], a[1]);
+		bitsl(((__iomem u32 *)ithc->regs) + a[0] / 4, a[1], a[2]);
+		break;
+	case 'r': // read register: offset
+		if (n != 1 || (a[0] & 3))
+			return -EINVAL;
+		pci_info(ithc->pci, "debug read 0x%04x = 0x%08x\n", a[0],
+			readl(((__iomem u32 *)ithc->regs) + a[0] / 4));
+		break;
+	case 's': // spi command: cmd offset len data...
+		// read config: s 4 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
+		// set touch cfg: s 6 12 4 XX
+		if (n < 3 || a[2] > (n - 3) * 4)
+			return -EINVAL;
+		pci_info(ithc->pci, "debug spi command %u with %u bytes of data\n", a[0], a[2]);
+		if (!CHECK(ithc_spi_command, ithc, a[0], a[1], a[2], a + 3))
+			for (u32 i = 0; i < (a[2] + 3) / 4; i++)
+				pci_info(ithc->pci, "resp %u = 0x%08x\n", i, a[3+i]);
+		break;
+	case 'd': // dma command: cmd len data...
+		// get report descriptor: d 7 8 0 0
+		// enable multitouch: d 3 2 0x0105
+		if (n < 1)
+			return -EINVAL;
+		pci_info(ithc->pci, "debug dma command with %u bytes of data\n", n * 4);
+		struct ithc_data data = { .type = ITHC_DATA_RAW, .size = n * 4, .data = a };
+		if (ithc_dma_tx(ithc, &data))
+			pci_err(ithc->pci, "dma tx failed\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+	ithc_log_regs(ithc);
+	return len;
+}
+
+static struct dentry *dbg_dir;
+
+void __init ithc_debug_init_module(void)
+{
+	struct dentry *d = debugfs_create_dir(DEVNAME, NULL);
+	if (IS_ERR(d))
+		pr_warn("failed to create debugfs dir (%li)\n", PTR_ERR(d));
+	else
+		dbg_dir = d;
+}
+
+void __exit ithc_debug_exit_module(void)
+{
+	debugfs_remove_recursive(dbg_dir);
+	dbg_dir = NULL;
+}
+
+static const struct file_operations ithc_debugfops_cmd = {
+	.owner = THIS_MODULE,
+	.write = ithc_debugfs_cmd_write,
+};
+
+static void ithc_debugfs_devres_release(struct device *dev, void *res)
+{
+	struct dentry **dbgm = res;
+	debugfs_remove_recursive(*dbgm);
+}
+
+int ithc_debug_init_device(struct ithc *ithc)
+{
+	if (!dbg_dir)
+		return -ENOENT;
+	struct dentry **dbgm = devres_alloc(ithc_debugfs_devres_release, sizeof(*dbgm), GFP_KERNEL);
+	if (!dbgm)
+		return -ENOMEM;
+	devres_add(&ithc->pci->dev, dbgm);
+	struct dentry *dbg = debugfs_create_dir(pci_name(ithc->pci), dbg_dir);
+	if (IS_ERR(dbg))
+		return PTR_ERR(dbg);
+	*dbgm = dbg;
+
+	struct dentry *cmd = debugfs_create_file("cmd", 0220, dbg, ithc, &ithc_debugfops_cmd);
+	if (IS_ERR(cmd))
+		return PTR_ERR(cmd);
+
+	return 0;
+}
+
diff --git a/drivers/hid/ithc/ithc-debug.h b/drivers/hid/ithc/ithc-debug.h
new file mode 100644
index 000000000000..38c53d916bdb
--- /dev/null
+++ b/drivers/hid/ithc/ithc-debug.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+void ithc_debug_init_module(void);
+void ithc_debug_exit_module(void);
+int ithc_debug_init_device(struct ithc *ithc);
+void ithc_log_regs(struct ithc *ithc);
+
diff --git a/drivers/hid/ithc/ithc-dma.c b/drivers/hid/ithc/ithc-dma.c
new file mode 100644
index 000000000000..bf4eab33062b
--- /dev/null
+++ b/drivers/hid/ithc/ithc-dma.c
@@ -0,0 +1,312 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+// The THC uses tables of PRDs (physical region descriptors) to describe the TX and RX data buffers.
+// Each PRD contains the DMA address and size of a block of DMA memory, and some status flags.
+// This allows each data buffer to consist of multiple non-contiguous blocks of memory.
+
+static int ithc_dma_prd_alloc(struct ithc *ithc, struct ithc_dma_prd_buffer *p,
+	unsigned int num_buffers, unsigned int num_pages, enum dma_data_direction dir)
+{
+	p->num_pages = num_pages;
+	p->dir = dir;
+	// We allocate enough space to have one PRD per data buffer page, however if the data
+	// buffer pages happen to be contiguous, we can describe the buffer using fewer PRDs, so
+	// some will remain unused (which is fine).
+	p->size = round_up(num_buffers * num_pages * sizeof(struct ithc_phys_region_desc), PAGE_SIZE);
+	p->addr = dmam_alloc_coherent(&ithc->pci->dev, p->size, &p->dma_addr, GFP_KERNEL);
+	if (!p->addr)
+		return -ENOMEM;
+	if (p->dma_addr & (PAGE_SIZE - 1))
+		return -EFAULT;
+	return 0;
+}
+
+// Devres managed sg_table wrapper.
+struct ithc_sg_table {
+	void *addr;
+	struct sg_table sgt;
+	enum dma_data_direction dir;
+};
+static void ithc_dma_sgtable_free(struct sg_table *sgt)
+{
+	struct scatterlist *sg;
+	int i;
+	for_each_sgtable_sg(sgt, sg, i) {
+		struct page *p = sg_page(sg);
+		if (p)
+			__free_page(p);
+	}
+	sg_free_table(sgt);
+}
+static void ithc_dma_data_devres_release(struct device *dev, void *res)
+{
+	struct ithc_sg_table *sgt = res;
+	if (sgt->addr)
+		vunmap(sgt->addr);
+	dma_unmap_sgtable(dev, &sgt->sgt, sgt->dir, 0);
+	ithc_dma_sgtable_free(&sgt->sgt);
+}
+
+static int ithc_dma_data_alloc(struct ithc *ithc, struct ithc_dma_prd_buffer *prds,
+	struct ithc_dma_data_buffer *b)
+{
+	// We don't use dma_alloc_coherent() for data buffers, because they don't have to be
+	// coherent (they are unidirectional) or contiguous (we can use one PRD per page).
+	// We could use dma_alloc_noncontiguous(), however this still always allocates a single
+	// DMA mapped segment, which is more restrictive than what we need.
+	// Instead we use an sg_table of individually allocated pages.
+	struct page *pages[16];
+	if (prds->num_pages == 0 || prds->num_pages > ARRAY_SIZE(pages))
+		return -EINVAL;
+	b->active_idx = -1;
+	struct ithc_sg_table *sgt = devres_alloc(
+		ithc_dma_data_devres_release, sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+	sgt->dir = prds->dir;
+
+	if (!sg_alloc_table(&sgt->sgt, prds->num_pages, GFP_KERNEL)) {
+		struct scatterlist *sg;
+		int i;
+		bool ok = true;
+		for_each_sgtable_sg(&sgt->sgt, sg, i) {
+			// NOTE: don't need __GFP_DMA for PCI DMA
+			struct page *p = pages[i] = alloc_page(GFP_KERNEL | __GFP_ZERO);
+			if (!p) {
+				ok = false;
+				break;
+			}
+			sg_set_page(sg, p, PAGE_SIZE, 0);
+		}
+		if (ok && !dma_map_sgtable(&ithc->pci->dev, &sgt->sgt, prds->dir, 0)) {
+			devres_add(&ithc->pci->dev, sgt);
+			b->sgt = &sgt->sgt;
+			b->addr = sgt->addr = vmap(pages, prds->num_pages, 0, PAGE_KERNEL);
+			if (!b->addr)
+				return -ENOMEM;
+			return 0;
+		}
+		ithc_dma_sgtable_free(&sgt->sgt);
+	}
+	devres_free(sgt);
+	return -ENOMEM;
+}
+
+static int ithc_dma_data_buffer_put(struct ithc *ithc, struct ithc_dma_prd_buffer *prds,
+	struct ithc_dma_data_buffer *b, unsigned int idx)
+{
+	// Give a buffer to the THC.
+	struct ithc_phys_region_desc *prd = prds->addr;
+	prd += idx * prds->num_pages;
+	if (b->active_idx >= 0) {
+		pci_err(ithc->pci, "buffer already active\n");
+		return -EINVAL;
+	}
+	b->active_idx = idx;
+	if (prds->dir == DMA_TO_DEVICE) {
+		// TX buffer: Caller should have already filled the data buffer, so just fill
+		// the PRD and flush.
+		// (TODO: Support multi-page TX buffers. So far no device seems to use or need
+		// these though.)
+		if (b->data_size > PAGE_SIZE)
+			return -EINVAL;
+		prd->addr = sg_dma_address(b->sgt->sgl) >> 10;
+		prd->size = b->data_size | PRD_FLAG_END;
+		flush_kernel_vmap_range(b->addr, b->data_size);
+	} else if (prds->dir == DMA_FROM_DEVICE) {
+		// RX buffer: Reset PRDs.
+		struct scatterlist *sg;
+		int i;
+		for_each_sgtable_dma_sg(b->sgt, sg, i) {
+			prd->addr = sg_dma_address(sg) >> 10;
+			prd->size = sg_dma_len(sg);
+			prd++;
+		}
+		prd[-1].size |= PRD_FLAG_END;
+	}
+	dma_wmb(); // for the prds
+	dma_sync_sgtable_for_device(&ithc->pci->dev, b->sgt, prds->dir);
+	return 0;
+}
+
+static int ithc_dma_data_buffer_get(struct ithc *ithc, struct ithc_dma_prd_buffer *prds,
+	struct ithc_dma_data_buffer *b, unsigned int idx)
+{
+	// Take a buffer from the THC.
+	struct ithc_phys_region_desc *prd = prds->addr;
+	prd += idx * prds->num_pages;
+	// This is purely a sanity check. We don't strictly need the idx parameter for this
+	// function, because it should always be the same as active_idx, unless we have a bug.
+	if (b->active_idx != idx) {
+		pci_err(ithc->pci, "wrong buffer index\n");
+		return -EINVAL;
+	}
+	b->active_idx = -1;
+	if (prds->dir == DMA_FROM_DEVICE) {
+		// RX buffer: Calculate actual received data size from PRDs.
+		dma_rmb(); // for the prds
+		b->data_size = 0;
+		struct scatterlist *sg;
+		int i;
+		for_each_sgtable_dma_sg(b->sgt, sg, i) {
+			unsigned int size = prd->size;
+			b->data_size += size & PRD_SIZE_MASK;
+			if (size & PRD_FLAG_END)
+				break;
+			if ((size & PRD_SIZE_MASK) != sg_dma_len(sg)) {
+				pci_err(ithc->pci, "truncated prd\n");
+				break;
+			}
+			prd++;
+		}
+		invalidate_kernel_vmap_range(b->addr, b->data_size);
+	}
+	dma_sync_sgtable_for_cpu(&ithc->pci->dev, b->sgt, prds->dir);
+	return 0;
+}
+
+int ithc_dma_rx_init(struct ithc *ithc, u8 channel)
+{
+	struct ithc_dma_rx *rx = &ithc->dma_rx[channel];
+	mutex_init(&rx->mutex);
+
+	// Allocate buffers.
+	unsigned int num_pages = (ithc->max_rx_size + PAGE_SIZE - 1) / PAGE_SIZE;
+	pci_dbg(ithc->pci, "allocating rx buffers: num = %u, size = %u, pages = %u\n",
+		NUM_RX_BUF, ithc->max_rx_size, num_pages);
+	CHECK_RET(ithc_dma_prd_alloc, ithc, &rx->prds, NUM_RX_BUF, num_pages, DMA_FROM_DEVICE);
+	for (unsigned int i = 0; i < NUM_RX_BUF; i++)
+		CHECK_RET(ithc_dma_data_alloc, ithc, &rx->prds, &rx->bufs[i]);
+
+	// Init registers.
+	writeb(DMA_RX_CONTROL2_RESET, &ithc->regs->dma_rx[channel].control2);
+	lo_hi_writeq(rx->prds.dma_addr, &ithc->regs->dma_rx[channel].addr);
+	writeb(NUM_RX_BUF - 1, &ithc->regs->dma_rx[channel].num_bufs);
+	writeb(num_pages - 1, &ithc->regs->dma_rx[channel].num_prds);
+	u8 head = readb(&ithc->regs->dma_rx[channel].head);
+	if (head) {
+		pci_err(ithc->pci, "head is nonzero (%u)\n", head);
+		return -EIO;
+	}
+
+	// Init buffers.
+	for (unsigned int i = 0; i < NUM_RX_BUF; i++)
+		CHECK_RET(ithc_dma_data_buffer_put, ithc, &rx->prds, &rx->bufs[i], i);
+
+	writeb(head ^ DMA_RX_WRAP_FLAG, &ithc->regs->dma_rx[channel].tail);
+	return 0;
+}
+
+void ithc_dma_rx_enable(struct ithc *ithc, u8 channel)
+{
+	bitsb_set(&ithc->regs->dma_rx[channel].control,
+		DMA_RX_CONTROL_ENABLE | DMA_RX_CONTROL_IRQ_ERROR | DMA_RX_CONTROL_IRQ_DATA);
+	CHECK(waitl, ithc, &ithc->regs->dma_rx[channel].status,
+		DMA_RX_STATUS_ENABLED, DMA_RX_STATUS_ENABLED);
+}
+
+int ithc_dma_tx_init(struct ithc *ithc)
+{
+	struct ithc_dma_tx *tx = &ithc->dma_tx;
+	mutex_init(&tx->mutex);
+
+	// Allocate buffers.
+	unsigned int num_pages = (ithc->max_tx_size + PAGE_SIZE - 1) / PAGE_SIZE;
+	pci_dbg(ithc->pci, "allocating tx buffers: size = %u, pages = %u\n",
+		ithc->max_tx_size, num_pages);
+	CHECK_RET(ithc_dma_prd_alloc, ithc, &tx->prds, 1, num_pages, DMA_TO_DEVICE);
+	CHECK_RET(ithc_dma_data_alloc, ithc, &tx->prds, &tx->buf);
+
+	// Init registers.
+	lo_hi_writeq(tx->prds.dma_addr, &ithc->regs->dma_tx.addr);
+	writeb(num_pages - 1, &ithc->regs->dma_tx.num_prds);
+
+	// Init buffers.
+	CHECK_RET(ithc_dma_data_buffer_put, ithc, &ithc->dma_tx.prds, &ithc->dma_tx.buf, 0);
+	return 0;
+}
+
+static int ithc_dma_rx_unlocked(struct ithc *ithc, u8 channel)
+{
+	// Process all filled RX buffers from the ringbuffer.
+	struct ithc_dma_rx *rx = &ithc->dma_rx[channel];
+	unsigned int n = rx->num_received;
+	u8 head_wrap = readb(&ithc->regs->dma_rx[channel].head);
+	while (1) {
+		u8 tail = n % NUM_RX_BUF;
+		u8 tail_wrap = tail | ((n / NUM_RX_BUF) & 1 ? 0 : DMA_RX_WRAP_FLAG);
+		writeb(tail_wrap, &ithc->regs->dma_rx[channel].tail);
+		// ringbuffer is full if tail_wrap == head_wrap
+		// ringbuffer is empty if tail_wrap == head_wrap ^ WRAP_FLAG
+		if (tail_wrap == (head_wrap ^ DMA_RX_WRAP_FLAG))
+			return 0;
+
+		// take the buffer that the device just filled
+		struct ithc_dma_data_buffer *b = &rx->bufs[n % NUM_RX_BUF];
+		CHECK_RET(ithc_dma_data_buffer_get, ithc, &rx->prds, b, tail);
+		rx->num_received = ++n;
+
+		// process data
+		struct ithc_data d;
+		if ((ithc->use_quickspi ? ithc_quickspi_decode_rx : ithc_legacy_decode_rx)
+			(ithc, b->addr, b->data_size, &d) < 0) {
+			pci_err(ithc->pci, "invalid dma rx data! channel %u, buffer %u, size %u: %*ph\n",
+				channel, tail, b->data_size, min((int)b->data_size, 64), b->addr);
+			print_hex_dump_debug(DEVNAME " data: ", DUMP_PREFIX_OFFSET, 32, 1,
+				b->addr, min(b->data_size, 0x400u), 0);
+		} else {
+			ithc_hid_process_data(ithc, &d);
+		}
+
+		// give the buffer back to the device
+		CHECK_RET(ithc_dma_data_buffer_put, ithc, &rx->prds, b, tail);
+	}
+}
+int ithc_dma_rx(struct ithc *ithc, u8 channel)
+{
+	struct ithc_dma_rx *rx = &ithc->dma_rx[channel];
+	mutex_lock(&rx->mutex);
+	int ret = ithc_dma_rx_unlocked(ithc, channel);
+	mutex_unlock(&rx->mutex);
+	return ret;
+}
+
+static int ithc_dma_tx_unlocked(struct ithc *ithc, const struct ithc_data *data)
+{
+	// Send a single TX buffer to the THC.
+	pci_dbg(ithc->pci, "dma tx data type %u, size %u\n", data->type, data->size);
+	CHECK_RET(ithc_dma_data_buffer_get, ithc, &ithc->dma_tx.prds, &ithc->dma_tx.buf, 0);
+
+	// Fill the TX buffer with header and data.
+	ssize_t sz;
+	if (data->type == ITHC_DATA_RAW) {
+		sz = min(data->size, ithc->max_tx_size);
+		memcpy(ithc->dma_tx.buf.addr, data->data, sz);
+	} else {
+		sz = (ithc->use_quickspi ? ithc_quickspi_encode_tx : ithc_legacy_encode_tx)
+			(ithc, data, ithc->dma_tx.buf.addr, ithc->max_tx_size);
+	}
+	ithc->dma_tx.buf.data_size = sz < 0 ? 0 : sz;
+	CHECK_RET(ithc_dma_data_buffer_put, ithc, &ithc->dma_tx.prds, &ithc->dma_tx.buf, 0);
+	if (sz < 0) {
+		pci_err(ithc->pci, "failed to encode tx data type %i, size %u, error %i\n",
+			data->type, data->size, (int)sz);
+		return -EINVAL;
+	}
+
+	// Let the THC process the buffer.
+	bitsb_set(&ithc->regs->dma_tx.control, DMA_TX_CONTROL_SEND);
+	CHECK_RET(waitb, ithc, &ithc->regs->dma_tx.control, DMA_TX_CONTROL_SEND, 0);
+	writel(DMA_TX_STATUS_DONE, &ithc->regs->dma_tx.status);
+	return 0;
+}
+int ithc_dma_tx(struct ithc *ithc, const struct ithc_data *data)
+{
+	mutex_lock(&ithc->dma_tx.mutex);
+	int ret = ithc_dma_tx_unlocked(ithc, data);
+	mutex_unlock(&ithc->dma_tx.mutex);
+	return ret;
+}
+
diff --git a/drivers/hid/ithc/ithc-dma.h b/drivers/hid/ithc/ithc-dma.h
new file mode 100644
index 000000000000..1749a5819b3e
--- /dev/null
+++ b/drivers/hid/ithc/ithc-dma.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+#define PRD_SIZE_MASK            0xffffff
+#define PRD_FLAG_END             0x1000000
+#define PRD_FLAG_SUCCESS         0x2000000
+#define PRD_FLAG_ERROR           0x4000000
+
+struct ithc_phys_region_desc {
+	u64 addr; // physical addr/1024
+	u32 size; // num bytes, PRD_FLAG_END marks last prd for data split over multiple prds
+	u32 unused;
+};
+
+struct ithc_dma_prd_buffer {
+	void *addr;
+	dma_addr_t dma_addr;
+	u32 size;
+	u32 num_pages; // per data buffer
+	enum dma_data_direction dir;
+};
+
+struct ithc_dma_data_buffer {
+	void *addr;
+	struct sg_table *sgt;
+	int active_idx;
+	u32 data_size;
+};
+
+struct ithc_dma_tx {
+	struct mutex mutex;
+	struct ithc_dma_prd_buffer prds;
+	struct ithc_dma_data_buffer buf;
+};
+
+struct ithc_dma_rx {
+	struct mutex mutex;
+	u32 num_received;
+	struct ithc_dma_prd_buffer prds;
+	struct ithc_dma_data_buffer bufs[NUM_RX_BUF];
+};
+
+int ithc_dma_rx_init(struct ithc *ithc, u8 channel);
+void ithc_dma_rx_enable(struct ithc *ithc, u8 channel);
+int ithc_dma_tx_init(struct ithc *ithc);
+int ithc_dma_rx(struct ithc *ithc, u8 channel);
+int ithc_dma_tx(struct ithc *ithc, const struct ithc_data *data);
+
diff --git a/drivers/hid/ithc/ithc-hid.c b/drivers/hid/ithc/ithc-hid.c
new file mode 100644
index 000000000000..065646ab499e
--- /dev/null
+++ b/drivers/hid/ithc/ithc-hid.c
@@ -0,0 +1,207 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+static int ithc_hid_start(struct hid_device *hdev) { return 0; }
+static void ithc_hid_stop(struct hid_device *hdev) { }
+static int ithc_hid_open(struct hid_device *hdev) { return 0; }
+static void ithc_hid_close(struct hid_device *hdev) { }
+
+static int ithc_hid_parse(struct hid_device *hdev)
+{
+	struct ithc *ithc = hdev->driver_data;
+	const struct ithc_data get_report_desc = { .type = ITHC_DATA_REPORT_DESCRIPTOR };
+	WRITE_ONCE(ithc->hid.parse_done, false);
+	for (int retries = 0; ; retries++) {
+		ithc_log_regs(ithc);
+		CHECK_RET(ithc_dma_tx, ithc, &get_report_desc);
+		if (wait_event_timeout(ithc->hid.wait_parse, READ_ONCE(ithc->hid.parse_done),
+				msecs_to_jiffies(200))) {
+			ithc_log_regs(ithc);
+			return 0;
+		}
+		if (retries > 5) {
+			ithc_log_regs(ithc);
+			pci_err(ithc->pci, "failed to read report descriptor\n");
+			return -ETIMEDOUT;
+		}
+		pci_warn(ithc->pci, "failed to read report descriptor, retrying\n");
+	}
+}
+
+static int ithc_hid_raw_request(struct hid_device *hdev, unsigned char reportnum, __u8 *buf,
+	size_t len, unsigned char rtype, int reqtype)
+{
+	struct ithc *ithc = hdev->driver_data;
+	if (!buf || !len)
+		return -EINVAL;
+
+	struct ithc_data d = { .size = len, .data = buf };
+	buf[0] = reportnum;
+
+	if (rtype == HID_OUTPUT_REPORT && reqtype == HID_REQ_SET_REPORT) {
+		d.type = ITHC_DATA_OUTPUT_REPORT;
+		CHECK_RET(ithc_dma_tx, ithc, &d);
+		return 0;
+	}
+
+	if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_SET_REPORT) {
+		d.type = ITHC_DATA_SET_FEATURE;
+		CHECK_RET(ithc_dma_tx, ithc, &d);
+		return 0;
+	}
+
+	if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_GET_REPORT) {
+		d.type = ITHC_DATA_GET_FEATURE;
+		d.data = &reportnum;
+		d.size = 1;
+
+		// Prepare for response.
+		mutex_lock(&ithc->hid.get_feature_mutex);
+		ithc->hid.get_feature_buf = buf;
+		ithc->hid.get_feature_size = len;
+		mutex_unlock(&ithc->hid.get_feature_mutex);
+
+		// Transmit 'get feature' request.
+		int r = CHECK(ithc_dma_tx, ithc, &d);
+		if (!r) {
+			r = wait_event_interruptible_timeout(ithc->hid.wait_get_feature,
+				!ithc->hid.get_feature_buf, msecs_to_jiffies(1000));
+			if (!r)
+				r = -ETIMEDOUT;
+			else if (r < 0)
+				r = -EINTR;
+			else
+				r = 0;
+		}
+
+		// If everything went ok, the buffer has been filled with the response data.
+		// Return the response size.
+		mutex_lock(&ithc->hid.get_feature_mutex);
+		ithc->hid.get_feature_buf = NULL;
+		if (!r)
+			r = ithc->hid.get_feature_size;
+		mutex_unlock(&ithc->hid.get_feature_mutex);
+		return r;
+	}
+
+	pci_err(ithc->pci, "unhandled hid request %i %i for report id %i\n",
+		rtype, reqtype, reportnum);
+	return -EINVAL;
+}
+
+// FIXME hid_input_report()/hid_parse_report() currently don't take const buffers, so we have to
+// cast away the const to avoid a compiler warning...
+#define NOCONST(x) ((void *)x)
+
+void ithc_hid_process_data(struct ithc *ithc, struct ithc_data *d)
+{
+	WARN_ON(!ithc->hid.dev);
+	if (!ithc->hid.dev)
+		return;
+
+	switch (d->type) {
+
+	case ITHC_DATA_IGNORE:
+		return;
+
+	case ITHC_DATA_ERROR:
+		CHECK(ithc_reset, ithc);
+		return;
+
+	case ITHC_DATA_REPORT_DESCRIPTOR:
+		// Response to the report descriptor request sent by ithc_hid_parse().
+		CHECK(hid_parse_report, ithc->hid.dev, NOCONST(d->data), d->size);
+		WRITE_ONCE(ithc->hid.parse_done, true);
+		wake_up(&ithc->hid.wait_parse);
+		return;
+
+	case ITHC_DATA_INPUT_REPORT:
+	{
+		// Standard HID input report.
+		int r = hid_input_report(ithc->hid.dev, HID_INPUT_REPORT, NOCONST(d->data), d->size, 1);
+		if (r < 0) {
+			pci_warn(ithc->pci, "hid_input_report failed with %i (size %u, report ID 0x%02x)\n",
+				r, d->size, d->size ? *(u8 *)d->data : 0);
+			print_hex_dump_debug(DEVNAME " report: ", DUMP_PREFIX_OFFSET, 32, 1,
+				d->data, min(d->size, 0x400u), 0);
+		}
+		return;
+	}
+
+	case ITHC_DATA_GET_FEATURE:
+	{
+		// Response to a 'get feature' request sent by ithc_hid_raw_request().
+		bool done = false;
+		mutex_lock(&ithc->hid.get_feature_mutex);
+		if (ithc->hid.get_feature_buf) {
+			if (d->size < ithc->hid.get_feature_size)
+				ithc->hid.get_feature_size = d->size;
+			memcpy(ithc->hid.get_feature_buf, d->data, ithc->hid.get_feature_size);
+			ithc->hid.get_feature_buf = NULL;
+			done = true;
+		}
+		mutex_unlock(&ithc->hid.get_feature_mutex);
+		if (done) {
+			wake_up(&ithc->hid.wait_get_feature);
+		} else {
+			// Received data without a matching request, or the request already
+			// timed out. (XXX What's the correct thing to do here?)
+			CHECK(hid_input_report, ithc->hid.dev, HID_FEATURE_REPORT,
+				NOCONST(d->data), d->size, 1);
+		}
+		return;
+	}
+
+	default:
+		pci_err(ithc->pci, "unhandled data type %i\n", d->type);
+		return;
+	}
+}
+
+static struct hid_ll_driver ithc_ll_driver = {
+	.start = ithc_hid_start,
+	.stop = ithc_hid_stop,
+	.open = ithc_hid_open,
+	.close = ithc_hid_close,
+	.parse = ithc_hid_parse,
+	.raw_request = ithc_hid_raw_request,
+};
+
+static void ithc_hid_devres_release(struct device *dev, void *res)
+{
+	struct hid_device **hidm = res;
+	if (*hidm)
+		hid_destroy_device(*hidm);
+}
+
+int ithc_hid_init(struct ithc *ithc)
+{
+	struct hid_device **hidm = devres_alloc(ithc_hid_devres_release, sizeof(*hidm), GFP_KERNEL);
+	if (!hidm)
+		return -ENOMEM;
+	devres_add(&ithc->pci->dev, hidm);
+	struct hid_device *hid = hid_allocate_device();
+	if (IS_ERR(hid))
+		return PTR_ERR(hid);
+	*hidm = hid;
+
+	strscpy(hid->name, DEVFULLNAME, sizeof(hid->name));
+	strscpy(hid->phys, ithc->phys, sizeof(hid->phys));
+	hid->ll_driver = &ithc_ll_driver;
+	hid->bus = BUS_PCI;
+	hid->vendor = ithc->vendor_id;
+	hid->product = ithc->product_id;
+	hid->version = 0x100;
+	hid->dev.parent = &ithc->pci->dev;
+	hid->driver_data = ithc;
+
+	ithc->hid.dev = hid;
+
+	init_waitqueue_head(&ithc->hid.wait_parse);
+	init_waitqueue_head(&ithc->hid.wait_get_feature);
+	mutex_init(&ithc->hid.get_feature_mutex);
+
+	return 0;
+}
+
diff --git a/drivers/hid/ithc/ithc-hid.h b/drivers/hid/ithc/ithc-hid.h
new file mode 100644
index 000000000000..599eb912c8c8
--- /dev/null
+++ b/drivers/hid/ithc/ithc-hid.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+enum ithc_data_type {
+	ITHC_DATA_IGNORE,
+	ITHC_DATA_RAW,
+	ITHC_DATA_ERROR,
+	ITHC_DATA_REPORT_DESCRIPTOR,
+	ITHC_DATA_INPUT_REPORT,
+	ITHC_DATA_OUTPUT_REPORT,
+	ITHC_DATA_GET_FEATURE,
+	ITHC_DATA_SET_FEATURE,
+};
+
+struct ithc_data {
+	enum ithc_data_type type;
+	u32 size;
+	const void *data;
+};
+
+struct ithc_hid {
+	struct hid_device *dev;
+	bool parse_done;
+	wait_queue_head_t wait_parse;
+	wait_queue_head_t wait_get_feature;
+	struct mutex get_feature_mutex;
+	void *get_feature_buf;
+	size_t get_feature_size;
+};
+
+int ithc_hid_init(struct ithc *ithc);
+void ithc_hid_process_data(struct ithc *ithc, struct ithc_data *d);
+
diff --git a/drivers/hid/ithc/ithc-legacy.c b/drivers/hid/ithc/ithc-legacy.c
new file mode 100644
index 000000000000..8883987fb352
--- /dev/null
+++ b/drivers/hid/ithc/ithc-legacy.c
@@ -0,0 +1,254 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+#define DEVCFG_DMA_RX_SIZE(x)          ((((x) & 0x3fff) + 1) << 6)
+#define DEVCFG_DMA_TX_SIZE(x)          (((((x) >> 14) & 0x3ff) + 1) << 6)
+
+#define DEVCFG_TOUCH_MASK              0x3f
+#define DEVCFG_TOUCH_ENABLE            BIT(0)
+#define DEVCFG_TOUCH_PROP_DATA_ENABLE  BIT(1)
+#define DEVCFG_TOUCH_HID_REPORT_ENABLE BIT(2)
+#define DEVCFG_TOUCH_POWER_STATE(x)    (((x) & 7) << 3)
+#define DEVCFG_TOUCH_UNKNOWN_6         BIT(6)
+
+#define DEVCFG_DEVICE_ID_TIC           0x43495424 // "$TIC"
+
+#define DEVCFG_SPI_CLKDIV(x)           (((x) >> 1) & 7)
+#define DEVCFG_SPI_CLKDIV_8            BIT(4)
+#define DEVCFG_SPI_SUPPORTS_SINGLE     BIT(5)
+#define DEVCFG_SPI_SUPPORTS_DUAL       BIT(6)
+#define DEVCFG_SPI_SUPPORTS_QUAD       BIT(7)
+#define DEVCFG_SPI_MAX_TOUCH_POINTS(x) (((x) >> 8) & 0x3f)
+#define DEVCFG_SPI_MIN_RESET_TIME(x)   (((x) >> 16) & 0xf)
+#define DEVCFG_SPI_NEEDS_HEARTBEAT     BIT(20) // TODO implement heartbeat
+#define DEVCFG_SPI_HEARTBEAT_INTERVAL(x) (((x) >> 21) & 7)
+#define DEVCFG_SPI_UNKNOWN_25          BIT(25)
+#define DEVCFG_SPI_UNKNOWN_26          BIT(26)
+#define DEVCFG_SPI_UNKNOWN_27          BIT(27)
+#define DEVCFG_SPI_DELAY(x)            (((x) >> 28) & 7) // TODO use this
+#define DEVCFG_SPI_USE_EXT_READ_CFG    BIT(31) // TODO use this?
+
+struct ithc_device_config { // (Example values are from an SP7+.)
+	u32 irq_cause;        // 00 = 0xe0000402 (0xe0000401 after DMA_RX_CODE_RESET)
+	u32 error;            // 04 = 0x00000000
+	u32 dma_buf_sizes;    // 08 = 0x000a00ff
+	u32 touch_cfg;        // 0c = 0x0000001c
+	u32 touch_state;      // 10 = 0x0000001c
+	u32 device_id;        // 14 = 0x43495424 = "$TIC"
+	u32 spi_config;       // 18 = 0xfda00a2e
+	u16 vendor_id;        // 1c = 0x045e = Microsoft Corp.
+	u16 product_id;       // 1e = 0x0c1a
+	u32 revision;         // 20 = 0x00000001
+	u32 fw_version;       // 24 = 0x05008a8b = 5.0.138.139 (this value looks more random on newer devices)
+	u32 command;          // 28 = 0x00000000
+	u32 fw_mode;          // 2c = 0x00000000 (for fw update?)
+	u32 _unknown_30;      // 30 = 0x00000000
+	u8 eds_minor_ver;     // 34 = 0x5e
+	u8 eds_major_ver;     // 35 = 0x03
+	u8 interface_rev;     // 36 = 0x04
+	u8 eu_kernel_ver;     // 37 = 0x04
+	u32 _unknown_38;      // 38 = 0x000001c0 (0x000001c1 after DMA_RX_CODE_RESET)
+	u32 _unknown_3c;      // 3c = 0x00000002
+};
+static_assert(sizeof(struct ithc_device_config) == 64);
+
+#define RX_CODE_INPUT_REPORT          3
+#define RX_CODE_FEATURE_REPORT        4
+#define RX_CODE_REPORT_DESCRIPTOR     5
+#define RX_CODE_RESET                 7
+
+#define TX_CODE_SET_FEATURE           3
+#define TX_CODE_GET_FEATURE           4
+#define TX_CODE_OUTPUT_REPORT         5
+#define TX_CODE_GET_REPORT_DESCRIPTOR 7
+
+static int ithc_set_device_enabled(struct ithc *ithc, bool enable)
+{
+	u32 x = ithc->legacy_touch_cfg =
+		(ithc->legacy_touch_cfg & ~(u32)DEVCFG_TOUCH_MASK) |
+		DEVCFG_TOUCH_HID_REPORT_ENABLE |
+		(enable ? DEVCFG_TOUCH_ENABLE | DEVCFG_TOUCH_POWER_STATE(3) : 0);
+	return ithc_spi_command(ithc, SPI_CMD_CODE_WRITE,
+		offsetof(struct ithc_device_config, touch_cfg), sizeof(x), &x);
+}
+
+int ithc_legacy_init(struct ithc *ithc)
+{
+	// Since we don't yet know which SPI config the device wants, use default speed and mode
+	// initially for reading config data.
+	CHECK(ithc_set_spi_config, ithc, 2, true, SPI_MODE_SINGLE, SPI_MODE_SINGLE);
+
+	// Setting the following bit seems to make reading the config more reliable.
+	bitsl_set(&ithc->regs->dma_rx[0].init_unknown, INIT_UNKNOWN_31);
+
+	// Setting this bit may be necessary on ADL devices.
+	switch (ithc->pci->device) {
+	case PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT2:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT2:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT2:
+		bitsl_set(&ithc->regs->dma_rx[0].init_unknown, INIT_UNKNOWN_5);
+		break;
+	}
+
+	// Take the touch device out of reset.
+	bitsl(&ithc->regs->control_bits, CONTROL_QUIESCE, 0);
+	CHECK_RET(waitl, ithc, &ithc->regs->control_bits, CONTROL_IS_QUIESCED, 0);
+	for (int retries = 0; ; retries++) {
+		ithc_log_regs(ithc);
+		bitsl_set(&ithc->regs->control_bits, CONTROL_NRESET);
+		if (!waitl(ithc, &ithc->regs->irq_cause, 0xf, 2))
+			break;
+		if (retries > 5) {
+			pci_err(ithc->pci, "failed to reset device, irq_cause = 0x%08x\n",
+				readl(&ithc->regs->irq_cause));
+			return -ETIMEDOUT;
+		}
+		pci_warn(ithc->pci, "invalid irq_cause, retrying reset\n");
+		bitsl(&ithc->regs->control_bits, CONTROL_NRESET, 0);
+		if (msleep_interruptible(1000))
+			return -EINTR;
+	}
+	ithc_log_regs(ithc);
+
+	CHECK(waitl, ithc, &ithc->regs->dma_rx[0].status, DMA_RX_STATUS_READY, DMA_RX_STATUS_READY);
+
+	// Read configuration data.
+	u32 spi_cfg;
+	for (int retries = 0; ; retries++) {
+		ithc_log_regs(ithc);
+		struct ithc_device_config config = { 0 };
+		CHECK_RET(ithc_spi_command, ithc, SPI_CMD_CODE_READ, 0, sizeof(config), &config);
+		u32 *p = (void *)&config;
+		pci_info(ithc->pci, "config: %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
+			p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);
+		if (config.device_id == DEVCFG_DEVICE_ID_TIC) {
+			spi_cfg = config.spi_config;
+			ithc->vendor_id = config.vendor_id;
+			ithc->product_id = config.product_id;
+			ithc->product_rev = config.revision;
+			ithc->max_rx_size = DEVCFG_DMA_RX_SIZE(config.dma_buf_sizes);
+			ithc->max_tx_size = DEVCFG_DMA_TX_SIZE(config.dma_buf_sizes);
+			ithc->legacy_touch_cfg = config.touch_cfg;
+			ithc->have_config = true;
+			break;
+		}
+		if (retries > 10) {
+			pci_err(ithc->pci, "failed to read config, unknown device ID 0x%08x\n",
+				config.device_id);
+			return -EIO;
+		}
+		pci_warn(ithc->pci, "failed to read config, retrying\n");
+		if (msleep_interruptible(100))
+			return -EINTR;
+	}
+	ithc_log_regs(ithc);
+
+	// Apply SPI config and enable touch device.
+	CHECK_RET(ithc_set_spi_config, ithc,
+		DEVCFG_SPI_CLKDIV(spi_cfg), (spi_cfg & DEVCFG_SPI_CLKDIV_8) != 0,
+		spi_cfg & DEVCFG_SPI_SUPPORTS_QUAD ? SPI_MODE_QUAD :
+		spi_cfg & DEVCFG_SPI_SUPPORTS_DUAL ? SPI_MODE_DUAL :
+		SPI_MODE_SINGLE,
+		SPI_MODE_SINGLE);
+	CHECK_RET(ithc_set_device_enabled, ithc, true);
+	ithc_log_regs(ithc);
+	return 0;
+}
+
+void ithc_legacy_exit(struct ithc *ithc)
+{
+	CHECK(ithc_set_device_enabled, ithc, false);
+}
+
+int ithc_legacy_decode_rx(struct ithc *ithc, const void *src, size_t len, struct ithc_data *dest)
+{
+	const struct {
+		u32 code;
+		u32 data_size;
+		u32 _unknown[14];
+	} *hdr = src;
+
+	if (len < sizeof(*hdr))
+		return -ENODATA;
+	// Note: RX data is not padded, even though TX data must be padded.
+	if (len != sizeof(*hdr) + hdr->data_size)
+		return -EMSGSIZE;
+
+	dest->data = hdr + 1;
+	dest->size = hdr->data_size;
+
+	switch (hdr->code) {
+	case RX_CODE_RESET:
+		// The THC sends a reset request when we need to reinitialize the device.
+		// This usually only happens if we send an invalid command or put the device
+		// in a bad state.
+		dest->type = ITHC_DATA_ERROR;
+		return 0;
+	case RX_CODE_REPORT_DESCRIPTOR:
+		// The descriptor is preceded by 8 nul bytes.
+		if (hdr->data_size < 8)
+			return -ENODATA;
+		dest->type = ITHC_DATA_REPORT_DESCRIPTOR;
+		dest->data = (char *)(hdr + 1) + 8;
+		dest->size = hdr->data_size - 8;
+		return 0;
+	case RX_CODE_INPUT_REPORT:
+		dest->type = ITHC_DATA_INPUT_REPORT;
+		return 0;
+	case RX_CODE_FEATURE_REPORT:
+		dest->type = ITHC_DATA_GET_FEATURE;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+ssize_t ithc_legacy_encode_tx(struct ithc *ithc, const struct ithc_data *src, void *dest,
+	size_t maxlen)
+{
+	struct {
+		u32 code;
+		u32 data_size;
+	} *hdr = dest;
+
+	size_t src_size = src->size;
+	const void *src_data = src->data;
+	const u64 get_report_desc_data = 0;
+	u32 code;
+
+	switch (src->type) {
+	case ITHC_DATA_SET_FEATURE:
+		code = TX_CODE_SET_FEATURE;
+		break;
+	case ITHC_DATA_GET_FEATURE:
+		code = TX_CODE_GET_FEATURE;
+		break;
+	case ITHC_DATA_OUTPUT_REPORT:
+		code = TX_CODE_OUTPUT_REPORT;
+		break;
+	case ITHC_DATA_REPORT_DESCRIPTOR:
+		code = TX_CODE_GET_REPORT_DESCRIPTOR;
+		src_size = sizeof(get_report_desc_data);
+		src_data = &get_report_desc_data;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	// Data must be padded to next 4-byte boundary.
+	size_t padded = round_up(src_size, 4);
+	if (sizeof(*hdr) + padded > maxlen)
+		return -EOVERFLOW;
+
+	// Fill the TX buffer with header and data.
+	hdr->code = code;
+	hdr->data_size = src_size;
+	memcpy_and_pad(hdr + 1, padded, src_data, src_size, 0);
+
+	return sizeof(*hdr) + padded;
+}
+
diff --git a/drivers/hid/ithc/ithc-legacy.h b/drivers/hid/ithc/ithc-legacy.h
new file mode 100644
index 000000000000..28d692462072
--- /dev/null
+++ b/drivers/hid/ithc/ithc-legacy.h
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+int ithc_legacy_init(struct ithc *ithc);
+void ithc_legacy_exit(struct ithc *ithc);
+int ithc_legacy_decode_rx(struct ithc *ithc, const void *src, size_t len, struct ithc_data *dest);
+ssize_t ithc_legacy_encode_tx(struct ithc *ithc, const struct ithc_data *src, void *dest,
+	size_t maxlen);
+
diff --git a/drivers/hid/ithc/ithc-main.c b/drivers/hid/ithc/ithc-main.c
new file mode 100644
index 000000000000..bde099451416
--- /dev/null
+++ b/drivers/hid/ithc/ithc-main.c
@@ -0,0 +1,431 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+MODULE_DESCRIPTION("Intel Touch Host Controller driver");
+MODULE_LICENSE("Dual BSD/GPL");
+
+static const struct pci_device_id ithc_pci_tbl[] = {
+	{
+		.vendor = PCI_VENDOR_ID_INTEL,
+		.device = PCI_ANY_ID,
+		.subvendor = PCI_ANY_ID,
+		.subdevice = PCI_ANY_ID,
+		.class = PCI_CLASS_INPUT_PEN << 8,
+		.class_mask = ~0,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(pci, ithc_pci_tbl);
+
+// Module parameters
+
+static bool ithc_use_polling = false;
+module_param_named(poll, ithc_use_polling, bool, 0);
+MODULE_PARM_DESC(poll, "Use polling instead of interrupts");
+
+// Since all known devices seem to use only channel 1, by default we disable channel 0.
+static bool ithc_use_rx0 = false;
+module_param_named(rx0, ithc_use_rx0, bool, 0);
+MODULE_PARM_DESC(rx0, "Use DMA RX channel 0");
+
+static bool ithc_use_rx1 = true;
+module_param_named(rx1, ithc_use_rx1, bool, 0);
+MODULE_PARM_DESC(rx1, "Use DMA RX channel 1");
+
+static int ithc_active_ltr_us = -1;
+module_param_named(activeltr, ithc_active_ltr_us, int, 0);
+MODULE_PARM_DESC(activeltr, "Active LTR value override (in microseconds)");
+
+static int ithc_idle_ltr_us = -1;
+module_param_named(idleltr, ithc_idle_ltr_us, int, 0);
+MODULE_PARM_DESC(idleltr, "Idle LTR value override (in microseconds)");
+
+static unsigned int ithc_idle_delay_ms = 1000;
+module_param_named(idledelay, ithc_idle_delay_ms, uint, 0);
+MODULE_PARM_DESC(idleltr, "Minimum idle time before applying idle LTR value (in milliseconds)");
+
+static bool ithc_log_regs_enabled = false;
+module_param_named(logregs, ithc_log_regs_enabled, bool, 0);
+MODULE_PARM_DESC(logregs, "Log changes in register values (for debugging)");
+
+// Interrupts/polling
+
+static void ithc_disable_interrupts(struct ithc *ithc)
+{
+	writel(0, &ithc->regs->error_control);
+	bitsb(&ithc->regs->spi_cmd.control, SPI_CMD_CONTROL_IRQ, 0);
+	bitsb(&ithc->regs->dma_rx[0].control, DMA_RX_CONTROL_IRQ_UNKNOWN_1 | DMA_RX_CONTROL_IRQ_ERROR | DMA_RX_CONTROL_IRQ_READY | DMA_RX_CONTROL_IRQ_DATA, 0);
+	bitsb(&ithc->regs->dma_rx[1].control, DMA_RX_CONTROL_IRQ_UNKNOWN_1 | DMA_RX_CONTROL_IRQ_ERROR | DMA_RX_CONTROL_IRQ_READY | DMA_RX_CONTROL_IRQ_DATA, 0);
+	bitsb(&ithc->regs->dma_tx.control, DMA_TX_CONTROL_IRQ, 0);
+}
+
+static void ithc_clear_dma_rx_interrupts(struct ithc *ithc, unsigned int channel)
+{
+	writel(DMA_RX_STATUS_ERROR | DMA_RX_STATUS_READY | DMA_RX_STATUS_HAVE_DATA,
+		&ithc->regs->dma_rx[channel].status);
+}
+
+static void ithc_clear_interrupts(struct ithc *ithc)
+{
+	writel(0xffffffff, &ithc->regs->error_flags);
+	writel(ERROR_STATUS_DMA | ERROR_STATUS_SPI, &ithc->regs->error_status);
+	writel(SPI_CMD_STATUS_DONE | SPI_CMD_STATUS_ERROR, &ithc->regs->spi_cmd.status);
+	ithc_clear_dma_rx_interrupts(ithc, 0);
+	ithc_clear_dma_rx_interrupts(ithc, 1);
+	writel(DMA_TX_STATUS_DONE | DMA_TX_STATUS_ERROR | DMA_TX_STATUS_UNKNOWN_2,
+		&ithc->regs->dma_tx.status);
+}
+
+static void ithc_idle_timer_callback(struct timer_list *t)
+{
+	struct ithc *ithc = container_of(t, struct ithc, idle_timer);
+	ithc_set_ltr_idle(ithc);
+}
+
+static void ithc_process(struct ithc *ithc)
+{
+	ithc_log_regs(ithc);
+
+	// The THC automatically transitions from LTR idle to active at the start of a DMA transfer.
+	// It does not appear to automatically go back to idle, so we switch it back after a delay.
+	mod_timer(&ithc->idle_timer, jiffies + msecs_to_jiffies(ithc_idle_delay_ms));
+
+	bool rx0 = ithc_use_rx0 && (readl(&ithc->regs->dma_rx[0].status) & (DMA_RX_STATUS_ERROR | DMA_RX_STATUS_HAVE_DATA)) != 0;
+	bool rx1 = ithc_use_rx1 && (readl(&ithc->regs->dma_rx[1].status) & (DMA_RX_STATUS_ERROR | DMA_RX_STATUS_HAVE_DATA)) != 0;
+
+	// Read and clear error bits
+	u32 err = readl(&ithc->regs->error_flags);
+	if (err) {
+		writel(err, &ithc->regs->error_flags);
+		if (err & ~ERROR_FLAG_DMA_RX_TIMEOUT)
+			pci_err(ithc->pci, "error flags: 0x%08x\n", err);
+		if (err & ERROR_FLAG_DMA_RX_TIMEOUT)
+			pci_err(ithc->pci, "DMA RX timeout/error (try decreasing activeltr/idleltr if this happens frequently)\n");
+	}
+
+	// Process DMA rx
+	if (ithc_use_rx0) {
+		ithc_clear_dma_rx_interrupts(ithc, 0);
+		if (rx0)
+			ithc_dma_rx(ithc, 0);
+	}
+	if (ithc_use_rx1) {
+		ithc_clear_dma_rx_interrupts(ithc, 1);
+		if (rx1)
+			ithc_dma_rx(ithc, 1);
+	}
+
+	ithc_log_regs(ithc);
+}
+
+static irqreturn_t ithc_interrupt_thread(int irq, void *arg)
+{
+	struct ithc *ithc = arg;
+	pci_dbg(ithc->pci, "IRQ! err=%08x/%08x/%08x, cmd=%02x/%08x, rx0=%02x/%08x, rx1=%02x/%08x, tx=%02x/%08x\n",
+		readl(&ithc->regs->error_control), readl(&ithc->regs->error_status), readl(&ithc->regs->error_flags),
+		readb(&ithc->regs->spi_cmd.control), readl(&ithc->regs->spi_cmd.status),
+		readb(&ithc->regs->dma_rx[0].control), readl(&ithc->regs->dma_rx[0].status),
+		readb(&ithc->regs->dma_rx[1].control), readl(&ithc->regs->dma_rx[1].status),
+		readb(&ithc->regs->dma_tx.control), readl(&ithc->regs->dma_tx.status));
+	ithc_process(ithc);
+	return IRQ_HANDLED;
+}
+
+static int ithc_poll_thread(void *arg)
+{
+	struct ithc *ithc = arg;
+	unsigned int sleep = 100;
+	while (!kthread_should_stop()) {
+		u32 n = ithc->dma_rx[1].num_received;
+		ithc_process(ithc);
+		// Decrease polling interval to 20ms if we received data, otherwise slowly
+		// increase it up to 200ms.
+		sleep = n != ithc->dma_rx[1].num_received ? 20
+			: min(200u, sleep + (sleep >> 4) + 1);
+		msleep_interruptible(sleep);
+	}
+	return 0;
+}
+
+// Device initialization and shutdown
+
+static void ithc_disable(struct ithc *ithc)
+{
+	bitsl_set(&ithc->regs->control_bits, CONTROL_QUIESCE);
+	CHECK(waitl, ithc, &ithc->regs->control_bits, CONTROL_IS_QUIESCED, CONTROL_IS_QUIESCED);
+	bitsl(&ithc->regs->control_bits, CONTROL_NRESET, 0);
+	bitsb(&ithc->regs->spi_cmd.control, SPI_CMD_CONTROL_SEND, 0);
+	bitsb(&ithc->regs->dma_tx.control, DMA_TX_CONTROL_SEND, 0);
+	bitsb(&ithc->regs->dma_rx[0].control, DMA_RX_CONTROL_ENABLE, 0);
+	bitsb(&ithc->regs->dma_rx[1].control, DMA_RX_CONTROL_ENABLE, 0);
+	ithc_disable_interrupts(ithc);
+	ithc_clear_interrupts(ithc);
+}
+
+static int ithc_init_device(struct ithc *ithc)
+{
+	// Read ACPI config for QuickSPI mode
+	struct ithc_acpi_config cfg = { 0 };
+	CHECK_RET(ithc_read_acpi_config, ithc, &cfg);
+	if (!cfg.has_config)
+		pci_info(ithc->pci, "no ACPI config, using legacy mode\n");
+	else
+		ithc_print_acpi_config(ithc, &cfg);
+	ithc->use_quickspi = cfg.has_config;
+
+	// Shut down device
+	ithc_log_regs(ithc);
+	bool was_enabled = (readl(&ithc->regs->control_bits) & CONTROL_NRESET) != 0;
+	ithc_disable(ithc);
+	CHECK_RET(waitl, ithc, &ithc->regs->control_bits, CONTROL_READY, CONTROL_READY);
+	ithc_log_regs(ithc);
+
+	// If the device was previously enabled, wait a bit to make sure it's fully shut down.
+	if (was_enabled)
+		if (msleep_interruptible(100))
+			return -EINTR;
+
+	// Set Latency Tolerance Reporting config. The device will automatically
+	// apply these values depending on whether it is active or idle.
+	// If active value is too high, DMA buffer data can become truncated.
+	// By default, we set the active LTR value to 50us, and idle to 100ms.
+	u64 active_ltr_ns = ithc_active_ltr_us >= 0 ? (u64)ithc_active_ltr_us * 1000
+		: cfg.has_config && cfg.has_active_ltr ? (u64)cfg.active_ltr << 10
+		: 50 * 1000;
+	u64 idle_ltr_ns = ithc_idle_ltr_us >= 0 ? (u64)ithc_idle_ltr_us * 1000
+		: cfg.has_config && cfg.has_idle_ltr ? (u64)cfg.idle_ltr << 10
+		: 100 * 1000 * 1000;
+	ithc_set_ltr_config(ithc, active_ltr_ns, idle_ltr_ns);
+
+	if (ithc->use_quickspi)
+		CHECK_RET(ithc_quickspi_init, ithc, &cfg);
+	else
+		CHECK_RET(ithc_legacy_init, ithc);
+
+	return 0;
+}
+
+int ithc_reset(struct ithc *ithc)
+{
+	// FIXME This should probably do devres_release_group()+ithc_start().
+	// But because this is called during DMA processing, that would have to be done
+	// asynchronously (schedule_work()?). And with extra locking?
+	pci_err(ithc->pci, "reset\n");
+	CHECK(ithc_init_device, ithc);
+	if (ithc_use_rx0)
+		ithc_dma_rx_enable(ithc, 0);
+	if (ithc_use_rx1)
+		ithc_dma_rx_enable(ithc, 1);
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "reset completed\n");
+	return 0;
+}
+
+static void ithc_stop(void *res)
+{
+	struct ithc *ithc = res;
+	pci_dbg(ithc->pci, "stopping\n");
+	ithc_log_regs(ithc);
+
+	if (ithc->poll_thread)
+		CHECK(kthread_stop, ithc->poll_thread);
+	if (ithc->irq >= 0)
+		disable_irq(ithc->irq);
+	if (ithc->use_quickspi)
+		ithc_quickspi_exit(ithc);
+	else
+		ithc_legacy_exit(ithc);
+	ithc_disable(ithc);
+	timer_delete_sync(&ithc->idle_timer);
+
+	// Clear DMA config.
+	for (unsigned int i = 0; i < 2; i++) {
+		CHECK(waitl, ithc, &ithc->regs->dma_rx[i].status, DMA_RX_STATUS_ENABLED, 0);
+		lo_hi_writeq(0, &ithc->regs->dma_rx[i].addr);
+		writeb(0, &ithc->regs->dma_rx[i].num_bufs);
+		writeb(0, &ithc->regs->dma_rx[i].num_prds);
+	}
+	lo_hi_writeq(0, &ithc->regs->dma_tx.addr);
+	writeb(0, &ithc->regs->dma_tx.num_prds);
+
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "stopped\n");
+}
+
+static void ithc_clear_drvdata(void *res)
+{
+	struct pci_dev *pci = res;
+	pci_set_drvdata(pci, NULL);
+}
+
+static int ithc_start(struct pci_dev *pci)
+{
+	pci_dbg(pci, "starting\n");
+	if (pci_get_drvdata(pci)) {
+		pci_err(pci, "device already initialized\n");
+		return -EINVAL;
+	}
+	if (!devres_open_group(&pci->dev, ithc_start, GFP_KERNEL))
+		return -ENOMEM;
+
+	// Allocate/init main driver struct.
+	struct ithc *ithc = devm_kzalloc(&pci->dev, sizeof(*ithc), GFP_KERNEL);
+	if (!ithc)
+		return -ENOMEM;
+	ithc->irq = -1;
+	ithc->pci = pci;
+	snprintf(ithc->phys, sizeof(ithc->phys), "pci-%s/" DEVNAME, pci_name(pci));
+	pci_set_drvdata(pci, ithc);
+	CHECK_RET(devm_add_action_or_reset, &pci->dev, ithc_clear_drvdata, pci);
+	if (ithc_log_regs_enabled)
+		ithc->prev_regs = devm_kzalloc(&pci->dev, sizeof(*ithc->prev_regs), GFP_KERNEL);
+
+	// PCI initialization.
+	CHECK_RET(pcim_enable_device, pci);
+	pci_set_master(pci);
+	CHECK_RET(pcim_iomap_regions, pci, BIT(0), DEVNAME " regs");
+	CHECK_RET(dma_set_mask_and_coherent, &pci->dev, DMA_BIT_MASK(64));
+	CHECK_RET(pci_set_power_state, pci, PCI_D0);
+	ithc->regs = pcim_iomap_table(pci)[0];
+
+	// Allocate IRQ.
+	if (!ithc_use_polling) {
+		CHECK_RET(pci_alloc_irq_vectors, pci, 1, 1, PCI_IRQ_MSI | PCI_IRQ_MSIX);
+		ithc->irq = CHECK(pci_irq_vector, pci, 0);
+		if (ithc->irq < 0)
+			return ithc->irq;
+	}
+
+	// Initialize THC and touch device.
+	CHECK_RET(ithc_init_device, ithc);
+
+	// Initialize HID and DMA.
+	CHECK_RET(ithc_hid_init, ithc);
+	if (ithc_use_rx0)
+		CHECK_RET(ithc_dma_rx_init, ithc, 0);
+	if (ithc_use_rx1)
+		CHECK_RET(ithc_dma_rx_init, ithc, 1);
+	CHECK_RET(ithc_dma_tx_init, ithc);
+
+	timer_setup(&ithc->idle_timer, ithc_idle_timer_callback, 0);
+
+	// Add ithc_stop() callback AFTER setting up DMA buffers, so that polling/irqs/DMA are
+	// disabled BEFORE the buffers are freed.
+	CHECK_RET(devm_add_action_or_reset, &pci->dev, ithc_stop, ithc);
+
+	// Start polling/IRQ.
+	if (ithc_use_polling) {
+		pci_info(pci, "using polling instead of irq\n");
+		// Use a thread instead of simple timer because we want to be able to sleep.
+		ithc->poll_thread = kthread_run(ithc_poll_thread, ithc, DEVNAME "poll");
+		if (IS_ERR(ithc->poll_thread)) {
+			int err = PTR_ERR(ithc->poll_thread);
+			ithc->poll_thread = NULL;
+			return err;
+		}
+	} else {
+		CHECK_RET(devm_request_threaded_irq, &pci->dev, ithc->irq, NULL,
+			ithc_interrupt_thread, IRQF_TRIGGER_HIGH | IRQF_ONESHOT, DEVNAME, ithc);
+	}
+
+	if (ithc_use_rx0)
+		ithc_dma_rx_enable(ithc, 0);
+	if (ithc_use_rx1)
+		ithc_dma_rx_enable(ithc, 1);
+
+	// hid_add_device() can only be called after irq/polling is started and DMA is enabled,
+	// because it calls ithc_hid_parse() which reads the report descriptor via DMA.
+	CHECK_RET(hid_add_device, ithc->hid.dev);
+
+	CHECK(ithc_debug_init_device, ithc);
+
+	ithc_set_ltr_idle(ithc);
+
+	pci_dbg(pci, "started\n");
+	return 0;
+}
+
+static int ithc_probe(struct pci_dev *pci, const struct pci_device_id *id)
+{
+	pci_dbg(pci, "device probe\n");
+	return ithc_start(pci);
+}
+
+static void ithc_remove(struct pci_dev *pci)
+{
+	pci_dbg(pci, "device remove\n");
+	// all cleanup is handled by devres
+}
+
+// For suspend/resume, we just deinitialize and reinitialize everything.
+// TODO It might be cleaner to keep the HID device around, however we would then have to signal
+// to userspace that the touch device has lost state and userspace needs to e.g. resend 'set
+// feature' requests. Hidraw does not seem to have a facility to do that.
+static int ithc_suspend(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+	pci_dbg(pci, "pm suspend\n");
+	devres_release_group(dev, ithc_start);
+	return 0;
+}
+
+static int ithc_resume(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+	pci_dbg(pci, "pm resume\n");
+	return ithc_start(pci);
+}
+
+static int ithc_freeze(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+	pci_dbg(pci, "pm freeze\n");
+	devres_release_group(dev, ithc_start);
+	return 0;
+}
+
+static int ithc_thaw(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+	pci_dbg(pci, "pm thaw\n");
+	return ithc_start(pci);
+}
+
+static int ithc_restore(struct device *dev)
+{
+	struct pci_dev *pci = to_pci_dev(dev);
+	pci_dbg(pci, "pm restore\n");
+	return ithc_start(pci);
+}
+
+static struct pci_driver ithc_driver = {
+	.name = DEVNAME,
+	.id_table = ithc_pci_tbl,
+	.probe = ithc_probe,
+	.remove = ithc_remove,
+	.driver.pm = &(const struct dev_pm_ops) {
+		.suspend = ithc_suspend,
+		.resume = ithc_resume,
+		.freeze = ithc_freeze,
+		.thaw = ithc_thaw,
+		.restore = ithc_restore,
+	},
+	.driver.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+};
+
+static int __init ithc_init(void)
+{
+	ithc_debug_init_module();
+	return pci_register_driver(&ithc_driver);
+}
+
+static void __exit ithc_exit(void)
+{
+	pci_unregister_driver(&ithc_driver);
+	ithc_debug_exit_module();
+}
+
+module_init(ithc_init);
+module_exit(ithc_exit);
+
diff --git a/drivers/hid/ithc/ithc-quickspi.c b/drivers/hid/ithc/ithc-quickspi.c
new file mode 100644
index 000000000000..e2d1690b8cf8
--- /dev/null
+++ b/drivers/hid/ithc/ithc-quickspi.c
@@ -0,0 +1,607 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+// Some public THC/QuickSPI documentation can be found in:
+// - Intel Firmware Support Package repo: https://github.com/intel/FSP
+// - HID over SPI (HIDSPI) spec: https://www.microsoft.com/en-us/download/details.aspx?id=103325
+
+#include "ithc.h"
+
+static const guid_t guid_hidspi =
+	GUID_INIT(0x6e2ac436, 0x0fcf, 0x41af, 0xa2, 0x65, 0xb3, 0x2a, 0x22, 0x0d, 0xcf, 0xab);
+static const guid_t guid_thc_quickspi =
+	GUID_INIT(0x300d35b7, 0xac20, 0x413e, 0x8e, 0x9c, 0x92, 0xe4, 0xda, 0xfd, 0x0a, 0xfe);
+static const guid_t guid_thc_ltr =
+	GUID_INIT(0x84005682, 0x5b71, 0x41a4, 0x8d, 0x66, 0x81, 0x30, 0xf7, 0x87, 0xa1, 0x38);
+
+// TODO The HIDSPI spec says revision should be 3. Should we try both?
+#define DSM_REV 2
+
+struct hidspi_header {
+	u8 type;
+	u16 len;
+	u8 id;
+} __packed;
+static_assert(sizeof(struct hidspi_header) == 4);
+
+#define HIDSPI_INPUT_TYPE_DATA                        1
+#define HIDSPI_INPUT_TYPE_RESET_RESPONSE              3
+#define HIDSPI_INPUT_TYPE_COMMAND_RESPONSE            4
+#define HIDSPI_INPUT_TYPE_GET_FEATURE_RESPONSE        5
+#define HIDSPI_INPUT_TYPE_DEVICE_DESCRIPTOR           7
+#define HIDSPI_INPUT_TYPE_REPORT_DESCRIPTOR           8
+#define HIDSPI_INPUT_TYPE_SET_FEATURE_RESPONSE        9
+#define HIDSPI_INPUT_TYPE_OUTPUT_REPORT_RESPONSE      10
+#define HIDSPI_INPUT_TYPE_GET_INPUT_REPORT_RESPONSE   11
+
+#define HIDSPI_OUTPUT_TYPE_DEVICE_DESCRIPTOR_REQUEST  1
+#define HIDSPI_OUTPUT_TYPE_REPORT_DESCRIPTOR_REQUEST  2
+#define HIDSPI_OUTPUT_TYPE_SET_FEATURE                3
+#define HIDSPI_OUTPUT_TYPE_GET_FEATURE                4
+#define HIDSPI_OUTPUT_TYPE_OUTPUT_REPORT              5
+#define HIDSPI_OUTPUT_TYPE_INPUT_REPORT_REQUEST       6
+#define HIDSPI_OUTPUT_TYPE_COMMAND                    7
+
+struct hidspi_device_descriptor {
+	u16 wDeviceDescLength;
+	u16 bcdVersion;
+	u16 wReportDescLength;
+	u16 wMaxInputLength;
+	u16 wMaxOutputLength;
+	u16 wMaxFragmentLength;
+	u16 wVendorID;
+	u16 wProductID;
+	u16 wVersionID;
+	u16 wFlags;
+	u32 dwReserved;
+};
+static_assert(sizeof(struct hidspi_device_descriptor) == 24);
+
+static int read_acpi_u32(struct ithc *ithc, const guid_t *guid, u32 func, u32 *dest)
+{
+	acpi_handle handle = ACPI_HANDLE(&ithc->pci->dev);
+	union acpi_object *o = acpi_evaluate_dsm(handle, guid, DSM_REV, func, NULL);
+	if (!o)
+		return 0;
+	if (o->type != ACPI_TYPE_INTEGER) {
+		pci_err(ithc->pci, "DSM %pUl %u returned type %i instead of integer\n",
+			guid, func, o->type);
+		ACPI_FREE(o);
+		return -1;
+	}
+	pci_dbg(ithc->pci, "DSM %pUl %u = 0x%08x\n", guid, func, (u32)o->integer.value);
+	*dest = (u32)o->integer.value;
+	ACPI_FREE(o);
+	return 1;
+}
+
+static int read_acpi_buf(struct ithc *ithc, const guid_t *guid, u32 func, size_t len, u8 *dest)
+{
+	acpi_handle handle = ACPI_HANDLE(&ithc->pci->dev);
+	union acpi_object *o = acpi_evaluate_dsm(handle, guid, DSM_REV, func, NULL);
+	if (!o)
+		return 0;
+	if (o->type != ACPI_TYPE_BUFFER) {
+		pci_err(ithc->pci, "DSM %pUl %u returned type %i instead of buffer\n",
+			guid, func, o->type);
+		ACPI_FREE(o);
+		return -1;
+	}
+	if (o->buffer.length != len) {
+		pci_err(ithc->pci, "DSM %pUl %u returned len %u instead of %zu\n",
+			guid, func, o->buffer.length, len);
+		ACPI_FREE(o);
+		return -1;
+	}
+	memcpy(dest, o->buffer.pointer, len);
+	pci_dbg(ithc->pci, "DSM %pUl %u = 0x%02x\n", guid, func, dest[0]);
+	ACPI_FREE(o);
+	return 1;
+}
+
+int ithc_read_acpi_config(struct ithc *ithc, struct ithc_acpi_config *cfg)
+{
+	int r;
+	acpi_handle handle = ACPI_HANDLE(&ithc->pci->dev);
+
+	cfg->has_config = acpi_check_dsm(handle, &guid_hidspi, DSM_REV, BIT(0));
+	if (!cfg->has_config)
+		return 0;
+
+	// HIDSPI settings
+
+	r = read_acpi_u32(ithc, &guid_hidspi, 1, &cfg->input_report_header_address);
+	if (r < 0)
+		return r;
+	cfg->has_input_report_header_address = r > 0;
+	if (r > 0 && cfg->input_report_header_address > 0xffffff) {
+		pci_err(ithc->pci, "Invalid input report header address 0x%x\n",
+			cfg->input_report_header_address);
+		return -1;
+	}
+
+	r = read_acpi_u32(ithc, &guid_hidspi, 2, &cfg->input_report_body_address);
+	if (r < 0)
+		return r;
+	cfg->has_input_report_body_address = r > 0;
+	if (r > 0 && cfg->input_report_body_address > 0xffffff) {
+		pci_err(ithc->pci, "Invalid input report body address 0x%x\n",
+			cfg->input_report_body_address);
+		return -1;
+	}
+
+	r = read_acpi_u32(ithc, &guid_hidspi, 3, &cfg->output_report_body_address);
+	if (r < 0)
+		return r;
+	cfg->has_output_report_body_address = r > 0;
+	if (r > 0 && cfg->output_report_body_address > 0xffffff) {
+		pci_err(ithc->pci, "Invalid output report body address 0x%x\n",
+			cfg->output_report_body_address);
+		return -1;
+	}
+
+	r = read_acpi_buf(ithc, &guid_hidspi, 4, sizeof(cfg->read_opcode), &cfg->read_opcode);
+	if (r < 0)
+		return r;
+	cfg->has_read_opcode = r > 0;
+
+	r = read_acpi_buf(ithc, &guid_hidspi, 5, sizeof(cfg->write_opcode), &cfg->write_opcode);
+	if (r < 0)
+		return r;
+	cfg->has_write_opcode = r > 0;
+
+	u32 flags;
+	r = read_acpi_u32(ithc, &guid_hidspi, 6, &flags);
+	if (r < 0)
+		return r;
+	cfg->has_read_mode = cfg->has_write_mode = r > 0;
+	if (r > 0) {
+		cfg->read_mode = (flags >> 14) & 3;
+		cfg->write_mode = flags & BIT(13) ? cfg->read_mode : SPI_MODE_SINGLE;
+	}
+
+	// Quick SPI settings
+
+	r = read_acpi_u32(ithc, &guid_thc_quickspi, 1, &cfg->spi_frequency);
+	if (r < 0)
+		return r;
+	cfg->has_spi_frequency = r > 0;
+
+	r = read_acpi_u32(ithc, &guid_thc_quickspi, 2, &cfg->limit_packet_size);
+	if (r < 0)
+		return r;
+	cfg->has_limit_packet_size = r > 0;
+
+	r = read_acpi_u32(ithc, &guid_thc_quickspi, 3, &cfg->tx_delay);
+	if (r < 0)
+		return r;
+	cfg->has_tx_delay = r > 0;
+	if (r > 0)
+		cfg->tx_delay &= 0xffff;
+
+	// LTR settings
+
+	r = read_acpi_u32(ithc, &guid_thc_ltr, 1, &cfg->active_ltr);
+	if (r < 0)
+		return r;
+	cfg->has_active_ltr = r > 0;
+	if (r > 0 && (!cfg->active_ltr || cfg->active_ltr > 0x3ff)) {
+		if (cfg->active_ltr != 0xffffffff)
+			pci_warn(ithc->pci, "Ignoring invalid active LTR value 0x%x\n",
+				cfg->active_ltr);
+		cfg->active_ltr = 500;
+	}
+
+	r = read_acpi_u32(ithc, &guid_thc_ltr, 2, &cfg->idle_ltr);
+	if (r < 0)
+		return r;
+	cfg->has_idle_ltr = r > 0;
+	if (r > 0 && (!cfg->idle_ltr || cfg->idle_ltr > 0x3ff)) {
+		if (cfg->idle_ltr != 0xffffffff)
+			pci_warn(ithc->pci, "Ignoring invalid idle LTR value 0x%x\n",
+				cfg->idle_ltr);
+		cfg->idle_ltr = 500;
+		if (cfg->has_active_ltr && cfg->active_ltr > cfg->idle_ltr)
+			cfg->idle_ltr = cfg->active_ltr;
+	}
+
+	return 0;
+}
+
+void ithc_print_acpi_config(struct ithc *ithc, const struct ithc_acpi_config *cfg)
+{
+	if (!cfg->has_config) {
+		pci_info(ithc->pci, "No ACPI config");
+		return;
+	}
+
+	char input_report_header_address[16] = "-";
+	if (cfg->has_input_report_header_address)
+		sprintf(input_report_header_address, "0x%x", cfg->input_report_header_address);
+	char input_report_body_address[16] = "-";
+	if (cfg->has_input_report_body_address)
+		sprintf(input_report_body_address, "0x%x", cfg->input_report_body_address);
+	char output_report_body_address[16] = "-";
+	if (cfg->has_output_report_body_address)
+		sprintf(output_report_body_address, "0x%x", cfg->output_report_body_address);
+	char read_opcode[16] = "-";
+	if (cfg->has_read_opcode)
+		sprintf(read_opcode, "0x%02x", cfg->read_opcode);
+	char write_opcode[16] = "-";
+	if (cfg->has_write_opcode)
+		sprintf(write_opcode, "0x%02x", cfg->write_opcode);
+	char read_mode[16] = "-";
+	if (cfg->has_read_mode)
+		sprintf(read_mode, "%i", cfg->read_mode);
+	char write_mode[16] = "-";
+	if (cfg->has_write_mode)
+		sprintf(write_mode, "%i", cfg->write_mode);
+	char spi_frequency[16] = "-";
+	if (cfg->has_spi_frequency)
+		sprintf(spi_frequency, "%u", cfg->spi_frequency);
+	char limit_packet_size[16] = "-";
+	if (cfg->has_limit_packet_size)
+		sprintf(limit_packet_size, "%u", cfg->limit_packet_size);
+	char tx_delay[16] = "-";
+	if (cfg->has_tx_delay)
+		sprintf(tx_delay, "%u", cfg->tx_delay);
+	char active_ltr[16] = "-";
+	if (cfg->has_active_ltr)
+		sprintf(active_ltr, "%u", cfg->active_ltr);
+	char idle_ltr[16] = "-";
+	if (cfg->has_idle_ltr)
+		sprintf(idle_ltr, "%u", cfg->idle_ltr);
+
+	pci_info(ithc->pci, "ACPI config: InputHeaderAddr=%s InputBodyAddr=%s OutputBodyAddr=%s ReadOpcode=%s WriteOpcode=%s ReadMode=%s WriteMode=%s Frequency=%s LimitPacketSize=%s TxDelay=%s ActiveLTR=%s IdleLTR=%s\n",
+		input_report_header_address, input_report_body_address, output_report_body_address,
+		read_opcode, write_opcode, read_mode, write_mode,
+		spi_frequency, limit_packet_size, tx_delay, active_ltr, idle_ltr);
+}
+
+static void set_opcode(struct ithc *ithc, size_t i, u8 opcode)
+{
+	writeb(opcode, &ithc->regs->opcode[i].header);
+	writeb(opcode, &ithc->regs->opcode[i].single);
+	writeb(opcode, &ithc->regs->opcode[i].dual);
+	writeb(opcode, &ithc->regs->opcode[i].quad);
+}
+
+static int ithc_quickspi_init_regs(struct ithc *ithc, const struct ithc_acpi_config *cfg)
+{
+	pci_dbg(ithc->pci, "initializing QuickSPI registers\n");
+
+	// SPI frequency and mode
+	if (!cfg->has_spi_frequency || !cfg->spi_frequency) {
+		pci_err(ithc->pci, "Missing SPI frequency in configuration\n");
+		return -EINVAL;
+	}
+	unsigned int clkdiv = DIV_ROUND_UP(SPI_CLK_FREQ_BASE, cfg->spi_frequency);
+	bool clkdiv8 = clkdiv > 7;
+	if (clkdiv8)
+		clkdiv = min(7u, DIV_ROUND_UP(clkdiv, 8u));
+	if (!clkdiv)
+		clkdiv = 1;
+	CHECK_RET(ithc_set_spi_config, ithc, clkdiv, clkdiv8,
+		cfg->has_read_mode ? cfg->read_mode : SPI_MODE_SINGLE,
+		cfg->has_write_mode ? cfg->write_mode : SPI_MODE_SINGLE);
+
+	// SPI addresses and opcodes
+	if (cfg->has_input_report_header_address)
+		writel(cfg->input_report_header_address, &ithc->regs->spi_header_addr);
+	if (cfg->has_input_report_body_address) {
+		writel(cfg->input_report_body_address, &ithc->regs->dma_rx[0].spi_addr);
+		writel(cfg->input_report_body_address, &ithc->regs->dma_rx[1].spi_addr);
+	}
+	if (cfg->has_output_report_body_address)
+		writel(cfg->output_report_body_address, &ithc->regs->dma_tx.spi_addr);
+
+	switch (ithc->pci->device) {
+	// LKF/TGL don't support QuickSPI.
+	// For ADL, opcode layout is RX/TX/unused.
+	case PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT2:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT2:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT1:
+	case PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT2:
+		if (cfg->has_read_opcode) {
+			set_opcode(ithc, 0, cfg->read_opcode);
+		}
+		if (cfg->has_write_opcode) {
+			set_opcode(ithc, 1, cfg->write_opcode);
+		}
+		break;
+	// For MTL, opcode layout was changed to RX/RX/TX.
+	// (RPL layout is unknown.)
+	default:
+		if (cfg->has_read_opcode) {
+			set_opcode(ithc, 0, cfg->read_opcode);
+			set_opcode(ithc, 1, cfg->read_opcode);
+		}
+		if (cfg->has_write_opcode) {
+			set_opcode(ithc, 2, cfg->write_opcode);
+		}
+		break;
+	}
+
+	ithc_log_regs(ithc);
+
+	// The rest...
+	bitsl_set(&ithc->regs->dma_rx[0].init_unknown, INIT_UNKNOWN_31);
+
+	bitsl(&ithc->regs->quickspi_config1,
+		QUICKSPI_CONFIG1_UNKNOWN_0(0xff) | QUICKSPI_CONFIG1_UNKNOWN_5(0xff) |
+		QUICKSPI_CONFIG1_UNKNOWN_10(0xff) | QUICKSPI_CONFIG1_UNKNOWN_16(0xffff),
+		QUICKSPI_CONFIG1_UNKNOWN_0(4) | QUICKSPI_CONFIG1_UNKNOWN_5(4) |
+		QUICKSPI_CONFIG1_UNKNOWN_10(22) | QUICKSPI_CONFIG1_UNKNOWN_16(2));
+
+	bitsl(&ithc->regs->quickspi_config2,
+		QUICKSPI_CONFIG2_UNKNOWN_0(0xff) | QUICKSPI_CONFIG2_UNKNOWN_5(0xff) |
+		QUICKSPI_CONFIG2_UNKNOWN_12(0xff),
+		QUICKSPI_CONFIG2_UNKNOWN_0(8) | QUICKSPI_CONFIG2_UNKNOWN_5(14) |
+		QUICKSPI_CONFIG2_UNKNOWN_12(2));
+
+	u32 pktsize = cfg->has_limit_packet_size && cfg->limit_packet_size == 1 ? 4 : 0x80;
+	bitsl(&ithc->regs->spi_config,
+		SPI_CONFIG_READ_PACKET_SIZE(0xfff) | SPI_CONFIG_WRITE_PACKET_SIZE(0xfff),
+		SPI_CONFIG_READ_PACKET_SIZE(pktsize) | SPI_CONFIG_WRITE_PACKET_SIZE(pktsize));
+
+	bitsl_set(&ithc->regs->quickspi_config2,
+		QUICKSPI_CONFIG2_UNKNOWN_16 | QUICKSPI_CONFIG2_UNKNOWN_17);
+	bitsl(&ithc->regs->quickspi_config2,
+		QUICKSPI_CONFIG2_DISABLE_READ_ADDRESS_INCREMENT |
+		QUICKSPI_CONFIG2_DISABLE_WRITE_ADDRESS_INCREMENT |
+		QUICKSPI_CONFIG2_ENABLE_WRITE_STREAMING_MODE, 0);
+
+	return 0;
+}
+
+static int wait_for_report(struct ithc *ithc)
+{
+	CHECK_RET(waitl, ithc, &ithc->regs->dma_rx[0].status,
+		DMA_RX_STATUS_READY, DMA_RX_STATUS_READY);
+	writel(DMA_RX_STATUS_READY, &ithc->regs->dma_rx[0].status);
+
+	u32 h = readl(&ithc->regs->input_header);
+	ithc_log_regs(ithc);
+	if (INPUT_HEADER_SYNC(h) != INPUT_HEADER_SYNC_VALUE
+		|| INPUT_HEADER_VERSION(h) != INPUT_HEADER_VERSION_VALUE) {
+		pci_err(ithc->pci, "invalid input report frame header 0x%08x\n", h);
+		return -ENODATA;
+	}
+	return INPUT_HEADER_REPORT_LENGTH(h) * 4;
+}
+
+static int ithc_quickspi_init_hidspi(struct ithc *ithc, const struct ithc_acpi_config *cfg)
+{
+	pci_dbg(ithc->pci, "initializing HIDSPI\n");
+
+	// HIDSPI initialization sequence:
+	// "1. The host shall invoke the ACPI reset method to clear the device state."
+	acpi_status s = acpi_evaluate_object(ACPI_HANDLE(&ithc->pci->dev), "_RST", NULL, NULL);
+	if (ACPI_FAILURE(s)) {
+		pci_err(ithc->pci, "ACPI reset failed\n");
+		return -EIO;
+	}
+
+	bitsl(&ithc->regs->control_bits, CONTROL_QUIESCE, 0);
+
+	// "2. Within 1 second, the device shall signal an interrupt and make available to the host
+	// an input report containing a device reset response."
+	int size = wait_for_report(ithc);
+	if (size < 0)
+		return size;
+	if (size < sizeof(struct hidspi_header)) {
+		pci_err(ithc->pci, "SPI data size too small for reset response (%u)\n", size);
+		return -EMSGSIZE;
+	}
+
+	// "3. The host shall read the reset response from the device at the Input Report addresses
+	// specified in ACPI."
+	u32 in_addr = cfg->has_input_report_body_address ? cfg->input_report_body_address : 0x1000;
+	struct {
+		struct hidspi_header header;
+		union {
+			struct hidspi_device_descriptor device_desc;
+			u32 data[16];
+		};
+	} resp = { 0 };
+	if (size > sizeof(resp)) {
+		pci_err(ithc->pci, "SPI data size for reset response too big (%u)\n", size);
+		return -EMSGSIZE;
+	}
+	CHECK_RET(ithc_spi_command, ithc, SPI_CMD_CODE_READ, in_addr, size, &resp);
+	if (resp.header.type != HIDSPI_INPUT_TYPE_RESET_RESPONSE) {
+		pci_err(ithc->pci, "received type %i instead of reset response\n", resp.header.type);
+		return -ENOMSG;
+	}
+
+	// "4. The host shall then write an Output Report to the device at the Output Report Address
+	// specified in ACPI, requesting the Device Descriptor from the device."
+	u32 out_addr = cfg->has_output_report_body_address ? cfg->output_report_body_address : 0x1000;
+	struct hidspi_header req = { .type = HIDSPI_OUTPUT_TYPE_DEVICE_DESCRIPTOR_REQUEST };
+	CHECK_RET(ithc_spi_command, ithc, SPI_CMD_CODE_WRITE, out_addr, sizeof(req), &req);
+
+	// "5. Within 1 second, the device shall signal an interrupt and make available to the host
+	// an input report containing the Device Descriptor."
+	size = wait_for_report(ithc);
+	if (size < 0)
+		return size;
+	if (size < sizeof(resp.header) + sizeof(resp.device_desc)) {
+		pci_err(ithc->pci, "SPI data size too small for device descriptor (%u)\n", size);
+		return -EMSGSIZE;
+	}
+
+	// "6. The host shall read the Device Descriptor from the Input Report addresses specified
+	// in ACPI."
+	if (size > sizeof(resp)) {
+		pci_err(ithc->pci, "SPI data size for device descriptor too big (%u)\n", size);
+		return -EMSGSIZE;
+	}
+	memset(&resp, 0, sizeof(resp));
+	CHECK_RET(ithc_spi_command, ithc, SPI_CMD_CODE_READ, in_addr, size, &resp);
+	if (resp.header.type != HIDSPI_INPUT_TYPE_DEVICE_DESCRIPTOR) {
+		pci_err(ithc->pci, "received type %i instead of device descriptor\n",
+			resp.header.type);
+		return -ENOMSG;
+	}
+	struct hidspi_device_descriptor *d = &resp.device_desc;
+	if (resp.header.len < sizeof(*d)) {
+		pci_err(ithc->pci, "response too small for device descriptor (%u)\n",
+			resp.header.len);
+		return -EMSGSIZE;
+	}
+	if (d->wDeviceDescLength != sizeof(*d)) {
+		pci_err(ithc->pci, "invalid device descriptor length (%u)\n",
+			d->wDeviceDescLength);
+		return -EMSGSIZE;
+	}
+
+	pci_info(ithc->pci, "Device descriptor: bcdVersion=0x%04x wReportDescLength=%u wMaxInputLength=%u wMaxOutputLength=%u wMaxFragmentLength=%u wVendorID=0x%04x wProductID=0x%04x wVersionID=0x%04x wFlags=0x%04x dwReserved=0x%08x\n",
+		d->bcdVersion, d->wReportDescLength,
+		d->wMaxInputLength, d->wMaxOutputLength, d->wMaxFragmentLength,
+		d->wVendorID, d->wProductID, d->wVersionID,
+		d->wFlags, d->dwReserved);
+
+	ithc->vendor_id = d->wVendorID;
+	ithc->product_id = d->wProductID;
+	ithc->product_rev = d->wVersionID;
+	ithc->max_rx_size = max_t(u32, d->wMaxInputLength,
+		d->wReportDescLength + sizeof(struct hidspi_header));
+	ithc->max_tx_size = d->wMaxOutputLength;
+	ithc->have_config = true;
+
+	// "7. The device and host shall then enter their "Ready" states - where the device may
+	// begin sending Input Reports, and the device shall be prepared for Output Reports from
+	// the host."
+
+	return 0;
+}
+
+int ithc_quickspi_init(struct ithc *ithc, const struct ithc_acpi_config *cfg)
+{
+	bitsl_set(&ithc->regs->control_bits, CONTROL_QUIESCE);
+	CHECK_RET(waitl, ithc, &ithc->regs->control_bits, CONTROL_IS_QUIESCED, CONTROL_IS_QUIESCED);
+
+	ithc_log_regs(ithc);
+	CHECK_RET(ithc_quickspi_init_regs, ithc, cfg);
+	ithc_log_regs(ithc);
+	CHECK_RET(ithc_quickspi_init_hidspi, ithc, cfg);
+	ithc_log_regs(ithc);
+
+	// This value is set to 2 in ithc_quickspi_init_regs(). It needs to be set to 1 here,
+	// otherwise DMA will not work. Maybe selects between DMA and PIO mode?
+	bitsl(&ithc->regs->quickspi_config1,
+		QUICKSPI_CONFIG1_UNKNOWN_16(0xffff), QUICKSPI_CONFIG1_UNKNOWN_16(1));
+
+	// TODO Do we need to set any of the following bits here?
+	//bitsb_set(&ithc->regs->dma_rx[1].control2, DMA_RX_CONTROL2_UNKNOWN_4);
+	//bitsb_set(&ithc->regs->dma_rx[0].control2, DMA_RX_CONTROL2_UNKNOWN_5);
+	//bitsb_set(&ithc->regs->dma_rx[1].control2, DMA_RX_CONTROL2_UNKNOWN_5);
+	//bitsl_set(&ithc->regs->dma_rx[0].init_unknown, INIT_UNKNOWN_3);
+	//bitsl_set(&ithc->regs->dma_rx[0].init_unknown, INIT_UNKNOWN_31);
+
+	ithc_log_regs(ithc);
+
+	return 0;
+}
+
+void ithc_quickspi_exit(struct ithc *ithc)
+{
+	// TODO Should we send HIDSPI 'power off' command?
+	//struct hidspi_header h = { .type = HIDSPI_OUTPUT_TYPE_COMMAND, .id = 3, };
+	//struct ithc_data d = { .type = ITHC_DATA_RAW, .data = &h, .size = sizeof(h) };
+	//CHECK(ithc_dma_tx, ithc, &d); // or ithc_spi_command()
+}
+
+int ithc_quickspi_decode_rx(struct ithc *ithc, const void *src, size_t len, struct ithc_data *dest)
+{
+	const struct hidspi_header *hdr = src;
+
+	if (len < sizeof(*hdr))
+		return -ENODATA;
+	// TODO Do we need to handle HIDSPI packet fragmentation?
+	if (len < sizeof(*hdr) + hdr->len)
+		return -EMSGSIZE;
+	if (len > round_up(sizeof(*hdr) + hdr->len, 4))
+		return -EMSGSIZE;
+
+	switch (hdr->type) {
+	case HIDSPI_INPUT_TYPE_RESET_RESPONSE:
+		// TODO "When the device detects an error condition, it may interrupt and make
+		// available to the host an Input Report containing an unsolicited Reset Response.
+		// After receiving an unsolicited Reset Response, the host shall initiate the
+		// request procedure from step (4) in the [HIDSPI initialization] process."
+		dest->type = ITHC_DATA_ERROR;
+		return 0;
+	case HIDSPI_INPUT_TYPE_REPORT_DESCRIPTOR:
+		dest->type = ITHC_DATA_REPORT_DESCRIPTOR;
+		dest->data = hdr + 1;
+		dest->size = hdr->len;
+		return 0;
+	case HIDSPI_INPUT_TYPE_DATA:
+	case HIDSPI_INPUT_TYPE_GET_INPUT_REPORT_RESPONSE:
+		dest->type = ITHC_DATA_INPUT_REPORT;
+		dest->data = &hdr->id;
+		dest->size = hdr->len + 1;
+		return 0;
+	case HIDSPI_INPUT_TYPE_GET_FEATURE_RESPONSE:
+		dest->type = ITHC_DATA_GET_FEATURE;
+		dest->data = &hdr->id;
+		dest->size = hdr->len + 1;
+		return 0;
+	case HIDSPI_INPUT_TYPE_SET_FEATURE_RESPONSE:
+	case HIDSPI_INPUT_TYPE_OUTPUT_REPORT_RESPONSE:
+		dest->type = ITHC_DATA_IGNORE;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+ssize_t ithc_quickspi_encode_tx(struct ithc *ithc, const struct ithc_data *src, void *dest,
+	size_t maxlen)
+{
+	struct hidspi_header *hdr = dest;
+
+	size_t src_size = src->size;
+	const u8 *src_data = src->data;
+	u8 type;
+
+	switch (src->type) {
+	case ITHC_DATA_SET_FEATURE:
+		type = HIDSPI_OUTPUT_TYPE_SET_FEATURE;
+		break;
+	case ITHC_DATA_GET_FEATURE:
+		type = HIDSPI_OUTPUT_TYPE_GET_FEATURE;
+		break;
+	case ITHC_DATA_OUTPUT_REPORT:
+		type = HIDSPI_OUTPUT_TYPE_OUTPUT_REPORT;
+		break;
+	case ITHC_DATA_REPORT_DESCRIPTOR:
+		type = HIDSPI_OUTPUT_TYPE_REPORT_DESCRIPTOR_REQUEST;
+		src_size = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	u8 id = 0;
+	if (src_size) {
+		id = *src_data++;
+		src_size--;
+	}
+
+	// Data must be padded to next 4-byte boundary.
+	size_t padded = round_up(src_size, 4);
+	if (sizeof(*hdr) + padded > maxlen)
+		return -EOVERFLOW;
+
+	// Fill the TX buffer with header and data.
+	hdr->type = type;
+	hdr->len = (u16)src_size;
+	hdr->id = id;
+	memcpy_and_pad(hdr + 1, padded, src_data, src_size, 0);
+
+	return sizeof(*hdr) + padded;
+}
+
diff --git a/drivers/hid/ithc/ithc-quickspi.h b/drivers/hid/ithc/ithc-quickspi.h
new file mode 100644
index 000000000000..74d882f6b2f0
--- /dev/null
+++ b/drivers/hid/ithc/ithc-quickspi.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+struct ithc_acpi_config {
+	bool has_config: 1;
+	bool has_input_report_header_address: 1;
+	bool has_input_report_body_address: 1;
+	bool has_output_report_body_address: 1;
+	bool has_read_opcode: 1;
+	bool has_write_opcode: 1;
+	bool has_read_mode: 1;
+	bool has_write_mode: 1;
+	bool has_spi_frequency: 1;
+	bool has_limit_packet_size: 1;
+	bool has_tx_delay: 1;
+	bool has_active_ltr: 1;
+	bool has_idle_ltr: 1;
+	u32 input_report_header_address;
+	u32 input_report_body_address;
+	u32 output_report_body_address;
+	u8 read_opcode;
+	u8 write_opcode;
+	u8 read_mode;
+	u8 write_mode;
+	u32 spi_frequency;
+	u32 limit_packet_size;
+	u32 tx_delay; // us/10 // TODO use?
+	u32 active_ltr; // ns/1024
+	u32 idle_ltr; // ns/1024
+};
+
+int ithc_read_acpi_config(struct ithc *ithc, struct ithc_acpi_config *cfg);
+void ithc_print_acpi_config(struct ithc *ithc, const struct ithc_acpi_config *cfg);
+
+int ithc_quickspi_init(struct ithc *ithc, const struct ithc_acpi_config *cfg);
+void ithc_quickspi_exit(struct ithc *ithc);
+int ithc_quickspi_decode_rx(struct ithc *ithc, const void *src, size_t len, struct ithc_data *dest);
+ssize_t ithc_quickspi_encode_tx(struct ithc *ithc, const struct ithc_data *src, void *dest,
+	size_t maxlen);
+
diff --git a/drivers/hid/ithc/ithc-regs.c b/drivers/hid/ithc/ithc-regs.c
new file mode 100644
index 000000000000..c0f13506af20
--- /dev/null
+++ b/drivers/hid/ithc/ithc-regs.c
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+
+#include "ithc.h"
+
+#define reg_num(r) (0x1fff & (u16)(__force u64)(r))
+
+void bitsl(__iomem u32 *reg, u32 mask, u32 val)
+{
+	if (val & ~mask)
+		pr_err("register 0x%x: invalid value 0x%x for bitmask 0x%x\n",
+			reg_num(reg), val, mask);
+	writel((readl(reg) & ~mask) | (val & mask), reg);
+}
+
+void bitsb(__iomem u8 *reg, u8 mask, u8 val)
+{
+	if (val & ~mask)
+		pr_err("register 0x%x: invalid value 0x%x for bitmask 0x%x\n",
+			reg_num(reg), val, mask);
+	writeb((readb(reg) & ~mask) | (val & mask), reg);
+}
+
+int waitl(struct ithc *ithc, __iomem u32 *reg, u32 mask, u32 val)
+{
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "waiting for reg 0x%04x mask 0x%08x val 0x%08x\n",
+		reg_num(reg), mask, val);
+	u32 x;
+	if (readl_poll_timeout(reg, x, (x & mask) == val, 200, 1000*1000)) {
+		ithc_log_regs(ithc);
+		pci_err(ithc->pci, "timed out waiting for reg 0x%04x mask 0x%08x val 0x%08x\n",
+			reg_num(reg), mask, val);
+		return -ETIMEDOUT;
+	}
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "done waiting\n");
+	return 0;
+}
+
+int waitb(struct ithc *ithc, __iomem u8 *reg, u8 mask, u8 val)
+{
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "waiting for reg 0x%04x mask 0x%02x val 0x%02x\n",
+		reg_num(reg), mask, val);
+	u8 x;
+	if (readb_poll_timeout(reg, x, (x & mask) == val, 200, 1000*1000)) {
+		ithc_log_regs(ithc);
+		pci_err(ithc->pci, "timed out waiting for reg 0x%04x mask 0x%02x val 0x%02x\n",
+			reg_num(reg), mask, val);
+		return -ETIMEDOUT;
+	}
+	ithc_log_regs(ithc);
+	pci_dbg(ithc->pci, "done waiting\n");
+	return 0;
+}
+
+static void calc_ltr(u64 *ns, unsigned int *val, unsigned int *scale)
+{
+	unsigned int s = 0;
+	u64 v = *ns;
+	while (v > 0x3ff) {
+		s++;
+		v >>= 5;
+	}
+	if (s > 5) {
+		s = 5;
+		v = 0x3ff;
+	}
+	*val = v;
+	*scale = s;
+	*ns = v << (5 * s);
+}
+
+void ithc_set_ltr_config(struct ithc *ithc, u64 active_ltr_ns, u64 idle_ltr_ns)
+{
+	unsigned int active_val, active_scale, idle_val, idle_scale;
+	calc_ltr(&active_ltr_ns, &active_val, &active_scale);
+	calc_ltr(&idle_ltr_ns, &idle_val, &idle_scale);
+	pci_dbg(ithc->pci, "setting active LTR value to %llu ns, idle LTR value to %llu ns\n",
+		active_ltr_ns, idle_ltr_ns);
+	writel(LTR_CONFIG_ENABLE_ACTIVE | LTR_CONFIG_ENABLE_IDLE | LTR_CONFIG_APPLY |
+		LTR_CONFIG_ACTIVE_LTR_SCALE(active_scale) | LTR_CONFIG_ACTIVE_LTR_VALUE(active_val) |
+		LTR_CONFIG_IDLE_LTR_SCALE(idle_scale) | LTR_CONFIG_IDLE_LTR_VALUE(idle_val),
+		&ithc->regs->ltr_config);
+}
+
+void ithc_set_ltr_idle(struct ithc *ithc)
+{
+	u32 ltr = readl(&ithc->regs->ltr_config);
+	switch (ltr & (LTR_CONFIG_STATUS_ACTIVE | LTR_CONFIG_STATUS_IDLE)) {
+	case LTR_CONFIG_STATUS_IDLE:
+		break;
+	case LTR_CONFIG_STATUS_ACTIVE:
+		writel(ltr | LTR_CONFIG_TOGGLE | LTR_CONFIG_APPLY, &ithc->regs->ltr_config);
+		break;
+	default:
+		pci_err(ithc->pci, "invalid LTR state 0x%08x\n", ltr);
+		break;
+	}
+}
+
+int ithc_set_spi_config(struct ithc *ithc, u8 clkdiv, bool clkdiv8, u8 read_mode, u8 write_mode)
+{
+	if (clkdiv == 0 || clkdiv > 7 || read_mode > SPI_MODE_QUAD || write_mode > SPI_MODE_QUAD)
+		return -EINVAL;
+	static const char * const modes[] = { "single", "dual", "quad" };
+	pci_dbg(ithc->pci, "setting SPI frequency to %i Hz, %s read, %s write\n",
+		SPI_CLK_FREQ_BASE / (clkdiv * (clkdiv8 ? 8 : 1)),
+		modes[read_mode], modes[write_mode]);
+	bitsl(&ithc->regs->spi_config,
+		SPI_CONFIG_READ_MODE(0xff) | SPI_CONFIG_READ_CLKDIV(0xff) |
+		SPI_CONFIG_WRITE_MODE(0xff) | SPI_CONFIG_WRITE_CLKDIV(0xff) |
+		SPI_CONFIG_CLKDIV_8,
+		SPI_CONFIG_READ_MODE(read_mode) | SPI_CONFIG_READ_CLKDIV(clkdiv) |
+		SPI_CONFIG_WRITE_MODE(write_mode) | SPI_CONFIG_WRITE_CLKDIV(clkdiv) |
+		(clkdiv8 ? SPI_CONFIG_CLKDIV_8 : 0));
+	return 0;
+}
+
+int ithc_spi_command(struct ithc *ithc, u8 command, u32 offset, u32 size, void *data)
+{
+	pci_dbg(ithc->pci, "SPI command %u, size %u, offset 0x%x\n", command, size, offset);
+	if (size > sizeof(ithc->regs->spi_cmd.data))
+		return -EINVAL;
+
+	// Wait if the device is still busy.
+	CHECK_RET(waitl, ithc, &ithc->regs->spi_cmd.status, SPI_CMD_STATUS_BUSY, 0);
+	// Clear result flags.
+	writel(SPI_CMD_STATUS_DONE | SPI_CMD_STATUS_ERROR, &ithc->regs->spi_cmd.status);
+
+	// Init SPI command data.
+	writeb(command, &ithc->regs->spi_cmd.code);
+	writew(size, &ithc->regs->spi_cmd.size);
+	writel(offset, &ithc->regs->spi_cmd.offset);
+	u32 *p = data, n = (size + 3) / 4;
+	for (u32 i = 0; i < n; i++)
+		writel(p[i], &ithc->regs->spi_cmd.data[i]);
+
+	// Start transmission.
+	bitsb_set(&ithc->regs->spi_cmd.control, SPI_CMD_CONTROL_SEND);
+	CHECK_RET(waitl, ithc, &ithc->regs->spi_cmd.status, SPI_CMD_STATUS_BUSY, 0);
+
+	// Read response.
+	if ((readl(&ithc->regs->spi_cmd.status) & (SPI_CMD_STATUS_DONE | SPI_CMD_STATUS_ERROR)) != SPI_CMD_STATUS_DONE)
+		return -EIO;
+	if (readw(&ithc->regs->spi_cmd.size) != size)
+		return -EMSGSIZE;
+	for (u32 i = 0; i < n; i++)
+		p[i] = readl(&ithc->regs->spi_cmd.data[i]);
+
+	writel(SPI_CMD_STATUS_DONE | SPI_CMD_STATUS_ERROR, &ithc->regs->spi_cmd.status);
+	return 0;
+}
+
diff --git a/drivers/hid/ithc/ithc-regs.h b/drivers/hid/ithc/ithc-regs.h
new file mode 100644
index 000000000000..4f541fe533fa
--- /dev/null
+++ b/drivers/hid/ithc/ithc-regs.h
@@ -0,0 +1,211 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+#define LTR_CONFIG_ENABLE_ACTIVE            BIT(0)
+#define LTR_CONFIG_TOGGLE                   BIT(1)
+#define LTR_CONFIG_ENABLE_IDLE              BIT(2)
+#define LTR_CONFIG_APPLY                    BIT(3)
+#define LTR_CONFIG_IDLE_LTR_SCALE(x)        (((x) & 7) << 4)
+#define LTR_CONFIG_IDLE_LTR_VALUE(x)        (((x) & 0x3ff) << 7)
+#define LTR_CONFIG_ACTIVE_LTR_SCALE(x)      (((x) & 7) << 17)
+#define LTR_CONFIG_ACTIVE_LTR_VALUE(x)      (((x) & 0x3ff) << 20)
+#define LTR_CONFIG_STATUS_ACTIVE            BIT(30)
+#define LTR_CONFIG_STATUS_IDLE              BIT(31)
+
+#define CONTROL_QUIESCE                     BIT(1)
+#define CONTROL_IS_QUIESCED                 BIT(2)
+#define CONTROL_NRESET                      BIT(3)
+#define CONTROL_UNKNOWN_24(x)               (((x) & 3) << 24)
+#define CONTROL_READY                       BIT(29)
+
+#define SPI_CONFIG_READ_MODE(x)             (((x) & 3) << 2)
+#define SPI_CONFIG_READ_CLKDIV(x)           (((x) & 7) << 4)
+#define SPI_CONFIG_READ_PACKET_SIZE(x)      (((x) & 0x1ff) << 7)
+#define SPI_CONFIG_WRITE_MODE(x)            (((x) & 3) << 18)
+#define SPI_CONFIG_WRITE_CLKDIV(x)          (((x) & 7) << 20)
+#define SPI_CONFIG_CLKDIV_8                 BIT(23) // additionally divide clk by 8, for both read and write
+#define SPI_CONFIG_WRITE_PACKET_SIZE(x)     (((x) & 0xff) << 24)
+
+#define SPI_CLK_FREQ_BASE                   125000000
+#define SPI_MODE_SINGLE                     0
+#define SPI_MODE_DUAL                       1
+#define SPI_MODE_QUAD                       2
+
+#define ERROR_CONTROL_UNKNOWN_0             BIT(0)
+#define ERROR_CONTROL_DISABLE_DMA           BIT(1) // clears DMA_RX_CONTROL_ENABLE when a DMA error occurs
+#define ERROR_CONTROL_UNKNOWN_2             BIT(2)
+#define ERROR_CONTROL_UNKNOWN_3             BIT(3)
+#define ERROR_CONTROL_IRQ_DMA_UNKNOWN_9     BIT(9)
+#define ERROR_CONTROL_IRQ_DMA_UNKNOWN_10    BIT(10)
+#define ERROR_CONTROL_IRQ_DMA_UNKNOWN_12    BIT(12)
+#define ERROR_CONTROL_IRQ_DMA_UNKNOWN_13    BIT(13)
+#define ERROR_CONTROL_UNKNOWN_16(x)         (((x) & 0xff) << 16) // spi error code irq?
+#define ERROR_CONTROL_SET_DMA_STATUS        BIT(29) // sets DMA_RX_STATUS_ERROR when a DMA error occurs
+
+#define ERROR_STATUS_DMA                    BIT(28)
+#define ERROR_STATUS_SPI                    BIT(30)
+
+#define ERROR_FLAG_DMA_UNKNOWN_9            BIT(9)
+#define ERROR_FLAG_DMA_UNKNOWN_10           BIT(10)
+#define ERROR_FLAG_DMA_RX_TIMEOUT           BIT(12) // set when we receive a truncated DMA message
+#define ERROR_FLAG_DMA_UNKNOWN_13           BIT(13)
+#define ERROR_FLAG_SPI_BUS_TURNAROUND       BIT(16)
+#define ERROR_FLAG_SPI_RESPONSE_TIMEOUT     BIT(17)
+#define ERROR_FLAG_SPI_INTRA_PACKET_TIMEOUT BIT(18)
+#define ERROR_FLAG_SPI_INVALID_RESPONSE     BIT(19)
+#define ERROR_FLAG_SPI_HS_RX_TIMEOUT        BIT(20)
+#define ERROR_FLAG_SPI_TOUCH_IC_INIT        BIT(21)
+
+#define SPI_CMD_CONTROL_SEND                BIT(0) // cleared by device when sending is complete
+#define SPI_CMD_CONTROL_IRQ                 BIT(1)
+
+#define SPI_CMD_CODE_READ                   4
+#define SPI_CMD_CODE_WRITE                  6
+
+#define SPI_CMD_STATUS_DONE                 BIT(0)
+#define SPI_CMD_STATUS_ERROR                BIT(1)
+#define SPI_CMD_STATUS_BUSY                 BIT(3)
+
+#define DMA_TX_CONTROL_SEND                 BIT(0) // cleared by device when sending is complete
+#define DMA_TX_CONTROL_IRQ                  BIT(3)
+
+#define DMA_TX_STATUS_DONE                  BIT(0)
+#define DMA_TX_STATUS_ERROR                 BIT(1)
+#define DMA_TX_STATUS_UNKNOWN_2             BIT(2)
+#define DMA_TX_STATUS_UNKNOWN_3             BIT(3) // busy?
+
+#define INPUT_HEADER_VERSION(x)             ((x) & 0xf)
+#define INPUT_HEADER_REPORT_LENGTH(x)       (((x) >> 8) & 0x3fff)
+#define INPUT_HEADER_SYNC(x)                ((x) >> 24)
+#define INPUT_HEADER_VERSION_VALUE          3
+#define INPUT_HEADER_SYNC_VALUE             0x5a
+
+#define QUICKSPI_CONFIG1_UNKNOWN_0(x)       (((x) & 0x1f) << 0)
+#define QUICKSPI_CONFIG1_UNKNOWN_5(x)       (((x) & 0x1f) << 5)
+#define QUICKSPI_CONFIG1_UNKNOWN_10(x)      (((x) & 0x1f) << 10)
+#define QUICKSPI_CONFIG1_UNKNOWN_16(x)      (((x) & 0xffff) << 16)
+
+#define QUICKSPI_CONFIG2_UNKNOWN_0(x)       (((x) & 0x1f) << 0)
+#define QUICKSPI_CONFIG2_UNKNOWN_5(x)       (((x) & 0x1f) << 5)
+#define QUICKSPI_CONFIG2_UNKNOWN_12(x)      (((x) & 0xf) << 12)
+#define QUICKSPI_CONFIG2_UNKNOWN_16         BIT(16)
+#define QUICKSPI_CONFIG2_UNKNOWN_17         BIT(17)
+#define QUICKSPI_CONFIG2_DISABLE_READ_ADDRESS_INCREMENT  BIT(24)
+#define QUICKSPI_CONFIG2_DISABLE_WRITE_ADDRESS_INCREMENT BIT(25)
+#define QUICKSPI_CONFIG2_ENABLE_WRITE_STREAMING_MODE     BIT(27)
+#define QUICKSPI_CONFIG2_IRQ_POLARITY       BIT(28)
+
+#define DMA_RX_CONTROL_ENABLE               BIT(0)
+#define DMA_RX_CONTROL_IRQ_UNKNOWN_1        BIT(1) // rx1 only?
+#define DMA_RX_CONTROL_IRQ_ERROR            BIT(3) // rx1 only?
+#define DMA_RX_CONTROL_IRQ_READY            BIT(4) // rx0 only
+#define DMA_RX_CONTROL_IRQ_DATA             BIT(5)
+
+#define DMA_RX_CONTROL2_UNKNOWN_4           BIT(4) // rx1 only?
+#define DMA_RX_CONTROL2_UNKNOWN_5           BIT(5) // rx0 only?
+#define DMA_RX_CONTROL2_RESET               BIT(7) // resets ringbuffer indices
+
+#define DMA_RX_WRAP_FLAG                    BIT(7)
+
+#define DMA_RX_STATUS_ERROR                 BIT(3)
+#define DMA_RX_STATUS_READY                 BIT(4) // set in rx0 after using CONTROL_NRESET when it becomes possible to read config (can take >100ms)
+#define DMA_RX_STATUS_HAVE_DATA             BIT(5)
+#define DMA_RX_STATUS_ENABLED               BIT(8)
+
+#define INIT_UNKNOWN_GUC_2                  BIT(2)
+#define INIT_UNKNOWN_3                      BIT(3)
+#define INIT_UNKNOWN_GUC_4                  BIT(4)
+#define INIT_UNKNOWN_5                      BIT(5)
+#define INIT_UNKNOWN_31                     BIT(31)
+
+// COUNTER_RESET can be written to counter registers to reset them to zero. However, in some cases this can mess up the THC.
+#define COUNTER_RESET                       BIT(31)
+
+struct ithc_registers {
+	/* 0000 */ u32 _unknown_0000[5];
+	/* 0014 */ u32 ltr_config;
+	/* 0018 */ u32 _unknown_0018[1018];
+	/* 1000 */ u32 _unknown_1000;
+	/* 1004 */ u32 _unknown_1004;
+	/* 1008 */ u32 control_bits;
+	/* 100c */ u32 _unknown_100c;
+	/* 1010 */ u32 spi_config;
+	struct {
+		/* 1014/1018/101c */ u8 header;
+		/* 1015/1019/101d */ u8 quad;
+		/* 1016/101a/101e */ u8 dual;
+		/* 1017/101b/101f */ u8 single;
+	} opcode[3];
+	/* 1020 */ u32 error_control;
+	/* 1024 */ u32 error_status; // write to clear
+	/* 1028 */ u32 error_flags; // write to clear
+	/* 102c */ u32 _unknown_102c[5];
+	struct {
+		/* 1040 */ u8 control;
+		/* 1041 */ u8 code;
+		/* 1042 */ u16 size;
+		/* 1044 */ u32 status; // write to clear
+		/* 1048 */ u32 offset;
+		/* 104c */ u32 data[16];
+		/* 108c */ u32 _unknown_108c;
+	} spi_cmd;
+	struct {
+		/* 1090 */ u64 addr; // cannot be written with writeq(), must use lo_hi_writeq()
+		/* 1098 */ u8 control;
+		/* 1099 */ u8 _unknown_1099;
+		/* 109a */ u8 _unknown_109a;
+		/* 109b */ u8 num_prds;
+		/* 109c */ u32 status; // write to clear
+		/* 10a0 */ u32 _unknown_10a0[5];
+		/* 10b4 */ u32 spi_addr;
+	} dma_tx;
+	/* 10b8 */ u32 spi_header_addr;
+	union {
+		/* 10bc */ u32 irq_cause; // in legacy THC mode
+		/* 10bc */ u32 input_header; // in QuickSPI mode (see HIDSPI spec)
+	};
+	/* 10c0 */ u32 _unknown_10c0[8];
+	/* 10e0 */ u32 _unknown_10e0_counters[3];
+	/* 10ec */ u32 quickspi_config1;
+	/* 10f0 */ u32 quickspi_config2;
+	/* 10f4 */ u32 _unknown_10f4[3];
+	struct {
+		/* 1100/1200 */ u64 addr; // cannot be written with writeq(), must use lo_hi_writeq()
+		/* 1108/1208 */ u8 num_bufs;
+		/* 1109/1209 */ u8 num_prds;
+		/* 110a/120a */ u16 _unknown_110a;
+		/* 110c/120c */ u8 control;
+		/* 110d/120d */ u8 head;
+		/* 110e/120e */ u8 tail;
+		/* 110f/120f */ u8 control2;
+		/* 1110/1210 */ u32 status; // write to clear
+		/* 1114/1214 */ u32 _unknown_1114;
+		/* 1118/1218 */ u64 _unknown_1118_guc_addr;
+		/* 1120/1220 */ u32 _unknown_1120_guc;
+		/* 1124/1224 */ u32 _unknown_1124_guc;
+		/* 1128/1228 */ u32 init_unknown;
+		/* 112c/122c */ u32 _unknown_112c;
+		/* 1130/1230 */ u64 _unknown_1130_guc_addr;
+		/* 1138/1238 */ u32 _unknown_1138_guc;
+		/* 113c/123c */ u32 _unknown_113c;
+		/* 1140/1240 */ u32 _unknown_1140_guc;
+		/* 1144/1244 */ u32 _unknown_1144[11];
+		/* 1170/1270 */ u32 spi_addr;
+		/* 1174/1274 */ u32 _unknown_1174[11];
+		/* 11a0/12a0 */ u32 _unknown_11a0_counters[6];
+		/* 11b8/12b8 */ u32 _unknown_11b8[18];
+	} dma_rx[2];
+};
+static_assert(sizeof(struct ithc_registers) == 0x1300);
+
+void bitsl(__iomem u32 *reg, u32 mask, u32 val);
+void bitsb(__iomem u8 *reg, u8 mask, u8 val);
+#define bitsl_set(reg, x) bitsl(reg, x, x)
+#define bitsb_set(reg, x) bitsb(reg, x, x)
+int waitl(struct ithc *ithc, __iomem u32 *reg, u32 mask, u32 val);
+int waitb(struct ithc *ithc, __iomem u8 *reg, u8 mask, u8 val);
+
+void ithc_set_ltr_config(struct ithc *ithc, u64 active_ltr_ns, u64 idle_ltr_ns);
+void ithc_set_ltr_idle(struct ithc *ithc);
+int ithc_set_spi_config(struct ithc *ithc, u8 clkdiv, bool clkdiv8, u8 read_mode, u8 write_mode);
+int ithc_spi_command(struct ithc *ithc, u8 command, u32 offset, u32 size, void *data);
+
diff --git a/drivers/hid/ithc/ithc.h b/drivers/hid/ithc/ithc.h
new file mode 100644
index 000000000000..aec320d4e945
--- /dev/null
+++ b/drivers/hid/ithc/ithc.h
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause */
+
+#include <linux/acpi.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/hid.h>
+#include <linux/highmem.h>
+#include <linux/input.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/iopoll.h>
+#include <linux/kthread.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/poll.h>
+#include <linux/timer.h>
+#include <linux/vmalloc.h>
+
+#define DEVNAME "ithc"
+#define DEVFULLNAME "Intel Touch Host Controller"
+
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#define CHECK(fn, ...) ({ int r = fn(__VA_ARGS__); if (r < 0) pci_err(ithc->pci, "%s: %s failed with %i\n", __func__, #fn, r); r; })
+#define CHECK_RET(...) do { int r = CHECK(__VA_ARGS__); if (r < 0) return r; } while (0)
+
+#define NUM_RX_BUF 16
+
+// PCI device IDs:
+// Lakefield
+#define PCI_DEVICE_ID_INTEL_THC_LKF_PORT1    0x98d0
+#define PCI_DEVICE_ID_INTEL_THC_LKF_PORT2    0x98d1
+// Tiger Lake
+#define PCI_DEVICE_ID_INTEL_THC_TGL_LP_PORT1 0xa0d0
+#define PCI_DEVICE_ID_INTEL_THC_TGL_LP_PORT2 0xa0d1
+#define PCI_DEVICE_ID_INTEL_THC_TGL_H_PORT1  0x43d0
+#define PCI_DEVICE_ID_INTEL_THC_TGL_H_PORT2  0x43d1
+// Alder Lake
+#define PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT1  0x7ad8
+#define PCI_DEVICE_ID_INTEL_THC_ADL_S_PORT2  0x7ad9
+#define PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT1  0x51d0
+#define PCI_DEVICE_ID_INTEL_THC_ADL_P_PORT2  0x51d1
+#define PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT1  0x54d0
+#define PCI_DEVICE_ID_INTEL_THC_ADL_M_PORT2  0x54d1
+// Raptor Lake
+#define PCI_DEVICE_ID_INTEL_THC_RPL_S_PORT1  0x7a58
+#define PCI_DEVICE_ID_INTEL_THC_RPL_S_PORT2  0x7a59
+// Meteor Lake
+#define PCI_DEVICE_ID_INTEL_THC_MTL_S_PORT1  0x7f59
+#define PCI_DEVICE_ID_INTEL_THC_MTL_S_PORT2  0x7f5b
+#define PCI_DEVICE_ID_INTEL_THC_MTL_MP_PORT1 0x7e49
+#define PCI_DEVICE_ID_INTEL_THC_MTL_MP_PORT2 0x7e4b
+
+struct ithc;
+
+#include "ithc-regs.h"
+#include "ithc-hid.h"
+#include "ithc-dma.h"
+#include "ithc-legacy.h"
+#include "ithc-quickspi.h"
+#include "ithc-debug.h"
+
+struct ithc {
+	char phys[32];
+	struct pci_dev *pci;
+	int irq;
+	struct task_struct *poll_thread;
+	struct timer_list idle_timer;
+
+	struct ithc_registers __iomem *regs;
+	struct ithc_registers *prev_regs; // for debugging
+	struct ithc_dma_rx dma_rx[2];
+	struct ithc_dma_tx dma_tx;
+	struct ithc_hid hid;
+
+	bool use_quickspi;
+	bool have_config;
+	u16 vendor_id;
+	u16 product_id;
+	u32 product_rev;
+	u32 max_rx_size;
+	u32 max_tx_size;
+	u32 legacy_touch_cfg;
+};
+
+int ithc_reset(struct ithc *ithc);
+
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sat, 25 Jul 2020 17:19:53 +0200
Subject: i2c: acpi: Implement RawBytes read access

Microsoft Surface Pro 4 and Book 1 devices access the MSHW0030 I2C
device via a generic serial bus operation region and RawBytes read
access. On the Surface Book 1, this access is required to turn on (and
off) the discrete GPU.

Multiple things are to note here:

a) The RawBytes access is device/driver dependent. The ACPI
   specification states:

   > Raw accesses assume that the writer has knowledge of the bus that
   > the access is made over and the device that is being accessed. The
   > protocol may only ensure that the buffer is transmitted to the
   > appropriate driver, but the driver must be able to interpret the
   > buffer to communicate to a register.

   Thus this implementation may likely not work on other devices
   accessing I2C via the RawBytes accessor type.

b) The MSHW0030 I2C device is an HID-over-I2C device which seems to
   serve multiple functions:

   1. It is the main access point for the legacy-type Surface Aggregator
      Module (also referred to as SAM-over-HID, as opposed to the newer
      SAM-over-SSH/UART). It has currently not been determined on how
      support for the legacy SAM should be implemented. Likely via a
      custom HID driver.

   2. It seems to serve as the HID device for the Integrated Sensor Hub.
      This might complicate matters with regards to implementing a
      SAM-over-HID driver required by legacy SAM.

In light of this, the simplest approach has been chosen for now.
However, it may make more sense regarding breakage and compatibility to
either provide functionality for replacing or enhancing the default
operation region handler via some additional API functions, or even to
completely blacklist MSHW0030 from the I2C core and provide a custom
driver for it.

Replacing/enhancing the default operation region handler would, however,
either require some sort of secondary driver and access point for it,
from which the new API functions would be called and the new handler
(part) would be installed, or hard-coding them via some sort of
quirk-like interface into the I2C core.

Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: surface-sam-over-hid
---
 drivers/i2c/i2c-core-acpi.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/i2c/i2c-core-acpi.c b/drivers/i2c/i2c-core-acpi.c
index ed90858a27b7..070c36637811 100644
--- a/drivers/i2c/i2c-core-acpi.c
+++ b/drivers/i2c/i2c-core-acpi.c
@@ -662,6 +662,27 @@ static int acpi_gsb_i2c_write_bytes(struct i2c_client *client,
 	return (ret == 1) ? 0 : -EIO;
 }
 
+static int acpi_gsb_i2c_write_raw_bytes(struct i2c_client *client,
+		u8 *data, u8 data_len)
+{
+	struct i2c_msg msgs[1];
+	int ret;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = data_len + 1;
+	msgs[0].buf = data;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret < 0) {
+		dev_err(&client->adapter->dev, "i2c write failed: %d\n", ret);
+		return ret;
+	}
+
+	/* 1 transfer must have completed successfully */
+	return (ret == 1) ? 0 : -EIO;
+}
+
 static acpi_status
 i2c_acpi_space_handler(u32 function, acpi_physical_address command,
 			u32 bits, u64 *value64,
@@ -763,6 +784,19 @@ i2c_acpi_space_handler(u32 function, acpi_physical_address command,
 		}
 		break;
 
+	case ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES:
+		if (action == ACPI_READ) {
+			dev_warn(&adapter->dev,
+				 "protocol 0x%02x not supported for client 0x%02x\n",
+				 accessor_type, client->addr);
+			ret = AE_BAD_PARAMETER;
+			goto err;
+		} else {
+			status = acpi_gsb_i2c_write_raw_bytes(client,
+					gsb->data, info->access_length);
+		}
+		break;
+
 	default:
 		dev_warn(&adapter->dev, "protocol 0x%02x not supported for client 0x%02x\n",
 			 accessor_type, client->addr);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sat, 13 Feb 2021 16:41:18 +0100
Subject: platform/surface: Add driver for Surface Book 1 dGPU switch

Add driver exposing the discrete GPU power-switch of the  Microsoft
Surface Book 1 to user-space.

On the Surface Book 1, the dGPU power is controlled via the Surface
System Aggregator Module (SAM). The specific SAM-over-HID command for
this is exposed via ACPI. This module provides a simple driver exposing
the ACPI call via a sysfs parameter to user-space, so that users can
easily power-on/-off the dGPU.

Patchset: surface-sam-over-hid
---
 drivers/platform/surface/Kconfig              |   7 +
 drivers/platform/surface/Makefile             |   1 +
 .../surface/surfacebook1_dgpu_switch.c        | 136 ++++++++++++++++++
 3 files changed, 144 insertions(+)
 create mode 100644 drivers/platform/surface/surfacebook1_dgpu_switch.c

diff --git a/drivers/platform/surface/Kconfig b/drivers/platform/surface/Kconfig
index f775c6ca1ec1..2075e3852053 100644
--- a/drivers/platform/surface/Kconfig
+++ b/drivers/platform/surface/Kconfig
@@ -149,6 +149,13 @@ config SURFACE_AGGREGATOR_TABLET_SWITCH
 	  Select M or Y here, if you want to provide tablet-mode switch input
 	  events on the Surface Pro 8, Surface Pro X, and Surface Laptop Studio.
 
+config SURFACE_BOOK1_DGPU_SWITCH
+	tristate "Surface Book 1 dGPU Switch Driver"
+	depends on SYSFS
+	help
+	  This driver provides a sysfs switch to set the power-state of the
+	  discrete GPU found on the Microsoft Surface Book 1.
+
 config SURFACE_DTX
 	tristate "Surface DTX (Detachment System) Driver"
 	depends on SURFACE_AGGREGATOR
diff --git a/drivers/platform/surface/Makefile b/drivers/platform/surface/Makefile
index 53344330939b..7efcd0cdb532 100644
--- a/drivers/platform/surface/Makefile
+++ b/drivers/platform/surface/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_SURFACE_AGGREGATOR_CDEV)	+= surface_aggregator_cdev.o
 obj-$(CONFIG_SURFACE_AGGREGATOR_HUB)	+= surface_aggregator_hub.o
 obj-$(CONFIG_SURFACE_AGGREGATOR_REGISTRY) += surface_aggregator_registry.o
 obj-$(CONFIG_SURFACE_AGGREGATOR_TABLET_SWITCH) += surface_aggregator_tabletsw.o
+obj-$(CONFIG_SURFACE_BOOK1_DGPU_SWITCH) += surfacebook1_dgpu_switch.o
 obj-$(CONFIG_SURFACE_DTX)		+= surface_dtx.o
 obj-$(CONFIG_SURFACE_GPE)		+= surface_gpe.o
 obj-$(CONFIG_SURFACE_HOTPLUG)		+= surface_hotplug.o
diff --git a/drivers/platform/surface/surfacebook1_dgpu_switch.c b/drivers/platform/surface/surfacebook1_dgpu_switch.c
new file mode 100644
index 000000000000..68db237734a1
--- /dev/null
+++ b/drivers/platform/surface/surfacebook1_dgpu_switch.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+
+/* MSHW0040/VGBI DSM UUID: 6fd05c69-cde3-49f4-95ed-ab1665498035 */
+static const guid_t dgpu_sw_guid =
+	GUID_INIT(0x6fd05c69, 0xcde3, 0x49f4,
+		  0x95, 0xed, 0xab, 0x16, 0x65, 0x49, 0x80, 0x35);
+
+#define DGPUSW_ACPI_PATH_DSM	"\\_SB_.PCI0.LPCB.EC0_.VGBI"
+#define DGPUSW_ACPI_PATH_HGON	"\\_SB_.PCI0.RP05.HGON"
+#define DGPUSW_ACPI_PATH_HGOF	"\\_SB_.PCI0.RP05.HGOF"
+
+static int sb1_dgpu_sw_dsmcall(void)
+{
+	union acpi_object *obj;
+	acpi_handle handle;
+	acpi_status status;
+
+	status = acpi_get_handle(NULL, DGPUSW_ACPI_PATH_DSM, &handle);
+	if (status)
+		return -EINVAL;
+
+	obj = acpi_evaluate_dsm_typed(handle, &dgpu_sw_guid, 1, 1, NULL, ACPI_TYPE_BUFFER);
+	if (!obj)
+		return -EINVAL;
+
+	ACPI_FREE(obj);
+	return 0;
+}
+
+static int sb1_dgpu_sw_hgon(struct device *dev)
+{
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+
+	status = acpi_evaluate_object(NULL, DGPUSW_ACPI_PATH_HGON, NULL, &buf);
+	if (status) {
+		dev_err(dev, "failed to run HGON: %d\n", status);
+		return -EINVAL;
+	}
+
+	ACPI_FREE(buf.pointer);
+
+	dev_info(dev, "turned-on dGPU via HGON\n");
+	return 0;
+}
+
+static int sb1_dgpu_sw_hgof(struct device *dev)
+{
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+
+	status = acpi_evaluate_object(NULL, DGPUSW_ACPI_PATH_HGOF, NULL, &buf);
+	if (status) {
+		dev_err(dev, "failed to run HGOF: %d\n", status);
+		return -EINVAL;
+	}
+
+	ACPI_FREE(buf.pointer);
+
+	dev_info(dev, "turned-off dGPU via HGOF\n");
+	return 0;
+}
+
+static ssize_t dgpu_dsmcall_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t len)
+{
+	bool value;
+	int status;
+
+	status = kstrtobool(buf, &value);
+	if (status < 0)
+		return status;
+
+	if (!value)
+		return 0;
+
+	status = sb1_dgpu_sw_dsmcall();
+
+	return status < 0 ? status : len;
+}
+static DEVICE_ATTR_WO(dgpu_dsmcall);
+
+static ssize_t dgpu_power_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	bool power;
+	int status;
+
+	status = kstrtobool(buf, &power);
+	if (status < 0)
+		return status;
+
+	if (power)
+		status = sb1_dgpu_sw_hgon(dev);
+	else
+		status = sb1_dgpu_sw_hgof(dev);
+
+	return status < 0 ? status : len;
+}
+static DEVICE_ATTR_WO(dgpu_power);
+
+static struct attribute *sb1_dgpu_sw_attrs[] = {
+	&dev_attr_dgpu_dsmcall.attr,
+	&dev_attr_dgpu_power.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(sb1_dgpu_sw);
+
+/*
+ * The dGPU power seems to be actually handled by MSHW0040. However, that is
+ * also the power-/volume-button device with a mainline driver. So let's use
+ * MSHW0041 instead for now, which seems to be the LTCH (latch/DTX) device.
+ */
+static const struct acpi_device_id sb1_dgpu_sw_match[] = {
+	{ "MSHW0041", },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, sb1_dgpu_sw_match);
+
+static struct platform_driver sb1_dgpu_sw = {
+	.driver = {
+		.name = "surfacebook1_dgpu_switch",
+		.acpi_match_table = sb1_dgpu_sw_match,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		.dev_groups = sb1_dgpu_sw_groups,
+	},
+};
+module_platform_driver(sb1_dgpu_sw);
+
+MODULE_AUTHOR("Maximilian Luz <luzmaximilian@gmail.com>");
+MODULE_DESCRIPTION("Discrete GPU Power-Switch for Surface Book 1");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sachi King <nakato@nakato.io>
Date: Tue, 5 Oct 2021 00:05:09 +1100
Subject: Input: soc_button_array - support AMD variant Surface devices

The power button on the AMD variant of the Surface Laptop uses the
same MSHW0040 device ID as the 5th and later generation of Surface
devices, however they report 0 for their OEM platform revision.  As the
_DSM does not exist on the devices requiring special casing, check for
the existance of the _DSM to determine if soc_button_array should be
loaded.

Fixes: c394159310d0 ("Input: soc_button_array - add support for newer surface devices")
Co-developed-by: Maximilian Luz <luzmaximilian@gmail.com>

Signed-off-by: Sachi King <nakato@nakato.io>
Patchset: surface-button
---
 drivers/input/misc/soc_button_array.c | 33 +++++++--------------------
 1 file changed, 8 insertions(+), 25 deletions(-)

diff --git a/drivers/input/misc/soc_button_array.c b/drivers/input/misc/soc_button_array.c
index b8cad415c62c..43b5d56383e3 100644
--- a/drivers/input/misc/soc_button_array.c
+++ b/drivers/input/misc/soc_button_array.c
@@ -540,8 +540,8 @@ static const struct soc_device_data soc_device_MSHW0028 = {
  * Both, the Surface Pro 4 (surfacepro3_button.c) and the above mentioned
  * devices use MSHW0040 for power and volume buttons, however the way they
  * have to be addressed differs. Make sure that we only load this drivers
- * for the correct devices by checking the OEM Platform Revision provided by
- * the _DSM method.
+ * for the correct devices by checking if the OEM Platform Revision DSM call
+ * exists.
  */
 #define MSHW0040_DSM_REVISION		0x01
 #define MSHW0040_DSM_GET_OMPR		0x02	// get OEM Platform Revision
@@ -552,31 +552,14 @@ static const guid_t MSHW0040_DSM_UUID =
 static int soc_device_check_MSHW0040(struct device *dev)
 {
 	acpi_handle handle = ACPI_HANDLE(dev);
-	union acpi_object *result;
-	u64 oem_platform_rev = 0;	// valid revisions are nonzero
-
-	// get OEM platform revision
-	result = acpi_evaluate_dsm_typed(handle, &MSHW0040_DSM_UUID,
-					 MSHW0040_DSM_REVISION,
-					 MSHW0040_DSM_GET_OMPR, NULL,
-					 ACPI_TYPE_INTEGER);
-
-	if (result) {
-		oem_platform_rev = result->integer.value;
-		ACPI_FREE(result);
-	}
-
-	/*
-	 * If the revision is zero here, the _DSM evaluation has failed. This
-	 * indicates that we have a Pro 4 or Book 1 and this driver should not
-	 * be used.
-	 */
-	if (oem_platform_rev == 0)
-		return -ENODEV;
+	bool exists;
 
-	dev_dbg(dev, "OEM Platform Revision %llu\n", oem_platform_rev);
+	// check if OEM platform revision DSM call exists
+	exists = acpi_check_dsm(handle, &MSHW0040_DSM_UUID,
+				MSHW0040_DSM_REVISION,
+				BIT(MSHW0040_DSM_GET_OMPR));
 
-	return 0;
+	return exists ? 0 : -ENODEV;
 }
 
 /*
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sachi King <nakato@nakato.io>
Date: Tue, 5 Oct 2021 00:22:57 +1100
Subject: platform/surface: surfacepro3_button: don't load on amd variant

The AMD variant of the Surface Laptop report 0 for their OEM platform
revision.  The Surface devices that require the surfacepro3_button
driver do not have the _DSM that gets the OEM platform revision.  If the
method does not exist, load surfacepro3_button.

Fixes: 64dd243d7356 ("platform/x86: surfacepro3_button: Fix device check")
Co-developed-by: Maximilian Luz <luzmaximilian@gmail.com>

Signed-off-by: Sachi King <nakato@nakato.io>
Patchset: surface-button
---
 drivers/platform/surface/surfacepro3_button.c | 30 ++++---------------
 1 file changed, 6 insertions(+), 24 deletions(-)

diff --git a/drivers/platform/surface/surfacepro3_button.c b/drivers/platform/surface/surfacepro3_button.c
index 2755601f979c..4240c98ca226 100644
--- a/drivers/platform/surface/surfacepro3_button.c
+++ b/drivers/platform/surface/surfacepro3_button.c
@@ -149,7 +149,8 @@ static int surface_button_resume(struct device *dev)
 /*
  * Surface Pro 4 and Surface Book 2 / Surface Pro 2017 use the same device
  * ID (MSHW0040) for the power/volume buttons. Make sure this is the right
- * device by checking for the _DSM method and OEM Platform Revision.
+ * device by checking for the _DSM method and OEM Platform Revision DSM
+ * function.
  *
  * Returns true if the driver should bind to this device, i.e. the device is
  * either MSWH0028 (Pro 3) or MSHW0040 on a Pro 4 or Book 1.
@@ -157,30 +158,11 @@ static int surface_button_resume(struct device *dev)
 static bool surface_button_check_MSHW0040(struct acpi_device *dev)
 {
 	acpi_handle handle = dev->handle;
-	union acpi_object *result;
-	u64 oem_platform_rev = 0;	// valid revisions are nonzero
-
-	// get OEM platform revision
-	result = acpi_evaluate_dsm_typed(handle, &MSHW0040_DSM_UUID,
-					 MSHW0040_DSM_REVISION,
-					 MSHW0040_DSM_GET_OMPR,
-					 NULL, ACPI_TYPE_INTEGER);
-
-	/*
-	 * If evaluating the _DSM fails, the method is not present. This means
-	 * that we have either MSHW0028 or MSHW0040 on Pro 4 or Book 1, so we
-	 * should use this driver. We use revision 0 indicating it is
-	 * unavailable.
-	 */
-
-	if (result) {
-		oem_platform_rev = result->integer.value;
-		ACPI_FREE(result);
-	}
-
-	dev_dbg(&dev->dev, "OEM Platform Revision %llu\n", oem_platform_rev);
 
-	return oem_platform_rev == 0;
+	// make sure that OEM platform revision DSM call does not exist
+	return !acpi_check_dsm(handle, &MSHW0040_DSM_UUID,
+			       MSHW0040_DSM_REVISION,
+			       BIT(MSHW0040_DSM_GET_OMPR));
 }
 
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sat, 18 Feb 2023 01:02:49 +0100
Subject: USB: quirks: Add USB_QUIRK_DELAY_INIT for Surface Go 3 Type-Cover

The touchpad on the Type-Cover of the Surface Go 3 is sometimes not
being initialized properly. Apply USB_QUIRK_DELAY_INIT to fix this
issue.

More specifically, the device in question is a fairly standard modern
touchpad with pointer and touchpad input modes. During setup, the device
needs to be switched from pointer- to touchpad-mode (which is done in
hid-multitouch) to fully utilize it as intended. Unfortunately, however,
this seems to occasionally fail silently, leaving the device in
pointer-mode. Applying USB_QUIRK_DELAY_INIT seems to fix this.

Link: https://github.com/linux-surface/linux-surface/issues/1059
Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: surface-typecover
---
 drivers/usb/core/quirks.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f5bc53875330..31fa895d73c4 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -223,6 +223,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Microsoft Surface Dock Ethernet (RTL8153 GigE) */
 	{ USB_DEVICE(0x045e, 0x07c6), .driver_info = USB_QUIRK_NO_LPM },
 
+	/* Microsoft Surface Go 3 Type-Cover */
+	{ USB_DEVICE(0x045e, 0x09b5), .driver_info = USB_QUIRK_DELAY_INIT },
+
 	/* Cherry Stream G230 2.0 (G85-231) and 3.0 (G85-232) */
 	{ USB_DEVICE(0x046a, 0x0023), .driver_info = USB_QUIRK_RESET_RESUME },
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20Dre=C3=9Fler?= <verdre@v0yd.nl>
Date: Thu, 5 Nov 2020 13:09:45 +0100
Subject: hid/multitouch: Turn off Type Cover keyboard backlight when
 suspending

The Type Cover for Microsoft Surface devices supports a special usb
control request to disable or enable the built-in keyboard backlight.
On Windows, this request happens when putting the device into suspend or
resuming it, without it the backlight of the Type Cover will remain
enabled for some time even though the computer is suspended, which looks
weird to the user.

So add support for this special usb control request to hid-multitouch,
which is the driver that's handling the Type Cover.

The reason we have to use a pm_notifier for this instead of the usual
suspend/resume methods is that those won't get called in case the usb
device is already autosuspended.

Also, if the device is autosuspended, we have to briefly autoresume it
in order to send the request. Doing that should be fine, the usb-core
driver does something similar during suspend inside choose_wakeup().

To make sure we don't send that request to every device but only to
devices which support it, add a new quirk
MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER to hid-multitouch. For now this quirk
is only enabled for the usb id of the Surface Pro 2017 Type Cover, which
is where I confirmed that it's working.

Patchset: surface-typecover
---
 drivers/hid/hid-multitouch.c | 99 +++++++++++++++++++++++++++++++++++-
 1 file changed, 97 insertions(+), 2 deletions(-)

diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index 22c6314a8843..4e99f9f015c6 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -35,7 +35,10 @@
 #include <linux/device.h>
 #include <linux/hid.h>
 #include <linux/module.h>
+#include <linux/pm_runtime.h>
 #include <linux/slab.h>
+#include <linux/suspend.h>
+#include <linux/usb.h>
 #include <linux/input/mt.h>
 #include <linux/jiffies.h>
 #include <linux/string.h>
@@ -48,6 +51,7 @@ MODULE_DESCRIPTION("HID multitouch panels");
 MODULE_LICENSE("GPL");
 
 #include "hid-ids.h"
+#include "usbhid/usbhid.h"
 
 /* quirks to control the device */
 #define MT_QUIRK_NOT_SEEN_MEANS_UP	BIT(0)
@@ -74,12 +78,15 @@ MODULE_LICENSE("GPL");
 #define MT_QUIRK_DISABLE_WAKEUP		BIT(21)
 #define MT_QUIRK_ORIENTATION_INVERT	BIT(22)
 #define MT_QUIRK_APPLE_TOUCHBAR		BIT(23)
+#define MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT	BIT(24)
 
 #define MT_INPUTMODE_TOUCHSCREEN	0x02
 #define MT_INPUTMODE_TOUCHPAD		0x03
 
 #define MT_BUTTONTYPE_CLICKPAD		0
 
+#define MS_TYPE_COVER_FEATURE_REPORT_USAGE	0xff050086
+
 enum latency_mode {
 	HID_LATENCY_NORMAL = 0,
 	HID_LATENCY_HIGH = 1,
@@ -177,6 +184,8 @@ struct mt_device {
 
 	struct list_head applications;
 	struct list_head reports;
+
+	struct notifier_block pm_notifier;
 };
 
 static void mt_post_parse_default_settings(struct mt_device *td,
@@ -222,6 +231,7 @@ static void mt_post_parse(struct mt_device *td, struct mt_application *app);
 #define MT_CLS_RAZER_BLADE_STEALTH		0x0112
 #define MT_CLS_SMART_TECH			0x0113
 #define MT_CLS_APPLE_TOUCHBAR			0x0114
+#define MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER	0x0115
 #define MT_CLS_SIS				0x0457
 
 #define MT_DEFAULT_MAXCONTACT	10
@@ -418,6 +428,16 @@ static const struct mt_class mt_classes[] = {
 			MT_QUIRK_ALWAYS_VALID |
 			MT_QUIRK_CONTACT_CNT_ACCURATE,
 	},
+	{ .name = MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER,
+		.quirks = MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT |
+			MT_QUIRK_ALWAYS_VALID |
+			MT_QUIRK_IGNORE_DUPLICATES |
+			MT_QUIRK_HOVERING |
+			MT_QUIRK_CONTACT_CNT_ACCURATE |
+			MT_QUIRK_STICKY_FINGERS |
+			MT_QUIRK_WIN8_PTP_BUTTONS,
+		.export_all_inputs = true
+	},
 	{ }
 };
 
@@ -1809,6 +1829,69 @@ static void mt_expired_timeout(struct timer_list *t)
 	clear_bit_unlock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);
 }
 
+static void get_type_cover_backlight_field(struct hid_device *hdev,
+					   struct hid_field **field)
+{
+	struct hid_report_enum *rep_enum;
+	struct hid_report *rep;
+	struct hid_field *cur_field;
+	int i, j;
+
+	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		for (i = 0; i < rep->maxfield; i++) {
+			cur_field = rep->field[i];
+
+			for (j = 0; j < cur_field->maxusage; j++) {
+				if (cur_field->usage[j].hid
+				    == MS_TYPE_COVER_FEATURE_REPORT_USAGE) {
+					*field = cur_field;
+					return;
+				}
+			}
+		}
+	}
+}
+
+static void update_keyboard_backlight(struct hid_device *hdev, bool enabled)
+{
+	struct usb_device *udev = hid_to_usb_dev(hdev);
+	struct hid_field *field = NULL;
+
+	/* Wake up the device in case it's already suspended */
+	pm_runtime_get_sync(&udev->dev);
+
+	get_type_cover_backlight_field(hdev, &field);
+	if (!field) {
+		hid_err(hdev, "couldn't find backlight field\n");
+		goto out;
+	}
+
+	field->value[field->index] = enabled ? 0x01ff00ff : 0x00ff00ff;
+	hid_hw_request(hdev, field->report, HID_REQ_SET_REPORT);
+
+out:
+	pm_runtime_put_sync(&udev->dev);
+}
+
+static int mt_pm_notifier(struct notifier_block *notifier,
+			  unsigned long pm_event,
+			  void *unused)
+{
+	struct mt_device *td =
+		container_of(notifier, struct mt_device, pm_notifier);
+	struct hid_device *hdev = td->hdev;
+
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT) {
+		if (pm_event == PM_SUSPEND_PREPARE)
+			update_keyboard_backlight(hdev, 0);
+		else if (pm_event == PM_POST_SUSPEND)
+			update_keyboard_backlight(hdev, 1);
+	}
+
+	return NOTIFY_DONE;
+}
+
 static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret, i;
@@ -1832,6 +1915,9 @@ static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	td->inputmode_value = MT_INPUTMODE_TOUCHSCREEN;
 	hid_set_drvdata(hdev, td);
 
+	td->pm_notifier.notifier_call = mt_pm_notifier;
+	register_pm_notifier(&td->pm_notifier);
+
 	INIT_LIST_HEAD(&td->applications);
 	INIT_LIST_HEAD(&td->reports);
 
@@ -1870,8 +1956,10 @@ static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	timer_setup(&td->release_timer, mt_expired_timeout, 0);
 
 	ret = hid_parse(hdev);
-	if (ret != 0)
+	if (ret != 0) {
+		unregister_pm_notifier(&td->pm_notifier);
 		return ret;
+	}
 
 	if (mtclass->name == MT_CLS_APPLE_TOUCHBAR &&
 	    !hid_find_field(hdev, HID_INPUT_REPORT,
@@ -1885,8 +1973,10 @@ static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		hdev->quirks |= HID_QUIRK_NOGET;
 
 	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
-	if (ret)
+	if (ret) {
+		unregister_pm_notifier(&td->pm_notifier);
 		return ret;
+	}
 
 	ret = sysfs_create_group(&hdev->dev.kobj, &mt_attribute_group);
 	if (ret)
@@ -1936,6 +2026,7 @@ static void mt_remove(struct hid_device *hdev)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
 
+	unregister_pm_notifier(&td->pm_notifier);
 	timer_delete_sync(&td->release_timer);
 
 	sysfs_remove_group(&hdev->dev.kobj, &mt_attribute_group);
@@ -2379,6 +2470,10 @@ static const struct hid_device_id mt_devices[] = {
 	{ .driver_data = MT_CLS_APPLE_TOUCHBAR,
 		HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
 			USB_DEVICE_ID_APPLE_TOUCHBAR_DISPLAY) },
+	/* Microsoft Surface type cover */
+	{ .driver_data = MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER,
+		HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+			USB_VENDOR_ID_MICROSOFT, 0x09c0) },
 
 	/* Google MT devices */
 	{ .driver_data = MT_CLS_GOOGLE,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PJungkamp <p.jungkamp@gmail.com>
Date: Fri, 25 Feb 2022 12:04:25 +0100
Subject: hid/multitouch: Add support for surface pro type cover tablet switch

The Surface Pro Type Cover has several non standard HID usages in it's
hid report descriptor.
I noticed that, upon folding the typecover back, a vendor specific range
of 4 32 bit integer hid usages is transmitted.
Only the first byte of the message seems to convey reliable information
about the keyboard state.

0x22 => Normal (keys enabled)
0x33 => Folded back (keys disabled)
0x53 => Rotated left/right side up (keys disabled)
0x13 => Cover closed (keys disabled)
0x43 => Folded back and Tablet upside down (keys disabled)
This list may not be exhaustive.

The tablet mode switch will be disabled for a value of 0x22 and enabled
on any other value.

Patchset: surface-typecover
---
 drivers/hid/hid-multitouch.c | 148 +++++++++++++++++++++++++++++------
 1 file changed, 122 insertions(+), 26 deletions(-)

diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c
index 4e99f9f015c6..8b6d15db11a0 100644
--- a/drivers/hid/hid-multitouch.c
+++ b/drivers/hid/hid-multitouch.c
@@ -79,6 +79,7 @@ MODULE_LICENSE("GPL");
 #define MT_QUIRK_ORIENTATION_INVERT	BIT(22)
 #define MT_QUIRK_APPLE_TOUCHBAR		BIT(23)
 #define MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT	BIT(24)
+#define MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH	BIT(25)
 
 #define MT_INPUTMODE_TOUCHSCREEN	0x02
 #define MT_INPUTMODE_TOUCHPAD		0x03
@@ -86,6 +87,8 @@ MODULE_LICENSE("GPL");
 #define MT_BUTTONTYPE_CLICKPAD		0
 
 #define MS_TYPE_COVER_FEATURE_REPORT_USAGE	0xff050086
+#define MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE	0xff050072
+#define MS_TYPE_COVER_APPLICATION	0xff050050
 
 enum latency_mode {
 	HID_LATENCY_NORMAL = 0,
@@ -430,6 +433,7 @@ static const struct mt_class mt_classes[] = {
 	},
 	{ .name = MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER,
 		.quirks = MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT |
+			MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH |
 			MT_QUIRK_ALWAYS_VALID |
 			MT_QUIRK_IGNORE_DUPLICATES |
 			MT_QUIRK_HOVERING |
@@ -1445,6 +1449,9 @@ static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 	    field->application != HID_CP_CONSUMER_CONTROL &&
 	    field->application != HID_GD_WIRELESS_RADIO_CTLS &&
 	    field->application != HID_GD_SYSTEM_MULTIAXIS &&
+	    !(field->application == MS_TYPE_COVER_APPLICATION &&
+	      application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	      usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) &&
 	    !(field->application == HID_VD_ASUS_CUSTOM_MEDIA_KEYS &&
 	      application->quirks & MT_QUIRK_ASUS_CUSTOM_UP))
 		return -1;
@@ -1472,6 +1479,21 @@ static int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		return 1;
 	}
 
+	/*
+	 * The Microsoft Surface Pro Typecover has a non-standard HID
+	 * tablet mode switch on a vendor specific usage page with vendor
+	 * specific usage.
+	 */
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		usage->type = EV_SW;
+		usage->code = SW_TABLET_MODE;
+		*max = SW_MAX;
+		*bit = hi->input->swbit;
+		return 1;
+	}
+
 	if (rdata->is_mt_collection)
 		return mt_touch_input_mapping(hdev, hi, field, usage, bit, max,
 					      application);
@@ -1493,6 +1515,7 @@ static int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
 	struct mt_report_data *rdata;
+	struct input_dev *input;
 
 	rdata = mt_find_report_data(td, field->report);
 	if (rdata && rdata->is_mt_collection) {
@@ -1500,6 +1523,19 @@ static int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 		return -1;
 	}
 
+	/*
+	 * We own an input device which acts as a tablet mode switch for
+	 * the Surface Pro Typecover.
+	 */
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    rdata->application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		input = hi->input;
+		input_set_capability(input, EV_SW, SW_TABLET_MODE);
+		input_report_switch(input, SW_TABLET_MODE, 0);
+		return -1;
+	}
+
 	/* let hid-core decide for the others */
 	return 0;
 }
@@ -1509,11 +1545,21 @@ static int mt_event(struct hid_device *hid, struct hid_field *field,
 {
 	struct mt_device *td = hid_get_drvdata(hid);
 	struct mt_report_data *rdata;
+	struct input_dev *input;
 
 	rdata = mt_find_report_data(td, field->report);
 	if (rdata && rdata->is_mt_collection)
 		return mt_touch_event(hid, field, usage, value);
 
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    rdata->application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		input = field->hidinput->input;
+		input_report_switch(input, SW_TABLET_MODE, (value & 0xFF) != 0x22);
+		input_sync(input);
+		return 1;
+	}
+
 	return 0;
 }
 
@@ -1696,6 +1742,42 @@ static void mt_post_parse(struct mt_device *td, struct mt_application *app)
 		app->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;
 }
 
+static int get_type_cover_field(struct hid_report_enum *rep_enum,
+				struct hid_field **field, int usage)
+{
+	struct hid_report *rep;
+	struct hid_field *cur_field;
+	int i, j;
+
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		for (i = 0; i < rep->maxfield; i++) {
+			cur_field = rep->field[i];
+			if (cur_field->application != MS_TYPE_COVER_APPLICATION)
+				continue;
+			for (j = 0; j < cur_field->maxusage; j++) {
+				if (cur_field->usage[j].hid == usage) {
+					*field = cur_field;
+					return true;
+				}
+			}
+		}
+	}
+	return false;
+}
+
+static void request_type_cover_tablet_mode_switch(struct hid_device *hdev)
+{
+	struct hid_field *field;
+
+	if (get_type_cover_field(&hdev->report_enum[HID_INPUT_REPORT],
+				 &field,
+				 MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE)) {
+		hid_hw_request(hdev, field->report, HID_REQ_GET_REPORT);
+	} else {
+		hid_err(hdev, "couldn't find tablet mode field\n");
+	}
+}
+
 static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
@@ -1744,6 +1826,13 @@ static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
 		/* force BTN_STYLUS to allow tablet matching in udev */
 		__set_bit(BTN_STYLUS, hi->input->keybit);
 		break;
+	case MS_TYPE_COVER_APPLICATION:
+		if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH) {
+			suffix = "Tablet Mode Switch";
+			request_type_cover_tablet_mode_switch(hdev);
+			break;
+		}
+		fallthrough;
 	default:
 		suffix = "UNKNOWN";
 		break;
@@ -1829,30 +1918,6 @@ static void mt_expired_timeout(struct timer_list *t)
 	clear_bit_unlock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);
 }
 
-static void get_type_cover_backlight_field(struct hid_device *hdev,
-					   struct hid_field **field)
-{
-	struct hid_report_enum *rep_enum;
-	struct hid_report *rep;
-	struct hid_field *cur_field;
-	int i, j;
-
-	rep_enum = &hdev->report_enum[HID_FEATURE_REPORT];
-	list_for_each_entry(rep, &rep_enum->report_list, list) {
-		for (i = 0; i < rep->maxfield; i++) {
-			cur_field = rep->field[i];
-
-			for (j = 0; j < cur_field->maxusage; j++) {
-				if (cur_field->usage[j].hid
-				    == MS_TYPE_COVER_FEATURE_REPORT_USAGE) {
-					*field = cur_field;
-					return;
-				}
-			}
-		}
-	}
-}
-
 static void update_keyboard_backlight(struct hid_device *hdev, bool enabled)
 {
 	struct usb_device *udev = hid_to_usb_dev(hdev);
@@ -1861,8 +1926,9 @@ static void update_keyboard_backlight(struct hid_device *hdev, bool enabled)
 	/* Wake up the device in case it's already suspended */
 	pm_runtime_get_sync(&udev->dev);
 
-	get_type_cover_backlight_field(hdev, &field);
-	if (!field) {
+	if (!get_type_cover_field(&hdev->report_enum[HID_FEATURE_REPORT],
+				  &field,
+				  MS_TYPE_COVER_FEATURE_REPORT_USAGE)) {
 		hid_err(hdev, "couldn't find backlight field\n");
 		goto out;
 	}
@@ -2004,13 +2070,24 @@ static int mt_suspend(struct hid_device *hdev, pm_message_t state)
 
 static int mt_reset_resume(struct hid_device *hdev)
 {
+	struct mt_device *td = hid_get_drvdata(hdev);
+
 	mt_release_contacts(hdev);
 	mt_set_modes(hdev, HID_LATENCY_NORMAL, TOUCHPAD_REPORT_ALL);
+
+	/* Request an update on the typecover folding state on resume
+	 * after reset.
+	 */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH)
+		request_type_cover_tablet_mode_switch(hdev);
+
 	return 0;
 }
 
 static int mt_resume(struct hid_device *hdev)
 {
+	struct mt_device *td = hid_get_drvdata(hdev);
+
 	/* Some Elan legacy devices require SET_IDLE to be set on resume.
 	 * It should be safe to send it to other devices too.
 	 * Tested on 3M, Stantum, Cypress, Zytronic, eGalax, and Elan panels. */
@@ -2019,12 +2096,31 @@ static int mt_resume(struct hid_device *hdev)
 
 	mt_set_modes(hdev, HID_LATENCY_NORMAL, TOUCHPAD_REPORT_ALL);
 
+	/* Request an update on the typecover folding state on resume. */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH)
+		request_type_cover_tablet_mode_switch(hdev);
+
 	return 0;
 }
 
 static void mt_remove(struct hid_device *hdev)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
+	struct hid_field *field;
+	struct input_dev *input;
+
+	/* Reset tablet mode switch on disconnect. */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH) {
+		if (get_type_cover_field(&hdev->report_enum[HID_INPUT_REPORT],
+					 &field,
+					 MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE)) {
+			input = field->hidinput->input;
+			input_report_switch(input, SW_TABLET_MODE, 0);
+			input_sync(input);
+		} else {
+			hid_err(hdev, "couldn't find tablet mode field\n");
+		}
+	}
 
 	unregister_pm_notifier(&td->pm_notifier);
 	timer_delete_sync(&td->release_timer);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sun, 19 Feb 2023 22:12:24 +0100
Subject: PCI: Add quirk to prevent calling shutdown mehtod

Work around buggy EFI firmware: On some Microsoft Surface devices
(Surface Pro 9 and Surface Laptop 5) the EFI ResetSystem call with
EFI_RESET_SHUTDOWN doesn't function properly. Instead of shutting the
system down, it returns and the system stays on.

It turns out that this only happens after PCI shutdown callbacks ran for
specific devices. Excluding those devices from the shutdown process
makes the ResetSystem call work as expected.

TODO: Maybe we can find a better way or the root cause of this?

Not-Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: surface-shutdown
---
 drivers/pci/pci-driver.c |  3 +++
 drivers/pci/quirks.c     | 36 ++++++++++++++++++++++++++++++++++++
 include/linux/pci.h      |  1 +
 3 files changed, 40 insertions(+)

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 6405acdb5d0f..c742414f2a9c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -505,6 +505,9 @@ static void pci_device_shutdown(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct pci_driver *drv = pci_dev->driver;
 
+	if (pci_dev->no_shutdown)
+		return;
+
 	pm_runtime_resume(dev);
 
 	if (drv && drv->shutdown)
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 3b0c24a0bf32..f0b131853155 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -6362,3 +6362,39 @@ static void pci_mask_replay_timer_timeout(struct pci_dev *pdev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_GLI, 0x9750, pci_mask_replay_timer_timeout);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_GLI, 0x9755, pci_mask_replay_timer_timeout);
 #endif
+
+static const struct dmi_system_id no_shutdown_dmi_table[] = {
+	/*
+	 * Systems on which some devices should not be touched during shutdown.
+	 */
+	{
+		.ident = "Microsoft Surface Pro 9",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Surface Pro 9"),
+		},
+	},
+	{
+		.ident = "Microsoft Surface Laptop 5",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Surface Laptop 5"),
+		},
+	},
+	{}
+};
+
+static void quirk_no_shutdown(struct pci_dev *dev)
+{
+	if (!dmi_check_system(no_shutdown_dmi_table))
+		return;
+
+	dev->no_shutdown = 1;
+	pci_info(dev, "disabling shutdown ops for [%04x:%04x]\n",
+		 dev->vendor, dev->device);
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x461e, quirk_no_shutdown);  // Thunderbolt 4 USB Controller
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x461f, quirk_no_shutdown);  // Thunderbolt 4 PCI Express Root Port
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x462f, quirk_no_shutdown);  // Thunderbolt 4 PCI Express Root Port
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x466d, quirk_no_shutdown);  // Thunderbolt 4 NHI
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x46a8, quirk_no_shutdown);  // GPU
diff --git a/include/linux/pci.h b/include/linux/pci.h
index 59876de13860..41d0a274a550 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -484,6 +484,7 @@ struct pci_dev {
 	unsigned int	rom_bar_overlap:1;	/* ROM BAR disable broken */
 	unsigned int	rom_attr_enabled:1;	/* Display of ROM attribute enabled? */
 	unsigned int	non_mappable_bars:1;	/* BARs can't be mapped to user-space  */
+	unsigned int	no_shutdown:1;		/* Do not touch device on shutdown */
 	pci_dev_flags_t dev_flags;
 	atomic_t	enable_cnt;	/* pci_enable_device has been called */
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Sun, 12 Mar 2023 01:41:57 +0100
Subject: platform/surface: gpe: Add support for Surface Pro 9

Add the lid GPE used by the Surface Pro 9.

Signed-off-by: Maximilian Luz <luzmaximilian@gmail.com>
Patchset: surface-gpe
---
 drivers/platform/surface/surface_gpe.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/drivers/platform/surface/surface_gpe.c b/drivers/platform/surface/surface_gpe.c
index b359413903b1..b4496db79f39 100644
--- a/drivers/platform/surface/surface_gpe.c
+++ b/drivers/platform/surface/surface_gpe.c
@@ -41,6 +41,11 @@ static const struct property_entry lid_device_props_l4F[] = {
 	{},
 };
 
+static const struct property_entry lid_device_props_l52[] = {
+	PROPERTY_ENTRY_U32("gpe", 0x52),
+	{},
+};
+
 static const struct property_entry lid_device_props_l57[] = {
 	PROPERTY_ENTRY_U32("gpe", 0x57),
 	{},
@@ -107,6 +112,18 @@ static const struct dmi_system_id dmi_lid_device_table[] = {
 		},
 		.driver_data = (void *)lid_device_props_l4B,
 	},
+	{
+		/*
+		 * We match for SKU here due to product name clash with the ARM
+		 * version.
+		 */
+		.ident = "Surface Pro 9",
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_9_2038"),
+		},
+		.driver_data = (void *)lid_device_props_l52,
+	},
 	{
 		.ident = "Surface Book 1",
 		.matches = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Sun, 10 Oct 2021 20:56:57 +0200
Subject: ACPI: delay enumeration of devices with a _DEP pointing to an INT3472
 device

The clk and regulator frameworks expect clk/regulator consumer-devices
to have info about the consumed clks/regulators described in the device's
fw_node.

To work around cases where this info is not present in the firmware tables,
which is often the case on x86/ACPI devices, both frameworks allow the
provider-driver to attach info about consumers to the clks/regulators
when registering these.

This causes problems with the probe ordering wrt drivers for consumers
of these clks/regulators. Since the lookups are only registered when the
provider-driver binds, trying to get these clks/regulators before then
results in a -ENOENT error for clks and a dummy regulator for regulators.

One case where we hit this issue is camera sensors such as e.g. the OV8865
sensor found on the Microsoft Surface Go. The sensor uses clks, regulators
and GPIOs provided by a TPS68470 PMIC which is described in an INT3472
ACPI device. There is special platform code handling this and setting
platform_data with the necessary consumer info on the MFD cells
instantiated for the PMIC under: drivers/platform/x86/intel/int3472.

For this to work properly the ov8865 driver must not bind to the I2C-client
for the OV8865 sensor until after the TPS68470 PMIC gpio, regulator and
clk MFD cells have all been fully setup.

The OV8865 on the Microsoft Surface Go is just one example, all X86
devices using the Intel IPU3 camera block found on recent Intel SoCs
have similar issues where there is an INT3472 HID ACPI-device, which
describes the clks and regulators, and the driver for this INT3472 device
must be fully initialized before the sensor driver (any sensor driver)
binds for things to work properly.

On these devices the ACPI nodes describing the sensors all have a _DEP
dependency on the matching INT3472 ACPI device (there is one per sensor).

This allows solving the probe-ordering problem by delaying the enumeration
(instantiation of the I2C-client in the ov8865 example) of ACPI-devices
which have a _DEP dependency on an INT3472 device.

The new acpi_dev_ready_for_enumeration() helper used for this is also
exported because for devices, which have the enumeration_by_parent flag
set, the parent-driver will do its own scan of child ACPI devices and
it will try to enumerate those during its probe(). Code doing this such
as e.g. the i2c-core-acpi.c code must call this new helper to ensure
that it too delays the enumeration until all the _DEP dependencies are
met on devices which have the new honor_deps flag set.

Signed-off-by: Hans de Goede <hdegoede@redhat.com>
Patchset: cameras
---
 drivers/acpi/scan.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 1a857d373b3d..d9a4d274def3 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -2208,6 +2208,9 @@ static acpi_status acpi_bus_check_add_2(acpi_handle handle, u32 lvl_not_used,
 
 static void acpi_default_enumeration(struct acpi_device *device)
 {
+	if (!acpi_dev_ready_for_enumeration(device))
+		return;
+
 	/*
 	 * Do not enumerate devices with enumeration_by_parent flag set as
 	 * they will be enumerated by their respective parents.
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Fri, 25 Jun 2021 08:52:59 +0800
Subject: iommu: intel-ipu: use IOMMU passthrough mode for Intel IPUs

Intel IPU(Image Processing Unit) has its own (IO)MMU hardware,
The IPU driver allocates its own page table that is not mapped
via the DMA, and thus the Intel IOMMU driver blocks access giving
this error: DMAR: DRHD: handling fault status reg 3 DMAR:
[DMA Read] Request device [00:05.0] PASID ffffffff
fault addr 76406000 [fault reason 06] PTE Read access is not set
As IPU is not an external facing device which is not risky, so use
IOMMU passthrough mode for Intel IPUs.

Change-Id: I6dcccdadac308cf42e20a18e1b593381391e3e6b
Depends-On: Iacd67578e8c6a9b9ac73285f52b4081b72fb68a6
Tracked-On: #JIITL8-411
Signed-off-by: Bingbu Cao <bingbu.cao@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
Signed-off-by: Xu Chongyang <chongyang.xu@intel.com>
Patchset: cameras
---
 drivers/iommu/intel/iommu.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index 9e31a5fe1f66..bdd32551c452 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -44,6 +44,13 @@
 		((pdev)->vendor == PCI_VENDOR_ID_INTEL && (pdev)->device == 0x34E4) \
 	)
 
+#define IS_INTEL_IPU(pdev) ((pdev)->vendor == PCI_VENDOR_ID_INTEL &&	\
+			   ((pdev)->device == 0x9a19 ||		\
+			    (pdev)->device == 0x9a39 ||		\
+			    (pdev)->device == 0x4e19 ||		\
+			    (pdev)->device == 0x465d ||		\
+			    (pdev)->device == 0x1919))
+
 #define IOAPIC_RANGE_START	(0xfee00000)
 #define IOAPIC_RANGE_END	(0xfeefffff)
 #define IOVA_START_ADDR		(0x1000)
@@ -215,12 +222,14 @@ int intel_iommu_enabled = 0;
 EXPORT_SYMBOL_GPL(intel_iommu_enabled);
 
 static int dmar_map_ipts = 1;
+static int dmar_map_ipu = 1;
 static int intel_iommu_superpage = 1;
 static int iommu_identity_mapping;
 static int iommu_skip_te_disable;
 static int disable_igfx_iommu;
 
 #define IDENTMAP_AZALIA		4
+#define IDENTMAP_IPU		8
 #define IDENTMAP_IPTS		16
 
 const struct iommu_ops intel_iommu_ops;
@@ -1887,6 +1896,9 @@ static int device_def_domain_type(struct device *dev)
 		if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
 
+		if ((iommu_identity_mapping & IDENTMAP_IPU) && IS_INTEL_IPU(pdev))
+			return IOMMU_DOMAIN_IDENTITY;
+
 		if ((iommu_identity_mapping & IDENTMAP_IPTS) && IS_IPTS(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
 	}
@@ -2179,6 +2191,9 @@ static int __init init_dmars(void)
 		iommu_set_root_entry(iommu);
 	}
 
+	if (!dmar_map_ipu)
+		iommu_identity_mapping |= IDENTMAP_IPU;
+
 	if (!dmar_map_ipts)
 		iommu_identity_mapping |= IDENTMAP_IPTS;
 
@@ -4528,6 +4543,18 @@ static void quirk_iommu_igfx(struct pci_dev *dev)
 	disable_igfx_iommu = 1;
 }
 
+static void quirk_iommu_ipu(struct pci_dev *dev)
+{
+	if (!IS_INTEL_IPU(dev))
+		return;
+
+	if (risky_device(dev))
+		return;
+
+	pci_info(dev, "Passthrough IOMMU for integrated Intel IPU\n");
+	dmar_map_ipu = 0;
+}
+
 static void quirk_iommu_ipts(struct pci_dev *dev)
 {
 	if (!IS_IPTS(dev))
@@ -4578,6 +4605,9 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x1632, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163A, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163D, quirk_iommu_igfx);
 
+/* disable IPU dmar support */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, quirk_iommu_ipu);
+
 /* disable IPTS dmar support */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9D3E, quirk_iommu_ipts);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x34E4, quirk_iommu_ipts);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniel Scally <djrscally@gmail.com>
Date: Sun, 10 Oct 2021 20:57:02 +0200
Subject: platform/x86: int3472: Enable I2c daisy chain

The TPS68470 PMIC has an I2C passthrough mode through which I2C traffic
can be forwarded to a device connected to the PMIC as though it were
connected directly to the system bus. Enable this mode when the chip
is initialised.

Signed-off-by: Daniel Scally <djrscally@gmail.com>
Patchset: cameras
---
 drivers/platform/x86/intel/int3472/tps68470.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/intel/int3472/tps68470.c b/drivers/platform/x86/intel/int3472/tps68470.c
index 0133405697dc..9e0763bdc758 100644
--- a/drivers/platform/x86/intel/int3472/tps68470.c
+++ b/drivers/platform/x86/intel/int3472/tps68470.c
@@ -46,6 +46,13 @@ static int tps68470_chip_init(struct device *dev, struct regmap *regmap)
 		return ret;
 	}
 
+	/* Enable I2C daisy chain */
+	ret = regmap_write(regmap, TPS68470_REG_S_I2C_CTL, 0x03);
+	if (ret) {
+		dev_err(dev, "Failed to enable i2c daisy chain\n");
+		return ret;
+	}
+
 	dev_info(dev, "TPS68470 REVID: 0x%02x\n", version);
 
 	return 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniel Scally <dan.scally@ideasonboard.com>
Date: Thu, 2 Mar 2023 12:59:39 +0000
Subject: platform/x86: int3472: Remap reset GPIO for INT347E

ACPI _HID INT347E represents the OmniVision 7251 camera sensor. The
driver for this sensor expects a single pin named "enable", but on
some Microsoft Surface platforms the sensor is assigned a single
GPIO who's type flag is INT3472_GPIO_TYPE_RESET.

Remap the GPIO pin's function from "reset" to "enable". This is done
outside of the existing remap table since it is a more widespread
discrepancy than that method is designed for. Additionally swap the
polarity of the pin to match the driver's expectation.

Signed-off-by: Daniel Scally <dan.scally@ideasonboard.com>
Patchset: cameras
---
 drivers/platform/x86/intel/int3472/discrete.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/platform/x86/intel/int3472/discrete.c b/drivers/platform/x86/intel/int3472/discrete.c
index 1505fc3ef7a8..1d3fec1924af 100644
--- a/drivers/platform/x86/intel/int3472/discrete.c
+++ b/drivers/platform/x86/intel/int3472/discrete.c
@@ -81,12 +81,27 @@ static int skl_int3472_map_gpio_to_sensor(struct int3472_discrete_device *int347
 					  const char *con_id, unsigned long gpio_flags)
 {
 	int ret;
+	const struct acpi_device_id ov7251_ids[] = {
+		{ "INT347E" },
+		{ }
+	};
 
 	if (int3472->n_sensor_gpios >= INT3472_MAX_SENSOR_GPIOS) {
 		dev_warn(int3472->dev, "Too many GPIOs mapped\n");
 		return -EINVAL;
 	}
 
+	/*
+	 * In addition to the function remap table we need to bulk remap the
+	 * "reset" GPIO for the OmniVision 7251 sensor, as the driver for that
+	 * expects its only GPIO pin to be called "enable" (and to have the
+	 * opposite polarity).
+	 */
+	if (!strcmp(con_id, "reset") && !acpi_match_device_ids(int3472->sensor, ov7251_ids)) {
+		con_id = "enable";
+		gpio_flags ^= GPIO_ACTIVE_LOW;
+	}
+
 	ret = skl_int3472_fill_gpiod_lookup(&int3472->gpios.table[int3472->n_sensor_gpios],
 					    agpio, con_id, gpio_flags);
 	if (ret)
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniel Scally <dan.scally@ideasonboard.com>
Date: Tue, 21 Mar 2023 13:45:26 +0000
Subject: media: i2c: Clarify that gain is Analogue gain in OV7251

Update the control ID for the gain control in the ov7251 driver to
V4L2_CID_ANALOGUE_GAIN.

Signed-off-by: Daniel Scally <dan.scally@ideasonboard.com>
Patchset: cameras
---
 drivers/media/i2c/ov7251.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/media/i2c/ov7251.c b/drivers/media/i2c/ov7251.c
index 31a42d81e970..0d5a8fd86e67 100644
--- a/drivers/media/i2c/ov7251.c
+++ b/drivers/media/i2c/ov7251.c
@@ -1053,7 +1053,7 @@ static int ov7251_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_EXPOSURE:
 		ret = ov7251_set_exposure(ov7251, ctrl->val);
 		break;
-	case V4L2_CID_GAIN:
+	case V4L2_CID_ANALOGUE_GAIN:
 		ret = ov7251_set_gain(ov7251, ctrl->val);
 		break;
 	case V4L2_CID_TEST_PATTERN:
@@ -1579,7 +1579,7 @@ static int ov7251_init_ctrls(struct ov7251 *ov7251)
 	ov7251->exposure = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
 					     V4L2_CID_EXPOSURE, 1, 32, 1, 32);
 	ov7251->gain = v4l2_ctrl_new_std(&ov7251->ctrls, &ov7251_ctrl_ops,
-					 V4L2_CID_GAIN, 16, 1023, 1, 16);
+					 V4L2_CID_ANALOGUE_GAIN, 16, 1023, 1, 16);
 	v4l2_ctrl_new_std_menu_items(&ov7251->ctrls, &ov7251_ctrl_ops,
 				     V4L2_CID_TEST_PATTERN,
 				     ARRAY_SIZE(ov7251_test_pattern_menu) - 1,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Daniel Scally <dan.scally@ideasonboard.com>
Date: Wed, 22 Mar 2023 11:01:42 +0000
Subject: media: v4l2-core: Acquire privacy led in v4l2_async_register_subdev()

The current call to v4l2_subdev_get_privacy_led() is contained in
v4l2_async_register_subdev_sensor(), but that function isn't used by
all the sensor drivers. Move the acquisition of the privacy led to
v4l2_async_register_subdev() instead.

Signed-off-by: Daniel Scally <dan.scally@ideasonboard.com>
Patchset: cameras
---
 drivers/media/v4l2-core/v4l2-async.c  | 4 ++++
 drivers/media/v4l2-core/v4l2-fwnode.c | 4 ----
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/media/v4l2-core/v4l2-async.c b/drivers/media/v4l2-core/v4l2-async.c
index ee884a8221fb..4f6bafd900ee 100644
--- a/drivers/media/v4l2-core/v4l2-async.c
+++ b/drivers/media/v4l2-core/v4l2-async.c
@@ -799,6 +799,10 @@ int __v4l2_async_register_subdev(struct v4l2_subdev *sd, struct module *module)
 
 	INIT_LIST_HEAD(&sd->asc_list);
 
+	ret = v4l2_subdev_get_privacy_led(sd);
+	if (ret < 0)
+		return ret;
+
 	/*
 	 * No reference taken. The reference is held by the device (struct
 	 * v4l2_subdev.dev), and async sub-device does not exist independently
diff --git a/drivers/media/v4l2-core/v4l2-fwnode.c b/drivers/media/v4l2-core/v4l2-fwnode.c
index cb153ce42c45..f11b499e14bb 100644
--- a/drivers/media/v4l2-core/v4l2-fwnode.c
+++ b/drivers/media/v4l2-core/v4l2-fwnode.c
@@ -1260,10 +1260,6 @@ int v4l2_async_register_subdev_sensor(struct v4l2_subdev *sd)
 
 	v4l2_async_subdev_nf_init(notifier, sd);
 
-	ret = v4l2_subdev_get_privacy_led(sd);
-	if (ret < 0)
-		goto out_cleanup;
-
 	ret = v4l2_async_nf_parse_fwnode_sensor(sd->dev, notifier);
 	if (ret < 0)
 		goto out_cleanup;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kate Hsuan <hpa@redhat.com>
Date: Tue, 21 Mar 2023 23:37:16 +0800
Subject: platform: x86: int3472: Add MFD cell for tps68470 LED

Add MFD cell for tps68470-led.

Reviewed-by: Daniel Scally <dan.scally@ideasonboard.com>
Signed-off-by: Kate Hsuan <hpa@redhat.com>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Patchset: cameras
---
 drivers/platform/x86/intel/int3472/tps68470.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/intel/int3472/tps68470.c b/drivers/platform/x86/intel/int3472/tps68470.c
index 9e0763bdc758..0976b267972b 100644
--- a/drivers/platform/x86/intel/int3472/tps68470.c
+++ b/drivers/platform/x86/intel/int3472/tps68470.c
@@ -17,7 +17,7 @@
 #define DESIGNED_FOR_CHROMEOS		1
 #define DESIGNED_FOR_WINDOWS		2
 
-#define TPS68470_WIN_MFD_CELL_COUNT	3
+#define TPS68470_WIN_MFD_CELL_COUNT	4
 
 static const struct mfd_cell tps68470_cros[] = {
 	{ .name = "tps68470-gpio" },
@@ -203,7 +203,8 @@ static int skl_int3472_tps68470_probe(struct i2c_client *client)
 		cells[1].name = "tps68470-regulator";
 		cells[1].platform_data = (void *)board_data->tps68470_regulator_pdata;
 		cells[1].pdata_size = sizeof(struct tps68470_regulator_platform_data);
-		cells[2].name = "tps68470-gpio";
+		cells[2].name = "tps68470-led";
+		cells[3].name = "tps68470-gpio";
 
 		for (i = 0; i < board_data->n_gpiod_lookups; i++)
 			gpiod_add_lookup_table(board_data->tps68470_gpio_lookup_tables[i]);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kate Hsuan <hpa@redhat.com>
Date: Tue, 21 Mar 2023 23:37:17 +0800
Subject: include: mfd: tps68470: Add masks for LEDA and LEDB

Add flags for both LEDA(TPS68470_ILEDCTL_ENA), LEDB
(TPS68470_ILEDCTL_ENB), and current control mask for LEDB
(TPS68470_ILEDCTL_CTRLB)

Reviewed-by: Daniel Scally <dan.scally@ideasonboard.com>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Signed-off-by: Kate Hsuan <hpa@redhat.com>
Patchset: cameras
---
 include/linux/mfd/tps68470.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/include/linux/mfd/tps68470.h b/include/linux/mfd/tps68470.h
index 7807fa329db0..2d2abb25b944 100644
--- a/include/linux/mfd/tps68470.h
+++ b/include/linux/mfd/tps68470.h
@@ -34,6 +34,7 @@
 #define TPS68470_REG_SGPO		0x22
 #define TPS68470_REG_GPDI		0x26
 #define TPS68470_REG_GPDO		0x27
+#define TPS68470_REG_ILEDCTL		0x28
 #define TPS68470_REG_VCMVAL		0x3C
 #define TPS68470_REG_VAUX1VAL		0x3D
 #define TPS68470_REG_VAUX2VAL		0x3E
@@ -94,4 +95,8 @@
 #define TPS68470_GPIO_MODE_OUT_CMOS	2
 #define TPS68470_GPIO_MODE_OUT_ODRAIN	3
 
+#define TPS68470_ILEDCTL_ENA		BIT(2)
+#define TPS68470_ILEDCTL_ENB		BIT(6)
+#define TPS68470_ILEDCTL_CTRLB		GENMASK(5, 4)
+
 #endif /* __LINUX_MFD_TPS68470_H */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kate Hsuan <hpa@redhat.com>
Date: Tue, 21 Mar 2023 23:37:18 +0800
Subject: leds: tps68470: Add LED control for tps68470

There are two LED controllers, LEDA indicator LED and LEDB flash LED for
tps68470. LEDA can be enabled by setting TPS68470_ILEDCTL_ENA. Moreover,
tps68470 provides four levels of power status for LEDB. If the
properties called "ti,ledb-current" can be found, the current will be
set according to the property values. These two LEDs can be controlled
through the LED class of sysfs (tps68470-leda and tps68470-ledb).

Signed-off-by: Kate Hsuan <hpa@redhat.com>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
Patchset: cameras
---
 drivers/leds/Kconfig         |  12 +++
 drivers/leds/Makefile        |   1 +
 drivers/leds/leds-tps68470.c | 185 +++++++++++++++++++++++++++++++++++
 3 files changed, 198 insertions(+)
 create mode 100644 drivers/leds/leds-tps68470.c

diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 6e3dce7e35a4..5b6ba103867c 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -1002,6 +1002,18 @@ config LEDS_TPS6105X
 	  It is a single boost converter primarily for white LEDs and
 	  audio amplifiers.
 
+config LEDS_TPS68470
+	tristate "LED support for TI TPS68470"
+	depends on LEDS_CLASS
+	depends on INTEL_SKL_INT3472
+	help
+	  This driver supports TPS68470 PMIC with LED chip.
+	  It provides two LED controllers, with the ability to drive 2
+	  indicator LEDs and 2 flash LEDs.
+
+	  To compile this driver as a module, choose M and it will be
+	  called leds-tps68470
+
 config LEDS_IP30
 	tristate "LED support for SGI Octane machines"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 9a0333ec1a86..4e1ca8fc9b41 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -93,6 +93,7 @@ obj-$(CONFIG_LEDS_TCA6507)		+= leds-tca6507.o
 obj-$(CONFIG_LEDS_TI_LMU_COMMON)	+= leds-ti-lmu-common.o
 obj-$(CONFIG_LEDS_TLC591XX)		+= leds-tlc591xx.o
 obj-$(CONFIG_LEDS_TPS6105X)		+= leds-tps6105x.o
+obj-$(CONFIG_LEDS_TPS68470)		+= leds-tps68470.o
 obj-$(CONFIG_LEDS_TURRIS_OMNIA)		+= leds-turris-omnia.o
 obj-$(CONFIG_LEDS_UPBOARD)		+= leds-upboard.o
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
diff --git a/drivers/leds/leds-tps68470.c b/drivers/leds/leds-tps68470.c
new file mode 100644
index 000000000000..35aeb5db89c8
--- /dev/null
+++ b/drivers/leds/leds-tps68470.c
@@ -0,0 +1,185 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * LED driver for TPS68470 PMIC
+ *
+ * Copyright (C) 2023 Red Hat
+ *
+ * Authors:
+ *	Kate Hsuan <hpa@redhat.com>
+ */
+
+#include <linux/leds.h>
+#include <linux/mfd/tps68470.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/regmap.h>
+
+
+#define lcdev_to_led(led_cdev) \
+	container_of(led_cdev, struct tps68470_led, lcdev)
+
+#define led_to_tps68470(led, index) \
+	container_of(led, struct tps68470_device, leds[index])
+
+enum tps68470_led_ids {
+	TPS68470_ILED_A,
+	TPS68470_ILED_B,
+	TPS68470_NUM_LEDS
+};
+
+static const char *tps68470_led_names[] = {
+	[TPS68470_ILED_A] = "tps68470-iled_a",
+	[TPS68470_ILED_B] = "tps68470-iled_b",
+};
+
+struct tps68470_led {
+	unsigned int led_id;
+	struct led_classdev lcdev;
+};
+
+struct tps68470_device {
+	struct device *dev;
+	struct regmap *regmap;
+	struct tps68470_led leds[TPS68470_NUM_LEDS];
+};
+
+enum ctrlb_current {
+	CTRLB_2MA	= 0,
+	CTRLB_4MA	= 1,
+	CTRLB_8MA	= 2,
+	CTRLB_16MA	= 3,
+};
+
+static int tps68470_brightness_set(struct led_classdev *led_cdev, enum led_brightness brightness)
+{
+	struct tps68470_led *led = lcdev_to_led(led_cdev);
+	struct tps68470_device *tps68470 = led_to_tps68470(led, led->led_id);
+	struct regmap *regmap = tps68470->regmap;
+
+	switch (led->led_id) {
+	case TPS68470_ILED_A:
+		return regmap_update_bits(regmap, TPS68470_REG_ILEDCTL, TPS68470_ILEDCTL_ENA,
+					  brightness ? TPS68470_ILEDCTL_ENA : 0);
+	case TPS68470_ILED_B:
+		return regmap_update_bits(regmap, TPS68470_REG_ILEDCTL, TPS68470_ILEDCTL_ENB,
+					  brightness ? TPS68470_ILEDCTL_ENB : 0);
+	}
+	return -EINVAL;
+}
+
+static enum led_brightness tps68470_brightness_get(struct led_classdev *led_cdev)
+{
+	struct tps68470_led *led = lcdev_to_led(led_cdev);
+	struct tps68470_device *tps68470 = led_to_tps68470(led, led->led_id);
+	struct regmap *regmap = tps68470->regmap;
+	int ret = 0;
+	int value = 0;
+
+	ret =  regmap_read(regmap, TPS68470_REG_ILEDCTL, &value);
+	if (ret)
+		return dev_err_probe(led_cdev->dev, -EINVAL, "failed on reading register\n");
+
+	switch (led->led_id) {
+	case TPS68470_ILED_A:
+		value = value & TPS68470_ILEDCTL_ENA;
+		break;
+	case TPS68470_ILED_B:
+		value = value & TPS68470_ILEDCTL_ENB;
+		break;
+	}
+
+	return value ? LED_ON : LED_OFF;
+}
+
+
+static int tps68470_ledb_current_init(struct platform_device *pdev,
+				      struct tps68470_device *tps68470)
+{
+	int ret = 0;
+	unsigned int curr;
+
+	/* configure LEDB current if the properties can be got */
+	if (!device_property_read_u32(&pdev->dev, "ti,ledb-current", &curr)) {
+		if (curr > CTRLB_16MA) {
+			dev_err(&pdev->dev,
+				"Invalid LEDB current value: %d\n",
+				curr);
+			return -EINVAL;
+		}
+		ret = regmap_update_bits(tps68470->regmap, TPS68470_REG_ILEDCTL,
+					 TPS68470_ILEDCTL_CTRLB, curr);
+	}
+	return ret;
+}
+
+static int tps68470_leds_probe(struct platform_device *pdev)
+{
+	int i = 0;
+	int ret = 0;
+	struct tps68470_device *tps68470;
+	struct tps68470_led *led;
+	struct led_classdev *lcdev;
+
+	tps68470 = devm_kzalloc(&pdev->dev, sizeof(struct tps68470_device),
+				GFP_KERNEL);
+	if (!tps68470)
+		return -ENOMEM;
+
+	tps68470->dev = &pdev->dev;
+	tps68470->regmap = dev_get_drvdata(pdev->dev.parent);
+
+	for (i = 0; i < TPS68470_NUM_LEDS; i++) {
+		led = &tps68470->leds[i];
+		lcdev = &led->lcdev;
+
+		led->led_id = i;
+
+		lcdev->name = devm_kasprintf(tps68470->dev, GFP_KERNEL, "%s::%s",
+					     tps68470_led_names[i], LED_FUNCTION_INDICATOR);
+		if (!lcdev->name)
+			return -ENOMEM;
+
+		lcdev->max_brightness = 1;
+		lcdev->brightness = 0;
+		lcdev->brightness_set_blocking = tps68470_brightness_set;
+		lcdev->brightness_get = tps68470_brightness_get;
+		lcdev->dev = &pdev->dev;
+
+		ret = devm_led_classdev_register(tps68470->dev, lcdev);
+		if (ret) {
+			dev_err_probe(tps68470->dev, ret,
+				      "error registering led\n");
+			goto err_exit;
+		}
+
+		if (i == TPS68470_ILED_B) {
+			ret = tps68470_ledb_current_init(pdev, tps68470);
+			if (ret)
+				goto err_exit;
+		}
+	}
+
+err_exit:
+	if (ret) {
+		for (i = 0; i < TPS68470_NUM_LEDS; i++) {
+			if (tps68470->leds[i].lcdev.name)
+				devm_led_classdev_unregister(&pdev->dev,
+							     &tps68470->leds[i].lcdev);
+		}
+	}
+
+	return ret;
+}
+static struct platform_driver tps68470_led_driver = {
+	.driver = {
+		   .name = "tps68470-led",
+	},
+	.probe = tps68470_leds_probe,
+};
+
+module_platform_driver(tps68470_led_driver);
+
+MODULE_ALIAS("platform:tps68470-led");
+MODULE_DESCRIPTION("LED driver for TPS68470 PMIC");
+MODULE_LICENSE("GPL v2");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: mojyack <mojyack@gmail.com>
Date: Tue, 26 Mar 2024 05:55:44 +0900
Subject: media: i2c: dw9719: fix probe error on surface go 2

On surface go 2, sometimes probing dw9719 fails with "dw9719: probe of i2c-INT347A:00-VCM failed with error -121".
The -121(-EREMOTEIO) is came from drivers/i2c/busses/i2c-designware-common.c:575, and indicates the initialize occurs too early.
So just add some delay.
There is no exact reason for this 10000us, but 100us failed.

Patchset: cameras
---
 drivers/media/i2c/dw9719.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/media/i2c/dw9719.c b/drivers/media/i2c/dw9719.c
index 032fbcb981f2..e03a1d8cdcb4 100644
--- a/drivers/media/i2c/dw9719.c
+++ b/drivers/media/i2c/dw9719.c
@@ -87,6 +87,9 @@ static int dw9719_power_up(struct dw9719_device *dw9719, bool detect)
 	if (ret)
 		return ret;
 
+	/* Wait for device to be acknowledged */
+	fsleep(10000);
+
 	/* Jiggle SCL pin to wake up device */
 	cci_write(dw9719->regmap, DW9719_CONTROL, DW9719_SHUTDOWN, &ret);
 	fsleep(100);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sachi King <nakato@nakato.io>
Date: Sat, 29 May 2021 17:47:38 +1000
Subject: ACPI: Add quirk for Surface Laptop 4 AMD missing irq 7 override

This patch is the work of Thomas Gleixner <tglx@linutronix.de> and is
copied from:
https://lore.kernel.org/lkml/87lf8ddjqx.ffs@nanos.tec.linutronix.de/

This patch adds a quirk to the ACPI setup to patch in the the irq 7 pin
setup that is missing in the laptops ACPI table.

This patch was used for validation of the issue, and is not a proper
fix, but is probably a better temporary hack than continuing to probe
the Legacy PIC and run with the PIC in an unknown state.

Patchset: amd-gpio
---
 arch/x86/kernel/acpi/boot.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c
index 9fa321a95eb3..8914a922be2b 100644
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@ -22,6 +22,7 @@
 #include <linux/efi-bgrt.h>
 #include <linux/serial_core.h>
 #include <linux/pgtable.h>
+#include <linux/dmi.h>
 
 #include <xen/xen.h>
 
@@ -1171,6 +1172,17 @@ static void __init mp_config_acpi_legacy_irqs(void)
 	}
 }
 
+static const struct dmi_system_id surface_quirk[] __initconst = {
+	{
+		.ident = "Microsoft Surface Laptop 4 (AMD)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "Surface_Laptop_4_1952:1953")
+		},
+	},
+	{}
+};
+
 /*
  * Parse IOAPIC related entries in MADT
  * returns 0 on success, < 0 on error
@@ -1227,6 +1239,11 @@ static int __init acpi_parse_madt_ioapic_entries(void)
 		acpi_sci_ioapic_setup(acpi_gbl_FADT.sci_interrupt, 0, 0,
 				      acpi_gbl_FADT.sci_interrupt);
 
+	if (dmi_check_system(surface_quirk)) {
+		pr_warn("Surface hack: Override irq 7\n");
+		mp_override_legacy_irq(7, 3, 3, 7);
+	}
+
 	/* Fill in identity legacy mappings where no override */
 	mp_config_acpi_legacy_irqs();
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maximilian Luz <luzmaximilian@gmail.com>
Date: Thu, 3 Jun 2021 14:04:26 +0200
Subject: ACPI: Add AMD 13" Surface Laptop 4 model to irq 7 override quirk

The 13" version of the Surface Laptop 4 has the same problem as the 15"
version, but uses a different SKU. Add that SKU to the quirk as well.

Patchset: amd-gpio
---
 arch/x86/kernel/acpi/boot.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c
index 8914a922be2b..c43d0a553867 100644
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@ -1174,12 +1174,19 @@ static void __init mp_config_acpi_legacy_irqs(void)
 
 static const struct dmi_system_id surface_quirk[] __initconst = {
 	{
-		.ident = "Microsoft Surface Laptop 4 (AMD)",
+		.ident = "Microsoft Surface Laptop 4 (AMD 15\")",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_MATCH(DMI_PRODUCT_SKU, "Surface_Laptop_4_1952:1953")
 		},
 	},
+	{
+		.ident = "Microsoft Surface Laptop 4 (AMD 13\")",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "Surface_Laptop_4_1958:1959")
+		},
+	},
 	{}
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Bart Groeneveld | GPX Solutions B.V" <bart@gpxbv.nl>
Date: Mon, 5 Dec 2022 16:08:46 +0100
Subject: acpi: allow usage of acpi_tad on HW-reduced platforms

The specification [1] allows so-called HW-reduced platforms,
which do not implement everything, especially the wakeup related stuff.

In that case, it is still usable as a RTC. This is helpful for [2]
and [3], which is about a device with no other working RTC,
but it does have an HW-reduced TAD, which can be used as a RTC instead.

[1]: https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#time-and-alarm-device
[2]: https://bugzilla.kernel.org/show_bug.cgi?id=212313
[3]: https://github.com/linux-surface/linux-surface/issues/415

Signed-off-by: Bart Groeneveld | GPX Solutions B.V. <bart@gpxbv.nl>
Patchset: rtc
---
 drivers/acpi/acpi_tad.c | 36 ++++++++++++++++++++++++------------
 1 file changed, 24 insertions(+), 12 deletions(-)

diff --git a/drivers/acpi/acpi_tad.c b/drivers/acpi/acpi_tad.c
index 33418dd6768a..f94bbdc1de06 100644
--- a/drivers/acpi/acpi_tad.c
+++ b/drivers/acpi/acpi_tad.c
@@ -433,6 +433,14 @@ static ssize_t caps_show(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR_RO(caps);
 
+static struct attribute *acpi_tad_attrs[] = {
+	&dev_attr_caps.attr,
+	NULL,
+};
+static const struct attribute_group acpi_tad_attr_group = {
+	.attrs	= acpi_tad_attrs,
+};
+
 static ssize_t ac_alarm_store(struct device *dev, struct device_attribute *attr,
 			      const char *buf, size_t count)
 {
@@ -481,15 +489,14 @@ static ssize_t ac_status_show(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR_RW(ac_status);
 
-static struct attribute *acpi_tad_attrs[] = {
-	&dev_attr_caps.attr,
+static struct attribute *acpi_tad_ac_attrs[] = {
 	&dev_attr_ac_alarm.attr,
 	&dev_attr_ac_policy.attr,
 	&dev_attr_ac_status.attr,
 	NULL,
 };
-static const struct attribute_group acpi_tad_attr_group = {
-	.attrs	= acpi_tad_attrs,
+static const struct attribute_group acpi_tad_ac_attr_group = {
+	.attrs	= acpi_tad_ac_attrs,
 };
 
 static ssize_t dc_alarm_store(struct device *dev, struct device_attribute *attr,
@@ -568,13 +575,18 @@ static void acpi_tad_remove(struct platform_device *pdev)
 	if (dd->capabilities & ACPI_TAD_RT)
 		sysfs_remove_group(&dev->kobj, &acpi_tad_time_attr_group);
 
+	if (dd->capabilities & ACPI_TAD_AC_WAKE)
+		sysfs_remove_group(&dev->kobj, &acpi_tad_ac_attr_group);
+
 	if (dd->capabilities & ACPI_TAD_DC_WAKE)
 		sysfs_remove_group(&dev->kobj, &acpi_tad_dc_attr_group);
 
 	sysfs_remove_group(&dev->kobj, &acpi_tad_attr_group);
 
-	acpi_tad_disable_timer(dev, ACPI_TAD_AC_TIMER);
-	acpi_tad_clear_status(dev, ACPI_TAD_AC_TIMER);
+	if (dd->capabilities & ACPI_TAD_AC_WAKE) {
+		acpi_tad_disable_timer(dev, ACPI_TAD_AC_TIMER);
+		acpi_tad_clear_status(dev, ACPI_TAD_AC_TIMER);
+	}
 	if (dd->capabilities & ACPI_TAD_DC_WAKE) {
 		acpi_tad_disable_timer(dev, ACPI_TAD_DC_TIMER);
 		acpi_tad_clear_status(dev, ACPI_TAD_DC_TIMER);
@@ -616,12 +628,6 @@ static int acpi_tad_probe(struct platform_device *pdev)
 		goto remove_handler;
 	}
 
-	if (!acpi_has_method(handle, "_PRW")) {
-		dev_info(dev, "Missing _PRW\n");
-		ret = -ENODEV;
-		goto remove_handler;
-	}
-
 	dd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);
 	if (!dd) {
 		ret = -ENOMEM;
@@ -652,6 +658,12 @@ static int acpi_tad_probe(struct platform_device *pdev)
 	if (ret)
 		goto fail;
 
+	if (caps & ACPI_TAD_AC_WAKE) {
+		ret = sysfs_create_group(&dev->kobj, &acpi_tad_ac_attr_group);
+		if (ret)
+			goto fail;
+	}
+
 	if (caps & ACPI_TAD_DC_WAKE) {
 		ret = sysfs_create_group(&dev->kobj, &acpi_tad_dc_attr_group);
 		if (ret)
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 9 Sep 2024 21:24:16 +0800
Subject: ASoC: qcom: q6asm-dai: Change some default periods

---
 sound/soc/qcom/qdsp6/q6asm-dai.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/sound/soc/qcom/qdsp6/q6asm-dai.c b/sound/soc/qcom/qdsp6/q6asm-dai.c
index a400c9a31fea..cddef7120a9a 100644
--- a/sound/soc/qcom/qdsp6/q6asm-dai.c
+++ b/sound/soc/qcom/qdsp6/q6asm-dai.c
@@ -25,8 +25,8 @@
 
 #define PLAYBACK_MIN_NUM_PERIODS    2
 #define PLAYBACK_MAX_NUM_PERIODS   8
-#define PLAYBACK_MAX_PERIOD_SIZE    65536
-#define PLAYBACK_MIN_PERIOD_SIZE    128
+#define PLAYBACK_MAX_PERIOD_SIZE    7168
+#define PLAYBACK_MIN_PERIOD_SIZE    8
 #define CAPTURE_MIN_NUM_PERIODS     2
 #define CAPTURE_MAX_NUM_PERIODS     8
 #define CAPTURE_MAX_PERIOD_SIZE     4096
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:16:22 +0800
Subject: arm64: dts: qcom: sm8250: add uart16

---
 arch/arm64/boot/dts/qcom/sm8250.dtsi | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/sm8250.dtsi b/arch/arm64/boot/dts/qcom/sm8250.dtsi
index b30aea8b0540..cff2c5761a23 100644
--- a/arch/arm64/boot/dts/qcom/sm8250.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250.dtsi
@@ -1154,6 +1154,23 @@ spi16: spi@888000 {
 				status = "disabled";
 			};
 
+			uart16: serial@888000 {
+				compatible = "qcom,geni-uart";
+				reg = <0 0x00888000 0 0x4000>;
+				clock-names = "se";
+				clocks = <&gcc GCC_QUPV3_WRAP2_S2_CLK>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&qup_uart16_default>;
+				interrupts = <GIC_SPI 584 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&rpmhpd RPMHPD_CX>;
+				operating-points-v2 = <&qup_opp_table>;
+				interconnects = <&qup_virt MASTER_QUP_CORE_2 0 &qup_virt SLAVE_QUP_CORE_2 0>,
+						<&gem_noc MASTER_AMPSS_M0 0 &config_noc SLAVE_QUP_2 0>;
+				interconnect-names = "qup-core",
+						     "qup-config";
+				status = "disabled";
+			};
+
 			i2c17: i2c@88c000 {
 				compatible = "qcom,geni-i2c";
 				reg = <0 0x0088c000 0 0x4000>;
@@ -5739,6 +5756,11 @@ qup_uart12_default: qup-uart12-default-state {
 				function = "qup12";
 			};
 
+			qup_uart16_default: qup-uart16-default-state {
+				pins = "gpio50", "gpio51";
+				function = "qup16";
+			};
+
 			qup_uart17_default: qup-uart17-default-state {
 				pins = "gpio52", "gpio53", "gpio54", "gpio55";
 				function = "qup17";
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 30 Sep 2024 14:43:45 +0700
Subject: drm: panel: Add DDIC CH13726A panel

---
 drivers/gpu/drm/panel/Kconfig               |  11 +
 drivers/gpu/drm/panel/Makefile              |   1 +
 drivers/gpu/drm/panel/panel-ddic-ch13726a.c | 325 ++++++++++++++++++++
 3 files changed, 337 insertions(+)
 create mode 100644 drivers/gpu/drm/panel/panel-ddic-ch13726a.c

diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 09b9f7ff9340..2256da530802 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -105,6 +105,17 @@ config DRM_PANEL_BOE_TV101WUM_LL2
 	  Say Y here if you want to support for BOE TV101WUM-LL2
 	  WUXGA PANEL DSI Video Mode panel
 
+config DRM_PANEL_DDIC_CH13726A
+	tristate "DDIC CH13726A-based DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	select DRM_DISPLAY_DP_HELPER
+	select DRM_DISPLAY_HELPER
+	help
+	  Say Y here if you want to enable support for DDIC CH13726A-based
+	  display panels.
+
 config DRM_PANEL_EBBG_FT8719
 	tristate "EBBG FT8719 panel driver"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 957555b49996..fb205fbe81a8 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_DRM_PANEL_BOE_TD4320) += panel-boe-td4320.o
 obj-$(CONFIG_DRM_PANEL_BOE_TH101MB31UIG002_28A) += panel-boe-th101mb31ig002-28a.o
 obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_LL2) += panel-boe-tv101wum-ll2.o
 obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
+obj-$(CONFIG_DRM_PANEL_DDIC_CH13726A) += panel-ddic-ch13726a.o
 obj-$(CONFIG_DRM_PANEL_DSI_CM) += panel-dsi-cm.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
diff --git a/drivers/gpu/drm/panel/panel-ddic-ch13726a.c b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
new file mode 100644
index 000000000000..3d4c0d36077d
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
@@ -0,0 +1,325 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * DDIC CH13726A MIPI-DSI panel driver
+ * Copyright (c) 2024, Teguh Sobirin <teguh@sobir.in>.
+ */
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/display/drm_dsc.h>
+#include <drm/display/drm_dsc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct ch13726a_panel {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct drm_dsc_config dsc;
+	struct regulator_bulk_data supplies[4];
+	struct gpio_desc *reset_gpio;
+	enum drm_panel_orientation orientation;
+	bool prepared;
+};
+
+static inline struct ch13726a_panel *to_ch13726a_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct ch13726a_panel, panel);
+}
+
+static void ch13726a_reset(struct ch13726a_panel *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+}
+
+static int ch13726a_on(struct ch13726a_panel *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int ch13726a_disable(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	msleep(100);
+
+	return 0;
+}
+
+static int ch13726a_prepare(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ch13726a_reset(ctx);
+
+	ret = ch13726a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	msleep(28);
+
+	ctx->prepared = true;
+
+	return 0;
+}
+
+static int ch13726a_unprepare(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+
+	if (!ctx->prepared)
+		return 0;
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ch13726a_mode = {
+	.clock = (960 + 28 + 4 + 36) * (1280 + 16 + 4 + 8) * 60 / 1000,
+	.hdisplay = 960,
+	.hsync_start = 960 + 28,
+	.hsync_end = 960 + 28 + 4,
+	.htotal = 960 + 28 + 4 + 36,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 4,
+	.vtotal = 1280 + 16 + 4 + 8,
+	.width_mm = 65,
+	.height_mm = 75,
+};
+
+static int ch13726a_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ch13726a_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static enum drm_panel_orientation ch13726a_get_orientation(struct drm_panel *panel)
+{
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
+
+	return ctx->orientation;
+}
+
+static const struct drm_panel_funcs ch13726a_panel_funcs = {
+	.prepare = ch13726a_prepare,
+	.unprepare = ch13726a_unprepare,
+	.disable = ch13726a_disable,
+	.get_modes = ch13726a_get_modes,
+	.get_orientation = ch13726a_get_orientation,
+};
+
+static int ch13726a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops ch13726a_bl_ops = {
+	.update_status = ch13726a_bl_update_status,
+};
+
+static struct backlight_device *
+ch13726a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &ch13726a_bl_ops, &props);
+}
+
+static int ch13726a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ch13726a_panel *ctx;
+	int rotation;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd1v2";
+	ctx->supplies[1].supply = "vddio";
+	ctx->supplies[2].supply = "vdd";
+	ctx->supplies[3].supply = "avdd";
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ret = of_property_read_u32(dev->of_node, "rotation", &rotation);
+	if (ret == -EINVAL) {
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_UNKNOWN;
+	}
+
+	if (rotation == 0)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_NORMAL;
+	else if (rotation == 90)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_RIGHT_UP;
+	else if (rotation == 180)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_BOTTOM_UP;
+	else if (rotation == 270)
+		ctx->orientation = DRM_MODE_PANEL_ORIENTATION_LEFT_UP;
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &ch13726a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = ch13726a_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ch13726a_remove(struct mipi_dsi_device *dsi)
+{
+	struct ch13726a_panel *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ch13726a_of_match[] = {
+	{ .compatible = "ddic,ch13726a" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ch13726a_of_match);
+
+static struct mipi_dsi_driver ch13726a_driver = {
+	.probe = ch13726a_probe,
+	.remove = ch13726a_remove,
+	.driver = {
+		.name = "panel-ch13726a-amoled",
+		.of_match_table = ch13726a_of_match,
+	},
+};
+module_mipi_dsi_driver(ch13726a_driver);
+
+MODULE_DESCRIPTION("DRM driver for CH13726A DSI panels");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:19:59 +0800
Subject: Input: driver for AYN Odin2 Gamepad

---
 drivers/input/joystick/Kconfig  |   4 +
 drivers/input/joystick/Makefile |   1 +
 drivers/input/joystick/odin2.c  | 259 ++++++++++++++++++++++++++++++++
 3 files changed, 264 insertions(+)
 create mode 100644 drivers/input/joystick/odin2.c

diff --git a/drivers/input/joystick/Kconfig b/drivers/input/joystick/Kconfig
index 7755e5b454d2..031b7428068a 100644
--- a/drivers/input/joystick/Kconfig
+++ b/drivers/input/joystick/Kconfig
@@ -344,6 +344,10 @@ config JOYSTICK_MAPLE
 	  To compile this as a module choose M here: the module will be called
 	  maplecontrol.
 
+config JOYSTICK_ODIN2
+	tristate "AYN Odin2 gamepad"
+	depends on SERIAL_DEV_BUS
+
 config JOYSTICK_PSXPAD_SPI
 	tristate "PlayStation 1/2 joypads via SPI interface"
 	depends on SPI
diff --git a/drivers/input/joystick/Makefile b/drivers/input/joystick/Makefile
index 9976f596a920..ba7d72514c8b 100644
--- a/drivers/input/joystick/Makefile
+++ b/drivers/input/joystick/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_JOYSTICK_JOYDUMP)		+= joydump.o
 obj-$(CONFIG_JOYSTICK_MAGELLAN)		+= magellan.o
 obj-$(CONFIG_JOYSTICK_MAPLE)		+= maplecontrol.o
 obj-$(CONFIG_JOYSTICK_N64)		+= n64joy.o
+obj-$(CONFIG_JOYSTICK_ODIN2)		+= odin2.o
 obj-$(CONFIG_JOYSTICK_PSXPAD_SPI)	+= psxpad-spi.o
 obj-$(CONFIG_JOYSTICK_PXRC)		+= pxrc.o
 obj-$(CONFIG_JOYSTICK_QWIIC)		+= qwiic-joystick.o
diff --git a/drivers/input/joystick/odin2.c b/drivers/input/joystick/odin2.c
new file mode 100644
index 000000000000..eeddcf5df569
--- /dev/null
+++ b/drivers/input/joystick/odin2.c
@@ -0,0 +1,259 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Ayn Odin 2 Gamepad
+ *
+ * Copyright (C) 2024 Molly Sophia <mollysophia379@gmail.com>
+ * Copyright (C) 2024 BigfootACA <bigfoot@classfun.cn>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/gpio/consumer.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/serdev.h>
+#include <linux/slab.h>
+#include <uapi/linux/sched/types.h>
+
+#define MAX_DATA_LEN 64
+
+#define gamepad_serdev_write_seq(serdev, seq...)                              \
+	do {                                                                  \
+		static const u8 d[] = { seq };                                \
+		struct device *dev = &serdev->dev;                            \
+		int ret;                                                      \
+		ret = serdev_device_write_buf(serdev, d, ARRAY_SIZE(d));      \
+		if (ret < 0 || ret < ARRAY_SIZE(d)) {                         \
+			dev_warn_ratelimited(dev, "Unable to write data: %d", \
+					     ret);                            \
+			return;                                               \
+		}                                                             \
+	} while (0)
+
+static const unsigned int keymap[] = {
+	BTN_DPAD_UP, BTN_DPAD_DOWN, BTN_DPAD_LEFT, BTN_DPAD_RIGHT,
+	BTN_NORTH,   BTN_WEST,	    BTN_EAST,	   BTN_SOUTH,
+	BTN_TL,	     BTN_TR,	    BTN_SELECT,	   BTN_START,
+	BTN_THUMBL,  BTN_THUMBR,    BTN_MODE,	   BTN_BACK
+};
+
+struct gamepad_data {
+	u8 header[4];
+	u8 frame_number;
+	u8 command;
+	u16 data_len;
+	u8 data[MAX_DATA_LEN];
+};
+
+struct gamepad_device {
+	struct device *dev;
+	struct gpio_desc *en_gpio;
+	struct input_dev *dev_input;
+};
+
+static u8 gamepad_data_checksum(const u8 *data, size_t count)
+{
+	const u8 *ptr = data;
+	u8 ret = data[4];
+
+	for (int i = 5; i < count - 1; i++)
+		ret ^= ptr[i];
+
+	return ret;
+}
+
+static void gamepad_send_init_sequence(struct serdev_device *serdev)
+{
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x0, 0x1, 0x2,
+				 0x0, 0x7, 0x1, 0x5);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x1, 0x1, 0x1,
+				 0x0, 0x6, 0x7);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x2, 0x1, 0x1, 0x0, 0x2, 0x0);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xa5, 0xd3, 0x5a, 0x3d, 0x3, 0x01,
+				 0x0a, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x28,
+				 0x00, 0x00, 0x00, 0x07, 0x23);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x4, 0x1, 0x1,
+				 0x0, 0x6, 0x2);
+	msleep(100);
+	gamepad_serdev_write_seq(serdev, 0xA5, 0xD3, 0x5A, 0x3D, 0x5, 0x1, 0x1,
+				 0x0, 0x2, 0x7);
+	msleep(100);
+}
+
+static void gamepad_input_handler(struct gamepad_device *dev,
+				  struct gamepad_data *data)
+{
+	static unsigned long prev_states;
+	unsigned long keys = data->data[0] | (data->data[1] << 8);
+	unsigned long current_states = keys, changes;
+	int i;
+	struct input_dev *indev;
+
+	indev = dev->dev_input;
+	if (!indev)
+		return;
+
+	bitmap_xor(&changes, &current_states, &prev_states, ARRAY_SIZE(keymap));
+
+	for_each_set_bit(i, &changes, ARRAY_SIZE(keymap)) {
+		input_report_key(indev, keymap[i], (current_states & BIT(i)));
+	}
+
+	input_report_abs(indev, ABS_Z, (int16_t)(2 *
+			 (0x3AA - (int16_t)(data->data[2] | (data->data[3] << 8)))));
+	input_report_abs(indev, ABS_RZ, (int16_t)(2 *
+			 (0x3AA - (int16_t)(data->data[4] | (data->data[5] << 8)))));
+	input_report_abs(indev, ABS_X,
+			 -(int16_t)(data->data[6] | (data->data[7] << 8)));
+	input_report_abs(indev, ABS_Y,
+			 -(int16_t)(data->data[8] | (data->data[9] << 8)));
+	input_report_abs(indev, ABS_RX,
+			 -(int16_t)(data->data[10] | (data->data[11] << 8)));
+	input_report_abs(indev, ABS_RY,
+			 -(int16_t)(data->data[12] | (data->data[13] << 8)));
+
+	input_sync(indev);
+	prev_states = keys;
+}
+
+static void gamepad_data_handler(struct serdev_device *serdev,
+				 struct gamepad_data *data)
+{
+	struct gamepad_device *dev = serdev_device_get_drvdata(serdev);
+
+	switch (data->command) {
+	case 0x2:
+		gamepad_input_handler(dev, data);
+		break;
+	default:
+		break;
+	}
+}
+
+static size_t gamepad_mcu_uart_rx_bytes(struct serdev_device *serdev,
+					const u8 *data, size_t count)
+{
+	struct device *dev = &serdev->dev;
+	struct gamepad_data recv_data_buffer;
+	u8 checksum;
+
+	if (!data || count < 7) {
+		dev_warn_ratelimited(dev, "invalid packet");
+		return count;
+	}
+
+	checksum = gamepad_data_checksum(data, count);
+	if (checksum != *(data + count - 1)) {
+		dev_warn_ratelimited(dev, "packet checksum failed");
+		return count;
+	}
+
+	memcpy(recv_data_buffer.header, data, 4);
+	recv_data_buffer.frame_number = *(data + 4);
+	recv_data_buffer.command = *(data + 5);
+	recv_data_buffer.data_len = *(data + 6) | (*(data + 7) << 8);
+
+	if (recv_data_buffer.data_len) {
+		memset(&recv_data_buffer.data[0], 0,
+		       sizeof(recv_data_buffer.data));
+		memcpy(&recv_data_buffer.data[0], data + 8,
+		       recv_data_buffer.data_len);
+	}
+
+	gamepad_data_handler(serdev, &recv_data_buffer);
+	return count;
+}
+
+static const struct serdev_device_ops gamepad_mcu_uart_client_ops = {
+	.receive_buf = gamepad_mcu_uart_rx_bytes,
+};
+
+static int gamepad_mcu_uart_probe(struct serdev_device *serdev)
+{
+	struct device *dev = &serdev->dev;
+	struct gamepad_device *gamepad_dev;
+	int ret;
+
+	gamepad_dev = devm_kzalloc(dev, sizeof(*gamepad_dev), GFP_KERNEL);
+	if (!gamepad_dev)
+		return dev_err_probe(dev, -ENOMEM, "could not allocate memory for device data\n");
+
+	gamepad_dev->en_gpio =
+		devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(gamepad_dev->en_gpio)) {
+		ret = PTR_ERR(gamepad_dev->en_gpio);
+		return dev_err_probe(dev, ret, "Unable to get enable gpio\n");
+	}
+
+	ret = devm_serdev_device_open(dev, serdev);
+	if (ret)
+		return dev_err_probe(dev, ret, "Unable to open UART device\n");
+	gamepad_dev->dev = dev;
+
+	serdev_device_set_drvdata(serdev, gamepad_dev);
+
+	ret = serdev_device_set_baudrate(serdev, 115200);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to set up host baud rate\n");
+
+	serdev_device_set_flow_control(serdev, false);
+
+	gamepad_dev->dev_input = devm_input_allocate_device(dev);
+	if (!gamepad_dev->dev_input)
+		return dev_err_probe(dev, -ENOMEM, "Not enough memory for input device\n");
+
+	gamepad_dev->dev_input->name = "Ayn Odin2 Gamepad";
+	gamepad_dev->dev_input->phys = "odin2-gamepad/input0";
+	__set_bit(EV_ABS, gamepad_dev->dev_input->evbit);
+
+	for (int i = 0; i < ARRAY_SIZE(keymap); i++)
+		input_set_capability(gamepad_dev->dev_input, EV_KEY, keymap[i]);
+
+	input_set_capability(gamepad_dev->dev_input, EV_KEY, BTN_JOYSTICK);
+
+	for (int i = ABS_X; i <= ABS_RZ; i++)
+		input_set_abs_params(gamepad_dev->dev_input, i, -0x580, 0x580,
+				     0, 0);
+
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT2X, 0, 1830, 0, 30);
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT2Y, 0, 1830, 0, 30);
+
+	ret = input_register_device(gamepad_dev->dev_input);
+	if (ret)
+		return dev_err_probe(dev, ret, "Could not register input device\n");
+
+	serdev_device_set_client_ops(serdev, &gamepad_mcu_uart_client_ops);
+
+	gamepad_send_init_sequence(serdev);
+
+	return 0;
+}
+
+static const struct of_device_id gamepad_mcu_uart_of_match[] = {
+	{ .compatible = "ayn,odin2-gamepad" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, gamepad_mcu_uart_of_match);
+
+static struct serdev_device_driver gamepad_mcu_uart_driver = {
+	.driver = {
+		.name = "odin2-gamepad",
+		.of_match_table = gamepad_mcu_uart_of_match,
+	},
+	.probe = gamepad_mcu_uart_probe,
+};
+
+module_serdev_device_driver(gamepad_mcu_uart_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Gamepad driver for Ayn Odin2");
+MODULE_AUTHOR("Molly Sophia <mollysophia379@gmail.com>");
+MODULE_AUTHOR("BigfootACA <bigfoot@classfun.cn>");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:25:55 +0800
Subject: arm64: dts: qcom: pm8150b: Add a charger

---
 arch/arm64/boot/dts/qcom/pm8150b.dtsi | 32 +++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/pm8150b.dtsi b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
index 3f7b0b6a1d10..d0cfe6361954 100644
--- a/arch/arm64/boot/dts/qcom/pm8150b.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
@@ -107,6 +107,26 @@ pm8150b_temp: temp-alarm@2400 {
 			#thermal-sensor-cells = <0>;
 		};
 
+		pm8150b_charger: charger@1000 {
+			compatible = "qcom,pm8150b-charger";
+			reg = <0x1000>;
+
+			interrupts = <0x2 0x13 0x4 IRQ_TYPE_EDGE_BOTH>,
+				     <0x2 0x12 0x2 IRQ_TYPE_EDGE_BOTH>,
+				     <0x2 0x16 0x1 IRQ_TYPE_EDGE_RISING>,
+				     <0x2 0x13 0x7 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "usbin-plugin",
+					  "bat-ov",
+					  "wdog-bark",
+					  "usbin-icl-change";
+
+			io-channels = <&pm8150b_adc 7>,
+				      <&pm8150b_adc 8>;
+			io-channel-names = "usb_in_i_uv", "usb_in_v_div_16";
+
+			status = "disabled";
+		};
+
 		pm8150b_adc: adc@3100 {
 			compatible = "qcom,spmi-adc5";
 			reg = <0x3100>;
@@ -133,6 +153,18 @@ channel@6 {
 				label = "die_temp";
 			};
 
+			channel@7 {
+				reg = <ADC5_USB_IN_I>;
+				qcom,pre-scaling = <1 1>;
+				label = "usb_in_i_uv";
+			};
+
+			channel@8 {
+				reg = <ADC5_USB_IN_V_16>;
+				qcom,pre-scaling = <1 16>;
+				label = "usb_in_v_div_16";
+			};
+
 			channel@9 {
 				reg = <ADC5_CHG_TEMP>;
 				qcom,pre-scaling = <1 1>;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sun, 8 Sep 2024 06:26:32 +0800
Subject: arm64: dts: qcom: pm8150b: Add a FG

---
 arch/arm64/boot/dts/qcom/pm8150b.dtsi | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/pm8150b.dtsi b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
index d0cfe6361954..42ef21238f18 100644
--- a/arch/arm64/boot/dts/qcom/pm8150b.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm8150b.dtsi
@@ -127,6 +127,14 @@ pm8150b_charger: charger@1000 {
 			status = "disabled";
 		};
 
+		pm8150b_fg: fuel-gauge@4000 {
+			compatible = "qcom,pm8150b-fg";
+			reg = <0x4000>;
+			interrupts = <0x2 0x40 0x3 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "soc-delta";
+			status = "disabled";
+		};
+
 		pm8150b_adc: adc@3100 {
 			compatible = "qcom,spmi-adc5";
 			reg = <0x3100>;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 30 Sep 2024 17:27:42 +0700
Subject: arm64: dts: qcom: sm8250-retroid-rpmini: Add SM8250 Retroid Pocket
 variants

Combination of two commits to fix git apply quirks
---
 arch/arm64/boot/dts/qcom/Makefile             |    2 +
 .../dts/qcom/sm8250-retroidpocket-common.dtsi | 1308 +++++++++++++++++
 .../dts/qcom/sm8250-retroidpocket-rp5.dts     |   44 +
 .../dts/qcom/sm8250-retroidpocket-rpmini.dts  |   42 +
 4 files changed, 1396 insertions(+)
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
 create mode 100644 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts

diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index 4bfa926b6a08..9b02917c4aac 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -275,6 +275,8 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-sony-xperia-kumano-bahamut.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-sony-xperia-kumano-griffin.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-mtp.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-retroidpocket-rp5.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-retroidpocket-rpmini.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx203.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-sony-xperia-edo-pdx206.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8250-xiaomi-elish-boe.dtb
diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
new file mode 100644
index 000000000000..7b20553ccdb5
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
@@ -0,0 +1,1308 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2024, Retroid Pocket.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/usb/pd.h>
+#include "sm8250.dtsi"
+#include "pm8150.dtsi"
+#include "pm8150b.dtsi"
+#include "pm8150l.dtsi"
+
+/ {
+	qcom,msm-id = <356 0x20001>;
+	qcom,board-id = <0x01001F 0x01>;
+
+	aliases {
+		serial0 = &uart12;
+		serial1 = &uart6;
+		serial2 = &uart16;
+		sdhc2 = &sdhc_2;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+
+		charge-full-design-microamp-hours = <3850000>;
+		voltage-min-design-microvolt = <3600000>;
+		voltage-max-design-microvolt = <4400000>;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	fan: pwm-fan {
+		compatible = "pwm-fan";
+		cooling-levels = <0 32 64 128 255>;
+		#cooling-cells = <2>;
+		fan-supply = <&vreg_fan_pwr>;
+		pwms = <&pm8150l_lpg 3 100000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fan_pwm_active>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		key-vol-up {
+			label = "Volume Up";
+			linux,code = <KEY_VOLUMEUP>;
+			gpios = <&pm8150_gpios 6 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	thermal-zones {
+		conn-thermal {
+			thermal-sensors = <&pm8150b_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <125000>;
+					hysteresis = <1000>;
+					type = "critical";
+				};
+			};
+		};
+
+		pm8150l-pcb-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		skin-msm-thermal {
+			thermal-sensors = <&pm8150l_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		wifi-thermal {
+			thermal-sensors = <&pm8150_adc_tm 1>;
+
+			trips {
+				active-config0 {
+					temperature = <52000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+
+		xo-thermal {
+			thermal-sensors = <&pm8150_adc_tm 0>;
+
+			trips {
+				active-config0 {
+					temperature = <50000>;
+					hysteresis = <4000>;
+					type = "passive";
+				};
+			};
+		};
+	};
+
+	vbat: vbat-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VBAT";
+		vin-supply = <&vreg_l11c_3p3>;
+		regulator-min-microvolt = <4200000>;
+		regulator-max-microvolt = <4200000>;
+		regulator-always-on;
+	};
+
+	vdc_3v3: vdc-3v3-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VDC_3V3";
+		vin-supply = <&vreg_l11c_3p3>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+	};
+
+	vdc_5v: vdc-5v-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VDC_5V";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+		vin-supply = <&vreg_l11c_3p3>;
+	};
+
+	vdda_panel: vdda-panel-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vdda_panel";
+
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+
+		gpio = <&tlmm 4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+		regulator-always-on;
+	};
+
+	vreg_s4a_1p8: vreg-s4a-1p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_s4a_1p8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vph_pwr>;
+	};
+
+	vreg_fan_pwr: vreg-fan-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_fan_pwr";
+
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&tlmm 7 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vreg_mcu_3v3: vreg-mcu-3v3-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vreg_mcu_3v3";
+
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 3 GPIO_ACTIVE_HIGH>;
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+	};
+
+	qca6390-pmu {
+		compatible = "qcom,qca6390-pmu";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&bt_en_state>, <&wlan_en_state>;
+
+		vddaon-supply = <&vreg_s6a_0p95>;
+		vddrfa1p3-supply = <&vreg_s8c_1p3>;
+		vddrfa1p9-supply = <&vreg_s5a_1p9>;
+		vddpcie1p3-supply = <&vreg_s8c_1p3>;
+		vddpcie1p9-supply = <&vreg_s5a_1p9>;
+		vddio-supply = <&vreg_s4a_1p8>;
+
+		wlan-enable-gpios = <&tlmm 20 GPIO_ACTIVE_HIGH>;
+		bt-enable-gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+
+		regulators {
+			vreg_pmu_rfa_cmn: ldo0 {
+				regulator-name = "vreg_pmu_rfa_cmn";
+			};
+
+			vreg_pmu_aon_0p59: ldo1 {
+				regulator-name = "vreg_pmu_aon_0p59";
+			};
+
+			vreg_pmu_wlcx_0p8: ldo2 {
+				regulator-name = "vreg_pmu_wlcx_0p8";
+			};
+
+			vreg_pmu_wlmx_0p85: ldo3 {
+				regulator-name = "vreg_pmu_wlmx_0p85";
+			};
+
+			vreg_pmu_btcmx_0p85: ldo4 {
+				regulator-name = "vreg_pmu_btcmx_0p85";
+			};
+
+			vreg_pmu_rfa_0p8: ldo5 {
+				regulator-name = "vreg_pmu_rfa_0p8";
+			};
+
+			vreg_pmu_rfa_1p2: ldo6 {
+				regulator-name = "vreg_pmu_rfa_1p2";
+			};
+
+			vreg_pmu_rfa_1p7: ldo7 {
+				regulator-name = "vreg_pmu_rfa_1p7";
+			};
+
+			vreg_pmu_pcie_0p9: ldo8 {
+				regulator-name = "vreg_pmu_pcie_0p9";
+			};
+
+			vreg_pmu_pcie_1p8: ldo9 {
+				regulator-name = "vreg_pmu_pcie_1p8";
+			};
+		};
+	};
+
+	wcd938x: audio-codec {
+		compatible = "qcom,wcd9385-codec";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wcd_default>;
+
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_LOW>;
+
+		vdd-buck-supply = <&vreg_s4a_1p8>;
+		vdd-rxtx-supply = <&vreg_s4a_1p8>;
+		vdd-io-supply = <&vreg_s4a_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		#sound-dai-cells = <1>;
+	};
+
+	reserved-memory {
+		cont_splash_mem: cont-splash@9c000000 {
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			no-map;
+		};
+	};
+};
+
+&adsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/adsp.mbn";
+};
+
+&apps_rsc {
+	regulators-0 {
+		compatible = "qcom,pm8150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-s9-supply = <&vph_pwr>;
+		vdd-s10-supply = <&vph_pwr>;
+		vdd-l2-l10-supply = <&vreg_bob>;
+		vdd-l3-l4-l5-l18-supply = <&vreg_s6a_0p95>;
+		vdd-l6-l9-supply = <&vreg_s8c_1p3>;
+		vdd-l7-l12-l14-l15-supply = <&vreg_s5a_1p9>;
+		vdd-l13-l16-l17-supply = <&vreg_bob>;
+
+		vreg_l2a_3p1: ldo2 {
+			regulator-name = "vreg_l2a_3p1";
+			regulator-min-microvolt = <3072000>;
+			regulator-max-microvolt = <3072000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3a_0p9: ldo3 {
+			regulator-name = "vreg_l3a_0p9";
+			regulator-min-microvolt = <928000>;
+			regulator-max-microvolt = <932000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5a_0p88: ldo5 {
+			regulator-name = "vreg_l5a_0p88";
+			regulator-min-microvolt = <880000>;
+			regulator-max-microvolt = <880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6a_1p2: ldo6 {
+			regulator-name = "vreg_l6a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7a_1p7: ldo7 {
+			regulator-name = "vreg_l7a_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9a_1p2: ldo9 {
+			regulator-name = "vreg_l9a_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-name = "vreg_l10a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-name = "vreg_l12a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_ts_3p0: ldo13 {
+			regulator-name = "vreg_l13a_ts_3p0";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-name = "vreg_l14a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1880000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l15a_1p8: ldo15 {
+			regulator-name = "vreg_l15a_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-name = "vreg_l16a_2p7";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-name = "vreg_l17a_3p0";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3008000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l18a_0p92: ldo18 {
+			regulator-name = "vreg_l18a_0p92";
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <912000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s5a_1p9: smps5 {
+			regulator-name = "vreg_s5a_1p9";
+			regulator-min-microvolt = <1904000>;
+			regulator-max-microvolt = <2000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_s6a_0p95: smps6 {
+			regulator-name = "vreg_s6a_0p95";
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <1128000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	regulators-1 {
+		compatible = "qcom,pm8150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vdd-s1-supply = <&vph_pwr>;
+		vdd-s2-supply = <&vph_pwr>;
+		vdd-s3-supply = <&vph_pwr>;
+		vdd-s4-supply = <&vph_pwr>;
+		vdd-s5-supply = <&vph_pwr>;
+		vdd-s6-supply = <&vph_pwr>;
+		vdd-s7-supply = <&vph_pwr>;
+		vdd-s8-supply = <&vph_pwr>;
+		vdd-l1-l8-supply = <&vreg_s4a_1p8>;
+		vdd-l2-l3-supply = <&vreg_s8c_1p3>;
+		vdd-l4-l5-l6-supply = <&vreg_bob>;
+		vdd-l7-l11-supply = <&vreg_bob>;
+		vdd-l9-l10-supply = <&vreg_bob>;
+		vdd-bob-supply = <&vph_pwr>;
+
+		vreg_bob: bob {
+			regulator-name = "vreg_bob";
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <4000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-name = "vreg_l1c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l2c_1p2: ldo2 {
+			regulator-name = "vreg_l2c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l3c_1p2: ldo3 {
+			regulator-name = "vreg_l3c_1p2";
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l4c_1p7: ldo4 {
+			regulator-name = "vreg_l4c_1p7";
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-name = "vreg_l5c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l6c_2p96: ldo6 {
+			regulator-name = "vreg_l6c_2p96";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_cam_vcm0_2p85: ldo7 {
+			regulator-name = "vreg_l7c_cam_vcm0_2p85";
+			regulator-min-microvolt = <2856000>;
+			regulator-max-microvolt = <3104000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-name = "vreg_l8c_1p8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l9c_2p96: ldo9 {
+			regulator-name = "vreg_l9c_2p96";
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p0: ldo10 {
+			regulator-name = "vreg_l10c_3p0";
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-name = "vreg_l11c_3p3";
+			regulator-min-microvolt = <3296000>;
+			regulator-max-microvolt = <3296000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+			regulator-always-on;
+		};
+
+		vreg_s8c_1p3: smps8 {
+			regulator-name = "vreg_s8c_1p3";
+			regulator-min-microvolt = <1352000>;
+			regulator-max-microvolt = <1352000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+};
+
+&cdsp {
+	status = "okay";
+	firmware-name = "qcom/sm8250/cdsp.mbn";
+};
+
+&gmu {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+
+	zap-shader {
+		memory-region = <&gpu_mem>;
+		firmware-name = "qcom/sm8250/a650_zap.mbn";
+	};
+};
+
+&i2c13 {
+	status = "okay";
+	clock-frequency = <400000>;
+
+	touchscreen@38 {
+		compatible = "focaltech,ft5452";
+		reg = <0x38>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <39 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+		vcc-supply = <&vreg_l13a_ts_3p0>;
+		iovcc-supply = <&vreg_l1c_1p8>;
+
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+		pinctrl-names = "default", "sleep";
+
+		touchscreen-size-x = <960>;
+		touchscreen-size-y = <1280>;
+	};
+};
+
+&i2c15 {
+	status = "okay";
+
+	typec-mux@1c {
+		compatible = "onnn,nb7vpq904m";
+		reg = <0x1c>;
+
+	 	enable-gpios = <&tlmm 9 GPIO_ACTIVE_LOW>;
+
+		vcc-supply = <&vreg_s4a_1p8>;
+
+		retimer-switch;
+		orientation-switch;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				redriver_usb_con_ss: endpoint {
+					remote-endpoint = <&pm8150b_typec_mux_in>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				redriver_phy_con_ss: endpoint {
+					remote-endpoint = <&usb_1_qmpphy_out>;
+					data-lanes = <0 1 2 3>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				redriver_usb_con_sbu: endpoint {
+					remote-endpoint = <&pm8150b_typec_sbu_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dp {
+	status = "okay";
+};
+
+&mdss_dp_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&usb_1_qmpphy_dp_in>;
+};
+
+&mdss_dsi0 {
+	status = "okay";
+	vdda-supply = <&vreg_l9a_1p2>;
+
+	panel@0 {
+		reg = <0>;
+		reset-gpios = <&tlmm 75 GPIO_ACTIVE_HIGH>;
+
+		vdd1v2-supply = <&vreg_l3c_1p2>;
+		vddio-supply = <&vreg_l14a_1p8>;
+		vdd-supply = <&vreg_l11c_3p3>;
+		avdd-supply = <&vdda_panel>;
+
+		pinctrl-0 = <&sde_dsi_active &sde_te_active>;
+		pinctrl-1 = <&sde_dsi_sleep &sde_te_sleep>;
+		pinctrl-names = "default", "sleep";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				panel_in_0: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in_0>;
+};
+
+&mdss_dsi0_phy {
+	status = "okay";
+	vdds-supply = <&vreg_l5a_0p88>;
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&pcie0_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pcieport0 {
+	wifi@0 {
+		compatible = "pci17cb,1101";
+		reg = <0x10000 0x0 0x0 0x0 0x0>;
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddwlcx-supply = <&vreg_pmu_wlcx_0p8>;
+		vddwlmx-supply = <&vreg_pmu_wlmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+		vddpcie0p9-supply = <&vreg_pmu_pcie_0p9>;
+		vddpcie1p8-supply = <&vreg_pmu_pcie_1p8>;
+	};
+};
+
+&pcie1 {
+	status = "okay";
+};
+
+&pcie1_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pcie2 {
+	status = "okay";
+};
+
+&pcie2_phy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&pm8150_adc {
+	channel@4c {
+		reg = <ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "xo_therm";
+	};
+
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "wifi_therm";
+	};
+};
+
+&pm8150_adc_tm {
+	status = "okay";
+
+	xo-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150_adc ADC5_XO_THERM_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	wifi-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_adc {
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "conn_therm";
+	};
+};
+
+&pm8150b_adc_tm {
+	status = "okay";
+
+	conn-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150b_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150b_charger {
+	monitored-battery = <&battery>;
+	status = "okay";
+};
+
+&pm8150b_fg {
+	status = "okay";
+	monitored-battery = <&battery>;
+	power-supplies = <&pm8150b_charger>;
+};
+
+&pm8150b_typec {
+	status = "okay";
+
+	vdd-pdphy-supply = <&vreg_l2a_3p1>;
+
+	connector {
+		compatible = "usb-c-connector";
+
+		power-role = "dual";
+		data-role = "dual";
+		try-power-role = "sink";
+		self-powered;
+
+		source-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		sink-pdos = <PDO_FIXED(5000, 3000,
+					 PDO_FIXED_DUAL_ROLE |
+					 PDO_FIXED_USB_COMM |
+					 PDO_FIXED_DATA_SWAP)>;
+
+		op-sink-microwatt = <15000000>;
+
+		altmodes {
+			displayport {
+				svid = /bits/ 16 <0xff01>;
+				vdo = <0x00001c46>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm8150b_hs_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				pm8150b_typec_mux_in: endpoint {
+					remote-endpoint = <&redriver_usb_con_ss>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+
+				pm8150b_typec_sbu_out: endpoint {
+					remote-endpoint = <&redriver_usb_con_sbu>;
+				};
+			};
+		};
+	};
+};
+
+&pm8150b_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&pm8150l_adc {
+	channel@4e {
+		reg = <ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "skin_msm_therm";
+	};
+
+	channel@4f {
+		reg = <ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time = <200>;
+		label = "pm8150l_therm";
+	};
+};
+
+&pm8150l_adc_tm {
+	status = "okay";
+
+	skin-msm-therm@0 {
+		reg = <0>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM2_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+
+	pm8150l-therm@1 {
+		reg = <1>;
+		io-channels = <&pm8150l_adc ADC5_AMUX_THM3_100K_PU>;
+		qcom,ratiometric;
+		qcom,hw-settle-time-us = <200>;
+	};
+};
+
+&pm8150l_gpios {
+	fan_pwm_active: fan-pwm-active-state {
+		pins = "gpio6";
+		function = "func1";
+        bias-disable;
+        power-source = <0>;
+        output-low;
+        qcom,drive-strength = <3>;
+        drive-push-pull;
+	};
+};
+
+&pm8150l_lpg {
+	status = "okay";
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+	status = "okay";
+
+	linux,code = <KEY_VOLUMEDOWN>;
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&qupv3_id_2 {
+	status = "okay";
+};
+
+&qup_uart16_default {
+	drive-strength = <2>;
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&sdhc_2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdc2_default_state &sdc2_card_det_n>;
+	vmmc-supply = <&vreg_l9c_2p96>;
+	vqmmc-supply = <&vreg_l6c_2p96>;
+	cd-gpios = <&tlmm 77 GPIO_ACTIVE_LOW>;
+	bus-width = <4>;
+	no-sdio;
+	no-mmc;
+};
+
+&sound {
+	compatible = "qcom,sm8250-sndcard";
+	model = "RetroidPocket";
+	audio-routing =
+		"SpkrLeft IN", "WSA_SPK1 OUT",
+		"SpkrRight IN", "WSA_SPK2 OUT",
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",	
+		"MM_DL1",  "MultiMedia1 Playback",
+		"MM_DL2",  "MultiMedia2 Playback",
+		"MultiMedia3 Capture", "MM_UL3";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai  MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+		codec {
+			sound-dai = <&wcd938x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wsa-dai-link {
+		link-name = "WSA Playback";
+		cpu {
+			sound-dai = <&q6afedai WSA_CODEC_DMA_RX_0>;
+		};
+
+		codec {
+			sound-dai = <&left_spkr>, <&right_spkr>, <&swr0 0>, <&wsamacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd938x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+};
+
+&swr0 {
+	status = "okay";
+
+	left_spkr: speaker@0,1 {
+		compatible = "sdw10217201000";
+		reg = <0 1>;
+		powerdown-gpios = <&tlmm 129 GPIO_ACTIVE_LOW>;
+		#thermal-sensor-cells = <0>;
+		sound-name-prefix = "SpkrLeft";
+		#sound-dai-cells = <0>;
+	};
+
+	right_spkr: speaker@0,2 {
+		compatible = "sdw10217201000";
+		reg = <0 2>;
+		powerdown-gpios = <&tlmm 127 GPIO_ACTIVE_LOW>;
+		#thermal-sensor-cells = <0>;
+		sound-name-prefix = "SpkrRight";
+		#sound-dai-cells = <0>;
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	wcd_rx: wcd9385-rx@0,4 {
+		compatible = "sdw20217010d00";
+		reg = <0 4>;
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+
+	wcd_tx: wcd9385-tx@0,3 {
+		compatible = "sdw20217010d00";
+		reg = <0 3>;
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&tlmm {
+	bt_en_state: bt-default-state {
+		pins = "gpio21";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+
+	mcu_en_default: mcu-en-default-state {
+		pins = "gpio111";
+		function = "gpio";
+		bias-pull-down;
+	};
+
+	sdc2_default_state: sdc2-default-state {
+		clk-pins {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		cmd-pins {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		data-pins {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+	};
+
+	sdc2_card_det_n: sd-card-det-n-state {
+		pins = "gpio77";
+		function = "gpio";
+		bias-pull-up;
+	};
+
+	sde_dsi_active: sde-dsi-active-state {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	sde_dsi_sleep: sde-dsi-sleep-state {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_active: sde-te-active-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sde_te_sleep: sde-te-sleep-state {
+		pins = "gpio66";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_int_active: ts-int-active-state {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_int_suspend: ts-int-suspend-state {
+		pins = "gpio39";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_reset_active: ts-reset-active-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+
+	ts_reset_suspend: ts-reset-suspend-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	wcd_default: wcd-default-state {
+		reset-pins {
+			pins = "gpio32";
+			function = "gpio";
+			bias-disable;
+		};
+	};
+
+	wlan_en_state: wlan-default-state {
+		pins = "gpio20";
+		function = "gpio";
+		drive-strength = <16>;
+		output-low;
+		bias-pull-up;
+	};
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&uart6 {
+	status = "okay";
+
+	bluetooth {
+		compatible = "qcom,qca6390-bt";
+
+		vddrfacmn-supply = <&vreg_pmu_rfa_cmn>;
+		vddaon-supply = <&vreg_pmu_aon_0p59>;
+		vddbtcmx-supply = <&vreg_pmu_btcmx_0p85>;
+		vddrfa0p8-supply = <&vreg_pmu_rfa_0p8>;
+		vddrfa1p2-supply = <&vreg_pmu_rfa_1p2>;
+		vddrfa1p7-supply = <&vreg_pmu_rfa_1p7>;
+	};
+};
+
+&uart12 {
+	status = "okay";
+};
+
+&uart16 {
+	status = "okay";
+
+	gamepad {
+		compatible = "ayn,odin2-gamepad";
+		vdd-supply = <&vreg_mcu_3v3>;
+		enable-gpios = <&tlmm 111 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&mcu_en_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&ufs_mem_hc {
+	status = "okay";
+
+	vcc-supply = <&vreg_l17a_3p0>;
+	vcc-max-microamp = <800000>;
+	vccq-supply = <&vreg_l6a_1p2>;
+	vccq-max-microamp = <800000>;
+	vccq2-supply = <&vreg_s4a_1p8>;
+	vccq2-max-microamp = <800000>;
+};
+
+&ufs_mem_phy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l5a_0p88>;
+	vdda-pll-supply = <&vreg_l9a_1p2>;
+};
+
+&usb_1 {
+	status = "okay";
+};
+
+&usb_1_dwc3 {
+	dr_mode = "otg";
+	usb-role-switch;
+};
+
+&usb_1_dwc3_hs_out {
+	remote-endpoint = <&pm8150b_hs_in>;
+};
+
+&usb_1_hsphy {
+	status = "okay";
+
+	vdda-pll-supply = <&vreg_l5a_0p88>;
+	vdda33-supply = <&vreg_l2a_3p1>;
+	vdda18-supply = <&vreg_l12a_1p8>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+
+	vdda-phy-supply = <&vreg_l9a_1p2>;
+	vdda-pll-supply = <&vreg_l18a_0p92>;
+};
+
+&usb_1_qmpphy_dp_in {
+	remote-endpoint = <&mdss_dp_out>;
+};
+
+&usb_1_qmpphy_out {
+	remote-endpoint = <&redriver_phy_con_ss>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&wsamacro {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
new file mode 100644
index 000000000000..f9101248f184
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2024, Retroid Pocket.
+ */
+
+/dts-v1/;
+
+#include "sm8250-retroidpocket-common.dtsi"
+
+/ {
+	model = "Retroid Pocket 5";
+	compatible = "retroidpocket,rp5", "qcom,sm8250";
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer: framebuffer@9c000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			width = <1080>;
+			height = <1920>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+};
+
+&i2c13 {
+	touchscreen@38 {
+		touchscreen-size-x = <1080>;
+		touchscreen-size-y = <1920>;
+		touchscreen-inverted-x;
+		touchscreen-inverted-y;
+	};
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "ch13726a,rp5";
+		rotation = <270>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts
new file mode 100644
index 000000000000..63d0dda470f0
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * Copyright (c) 2024, Retroid Pocket.
+ */
+
+/dts-v1/;
+
+#include "sm8250-retroidpocket-common.dtsi"
+
+/ {
+	model = "Retroid Pocket Mini";
+	compatible = "retroidpocket,rpmini", "qcom,sm8250";
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer: framebuffer@9c000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9c000000 0x0 0x2300000>;
+			width = <960>;
+			height = <1280>;
+			stride = <(960 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+};
+
+&i2c13 {
+	touchscreen@38 {
+		touchscreen-size-x = <960>;
+		touchscreen-size-y = <1280>;
+	};
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "ch13726a,rpmini";
+		rotation = <90>;
+	};
+};
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Wed, 9 Oct 2024 15:57:19 +0800
Subject: drm: panel: Add compatible CH13726A panel

---
 drivers/gpu/drm/panel/panel-ddic-ch13726a.c | 27 ++++++++++++++++++---
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-ddic-ch13726a.c b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
index 3d4c0d36077d..0af26b65bca6 100644
--- a/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
+++ b/drivers/gpu/drm/panel/panel-ddic-ch13726a.c
@@ -25,6 +25,7 @@ struct ch13726a_panel {
 	struct drm_dsc_config dsc;
 	struct regulator_bulk_data supplies[4];
 	struct gpio_desc *reset_gpio;
+	const struct drm_display_mode *display_mode;
 	enum drm_panel_orientation orientation;
 	bool prepared;
 };
@@ -141,7 +142,7 @@ static int ch13726a_unprepare(struct drm_panel *panel)
 	return 0;
 }
 
-static const struct drm_display_mode ch13726a_mode = {
+static const struct drm_display_mode rpmini_display_mode = {
 	.clock = (960 + 28 + 4 + 36) * (1280 + 16 + 4 + 8) * 60 / 1000,
 	.hdisplay = 960,
 	.hsync_start = 960 + 28,
@@ -155,12 +156,27 @@ static const struct drm_display_mode ch13726a_mode = {
 	.height_mm = 75,
 };
 
+static const struct drm_display_mode rp5_display_mode = {
+	.clock = (1080 + 12 + 4 + 12) * (1920 + 12 + 12 + 4) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 12,
+	.hsync_end = 1080 + 12 + 4,
+	.htotal = 1080 + 12 + 4 + 12,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 12,
+	.vsync_end = 1920 + 12 + 12,
+	.vtotal = 1920 + 12 + 12 + 4,
+	.width_mm = 68,
+	.height_mm = 121,
+};
+
 static int ch13726a_get_modes(struct drm_panel *panel,
 					struct drm_connector *connector)
 {
+	struct ch13726a_panel *ctx = to_ch13726a_panel(panel);
 	struct drm_display_mode *mode;
 
-	mode = drm_mode_duplicate(connector->dev, &ch13726a_mode);
+	mode = drm_mode_duplicate(connector->dev, ctx->display_mode);
 	if (!mode)
 		return -ENOMEM;
 
@@ -235,6 +251,8 @@ static int ch13726a_probe(struct mipi_dsi_device *dsi)
 	if (!ctx)
 		return -ENOMEM;
 
+	ctx->display_mode = of_device_get_match_data(dev);
+
 	ctx->supplies[0].supply = "vdd1v2";
 	ctx->supplies[1].supply = "vddio";
 	ctx->supplies[2].supply = "vdd";
@@ -306,8 +324,9 @@ static void ch13726a_remove(struct mipi_dsi_device *dsi)
 }
 
 static const struct of_device_id ch13726a_of_match[] = {
-	{ .compatible = "ddic,ch13726a" },
-	{ }
+	{ .compatible = "ch13726a,rpmini", .data = &rpmini_display_mode },
+	{ .compatible = "ch13726a,rp5", .data = &rp5_display_mode },
+	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, ch13726a_of_match);
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sat, 12 Oct 2024 01:26:37 +0800
Subject: pwm: htr3212: Add HEROIC HTR3212 support

---
 drivers/pwm/Kconfig       |  10 ++
 drivers/pwm/Makefile      |   1 +
 drivers/pwm/pwm-htr3212.c | 308 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 319 insertions(+)
 create mode 100644 drivers/pwm/pwm-htr3212.c

diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index f00ce973dddf..7b8f1586a54e 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -273,6 +273,16 @@ config PWM_HIBVT
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-hibvt.
 
+config PWM_HTR3212
+	tristate "HEROIC HTR3212 PWM driver"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  Generic PWM framework driver for HEROIC HTR3212 LED controller.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-htr3212.
+
 config PWM_IMG
 	tristate "Imagination Technologies PWM driver"
 	depends on HAS_IOMEM
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index ff4f47e5fb7a..cd289c7b9c4a 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_PWM_EP93XX)	+= pwm-ep93xx.o
 obj-$(CONFIG_PWM_FSL_FTM)	+= pwm-fsl-ftm.o
 obj-$(CONFIG_PWM_GPIO)		+= pwm-gpio.o
 obj-$(CONFIG_PWM_HIBVT)		+= pwm-hibvt.o
+obj-$(CONFIG_PWM_HTR3212)	+= pwm-htr3212.o
 obj-$(CONFIG_PWM_IMG)		+= pwm-img.o
 obj-$(CONFIG_PWM_IMX1)		+= pwm-imx1.o
 obj-$(CONFIG_PWM_IMX27)		+= pwm-imx27.o
diff --git a/drivers/pwm/pwm-htr3212.c b/drivers/pwm/pwm-htr3212.c
new file mode 100644
index 000000000000..cef5a80477c0
--- /dev/null
+++ b/drivers/pwm/pwm-htr3212.c
@@ -0,0 +1,308 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for HEROIC HTR3212 12-channel 8-bit PWM LED controller
+ *
+ * Copyright (c) 2024 Teguh Sobirin <teguh@sobir.in>
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#define HTR3212_CHANNELS 12
+#define HTR3212_SHUTDOWN 0x00
+#define HTR3212_PWM_REGISTER_BASE 0x0d
+#define HTR3212_PWM_UPDATE 0x25
+#define HTR3212_LED_CONTROL_BASE 0x32
+#define HTR3212_GLOBAL_CONTROL 0x4a
+#define HTR3212_OUTPUT_FREQ 0x4b
+#define HTR3212_RESET 0x4f
+
+struct htr3212 {
+	struct device *pdev;
+	struct regmap *regmap;
+	struct mutex lock;
+	struct regulator *vdd;
+	struct gpio_desc *sdb;
+	uint8_t pwm_val[HTR3212_CHANNELS];
+	uint8_t led_ctl[HTR3212_CHANNELS];
+};
+
+static int htr3212_write_reg(struct htr3212 *priv, unsigned int reg,
+			    unsigned int val)
+{
+	int err;
+
+	dev_dbg(priv->pdev, "request regmap_write 0x%x 0x%x\n", reg, val);
+	
+	err = regmap_write(priv->regmap, reg, val);
+	if (err)
+		dev_err(
+			priv->pdev,
+			"regmap_write to register 0x%x failed: %pe\n", reg,
+			ERR_PTR(err));
+
+	return err;
+}
+
+static int htr3212_set_led_reg(struct htr3212 *priv, unsigned int channel,
+			     bool enabled, bool write)
+{
+
+	if (channel >= HTR3212_CHANNELS)
+		return -EINVAL;
+
+
+	dev_dbg(priv->pdev, "channel %u enabled %u\n", channel, enabled);
+
+	priv->led_ctl[channel] = enabled;
+
+	if (!write)
+		return 0;
+
+	return htr3212_write_reg(priv, HTR3212_LED_CONTROL_BASE + channel,
+				priv->led_ctl[channel]);
+}
+
+static int htr3212_set_pwm_reg(struct htr3212 *priv, unsigned int channel,
+			      uint8_t val, bool write)
+{
+	if (channel >= HTR3212_CHANNELS)
+		return -EINVAL;
+	priv->pwm_val[channel] = val;
+	dev_dbg(priv->pdev, "set value reg %u to %u\n", channel,
+		priv->pwm_val[channel]);
+
+	if (!write)
+		return 0;
+
+	return htr3212_write_reg(priv, HTR3212_PWM_REGISTER_BASE + channel,
+				priv->pwm_val[channel]);
+}
+
+static int htr3212_init(struct htr3212 *priv)
+{
+	int i, ret;
+
+	/* enable global control */
+	ret = htr3212_write_reg(priv, HTR3212_GLOBAL_CONTROL, 0x00);
+	if (ret != 0)
+		return ret;
+
+	/* set output frequency */
+	ret = htr3212_write_reg(priv, HTR3212_OUTPUT_FREQ, 0x01);
+	if (ret != 0)
+		return ret;
+
+	/* clear all registers */
+	ret = htr3212_write_reg(priv, HTR3212_RESET, 0x00);
+	if (ret != 0)
+		return ret;
+
+	/* set software enable register */
+	ret = htr3212_write_reg(priv, HTR3212_SHUTDOWN, 0x01);
+	if (ret != 0)
+		return ret;
+
+	/* rewrite pwm value register */
+	for (i = 0; i < HTR3212_CHANNELS; i++) {
+		ret = htr3212_write_reg(priv, HTR3212_PWM_REGISTER_BASE + i,
+				       priv->pwm_val[i]);
+		if (ret != 0)
+			return ret;
+	}
+
+	/* rewrite pwm enable register */
+	for (i = 0; i < HTR3212_CHANNELS; i++) {
+		ret = htr3212_write_reg(priv, HTR3212_LED_CONTROL_BASE + i,
+				       priv->led_ctl[i]);
+		if (ret != 0)
+			return ret;
+	}
+
+	/* apply changes */
+	ret = htr3212_write_reg(priv, HTR3212_PWM_UPDATE, 0x00);
+	if (ret != 0)
+		return ret;
+
+	return 0;
+}
+
+static int htr3212_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)
+{
+	struct htr3212 *priv = pwmchip_get_drvdata(chip);
+
+	if (pwm->hwpwm >= HTR3212_CHANNELS)
+		return -EINVAL;
+
+	dev_dbg(priv->pdev, "htr3212 request channel %u\n", pwm->hwpwm);
+	pwm->args.period = 1000000;
+	return 0;
+}
+
+static int htr3212_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	u64 val = 0;
+	struct htr3212 *priv = pwmchip_get_drvdata(chip);
+
+	if (pwm->hwpwm >= HTR3212_CHANNELS)
+		return -EINVAL;
+
+	if (state->polarity != PWM_POLARITY_NORMAL)
+		return -EINVAL;
+
+	if (state->period <= 0)
+		return -EINVAL;
+
+	val = mul_u64_u64_div_u64(state->duty_cycle, 0xff, state->period);
+	dev_dbg(priv->pdev, "duty_cycle %llu period %llu\n", 
+		state->duty_cycle, state->period);
+	dev_dbg(priv->pdev, "set channel %u value to %llu\n", 
+		pwm->hwpwm, val);
+	dev_dbg(priv->pdev, "set channel %u enabled to %u\n", 
+		pwm->hwpwm, state->enabled);
+
+	mutex_lock(&priv->lock);
+	htr3212_set_led_reg(priv, pwm->hwpwm, state->enabled, true);
+	htr3212_set_pwm_reg(priv, pwm->hwpwm, val, true);
+	htr3212_write_reg(priv, HTR3212_PWM_UPDATE, 0x00);
+	mutex_unlock(&priv->lock);
+
+	return 0;
+}
+
+static const struct pwm_ops htr3212_pwm_ops = {
+	.apply = htr3212_pwm_apply,
+	.request = htr3212_pwm_request,
+};
+
+static const struct regmap_config htr3212_regmap_i2c_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xff,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int htr3212_pwm_probe(struct i2c_client *client)
+{
+	struct pwm_chip *chip;
+	struct htr3212 *priv;
+	int ret, i;
+
+	chip = devm_pwmchip_alloc(&client->dev, HTR3212_CHANNELS, sizeof(*priv));
+	if (IS_ERR(chip))
+		return PTR_ERR(chip);
+	priv = pwmchip_get_drvdata(chip);
+	priv->pdev = &client->dev;
+
+	/* get shutdown pin */
+	priv->sdb = devm_gpiod_get(priv->pdev, "sdb", GPIOD_OUT_HIGH);
+	if (PTR_ERR(priv->sdb) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	/* get power vdd */
+	priv->vdd = devm_regulator_get(priv->pdev, "vdd");
+	if (IS_ERR(priv->vdd)) {
+		ret = PTR_ERR(priv->vdd);
+		dev_err(priv->pdev, "Unable to get vdd regulator: %d\n", ret);
+		return ret;
+	}
+
+	/* turn on power vdd */
+	ret = regulator_enable(priv->vdd);
+	if (ret < 0) {
+		dev_err(priv->pdev, "Unable to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	/* disable shutdown pin */
+	gpiod_set_value_cansleep(priv->sdb, 1);
+	usleep_range(10000, 11000);
+
+	/* initialize htr3212 (chip does not support read command) */
+	for (i = 0; i < HTR3212_CHANNELS; i++)
+		priv->pwm_val[i] = 0;
+	for (i = 0; i < HTR3212_CHANNELS; i++)
+		priv->led_ctl[i] = 0;
+
+	priv->regmap = devm_regmap_init_i2c(client, &htr3212_regmap_i2c_config);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(priv->pdev, "Failed to initialize register map: %d\n",
+			ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(client, chip);
+	mutex_init(&priv->lock);
+
+	chip->ops = &htr3212_pwm_ops;
+	ret = pwmchip_add(chip);
+	if (ret < 0)
+		return ret;
+
+	/* initialize registers */
+	ret = htr3212_init(priv);
+	if (ret != 0) {
+		dev_err(priv->pdev, "Failed to initialize htr3212: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void htr3212_pwm_remove(struct i2c_client *client)
+{
+	struct pwm_chip *chip = i2c_get_clientdata(client);
+	struct htr3212 *priv = pwmchip_get_drvdata(chip);
+
+	/* set software enable register */
+	htr3212_write_reg(priv, HTR3212_SHUTDOWN, 0x00);
+
+	/* apply changes */
+	htr3212_write_reg(priv, HTR3212_PWM_UPDATE, 0x00);
+
+	/* enable shutdown pin */
+	gpiod_set_value_cansleep(priv->sdb, 0);
+
+	/* turn off power vdd */
+	regulator_disable(priv->vdd);
+
+	pwmchip_remove(chip);
+}
+
+static const struct i2c_device_id htr3212_id[] = {
+	{ "htr3212", 0 },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, htr3212_id);
+
+static const struct of_device_id htr3212_dt_ids[] = {
+	{ .compatible = "heroic,htr3212-pwm", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, htr3212_dt_ids);
+
+static struct i2c_driver htr3212_i2c_driver = {
+	.driver = {
+		.name = "htr3212-pwm",
+		.of_match_table = of_match_ptr(htr3212_dt_ids),
+	},
+	.probe = htr3212_pwm_probe,
+	.remove = htr3212_pwm_remove,
+	.id_table = htr3212_id,
+};
+
+module_i2c_driver(htr3212_i2c_driver);
+
+MODULE_AUTHOR("Teguh Sobirin <teguh@sobir.in>");
+MODULE_DESCRIPTION("PWM driver for HEROIC HTR3212");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Sat, 12 Oct 2024 01:31:29 +0800
Subject: arm64: dts: qcom: Enable Retroid Pocket Joystick RGB LED

Also remove unused DSI panel pins
---
 .../dts/qcom/sm8250-retroidpocket-common.dtsi | 59 +++++++++----------
 1 file changed, 27 insertions(+), 32 deletions(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
index 7b20553ccdb5..e16b61d4c11a 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
@@ -569,6 +569,32 @@ zap-shader {
 	};
 };
 
+&i2c3 {
+	clock-frequency = <400000>;
+	status = "okay";
+
+	htr3212r: htr3212@3c {
+		compatible = "heroic,htr3212-pwm";
+		reg = <0x3c>;
+		vdd-supply = <&vreg_mcu_3v3>;
+		sdb-gpios = <&tlmm 6 GPIO_ACTIVE_HIGH>;
+		#pwm-cells = <1>;
+	};
+};
+
+&i2c5 {
+	clock-frequency = <400000>;
+	status = "okay";
+
+	htr3212l: htr3212@3c {
+		compatible = "heroic,htr3212-pwm";
+		reg = <0x3c>;
+		vdd-supply = <&vreg_mcu_3v3>;
+		sdb-gpios = <&tlmm 5 GPIO_ACTIVE_HIGH>;
+		#pwm-cells = <1>;
+	};
+};
+
 &i2c13 {
 	status = "okay";
 	clock-frequency = <400000>;
@@ -658,6 +684,7 @@ &mdss_dsi0 {
 
 	panel@0 {
 		reg = <0>;
+
 		reset-gpios = <&tlmm 75 GPIO_ACTIVE_HIGH>;
 
 		vdd1v2-supply = <&vreg_l3c_1p2>;
@@ -665,10 +692,6 @@ panel@0 {
 		vdd-supply = <&vreg_l11c_3p3>;
 		avdd-supply = <&vdda_panel>;
 
-		pinctrl-0 = <&sde_dsi_active &sde_te_active>;
-		pinctrl-1 = <&sde_dsi_sleep &sde_te_sleep>;
-		pinctrl-names = "default", "sleep";
-
 		ports {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -1137,34 +1160,6 @@ sdc2_card_det_n: sd-card-det-n-state {
 		bias-pull-up;
 	};
 
-	sde_dsi_active: sde-dsi-active-state {
-		pins = "gpio75";
-		function = "gpio";
-		drive-strength = <8>;
-		bias-disable;
-	};
-
-	sde_dsi_sleep: sde-dsi-sleep-state {
-		pins = "gpio75";
-		function = "gpio";
-		drive-strength = <2>;
-		bias-pull-down;
-	};
-
-	sde_te_active: sde-te-active-state {
-		pins = "gpio66";
-		function = "mdp_vsync";
-		drive-strength = <2>;
-		bias-pull-down;
-	};
-
-	sde_te_sleep: sde-te-sleep-state {
-		pins = "gpio66";
-		function = "mdp_vsync";
-		drive-strength = <2>;
-		bias-pull-down;
-	};
-
 	ts_int_active: ts-int-active-state {
 		pins = "gpio39";
 		function = "gpio";
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 14 Oct 2024 18:00:57 +0800
Subject: Input: Odin2 Gamepad ability to set input id values from devicetree

---
 drivers/input/joystick/odin2.c | 43 +++++++++++++++++++++++++---------
 1 file changed, 32 insertions(+), 11 deletions(-)

diff --git a/drivers/input/joystick/odin2.c b/drivers/input/joystick/odin2.c
index eeddcf5df569..5145e2423171 100644
--- a/drivers/input/joystick/odin2.c
+++ b/drivers/input/joystick/odin2.c
@@ -4,6 +4,7 @@
  *
  * Copyright (C) 2024 Molly Sophia <mollysophia379@gmail.com>
  * Copyright (C) 2024 BigfootACA <bigfoot@classfun.cn>
+ * Copyright (C) 2024 Teguh Sobirin <teguh@sobir.in>
  *
  */
 
@@ -19,18 +20,19 @@
 #include <linux/slab.h>
 #include <uapi/linux/sched/types.h>
 
+#define DRIVER_NAME "odin2-gamepad"
 #define MAX_DATA_LEN 64
 
-#define gamepad_serdev_write_seq(serdev, seq...)                              \
-	do {                                                                  \
+#define gamepad_serdev_write_seq(serdev, seq...)                      \
+	do {                                                              \
 		static const u8 d[] = { seq };                                \
 		struct device *dev = &serdev->dev;                            \
 		int ret;                                                      \
 		ret = serdev_device_write_buf(serdev, d, ARRAY_SIZE(d));      \
 		if (ret < 0 || ret < ARRAY_SIZE(d)) {                         \
-			dev_warn_ratelimited(dev, "Unable to write data: %d", \
-					     ret);                            \
-			return;                                               \
+			dev_warn_ratelimited(dev, "Unable to write data: %d",     \
+					     ret);                                        \
+			return;                                                   \
 		}                                                             \
 	} while (0)
 
@@ -180,6 +182,10 @@ static int gamepad_mcu_uart_probe(struct serdev_device *serdev)
 {
 	struct device *dev = &serdev->dev;
 	struct gamepad_device *gamepad_dev;
+	u32 gamepad_bus = 0;
+	u32 gamepad_vid = 0;
+	u32 gamepad_pid = 0;
+	u32 gamepad_rev = 0;
 	int ret;
 
 	gamepad_dev = devm_kzalloc(dev, sizeof(*gamepad_dev), GFP_KERNEL);
@@ -210,15 +216,28 @@ static int gamepad_mcu_uart_probe(struct serdev_device *serdev)
 	if (!gamepad_dev->dev_input)
 		return dev_err_probe(dev, -ENOMEM, "Not enough memory for input device\n");
 
-	gamepad_dev->dev_input->name = "Ayn Odin2 Gamepad";
-	gamepad_dev->dev_input->phys = "odin2-gamepad/input0";
-	__set_bit(EV_ABS, gamepad_dev->dev_input->evbit);
+	gamepad_dev->dev_input->phys = DRIVER_NAME"/input0";
+	
+	ret = device_property_read_string(dev, "gamepad-name", &gamepad_dev->dev_input->name);
+	if (ret) {
+		gamepad_dev->dev_input->name = "Ayn Odin2 Gamepad";
+	}
+
+	device_property_read_u32(dev, "gamepad-bus", &gamepad_bus);
+	device_property_read_u32(dev, "gamepad-vid", &gamepad_vid);
+	device_property_read_u32(dev, "gamepad-pid", &gamepad_pid);
+	device_property_read_u32(dev, "gamepad-rev", &gamepad_rev);
 
+	gamepad_dev->dev_input->id.bustype = (u16)gamepad_bus;
+	gamepad_dev->dev_input->id.vendor  = (u16)gamepad_vid;
+	gamepad_dev->dev_input->id.product = (u16)gamepad_pid;
+	gamepad_dev->dev_input->id.version = (u16)gamepad_rev;
+
+	__set_bit(EV_KEY, gamepad_dev->dev_input->evbit);
 	for (int i = 0; i < ARRAY_SIZE(keymap); i++)
 		input_set_capability(gamepad_dev->dev_input, EV_KEY, keymap[i]);
 
-	input_set_capability(gamepad_dev->dev_input, EV_KEY, BTN_JOYSTICK);
-
+	__set_bit(EV_ABS, gamepad_dev->dev_input->evbit);
 	for (int i = ABS_X; i <= ABS_RZ; i++)
 		input_set_abs_params(gamepad_dev->dev_input, i, -0x580, 0x580,
 				     0, 0);
@@ -245,7 +264,7 @@ MODULE_DEVICE_TABLE(of, gamepad_mcu_uart_of_match);
 
 static struct serdev_device_driver gamepad_mcu_uart_driver = {
 	.driver = {
-		.name = "odin2-gamepad",
+		.name = DRIVER_NAME,
 		.of_match_table = gamepad_mcu_uart_of_match,
 	},
 	.probe = gamepad_mcu_uart_probe,
@@ -257,3 +276,5 @@ MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Gamepad driver for Ayn Odin2");
 MODULE_AUTHOR("Molly Sophia <mollysophia379@gmail.com>");
 MODULE_AUTHOR("BigfootACA <bigfoot@classfun.cn>");
+MODULE_AUTHOR("Teguh Sobirin <teguh@sobir.in>");
+MODULE_ALIAS("platform:" DRIVER_NAME);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Mon, 14 Oct 2024 18:54:05 +0800
Subject: arm64: dts: qcom: Set Gamepad ID for Retroid Pocket

---
 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
index e16b61d4c11a..e0f49e8e75cd 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-common.dtsi
@@ -1233,6 +1233,13 @@ &uart16 {
 
 	gamepad {
 		compatible = "ayn,odin2-gamepad";
+
+		gamepad-name = "Retroid Pocket Controller";
+		gamepad-bus = <0x0003>;
+		gamepad-vid = <0x2020>;
+		gamepad-pid = <0x3001>;
+		gamepad-rev = <0x0001>;
+
 		vdd-supply = <&vreg_mcu_3v3>;
 		enable-gpios = <&tlmm 111 GPIO_ACTIVE_HIGH>;
 		pinctrl-0 = <&mcu_en_default>;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Teguh Sobirin <teguh@sobir.in>
Date: Thu, 10 Oct 2024 15:03:09 +0800
Subject: arm64: dts: qcom: Batocera specific changes

---
 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts    | 2 +-
 arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
index f9101248f184..2f1b60b218df 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rp5.dts
@@ -31,8 +31,8 @@ &i2c13 {
 	touchscreen@38 {
 		touchscreen-size-x = <1080>;
 		touchscreen-size-y = <1920>;
+		touchscreen-swapped-x-y;
 		touchscreen-inverted-x;
-		touchscreen-inverted-y;
 	};
 };
 
diff --git a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts
index 63d0dda470f0..f71065573acd 100644
--- a/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts
+++ b/arch/arm64/boot/dts/qcom/sm8250-retroidpocket-rpmini.dts
@@ -31,6 +31,8 @@ &i2c13 {
 	touchscreen@38 {
 		touchscreen-size-x = <960>;
 		touchscreen-size-y = <1280>;
+		touchscreen-swapped-x-y;
+		touchscreen-inverted-x;
 	};
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 2 Nov 2024 17:41:40 +0100
Subject: HID: Add quirk to ignore the touchscreen battery on 8BitDo SN30 Pro
 Plus

---
 drivers/hid/hid-input.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index f45f856a127f..e4eb0703a14d 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -343,6 +343,8 @@ static enum power_supply_property hidinput_battery_props[] = {
 #define HID_BATTERY_QUIRK_AVOID_QUERY	(1 << 3) /* do not query the battery */
 
 static const struct hid_device_id hid_battery_quirks[] = {
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_8BITDO_SN30_PRO_PLUS),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE,
 		USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO),
 	  HID_BATTERY_QUIRK_PERCENT | HID_BATTERY_QUIRK_FEATURE },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 19 Feb 2022 16:08:36 -0800
Subject: mfd: Add MFD core driver for Steam Deck

Add MFD core driver for Steam Deck. Doesn't really do much so far
besides instantiating a number of MFD cells that implement all the
interesting functionality.

(cherry picked from commit 5f534c2d6ebdefccb9c024eb0f013bc1c0c622d9)
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mfd/Kconfig     |  11 ++++
 drivers/mfd/Makefile    |   2 +
 drivers/mfd/steamdeck.c | 127 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+)
 create mode 100644 drivers/mfd/steamdeck.c

diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 425c5fba6cb1..b3d465206db6 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -2469,6 +2469,17 @@ config MFD_RSMU_SPI
 	  Additional drivers must be enabled in order to use the functionality
 	  of the device.
 
+config MFD_STEAMDECK
+	tristate "Valve Steam Deck"
+	select MFD_CORE
+	depends on ACPI
+	depends on X86_64 || COMPILE_TEST
+	help
+	  This driver registers various MFD cells that expose aspects
+	  of Steam Deck specific ACPI functionality.
+
+	  Say N here, unless you are running on Steam Deck hardware.
+
 config MFD_UPBOARD_FPGA
 	tristate "Support for the AAeon UP board FPGA"
 	depends on (X86 && ACPI)
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index f7bdedd5a66d..f694f5a60502 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -294,4 +294,6 @@ obj-$(CONFIG_MFD_QNAP_MCU)	+= qnap-mcu.o
 obj-$(CONFIG_MFD_RSMU_I2C)	+= rsmu_i2c.o rsmu_core.o
 obj-$(CONFIG_MFD_RSMU_SPI)	+= rsmu_spi.o rsmu_core.o
 
+obj-$(CONFIG_MFD_STEAMDECK)	+= steamdeck.o
+
 obj-$(CONFIG_MFD_UPBOARD_FPGA)	+= upboard-fpga.o
diff --git a/drivers/mfd/steamdeck.c b/drivers/mfd/steamdeck.c
new file mode 100644
index 000000000000..0e504b3c2796
--- /dev/null
+++ b/drivers/mfd/steamdeck.c
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD core driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/core.h>
+
+#define STEAMDECK_STA_OK			\
+	(ACPI_STA_DEVICE_ENABLED |		\
+	 ACPI_STA_DEVICE_PRESENT |		\
+	 ACPI_STA_DEVICE_FUNCTIONING)
+
+struct steamdeck {
+	struct acpi_device *adev;
+	struct device *dev;
+};
+
+#define STEAMDECK_ATTR_RO(_name, _method)				\
+	static ssize_t _name##_show(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		struct steamdeck *sd = dev_get_drvdata(dev);		\
+		unsigned long long val;					\
+									\
+		if (ACPI_FAILURE(acpi_evaluate_integer(			\
+					 sd->adev->handle,		\
+					 _method, NULL, &val)))		\
+			return -EIO;					\
+									\
+		return sysfs_emit(buf, "%llu\n", val);			\
+	}								\
+	static DEVICE_ATTR_RO(_name)
+
+STEAMDECK_ATTR_RO(firmware_version, "PDFW");
+STEAMDECK_ATTR_RO(board_id, "BOID");
+
+static struct attribute *steamdeck_attrs[] = {
+	&dev_attr_firmware_version.attr,
+	&dev_attr_board_id.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(steamdeck);
+
+static const struct mfd_cell steamdeck_cells[] = {
+	{ .name = "steamdeck-hwmon"  },
+	{ .name = "steamdeck-leds"   },
+	{ .name = "steamdeck-extcon" },
+};
+
+static void steamdeck_remove_sysfs_groups(void *data)
+{
+	struct steamdeck *sd = data;
+
+	sysfs_remove_groups(&sd->dev->kobj, steamdeck_groups);
+}
+
+static int steamdeck_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	unsigned long long sta;
+	struct steamdeck *sd;
+	acpi_status status;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+	sd->adev = ACPI_COMPANION(dev);
+	sd->dev = dev;
+	platform_set_drvdata(pdev, sd);
+
+	status = acpi_evaluate_integer(sd->adev->handle, "_STA",
+				       NULL, &sta);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Status check failed (0x%x)\n", status);
+		return -EINVAL;
+	}
+
+	if ((sta & STEAMDECK_STA_OK) != STEAMDECK_STA_OK) {
+		dev_err(dev, "Device is not ready\n");
+		return -EINVAL;
+	}
+
+	ret = sysfs_create_groups(&dev->kobj, steamdeck_groups);
+	if (ret) {
+		dev_err(dev, "Failed to create sysfs group\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_sysfs_groups,
+				       sd);
+	if (ret) {
+		dev_err(dev, "Failed to register devres action\n");
+		return ret;
+	}
+
+	return devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,
+				    steamdeck_cells, ARRAY_SIZE(steamdeck_cells),
+				    NULL, 0, NULL);
+}
+
+static const struct acpi_device_id steamdeck_device_ids[] = {
+	{ "VLV0100", 0 },
+	{ "", 0 },
+};
+MODULE_DEVICE_TABLE(acpi, steamdeck_device_ids);
+
+static struct platform_driver steamdeck_driver = {
+	.probe = steamdeck_probe,
+	.driver = {
+		.name = "steamdeck",
+		.acpi_match_table = steamdeck_device_ids,
+	},
+};
+module_platform_driver(steamdeck_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck EC MFD core driver");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 24 Sep 2023 15:02:33 -0700
Subject: mfd: steamdeck: Expose controller board power in sysfs

As of version 118 Deck's BIOS implements "SCBP" method that allows
gating power of the controller board (VBUS). Add a basic WO method to
our root MFD device to allow toggling that.

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit f97f32718acc10cbb51fef925842392e80904d74)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mfd/steamdeck.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/drivers/mfd/steamdeck.c b/drivers/mfd/steamdeck.c
index 0e504b3c2796..a60fa7db9141 100644
--- a/drivers/mfd/steamdeck.c
+++ b/drivers/mfd/steamdeck.c
@@ -41,9 +41,29 @@ struct steamdeck {
 STEAMDECK_ATTR_RO(firmware_version, "PDFW");
 STEAMDECK_ATTR_RO(board_id, "BOID");
 
+static ssize_t controller_board_power_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	struct steamdeck *sd = dev_get_drvdata(dev);
+	bool enabled;
+	ssize_t ret = kstrtobool(buf, &enabled);
+
+	if (ret)
+		return ret;
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "SCBP", enabled)))
+		return -EIO;
+
+	return count;
+}
+static DEVICE_ATTR_WO(controller_board_power);
+
 static struct attribute *steamdeck_attrs[] = {
 	&dev_attr_firmware_version.attr,
 	&dev_attr_board_id.attr,
+	&dev_attr_controller_board_power.attr,
 	NULL
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 12:58:05 -0800
Subject: leds: steamdeck: Add support for Steam Deck LED

(cherry picked from commit 85a86d19aa7022ff0555023d53aef78323a42d0c)
[cristian: fwd-ported to v6.8]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/leds/Kconfig          |  7 ++++
 drivers/leds/Makefile         |  1 +
 drivers/leds/leds-steamdeck.c | 74 +++++++++++++++++++++++++++++++++++
 3 files changed, 82 insertions(+)
 create mode 100644 drivers/leds/leds-steamdeck.c

diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 5b6ba103867c..477d460fb7ba 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -1032,6 +1032,13 @@ config LEDS_ACER_A500
 	  This option enables support for the Power Button LED of
 	  Acer Iconia Tab A500.
 
+config LEDS_STEAMDECK
+	tristate "LED support for Steam Deck"
+	depends on LEDS_CLASS && MFD_STEAMDECK
+	help
+	  This option enabled support for the status LED (next to the
+	  power button) on Steam Deck
+
 source "drivers/leds/blink/Kconfig"
 
 comment "Flash and Torch LED drivers"
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 4e1ca8fc9b41..318dce29d84b 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_LEDS_QNAP_MCU)		+= leds-qnap-mcu.o
 obj-$(CONFIG_LEDS_REGULATOR)		+= leds-regulator.o
 obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
 obj-$(CONFIG_LEDS_ST1202)		+= leds-st1202.o
+obj-$(CONFIG_LEDS_STEAMDECK)		+= leds-steamdeck.o
 obj-$(CONFIG_LEDS_SUN50I_A100)		+= leds-sun50i-a100.o
 obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
 obj-$(CONFIG_LEDS_SYSCON)		+= leds-syscon.o
diff --git a/drivers/leds/leds-steamdeck.c b/drivers/leds/leds-steamdeck.c
new file mode 100644
index 000000000000..686500b8de73
--- /dev/null
+++ b/drivers/leds/leds-steamdeck.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/*
+ * Steam Deck EC MFD LED cell driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ *
+ */
+
+#include <linux/acpi.h>
+#include <linux/leds.h>
+#include <linux/platform_device.h>
+
+struct steamdeck_led {
+	struct acpi_device *adev;
+	struct led_classdev cdev;
+};
+
+static int steamdeck_leds_brightness_set(struct led_classdev *cdev,
+					 enum led_brightness value)
+{
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "CHBV", value)))
+		return -EIO;
+
+	return 0;
+}
+
+static int steamdeck_leds_probe(struct platform_device *pdev)
+{
+  	struct device *dev = &pdev->dev;
+	struct steamdeck_led *sd;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	sd->adev = ACPI_COMPANION(dev->parent);
+
+	sd->cdev.name = "status:white";
+	sd->cdev.brightness_set_blocking = steamdeck_leds_brightness_set;
+	sd->cdev.max_brightness = 100;
+
+	ret = devm_led_classdev_register(dev, &sd->cdev);
+	if (ret) {
+		dev_err(dev, "Failed to register LEDs device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id steamdeck_leds_id_table[] = {
+	{ .name = "steamdeck-leds" },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_leds_id_table);
+
+static struct platform_driver steamdeck_leds_driver = {
+	.probe = steamdeck_leds_probe,
+	.driver = {
+		.name = "steamdeck-leds",
+	},
+	.id_table = steamdeck_leds_id_table,
+};
+module_platform_driver(steamdeck_leds_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck LEDs driver");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Mon, 20 Nov 2023 05:42:03 -0800
Subject: leds-steamdeck: Add support for LED birghtness multiplier

Add support for LED birghtness multiplier exposed via custom sysfs
attribute (led_brightness_multiplier).

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit c4ea057992e189ec8821cde3a65e2cc0529a5088)
(cherry picked from commit e90fb9bec45c15c0c541ce60b994bab3922ddadf)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/leds/leds-steamdeck.c | 49 +++++++++++++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/drivers/leds/leds-steamdeck.c b/drivers/leds/leds-steamdeck.c
index 686500b8de73..ada9fffc0a42 100644
--- a/drivers/leds/leds-steamdeck.c
+++ b/drivers/leds/leds-steamdeck.c
@@ -16,6 +16,54 @@ struct steamdeck_led {
 	struct led_classdev cdev;
 };
 
+static ssize_t led_brightness_multiplier_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long long led_brightness_multiplier;
+
+	if (ACPI_FAILURE(acpi_evaluate_integer(sd->adev->handle,
+					       "GLDM",
+					       NULL,
+					       &led_brightness_multiplier)))
+		return -EIO;
+
+
+	return sprintf(buf, "%llu", led_brightness_multiplier);
+}
+
+static ssize_t led_brightness_multiplier_store(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct steamdeck_led *sd = container_of(cdev, struct steamdeck_led,
+						cdev);
+	unsigned long value;
+
+	if (kstrtoul(buf, 10, &value) || value > 100)
+		return -EINVAL;
+
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "SLDM", value)))
+		return -EIO;
+
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(led_brightness_multiplier);
+
+static struct attribute *steamdeck_led_attrs[] = {
+	&dev_attr_led_brightness_multiplier.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(steamdeck_led);
+
 static int steamdeck_leds_brightness_set(struct led_classdev *cdev,
 					 enum led_brightness value)
 {
@@ -44,6 +92,7 @@ static int steamdeck_leds_probe(struct platform_device *pdev)
 	sd->cdev.name = "status:white";
 	sd->cdev.brightness_set_blocking = steamdeck_leds_brightness_set;
 	sd->cdev.max_brightness = 100;
+	sd->cdev.groups = steamdeck_led_groups;
 
 	ret = devm_led_classdev_register(dev, &sd->cdev);
 	if (ret) {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 14:46:08 -0800
Subject: extcon: Add driver for Steam Deck

(cherry picked from commit f9f2eddae582ae39d5f89c1218448fc259b90aa8)
[cristian: fwd-ported to v6.8]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/extcon/Kconfig            |   7 ++
 drivers/extcon/Makefile           |   1 +
 drivers/extcon/extcon-steamdeck.c | 180 ++++++++++++++++++++++++++++++
 3 files changed, 188 insertions(+)
 create mode 100644 drivers/extcon/extcon-steamdeck.c

diff --git a/drivers/extcon/Kconfig b/drivers/extcon/Kconfig
index a6f6d467aacf..4adec844c4b4 100644
--- a/drivers/extcon/Kconfig
+++ b/drivers/extcon/Kconfig
@@ -214,4 +214,11 @@ config EXTCON_RTK_TYPE_C
 	  The DHC (Digital Home Hub) RTD series SoC contains a type c module.
 	  This driver will detect the status of the type-c port.
 
+config EXTCON_STEAMDECK
+	tristate "Steam Deck extcon support"
+	depends on MFD_STEAMDECK
+	help
+	  Say Y here to enable support of USB Type C cable detection extcon
+	  support on Steam Deck devices
+
 endif
diff --git a/drivers/extcon/Makefile b/drivers/extcon/Makefile
index 0d6d23faf748..6eb613e0bcba 100644
--- a/drivers/extcon/Makefile
+++ b/drivers/extcon/Makefile
@@ -27,3 +27,4 @@ obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
 obj-$(CONFIG_EXTCON_USBC_TUSB320) += extcon-usbc-tusb320.o
 obj-$(CONFIG_EXTCON_RTK_TYPE_C) += extcon-rtk-type-c.o
+obj-$(CONFIG_EXTCON_STEAMDECK)  += extcon-steamdeck.o
diff --git a/drivers/extcon/extcon-steamdeck.c b/drivers/extcon/extcon-steamdeck.c
new file mode 100644
index 000000000000..74f190adc8ea
--- /dev/null
+++ b/drivers/extcon/extcon-steamdeck.c
@@ -0,0 +1,180 @@
+
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <linux/extcon-provider.h>
+
+#define ACPI_STEAMDECK_NOTIFY_STATUS	0x80
+
+/* 0 - port connected, 1 -port disconnected */
+#define ACPI_STEAMDECK_PORT_CONNECT	BIT(0)
+/* 0 - Upstream Facing Port, 1 - Downdstream Facing Port */
+#define ACPI_STEAMDECK_CUR_DATA_ROLE	BIT(3)
+/*
+ * Debouncing delay to allow negotiation process to settle. 2s value
+ * was arrived at via trial and error.
+ */
+#define STEAMDECK_ROLE_SWITCH_DELAY	(msecs_to_jiffies(2000))
+
+struct steamdeck_extcon {
+	struct acpi_device *adev;
+	struct delayed_work role_work;
+	struct extcon_dev *edev;
+	struct device *dev;
+};
+
+static int steamdeck_read_pdcs(struct steamdeck_extcon *sd, unsigned long long *pdcs)
+{
+	acpi_status status;
+
+	status = acpi_evaluate_integer(sd->adev->handle, "PDCS", NULL, pdcs);
+	if (ACPI_FAILURE(status)) {
+		dev_err(sd->dev, "PDCS evaluation failed: %s\n",
+			acpi_format_exception(status));
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void steamdeck_usb_role_work(struct work_struct *work)
+{
+	struct steamdeck_extcon *sd =
+		container_of(work, struct steamdeck_extcon, role_work.work);
+	unsigned long long pdcs;
+	bool usb_host;
+
+	if (steamdeck_read_pdcs(sd, &pdcs))
+		return;
+
+	/*
+	 * We only care about these two
+	 */
+	pdcs &= ACPI_STEAMDECK_PORT_CONNECT | ACPI_STEAMDECK_CUR_DATA_ROLE;
+
+	/*
+	 * For "connect" events our role is determined by a bit in
+	 * PDCS, for "disconnect" we switch to being a gadget
+	 * unconditionally. The thinking for the latter is we don't
+	 * want to start acting as a USB host until we get
+	 * confirmation from the firmware that we are a USB host
+	 */
+	usb_host = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+		pdcs & ACPI_STEAMDECK_CUR_DATA_ROLE : false;
+
+	dev_dbg(sd->dev, "USB role is %s\n", usb_host ? "host" : "device");
+	WARN_ON(extcon_set_state_sync(sd->edev, EXTCON_USB_HOST,
+				      usb_host));
+
+}
+
+static void steamdeck_notify(acpi_handle handle, u32 event, void *context)
+{
+	struct device *dev = context;
+	struct steamdeck_extcon *sd = dev_get_drvdata(dev);
+	unsigned long long pdcs;
+	unsigned long delay;
+
+	switch (event) {
+	case ACPI_STEAMDECK_NOTIFY_STATUS:
+		if (steamdeck_read_pdcs(sd, &pdcs))
+			return;
+		/*
+		 * We process "disconnect" events immediately and
+		 * "connect" events with a delay to give the HW time
+		 * to settle. For example attaching USB hub (at least
+		 * for HW used for testing) will generate intermediary
+		 * event with "host" bit not set, followed by the one
+		 * that does have it set.
+		 */
+		delay = (pdcs & ACPI_STEAMDECK_PORT_CONNECT) ?
+			STEAMDECK_ROLE_SWITCH_DELAY : 0;
+
+		queue_delayed_work(system_long_wq, &sd->role_work, delay);
+		break;
+	default:
+		dev_warn(dev, "Unsupported event [0x%x]\n", event);
+	}
+}
+
+static void steamdeck_remove_notify_handler(void *data)
+{
+	struct steamdeck_extcon *sd = data;
+
+	acpi_remove_notify_handler(sd->adev->handle, ACPI_DEVICE_NOTIFY,
+				   steamdeck_notify);
+	cancel_delayed_work_sync(&sd->role_work);
+}
+
+static const unsigned int steamdeck_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+	EXTCON_CHG_USB_ACA,
+	EXTCON_NONE,
+};
+
+static int steamdeck_extcon_probe(struct platform_device *pdev)
+{
+  	struct device *dev = &pdev->dev;
+	struct steamdeck_extcon *sd;
+	acpi_status status;
+	int ret;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	INIT_DELAYED_WORK(&sd->role_work, steamdeck_usb_role_work);
+	platform_set_drvdata(pdev, sd);
+	sd->adev = ACPI_COMPANION(dev->parent);
+	sd->dev  = dev;
+	sd->edev = devm_extcon_dev_allocate(dev, steamdeck_extcon_cable);
+	if (IS_ERR(sd->edev))
+		return PTR_ERR(sd->edev);
+
+	ret = devm_extcon_dev_register(dev, sd->edev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register extcon device: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * Set initial role value
+	 */
+	queue_delayed_work(system_long_wq, &sd->role_work, 0);
+	flush_delayed_work(&sd->role_work);
+
+	status = acpi_install_notify_handler(sd->adev->handle,
+					     ACPI_DEVICE_NOTIFY,
+					     steamdeck_notify,
+					     dev);
+	if (ACPI_FAILURE(status)) {
+		dev_err(dev, "Error installing ACPI notify handler\n");
+		return -EIO;
+	}
+
+	ret = devm_add_action_or_reset(dev, steamdeck_remove_notify_handler,
+				       sd);
+	return ret;
+}
+
+static const struct platform_device_id steamdeck_extcon_id_table[] = {
+	{ .name = "steamdeck-extcon" },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_extcon_id_table);
+
+static struct platform_driver steamdeck_extcon_driver = {
+	.probe = steamdeck_extcon_probe,
+	.driver = {
+		.name = "steamdeck-extcon",
+	},
+	.id_table = steamdeck_extcon_id_table,
+};
+module_platform_driver(steamdeck_extcon_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck extcon driver");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 19 Feb 2022 16:09:45 -0800
Subject: hwmon: Add driver for Steam Deck's EC sensors

Add driver for sensors exposed by EC firmware on Steam Deck hardware.

(cherry picked from commit 6917aac77bee6185ae3920b936cdbe7876118c0b)
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/hwmon/Kconfig           |  11 ++
 drivers/hwmon/Makefile          |   1 +
 drivers/hwmon/steamdeck-hwmon.c | 224 ++++++++++++++++++++++++++++++++
 3 files changed, 236 insertions(+)
 create mode 100644 drivers/hwmon/steamdeck-hwmon.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 9d28fcf7cd2a..48341d5652ac 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -2128,6 +2128,17 @@ config SENSORS_SCH5636
 	  This driver can also be built as a module. If so, the module
 	  will be called sch5636.
 
+config SENSORS_STEAMDECK
+	tristate "Steam Deck EC sensors"
+	depends on MFD_STEAMDECK
+	help
+	  If you say yes here you get support for the hardware
+	  monitoring features exposed by EC firmware on Steam Deck
+	  devices
+
+	  This driver can also be built as a module. If so, the module
+	  will be called steamdeck-hwmon.
+
 config SENSORS_STTS751
 	tristate "ST Microelectronics STTS751"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index cd8bc4752b4d..f3e1422a68f9 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -216,6 +216,7 @@ obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
 obj-$(CONFIG_SENSORS_SPARX5)	+= sparx5-temp.o
 obj-$(CONFIG_SENSORS_SPD5118)	+= spd5118.o
+obj-$(CONFIG_SENSORS_STEAMDECK) += steamdeck-hwmon.o
 obj-$(CONFIG_SENSORS_STTS751)	+= stts751.o
 obj-$(CONFIG_SENSORS_SURFACE_FAN)+= surface_fan.o
 obj-$(CONFIG_SENSORS_SURFACE_TEMP)+= surface_temp.o
diff --git a/drivers/hwmon/steamdeck-hwmon.c b/drivers/hwmon/steamdeck-hwmon.c
new file mode 100644
index 000000000000..fab9e9460bd4
--- /dev/null
+++ b/drivers/hwmon/steamdeck-hwmon.c
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Steam Deck EC sensors driver
+ *
+ * Copyright (C) 2021-2022 Valve Corporation
+ */
+
+#include <linux/acpi.h>
+#include <linux/hwmon.h>
+#include <linux/platform_device.h>
+
+#define STEAMDECK_HWMON_NAME	"steamdeck-hwmon"
+
+struct steamdeck_hwmon {
+	struct acpi_device *adev;
+};
+
+static long
+steamdeck_hwmon_get(struct steamdeck_hwmon *sd, const char *method)
+{
+	unsigned long long val;
+	if (ACPI_FAILURE(acpi_evaluate_integer(sd->adev->handle,
+					       (char *)method, NULL, &val)))
+		return -EIO;
+
+	return val;
+}
+
+static int
+steamdeck_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+		     u32 attr, int channel, long *out)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_curr:
+		if (attr != hwmon_curr_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "PDAM");
+		if (*out < 0)
+			return *out;
+		break;
+	case hwmon_in:
+		if (attr != hwmon_in_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "PDVL");
+		if (*out < 0)
+			return *out;
+		break;
+	case hwmon_temp:
+		if (attr != hwmon_temp_input)
+			return -EOPNOTSUPP;
+
+		*out = steamdeck_hwmon_get(sd, "BATT");
+		if (*out < 0)
+			return *out;
+		/*
+		 * Assuming BATT returns deg C we need to mutiply it
+		 * by 1000 to convert to mC
+		 */
+		*out *= 1000;
+		break;
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			*out = steamdeck_hwmon_get(sd, "FANR");
+			if (*out < 0)
+				return *out;
+			break;
+		case hwmon_fan_target:
+			*out = steamdeck_hwmon_get(sd, "FSSR");
+			if (*out < 0)
+				return *out;
+			break;
+		case hwmon_fan_fault:
+			*out = steamdeck_hwmon_get(sd, "FANC");
+			if (*out < 0)
+				return *out;
+			/*
+			 * FANC (Fan check):
+			 * 0: Abnormal
+			 * 1: Normal
+			 */
+			*out = !*out;
+			break;
+		default:
+			return -EOPNOTSUPP;
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int
+steamdeck_hwmon_read_string(struct device *dev, enum hwmon_sensor_types type,
+			    u32 attr, int channel, const char **str)
+{
+	switch (type) {
+		/*
+		 * These two aren't, strictly speaking, measured. EC
+		 * firmware just reports what PD negotiation resulted
+		 * in.
+		 */
+	case hwmon_curr:
+		*str = "PD Contract Current";
+		break;
+	case hwmon_in:
+		*str = "PD Contract Voltage";
+		break;
+	case hwmon_temp:
+		*str = "Battery Temp";
+		break;
+	case hwmon_fan:
+		*str = "System Fan";
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int
+steamdeck_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+		      u32 attr, int channel, long val)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+
+	if (type != hwmon_fan ||
+	    attr != hwmon_fan_target)
+		return -EOPNOTSUPP;
+
+	val = clamp_val(val, 0, 7300);
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    "FANS", val)))
+		return -EIO;
+
+	return 0;
+}
+
+static umode_t
+steamdeck_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+			   u32 attr, int channel)
+{
+	if (type == hwmon_fan &&
+	    attr == hwmon_fan_target)
+		return 0644;
+
+	return 0444;
+}
+
+static const struct hwmon_channel_info *steamdeck_hwmon_info[] = {
+	HWMON_CHANNEL_INFO(in,
+			   HWMON_I_INPUT | HWMON_I_LABEL),
+	HWMON_CHANNEL_INFO(curr,
+			   HWMON_C_INPUT | HWMON_C_LABEL),
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_LABEL),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL |
+			   HWMON_F_TARGET | HWMON_F_FAULT),
+	NULL
+};
+
+static const struct hwmon_ops steamdeck_hwmon_ops = {
+	.is_visible = steamdeck_hwmon_is_visible,
+	.read = steamdeck_hwmon_read,
+	.read_string = steamdeck_hwmon_read_string,
+	.write = steamdeck_hwmon_write,
+};
+
+static const struct hwmon_chip_info steamdeck_hwmon_chip_info = {
+	.ops = &steamdeck_hwmon_ops,
+	.info = steamdeck_hwmon_info,
+};
+
+static int steamdeck_hwmon_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct steamdeck_hwmon *sd;
+	struct device *hwmon;
+
+	sd = devm_kzalloc(dev, sizeof(*sd), GFP_KERNEL);
+	if (!sd)
+		return -ENOMEM;
+
+	sd->adev = ACPI_COMPANION(dev->parent);
+	hwmon = devm_hwmon_device_register_with_info(dev,
+						     "steamdeck_hwmon",
+						     sd,
+						     &steamdeck_hwmon_chip_info,
+						     NULL);
+	if (IS_ERR(hwmon)) {
+		dev_err(dev, "Failed to register HWMON device");
+		return PTR_ERR(hwmon);
+	}
+
+	return 0;
+}
+
+static const struct platform_device_id steamdeck_hwmon_id_table[] = {
+	{ .name = STEAMDECK_HWMON_NAME },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, steamdeck_hwmon_id_table);
+
+static struct platform_driver steamdeck_hwmon_driver = {
+	.probe = steamdeck_hwmon_probe,
+	.driver = {
+		.name = STEAMDECK_HWMON_NAME,
+	},
+	.id_table = steamdeck_hwmon_id_table,
+};
+module_platform_driver(steamdeck_hwmon_driver);
+
+MODULE_AUTHOR("Andrey Smirnov <andrew.smirnov@gmail.com>");
+MODULE_DESCRIPTION("Steam Deck EC sensors driver");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 15 Jul 2023 12:58:54 -0700
Subject: hwmon: steamdeck-hwmon: Add support for max battery level/rate

Add support for max battery level/charge rate attributes.

Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
(cherry picked from commit 50af83e8fd75dc52221edd3fb6fd7a7f70c4d8a4)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/hwmon/steamdeck-hwmon.c | 72 ++++++++++++++++++++++++++++++++-
 1 file changed, 71 insertions(+), 1 deletion(-)

diff --git a/drivers/hwmon/steamdeck-hwmon.c b/drivers/hwmon/steamdeck-hwmon.c
index fab9e9460bd4..9d0a5471b181 100644
--- a/drivers/hwmon/steamdeck-hwmon.c
+++ b/drivers/hwmon/steamdeck-hwmon.c
@@ -180,6 +180,76 @@ static const struct hwmon_chip_info steamdeck_hwmon_chip_info = {
 	.info = steamdeck_hwmon_info,
 };
 
+
+static ssize_t
+steamdeck_hwmon_simple_store(struct device *dev, const char *buf, size_t count,
+			     const char *method,
+			     unsigned long upper_limit)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+	unsigned long value;
+
+	if (kstrtoul(buf, 10, &value) || value >= upper_limit)
+		return -EINVAL;
+
+	if (ACPI_FAILURE(acpi_execute_simple_method(sd->adev->handle,
+						    (char *)method, value)))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t
+steamdeck_hwmon_simple_show(struct device *dev, char *buf,
+			    const char *method)
+{
+	struct steamdeck_hwmon *sd = dev_get_drvdata(dev);
+	unsigned long value;
+
+	value = steamdeck_hwmon_get(sd, method);
+	if (value < 0)
+		return value;
+
+	return sprintf(buf, "%ld\n", value);
+}
+
+#define STEAMDECK_HWMON_ATTR_RW(_name, _set_method, _get_method,	\
+				_upper_limit)				\
+	static ssize_t _name##_show(struct device *dev,			\
+				    struct device_attribute *attr,	\
+				    char *buf)				\
+	{								\
+		return steamdeck_hwmon_simple_show(dev, buf,		\
+						   _get_method);	\
+	}								\
+	static ssize_t _name##_store(struct device *dev,		\
+				     struct device_attribute *attr,	\
+				     const char *buf, size_t count)	\
+	{								\
+		return steamdeck_hwmon_simple_store(dev, buf, count,	\
+						    _set_method,	\
+						    _upper_limit);	\
+	}								\
+	static DEVICE_ATTR_RW(_name)
+
+STEAMDECK_HWMON_ATTR_RW(max_battery_charge_level, "FCBL", "SFBL", 101);
+STEAMDECK_HWMON_ATTR_RW(max_battery_charge_rate,  "CHGR", "GCHR", 101);
+
+static struct attribute *steamdeck_hwmon_attributes[] = {
+	&dev_attr_max_battery_charge_level.attr,
+	&dev_attr_max_battery_charge_rate.attr,
+	NULL
+};
+
+static const struct attribute_group steamdeck_hwmon_group = {
+	.attrs = steamdeck_hwmon_attributes,
+};
+
+static const struct attribute_group *steamdeck_hwmon_groups[] = {
+	&steamdeck_hwmon_group,
+	NULL
+};
+
 static int steamdeck_hwmon_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -195,7 +265,7 @@ static int steamdeck_hwmon_probe(struct platform_device *pdev)
 						     "steamdeck_hwmon",
 						     sd,
 						     &steamdeck_hwmon_chip_info,
-						     NULL);
+						     steamdeck_hwmon_groups);
 	if (IS_ERR(hwmon)) {
 		dev_err(dev, "Failed to register HWMON device");
 		return PTR_ERR(hwmon);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Fri, 2 Sep 2022 19:13:12 +0300
Subject: usb: dwc3: Hardcode jupiter ACPI device as extcon name

Hardcode jupiter ACPI device as extcon name in order to connect the
two together. This is really a hack and should really be coming from
our ACPI tables.

(cherry picked from commit 190ce1057f9bafd3ca4e11e7cda286c234666196)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>

[Fwd port to 6.0]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 39c72cb52ce7..c899332a1078 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -194,6 +194,7 @@ static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_BOOL("usb-role-switch"),
 	PROPERTY_ENTRY_STRING("role-switch-default-mode", "host"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
+	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
 	{}
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sat, 29 Oct 2022 15:25:21 -0700
Subject: usb: dwc3: Drop "usb-role-swtich" from dwc3_pci_mr_properties

Having both "usb-role-swtich" and "linux,extcon-name" is a conflicting
configuration since the two are mutually exclusive. This wasn't a
problem before since "linux,extcon-name" had a priority, but recent
change in the kernel changed that, breaking Deck's role detection
integration.

Fix this by dropping "usb-role-switch" (and "role-switch-default-mode"
with it), to allow dwc3 driver to use extcon as it should.

(cherry picked from commit 498d5dccfac3e71b95fe3b9d6a156f15b6028aec)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index c899332a1078..8efdfad732fc 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -191,8 +191,6 @@ static const struct property_entry dwc3_pci_amd_properties[] = {
 
 static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_STRING("dr_mode", "otg"),
-	PROPERTY_ENTRY_BOOL("usb-role-switch"),
-	PROPERTY_ENTRY_STRING("role-switch-default-mode", "host"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
 	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
 	{}
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrey Smirnov <andrew.smirnov@gmail.com>
Date: Sun, 27 Feb 2022 16:34:23 -0800
Subject: usb: dwc3: Fix "linux,extcon-name"

(cherry picked from commit 601ff3cebe00d1d5e4f165f4ac69a8ec0a57549e)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/usb/dwc3/dwc3-pci.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index 8efdfad732fc..a4e0bfec04c8 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -192,7 +192,7 @@ static const struct property_entry dwc3_pci_amd_properties[] = {
 static const struct property_entry dwc3_pci_mr_properties[] = {
 	PROPERTY_ENTRY_STRING("dr_mode", "otg"),
 	PROPERTY_ENTRY_BOOL("linux,sysdev_is_parent"),
-	PROPERTY_ENTRY_STRING("linux,extcon-name", "VLV0100:00"),
+	PROPERTY_ENTRY_STRING("linux,extcon-name", "steamdeck-extcon"),
 	{}
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Fri, 26 Jul 2024 23:51:33 +0300
Subject: media: platform: cros-ec: Add AMD Lilac to the match table

Original commit: d03c74b3643b ("add missing lilac chromeos entry")

Co-developed-by: Pierre-Loup A. Griffais <pgriffais@valvesoftware.com>
Signed-off-by: Pierre-Loup A. Griffais <pgriffais@valvesoftware.com>
[fwd-ported to v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/media/cec/platform/cros-ec/cros-ec-cec.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/media/cec/platform/cros-ec/cros-ec-cec.c b/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
index 419b9a7abcce..22282578ab99 100644
--- a/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
+++ b/drivers/media/cec/platform/cros-ec/cros-ec-cec.c
@@ -296,6 +296,7 @@ struct cec_dmi_match {
 };
 
 static const char *const port_b_conns[] = { "Port B", NULL };
+static const char *const port_c_conns[] = { "Port C", NULL };
 static const char *const port_db_conns[] = { "Port D", "Port B", NULL };
 static const char *const port_ba_conns[] = { "Port B", "Port A", NULL };
 static const char *const port_ab_conns[] = { "Port A", "Port B", NULL };
@@ -334,6 +335,8 @@ static const struct cec_dmi_match cec_dmi_match_table[] = {
 	{ "Google", "Dirks", "0000:00:02.0", port_ab_conns },
 	/* Google Moxie */
 	{ "Google", "Moxie", "0000:00:02.0", port_b_conns },
+	/* AMD Lilac */
+	{ "AMD", "Lilac", "0000:06:00.0", port_c_conns },
 };
 
 static struct device *cros_ec_cec_find_hdmi_dev(struct device *dev,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ethan Geller <ethang@valvesoftware.com>
Date: Thu, 16 Nov 2023 21:31:48 +0000
Subject: [WIP] ASoC: max98388: Fix power on when resuming from suspend

Fix Max98388 issue where speakers would not be powered on when we resume
from S3.

The issue was that when we flush the regmap to the amp on resume, we
were also flushing a value of 1 to the SW_RESET pin.

Theoretically, this is fixed by marking the SW_RESET register volatile.
However, we did not observe a fix after marking the register volatile,
so we opted for a more complete fix of ensuring SW_RESET is zero in our
regmap after we have waited for the reset loop to be complete.

(cherry picked from commit c0c65da7ca4b0a4f93272f5e932dd7eed90703c8)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/codecs/max98388.c | 24 ++++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/sound/soc/codecs/max98388.c b/sound/soc/codecs/max98388.c
index 076f15a9867e..42f1e0b7f38a 100644
--- a/sound/soc/codecs/max98388.c
+++ b/sound/soc/codecs/max98388.c
@@ -390,27 +390,43 @@ static void max98388_reset(struct max98388_priv *max98388, struct device *dev)
 {
 	int ret, reg, count;
 
+
 	/* Software Reset */
 	ret = regmap_update_bits(max98388->regmap,
 				 MAX98388_R2000_SW_RESET,
 				 MAX98388_SOFT_RESET,
 				 MAX98388_SOFT_RESET);
-	if (ret)
+
+	if (ret) {
 		dev_err(dev, "Reset command failed. (ret:%d)\n", ret);
+		goto exit;
+	}
+
 
 	count = 0;
 	while (count < 3) {
 		usleep_range(10000, 11000);
+
 		/* Software Reset Verification */
 		ret = regmap_read(max98388->regmap,
 				  MAX98388_R22FF_REV_ID, &reg);
+
 		if (!ret) {
 			dev_info(dev, "Reset completed (retry:%d)\n", count);
-			return;
+			goto exit;
 		}
 		count++;
 	}
+
 	dev_err(dev, "Reset failed. (ret:%d)\n", ret);
+
+
+exit:
+	regcache_cache_only(max98388->regmap, true);
+	ret = regmap_update_bits(max98388->regmap,
+				 MAX98388_R2000_SW_RESET,
+				 MAX98388_SOFT_RESET, 0);
+	regcache_cache_only(max98388->regmap, false);
 }
 
 static int max98388_probe(struct snd_soc_component *component)
@@ -419,6 +435,7 @@ static int max98388_probe(struct snd_soc_component *component)
 
 	/* Software Reset */
 	max98388_reset(max98388, component->dev);
+	usleep_range(400, 1000);
 
 	/* General channel source configuration */
 	regmap_write(max98388->regmap,
@@ -812,6 +829,7 @@ static bool max98388_readable_register(struct device *dev,
 	case MAX98388_R210E_AUTO_RESTART:
 	case MAX98388_R210F_GLOBAL_EN:
 	case MAX98388_R22FF_REV_ID:
+	case MAX98388_R2000_SW_RESET:
 		return true;
 	default:
 		return false;
@@ -824,6 +842,7 @@ static bool max98388_volatile_reg(struct device *dev, unsigned int reg)
 	case MAX98388_R2001_INT_RAW1 ... MAX98388_R2005_INT_STATE2:
 	case MAX98388_R210F_GLOBAL_EN:
 	case MAX98388_R22FF_REV_ID:
+	case MAX98388_R2000_SW_RESET:
 		return true;
 	default:
 		return false;
@@ -867,6 +886,7 @@ static int max98388_resume(struct device *dev)
 
 	regcache_cache_only(max98388->regmap, false);
 	max98388_reset(max98388, dev);
+	usleep_range(400, 1000);
 	regcache_sync(max98388->regmap);
 
 	return 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Christian Marcheselli <christianm@valvesoftware.com>
Date: Fri, 31 Mar 2023 15:21:25 -0700
Subject: [QUECTEL/VALVE] Added in Quectel patches for bluetooth

[Fwd-ported to v6.11.6]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 include/net/bluetooth/hci.h      |  1 +
 include/net/bluetooth/hci_core.h |  2 +-
 net/bluetooth/hci_core.c         | 10 +++++-----
 net/bluetooth/mgmt.c             |  4 ++--
 4 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/include/net/bluetooth/hci.h b/include/net/bluetooth/hci.h
index df1847b74e55..5db497d8a122 100644
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@ -485,6 +485,7 @@ enum {
 #define HCI_CMD_TIMEOUT		msecs_to_jiffies(2000)	/* 2 seconds */
 #define HCI_NCMD_TIMEOUT	msecs_to_jiffies(4000)	/* 4 seconds */
 #define HCI_ACL_TX_TIMEOUT	msecs_to_jiffies(45000)	/* 45 seconds */
+#define HCI_AUTO_ON_TIMEOUT	msecs_to_jiffies(200)	/* 0.2 seconds */
 #define HCI_AUTO_OFF_TIMEOUT	msecs_to_jiffies(2000)	/* 2 seconds */
 #define HCI_ACL_CONN_TIMEOUT	msecs_to_jiffies(20000)	/* 20 seconds */
 #define HCI_LE_CONN_TIMEOUT	msecs_to_jiffies(20000)	/* 20 seconds */
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 6560b32f3125..e0364f653a4c 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -494,7 +494,7 @@ struct hci_dev {
 	struct workqueue_struct	*workqueue;
 	struct workqueue_struct	*req_workqueue;
 
-	struct work_struct	power_on;
+	struct delayed_work	power_on;
 	struct delayed_work	power_off;
 	struct work_struct	error_reset;
 	struct work_struct	cmd_sync_work;
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index 55e0722fd066..19232a7a66e1 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -519,7 +519,7 @@ int hci_dev_close(__u16 dev)
 		goto done;
 	}
 
-	cancel_work_sync(&hdev->power_on);
+	cancel_delayed_work(&hdev->power_on);
 	if (hci_dev_test_and_clear_flag(hdev, HCI_AUTO_OFF))
 		cancel_delayed_work(&hdev->power_off);
 
@@ -942,7 +942,7 @@ static const struct rfkill_ops hci_rfkill_ops = {
 
 static void hci_power_on(struct work_struct *work)
 {
-	struct hci_dev *hdev = container_of(work, struct hci_dev, power_on);
+	struct hci_dev *hdev = container_of(work, struct hci_dev, power_on.work);
 	int err;
 
 	BT_DBG("%s", hdev->name);
@@ -2547,7 +2547,7 @@ struct hci_dev *hci_alloc_dev_priv(int sizeof_priv)
 	INIT_WORK(&hdev->rx_work, hci_rx_work);
 	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
 	INIT_WORK(&hdev->tx_work, hci_tx_work);
-	INIT_WORK(&hdev->power_on, hci_power_on);
+	INIT_DELAYED_WORK(&hdev->power_on, hci_power_on);
 	INIT_WORK(&hdev->error_reset, hci_error_reset);
 
 	hci_cmd_sync_init(hdev);
@@ -2668,7 +2668,7 @@ int hci_register_dev(struct hci_dev *hdev)
 	if (error)
 		BT_WARN("register suspend notifier failed error:%d\n", error);
 
-	queue_work(hdev->req_workqueue, &hdev->power_on);
+	queue_delayed_work(hdev->req_workqueue, &hdev->power_on,HCI_AUTO_ON_TIMEOUT);
 
 	idr_init(&hdev->adv_monitors_idr);
 	msft_register(hdev);
@@ -2705,7 +2705,7 @@ void hci_unregister_dev(struct hci_dev *hdev)
 	disable_work_sync(&hdev->rx_work);
 	disable_work_sync(&hdev->cmd_work);
 	disable_work_sync(&hdev->tx_work);
-	disable_work_sync(&hdev->power_on);
+	disable_delayed_work(&hdev->power_on);
 	disable_work_sync(&hdev->error_reset);
 
 	hci_cmd_sync_clear(hdev);
diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c
index a3d16eece0d2..2c66a391dfeb 100644
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@ -8071,7 +8071,7 @@ static int set_external_config(struct sock *sk, struct hci_dev *hdev,
 			hci_dev_set_flag(hdev, HCI_CONFIG);
 			hci_dev_set_flag(hdev, HCI_AUTO_OFF);
 
-			queue_work(hdev->req_workqueue, &hdev->power_on);
+			queue_work(hdev->req_workqueue, &hdev->power_on.work);
 		} else {
 			set_bit(HCI_RAW, &hdev->flags);
 			mgmt_index_added(hdev);
@@ -8127,7 +8127,7 @@ static int set_public_address(struct sock *sk, struct hci_dev *hdev,
 		hci_dev_set_flag(hdev, HCI_CONFIG);
 		hci_dev_set_flag(hdev, HCI_AUTO_OFF);
 
-		queue_work(hdev->req_workqueue, &hdev->power_on);
+		queue_work(hdev->req_workqueue, &hdev->power_on.work);
 	}
 
 unlock:
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>
Date: Tue, 23 May 2023 19:01:49 -0700
Subject: [QUECTEL/VALVE] acpi match based on Quanta's 11T09 bios

[Fwd-ported from v6.5]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/bluetooth/hci_qca.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/bluetooth/hci_qca.c b/drivers/bluetooth/hci_qca.c
index 4cff4d9be313..5824c4d02eb7 100644
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@ -2735,6 +2735,7 @@ static const struct acpi_device_id qca_bluetooth_acpi_match[] = {
 	{ "DLA16390", (kernel_ulong_t)&qca_soc_data_qca6390 },
 	{ "DLB16390", (kernel_ulong_t)&qca_soc_data_qca6390 },
 	{ "DLB26390", (kernel_ulong_t)&qca_soc_data_qca6390 },
+	{ "QCOM2066", (kernel_ulong_t)&qca_soc_data_qca2066 },
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, qca_bluetooth_acpi_match);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Rolando Roca <rolandor@valvesoftware.com>
Date: Fri, 22 Sep 2023 14:23:12 -0700
Subject: [FROM-QUECTEL] Bluetooth: Fixed an issue where the Steam Deck could
 not into sleep because it continued advertizing after the Steam Controller
 was disconnected.

<Change Type>: Poor experience

<<< Test Notes >>>
<Test-Proposal>:
1)BT BR/EDR gamepad wakeup function
1)BT BLE gamepad wakeup function
<Stress-Test>: Y

[Fwd-ported from v6.5]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 net/bluetooth/hci_sync.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index eefdb6134ca5..d39845d0d86f 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -6194,7 +6194,7 @@ int hci_suspend_sync(struct hci_dev *hdev)
 
 	if (hci_conn_count(hdev)) {
 		/* Soft disconnect everything (power off) */
-		err = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_POWER_OFF);
+		err = hci_disconnect_all_sync(hdev, HCI_ERROR_REMOTE_USER_TERM);
 		if (err) {
 			/* Set state to BT_RUNNING so resume doesn't notify */
 			hdev->suspend_state = BT_RUNNING;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Mon, 22 Apr 2024 13:23:25 +0300
Subject: [FROM-QUECTEL] Bluetooth: hci_sync: Fix BLE devices turning wakeup
 on/off

This is part 1 from initial patch provided by
  "zhongjun.yu" <zhongjun.yu@quectel.com>
and ported to v6.5:

1) Fixed an issue where BLE devices could not turn wakeup on or off.
2) Resolved an issue where bluez lib could not receive
   MGMT_EV_DEVICE_FLAGS_CHANGED notifications after sending
   MGMT_OP_SET_DEVICE_FLAGS

<Change Type>: Develop the function to set the Bluetooth device wake-up
switch

<<< Test Notes >>>
<Test-Proposal>:
1) python script set_wakeup.py
2) valve sw guys Developing UI validation
<Stress-Test>: Y

[fwd-ported to v6.11 and dropped part 2 due to a breakage with BlueZ 5.78+]
Link: https://gitlab.steamos.cloud/holo-team/tasks/-/issues/1456
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 net/bluetooth/hci_sync.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index d39845d0d86f..32b9b57f9c61 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -2744,6 +2744,7 @@ static u8 hci_update_accept_list_sync(struct hci_dev *hdev)
 	struct bdaddr_list *b, *t;
 	u8 num_entries = 0;
 	bool pend_conn, pend_report;
+	struct hci_conn_params *conn_params;
 	u8 filter_policy;
 	size_t i, n;
 	int err;
@@ -2821,6 +2822,15 @@ static u8 hci_update_accept_list_sync(struct hci_dev *hdev)
 			continue;
 		}
 
+		/* During suspend, only wakeable devices can be in acceptlist */
+		conn_params = hci_conn_params_lookup(hdev,&b->bdaddr,b->bdaddr_type);
+		if (conn_params && hdev->suspended &&
+		    !(conn_params->flags & HCI_CONN_FLAG_REMOTE_WAKEUP)) {
+			hci_le_del_accept_list_sync(hdev, &b->bdaddr,
+						    b->bdaddr_type);
+			continue;
+		}
+
 		num_entries++;
 	}
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Thu, 21 Nov 2024 21:12:03 +0000
Subject: [FOR-UPSTREAM] Bluetooth: btrtl: add suspend handling to ignore
 BT_DIS

With new fw, btrtl can be set to ignore the BT_DIS
pin that is usually asserted during suspend.
This allows the device to be a wakeup source and
allows us to wakeup via bluetooth peripherals.

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
[Rebased onto v6.11.[4,5] to fix conflicts on drivers/bluetooth/btusb.c]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/bluetooth/btrtl.c | 144 ++++++++++++++++++++++++++++++++++++++
 drivers/bluetooth/btrtl.h |  13 ++++
 drivers/bluetooth/btusb.c |  16 +++++
 3 files changed, 173 insertions(+)

diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index 6abd962502e3..d695f46ea5cd 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -9,6 +9,7 @@
 #include <linux/firmware.h>
 #include <linux/unaligned.h>
 #include <linux/usb.h>
+#include <linux/dmi.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -51,6 +52,9 @@
 #define	RTL_CHIP_SUBVER (&(struct rtl_vendor_cmd) {{0x10, 0x38, 0x04, 0x28, 0x80}})
 #define	RTL_CHIP_REV    (&(struct rtl_vendor_cmd) {{0x10, 0x3A, 0x04, 0x28, 0x80}})
 #define	RTL_SEC_PROJ    (&(struct rtl_vendor_cmd) {{0x10, 0xA4, 0x0D, 0x00, 0xb0}})
+#define	RTL_IGNORE_MASK (&(struct rtl_vendor_cmd) {{0x10, 0x34, 0x60, 0x00, 0xb0}})
+
+#define	RTL_IGNORE_BT_DIS BIT(0)
 
 #define RTL_PATCH_SNIPPETS		0x01
 #define RTL_PATCH_DUMMY_HEADER		0x02
@@ -439,6 +443,58 @@ static int btrtl_vendor_read_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
+static int btrtl_vendor_read_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_read_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
+static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
+				    struct rtl_vendor_cmd *cmd, const u8 * const rp)
+{
+	struct sk_buff *skb;
+	u8 buf[sizeof(*cmd) + 2];
+	int err = 0;
+
+	memcpy(buf, cmd, sizeof(*cmd));
+	memcpy(buf + sizeof(*cmd), rp, 2);
+
+	skb = __hci_cmd_sync(hdev, 0xfc62, sizeof(buf), buf, HCI_INIT_TIMEOUT);
+	if (IS_ERR(skb)) {
+		err = PTR_ERR(skb);
+		rtl_dev_err(hdev, "RTL: Write reg16 failed (%d)", err);
+		return err;
+	}
+
+	if (skb->len != 1 || skb->data[0]) {
+		bt_dev_err(hdev, "RTL: Write reg16 length mismatch");
+		kfree_skb(skb);
+		return -EIO;
+	}
+
+	kfree_skb(skb);
+
+	return 0;
+}
+
+static int btrtl_vendor_write_reg16_unlocked(struct hci_dev *hdev,
+					    struct rtl_vendor_cmd *cmd, u8 *rp)
+{
+	int ret;
+
+	hci_req_sync_lock(hdev);
+	ret = btrtl_vendor_write_reg16(hdev, cmd, rp);
+	hci_req_sync_unlock(hdev);
+
+	return ret;
+}
+
 static void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)
 {
 	void *data = iov->data;
@@ -1282,8 +1338,44 @@ int btrtl_download_firmware(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_download_firmware);
 
+static const struct dmi_system_id btrtl_can_ignore_bt_dis_table[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Jupiter"),
+		},
+	},
+	{}
+};
+
+static bool btrtl_fw_can_ignore_bt_dis(struct hci_dev *hdev)
+{
+	struct sk_buff *skb;
+	struct hci_rp_read_local_version *rp;
+	bool ret = false;
+
+	if (!dmi_check_system(btrtl_can_ignore_bt_dis_table))
+		return false;
+
+	skb = btrtl_read_local_version(hdev);
+	if (IS_ERR(skb))
+		return false;
+
+	rp = (struct hci_rp_read_local_version *)skb->data;
+	if (le16_to_cpu(rp->hci_rev) == 0x98d7 &&
+	    le16_to_cpu(rp->lmp_subver) == 0x081e)
+		ret = true;
+
+	kfree_skb(skb);
+
+	return ret;
+}
+
 void btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)
 {
+	if (btrtl_fw_can_ignore_bt_dis(hdev))
+		btrealtek_set_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS);
+
 	/* Enable controller to do both LE scan and BR/EDR inquiry
 	 * simultaneously.
 	 */
@@ -1495,6 +1587,58 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
 
+int btrtl_early_suspend(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask |= RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_early_suspend);
+
+int btrtl_late_resume(struct hci_dev *hdev)
+{
+	int ret = 0;
+	u16 ignore_mask;
+	u8 buf[2];
+
+	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
+		return -EOPNOTSUPP;
+
+	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
+		return 0;
+
+	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		return ret;
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask &= ~RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(btrtl_late_resume);
+
 MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
 MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
 MODULE_VERSION(VERSION);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index a2d9d34f9fb0..61be34ccb625 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -105,6 +105,7 @@ struct rtl_vendor_cmd {
 
 enum {
 	REALTEK_ALT6_CONTINUOUS_TX_CHIP,
+	REALTEK_CAN_IGNORE_BT_DIS,
 
 	__REALTEK_NUM_FLAGS,
 };
@@ -148,6 +149,8 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 			    unsigned int *controller_baudrate,
 			    u32 *device_baudrate, bool *flow_control);
 void btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name);
+int btrtl_early_suspend(struct hci_dev *hdev);
+int btrtl_late_resume(struct hci_dev *hdev);
 
 #else
 
@@ -195,4 +198,14 @@ static inline void btrtl_set_driver_name(struct hci_dev *hdev, const char *drive
 {
 }
 
+static inline int btrtl_early_suspend(struct hci_dev *hdev, pm_message_t message)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int btrtl_late_resume(struct hci_dev *hdev)
+{
+	return -EOPNOTSUPP;
+}
+
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index e7a0c60286d5..cffd9b1fd588 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -942,9 +942,11 @@ struct btusb_data {
 
 	int (*setup_on_usb)(struct hci_dev *hdev);
 
+	int (*early_suspend)(struct hci_dev *hdev);
 	int (*suspend)(struct hci_dev *hdev);
 	int (*resume)(struct hci_dev *hdev);
 	int (*disconnect)(struct hci_dev *hdev);
+	int (*late_resume)(struct hci_dev *hdev);
 
 	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 
@@ -4218,6 +4220,8 @@ static int btusb_probe(struct usb_interface *intf,
 		hdev->shutdown = btrtl_shutdown_realtek;
 		hdev->reset = btusb_rtl_reset;
 		hdev->hw_error = btusb_rtl_hw_error;
+		data->early_suspend = btrtl_early_suspend;
+		data->late_resume = btrtl_late_resume;
 
 		/* Realtek devices need to set remote wakeup on auto-suspend */
 		set_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);
@@ -4383,6 +4387,8 @@ static void btusb_disconnect(struct usb_interface *intf)
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
+	struct hci_dev *hdev = data->hdev;
+	int ret = 0;
 
 	BT_DBG("intf %p", intf);
 
@@ -4395,6 +4401,11 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	if (data->suspend_count++)
 		return 0;
 
+	if (data->early_suspend)
+		ret = data->early_suspend(hdev);
+	if (ret && ret != -EOPNOTSUPP)
+		return ret;
+
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -4522,6 +4533,11 @@ static int btusb_resume(struct usb_interface *intf)
 	spin_unlock_irq(&data->txlock);
 	schedule_work(&data->work);
 
+	if (data->late_resume)
+		err = data->late_resume(hdev);
+	if (err && err != -EOPNOTSUPP)
+		goto done;
+
 	return 0;
 
 failed:
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Sat, 9 Dec 2023 20:03:30 +0200
Subject: [NOT-FOR-UPSTREAM] ASoC: amd: acp: Use correct DAI link ID for BT
 codec

Commit 671dd2ffbd8b ("ASoC: amd: acp: Add new cpu dai and dailink
creation for I2S BT instance") added I2S BT support in ACP common
machine driver, but using an unexpected BT_BE_ID set to 3 instead of 2:

[ 7.799659] snd_sof_amd_vangogh 0000:04:00.5: Firmware info: version 0:0:0-7863d
[ 7.803906] snd_sof_amd_vangogh 0000:04:00.5: Firmware: ABI 3:26:0 Kernel ABI 3:23:0
[ 7.872873] snd_sof_amd_vangogh 0000:04:00.5: Topology: ABI 3:26:0 Kernel ABI 3:23:0
[ 8.508218] sof_mach nau8821-max: ASoC: physical link acp-bt-codec (id 2) not exist
[ 8.513468] sof_mach nau8821-max: ASoC: topology: could not load header: -22
[ 8.518853] snd_sof_amd_vangogh 0000:04:00.5: error: tplg component load failed -22
[ 8.524049] snd_sof_amd_vangogh 0000:04:00.5: error: failed to load DSP topology -22
[ 8.529230] snd_sof_amd_vangogh 0000:04:00.5: ASoC: error at snd_soc_component_probe on 0000:04:00.5: -22
[ 8.534465] sof_mach nau8821-max: ASoC: failed to instantiate card -22
[ 8.539820] sof_mach nau8821-max: error -EINVAL: Failed to register card(sof-nau8821-max)
[ 8.545022] sof_mach: probe of nau8821-max failed with error -22

Move BT_BE_ID to position 2 in the enum, as expected by the current
topology found on Steam Deck.

Note this is not accepted upstream as it would break the other devices
which rely on BT_BE_ID set to 3.  The proper solution would be to update
the topology file on Steam Deck.

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/amd/acp/acp-mach.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sound/soc/amd/acp/acp-mach.h b/sound/soc/amd/acp/acp-mach.h
index f94c30c20f20..c3b3f047969c 100644
--- a/sound/soc/amd/acp/acp-mach.h
+++ b/sound/soc/amd/acp/acp-mach.h
@@ -29,8 +29,8 @@
 enum be_id {
 	HEADSET_BE_ID = 0,
 	AMP_BE_ID,
-	DMIC_BE_ID,
 	BT_BE_ID,
+	DMIC_BE_ID,
 };
 
 enum cpu_endpoints {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ethan Geller <ethang@valvesoftware.com>
Date: Fri, 18 Oct 2024 22:14:18 +0000
Subject: [NOT-FOR-UPSTREAM] ASoC: nau8821: Reset 8821 clock on start

This fixes the 3.5mm sound hissing bug, it is unclear if this needs to stay
or get fixed in FW, as of now.

Signed-off-by: Ethan Geller <ethang@valvesoftware.com>
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 sound/soc/codecs/nau8821.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/sound/soc/codecs/nau8821.c b/sound/soc/codecs/nau8821.c
index edb95f869a4a..52791d270a3b 100644
--- a/sound/soc/codecs/nau8821.c
+++ b/sound/soc/codecs/nau8821.c
@@ -1412,6 +1412,10 @@ static int nau8821_set_fll(struct snd_soc_component *component,
 	mdelay(2);
 	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);
+	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
+		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_MCLK);
+	regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
+		NAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);
 
 	return 0;
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Tue, 18 Feb 2025 19:24:07 +0000
Subject: fixup! [FOR-UPSTREAM] Bluetooth: btrtl: add suspend handling to
 ignore BT_DIS

Turns out 5/7 call chains that can lead to the close flushing the
request work come from another work item, most of which don't set any
state that we can gate the enabling on.

Given the number of possible paths that this can end up with a guranteed
lock inversion issue, it seems more prudent to rely on the same
guarantees that made the original btrtl code not need to lock, which
was to only do requests at start of day before registering with the
HCI subsystem so that no lock taking is ever required.

This commit simplifies the design considerably, and avoids any chance
of the lock inversion happing.

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
---
 drivers/bluetooth/btrtl.c | 107 +++++++++-----------------------------
 drivers/bluetooth/btrtl.h |  13 -----
 drivers/bluetooth/btusb.c |  16 ------
 3 files changed, 24 insertions(+), 112 deletions(-)

diff --git a/drivers/bluetooth/btrtl.c b/drivers/bluetooth/btrtl.c
index d695f46ea5cd..fbe29cb762b0 100644
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@ -443,18 +443,6 @@ static int btrtl_vendor_read_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
-static int btrtl_vendor_read_reg16_unlocked(struct hci_dev *hdev,
-					    struct rtl_vendor_cmd *cmd, u8 *rp)
-{
-	int ret;
-
-	hci_req_sync_lock(hdev);
-	ret = btrtl_vendor_read_reg16(hdev, cmd, rp);
-	hci_req_sync_unlock(hdev);
-
-	return ret;
-}
-
 static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
 				    struct rtl_vendor_cmd *cmd, const u8 * const rp)
 {
@@ -483,18 +471,6 @@ static int btrtl_vendor_write_reg16(struct hci_dev *hdev,
 	return 0;
 }
 
-static int btrtl_vendor_write_reg16_unlocked(struct hci_dev *hdev,
-					    struct rtl_vendor_cmd *cmd, u8 *rp)
-{
-	int ret;
-
-	hci_req_sync_lock(hdev);
-	ret = btrtl_vendor_write_reg16(hdev, cmd, rp);
-	hci_req_sync_unlock(hdev);
-
-	return ret;
-}
-
 static void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)
 {
 	void *data = iov->data;
@@ -1348,33 +1324,49 @@ static const struct dmi_system_id btrtl_can_ignore_bt_dis_table[] = {
 	{}
 };
 
-static bool btrtl_fw_can_ignore_bt_dis(struct hci_dev *hdev)
+static void btrtl_handle_fw_can_ignore_bt_dis(struct hci_dev *hdev)
 {
 	struct sk_buff *skb;
 	struct hci_rp_read_local_version *rp;
-	bool ret = false;
+	bool can_ignore = false;
+	u16 ignore_mask;
+	u8 buf[2];
+	int ret;
 
 	if (!dmi_check_system(btrtl_can_ignore_bt_dis_table))
-		return false;
+		return;
 
 	skb = btrtl_read_local_version(hdev);
 	if (IS_ERR(skb))
-		return false;
+		return;
 
 	rp = (struct hci_rp_read_local_version *)skb->data;
 	if (le16_to_cpu(rp->hci_rev) == 0x98d7 &&
 	    le16_to_cpu(rp->lmp_subver) == 0x081e)
-		ret = true;
+		can_ignore = true;
 
 	kfree_skb(skb);
+	if (!can_ignore)
+		return;
 
-	return ret;
+	ret = btrtl_vendor_read_reg16(hdev, RTL_IGNORE_MASK, buf);
+	if (ret) {
+		rtl_dev_warn(hdev, "failed to read ignore mask, will not wake on bluetooth");
+		return;
+	}
+
+	ignore_mask = get_unaligned_le16(buf);
+	ignore_mask |= RTL_IGNORE_BT_DIS;
+	put_unaligned_le16(ignore_mask, buf);
+
+	ret = btrtl_vendor_write_reg16(hdev, RTL_IGNORE_MASK, buf);
+	if (ret)
+		rtl_dev_warn(hdev, "failed to write ignore mask, will not wake on bluetooth");
 }
 
 void btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)
 {
-	if (btrtl_fw_can_ignore_bt_dis(hdev))
-		btrealtek_set_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS);
+	btrtl_handle_fw_can_ignore_bt_dis(hdev);
 
 	/* Enable controller to do both LE scan and BR/EDR inquiry
 	 * simultaneously.
@@ -1587,57 +1579,6 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 }
 EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
 
-int btrtl_early_suspend(struct hci_dev *hdev)
-{
-	int ret = 0;
-	u16 ignore_mask;
-	u8 buf[2];
-
-	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
-		return -EOPNOTSUPP;
-
-	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
-		return 0;
-
-	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-	if (ret)
-		return ret;
-
-	ignore_mask = get_unaligned_le16(buf);
-	ignore_mask |= RTL_IGNORE_BT_DIS;
-	put_unaligned_le16(ignore_mask, buf);
-
-	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(btrtl_early_suspend);
-
-int btrtl_late_resume(struct hci_dev *hdev)
-{
-	int ret = 0;
-	u16 ignore_mask;
-	u8 buf[2];
-
-	if (!btrealtek_test_flag(hdev, REALTEK_CAN_IGNORE_BT_DIS))
-		return -EOPNOTSUPP;
-
-	if (hci_dev_test_flag(hdev, HCI_POWERING_DOWN))
-		return 0;
-
-	ret = btrtl_vendor_read_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-	if (ret)
-		return ret;
-
-	ignore_mask = get_unaligned_le16(buf);
-	ignore_mask &= ~RTL_IGNORE_BT_DIS;
-	put_unaligned_le16(ignore_mask, buf);
-
-	ret = btrtl_vendor_write_reg16_unlocked(hdev, RTL_IGNORE_MASK, buf);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(btrtl_late_resume);
 
 MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
 MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
diff --git a/drivers/bluetooth/btrtl.h b/drivers/bluetooth/btrtl.h
index 61be34ccb625..a2d9d34f9fb0 100644
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@ -105,7 +105,6 @@ struct rtl_vendor_cmd {
 
 enum {
 	REALTEK_ALT6_CONTINUOUS_TX_CHIP,
-	REALTEK_CAN_IGNORE_BT_DIS,
 
 	__REALTEK_NUM_FLAGS,
 };
@@ -149,8 +148,6 @@ int btrtl_get_uart_settings(struct hci_dev *hdev,
 			    unsigned int *controller_baudrate,
 			    u32 *device_baudrate, bool *flow_control);
 void btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name);
-int btrtl_early_suspend(struct hci_dev *hdev);
-int btrtl_late_resume(struct hci_dev *hdev);
 
 #else
 
@@ -198,14 +195,4 @@ static inline void btrtl_set_driver_name(struct hci_dev *hdev, const char *drive
 {
 }
 
-static inline int btrtl_early_suspend(struct hci_dev *hdev, pm_message_t message)
-{
-	return -EOPNOTSUPP;
-}
-
-static inline int btrtl_late_resume(struct hci_dev *hdev)
-{
-	return -EOPNOTSUPP;
-}
-
 #endif
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index cffd9b1fd588..e7a0c60286d5 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -942,11 +942,9 @@ struct btusb_data {
 
 	int (*setup_on_usb)(struct hci_dev *hdev);
 
-	int (*early_suspend)(struct hci_dev *hdev);
 	int (*suspend)(struct hci_dev *hdev);
 	int (*resume)(struct hci_dev *hdev);
 	int (*disconnect)(struct hci_dev *hdev);
-	int (*late_resume)(struct hci_dev *hdev);
 
 	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 
@@ -4220,8 +4218,6 @@ static int btusb_probe(struct usb_interface *intf,
 		hdev->shutdown = btrtl_shutdown_realtek;
 		hdev->reset = btusb_rtl_reset;
 		hdev->hw_error = btusb_rtl_hw_error;
-		data->early_suspend = btrtl_early_suspend;
-		data->late_resume = btrtl_late_resume;
 
 		/* Realtek devices need to set remote wakeup on auto-suspend */
 		set_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);
@@ -4387,8 +4383,6 @@ static void btusb_disconnect(struct usb_interface *intf)
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
-	struct hci_dev *hdev = data->hdev;
-	int ret = 0;
 
 	BT_DBG("intf %p", intf);
 
@@ -4401,11 +4395,6 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	if (data->suspend_count++)
 		return 0;
 
-	if (data->early_suspend)
-		ret = data->early_suspend(hdev);
-	if (ret && ret != -EOPNOTSUPP)
-		return ret;
-
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &data->flags);
@@ -4533,11 +4522,6 @@ static int btusb_resume(struct usb_interface *intf)
 	spin_unlock_irq(&data->txlock);
 	schedule_work(&data->work);
 
-	if (data->late_resume)
-		err = data->late_resume(hdev);
-	if (err && err != -EOPNOTSUPP)
-		goto done;
-
 	return 0;
 
 failed:
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Swapnil Patel <swapatel@amd.com>
Date: Tue, 21 Nov 2023 17:00:14 -0500
Subject: [HACK] Add 2s delay before enabling DP link for dock

---
 .../gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c    | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
index c69194e04ff9..672cc5cbe647 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
@@ -96,6 +96,8 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+static const uint8_t DP_SINK_BRANCH_DEV_NAME_KT50X0[] = "KT50X0!";
+
 struct dce110_hw_seq_reg_offsets {
 	uint32_t crtc;
 };
@@ -3271,6 +3273,13 @@ void dce110_enable_dp_link_output(
 			link->dc->res_pool->dp_clock_source;
 	const struct link_hwss *link_hwss = get_link_hwss(link, link_res);
 	unsigned int i;
+	if (link->ctx->dce_version == DCN_VERSION_3_01 &&
+	    link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_0060AD &&
+	    memcmp(&link->dpcd_caps.branch_dev_name,
+		   DP_SINK_BRANCH_DEV_NAME_KT50X0,
+		   sizeof(link->dpcd_caps.branch_dev_name)) == 0) {
+		msleep(2000);
+	}
 
 	/*
 	 * Add the logic to extract BOTH power up and power down sequences
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andres Rodriguez <andresx7@gmail.com>
Date: Tue, 8 Nov 2022 17:32:25 -0500
Subject: mmc: core: add safe_trim_quirk attribute

This attribute is intended to be used by userspace tools to identify
if trimming a device is safe or not. It helps in cases where a
userspace tool is aware of the necessity of the quirk and a user
accidentally downgrades their kernel to a one that doesn't have
support for the quirk.

Signed-off-by: Andres Rodriguez <andresx7@gmail.com>
(cherry picked from commit dfc5952c55f58d0e0863ccba0aa598fdae16ed14)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/mmc/core/mmc.c    | 2 ++
 drivers/mmc/core/quirks.h | 2 ++
 drivers/mmc/core/sd.c     | 2 ++
 include/linux/mmc/card.h  | 1 +
 4 files changed, 7 insertions(+)

diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 5be9b42d5057..e67d39ecd63f 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -816,6 +816,7 @@ MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
 MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
 MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
 MMC_DEV_ATTR(cmdq_en, "%d\n", card->ext_csd.cmdq_en);
+MMC_DEV_ATTR(safe_trim_quirk, "%d\n", card->safe_trim_quirk_version);
 
 static ssize_t mmc_fwrev_show(struct device *dev,
 			      struct device_attribute *attr,
@@ -875,6 +876,7 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_rca.attr,
 	&dev_attr_dsr.attr,
 	&dev_attr_cmdq_en.attr,
+	&dev_attr_safe_trim_quirk.attr,
 	NULL,
 };
 ATTRIBUTE_GROUPS(mmc_std);
diff --git a/drivers/mmc/core/quirks.h b/drivers/mmc/core/quirks.h
index c417ed34c057..e6c5eca9d508 100644
--- a/drivers/mmc/core/quirks.h
+++ b/drivers/mmc/core/quirks.h
@@ -264,4 +264,6 @@ static inline void mmc_fixup_device(struct mmc_card *card,
 		dev_dbg(&card->dev, "calling %ps\n", f->vendor_fixup);
 		f->vendor_fixup(card, f->data);
 	}
+
+	card->safe_trim_quirk_version = 1;
 }
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index ec02067f03c5..9a726ef9eb3d 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -730,6 +730,7 @@ MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
 MMC_DEV_ATTR(ocr, "0x%08x\n", card->ocr);
 MMC_DEV_ATTR(rca, "0x%04x\n", card->rca);
+MMC_DEV_ATTR(safe_trim_quirk, "%d\n", card->safe_trim_quirk_version);
 
 
 static ssize_t mmc_dsr_show(struct device *dev, struct device_attribute *attr,
@@ -792,6 +793,7 @@ static struct attribute *sd_std_attrs[] = {
 	&dev_attr_ocr.attr,
 	&dev_attr_rca.attr,
 	&dev_attr_dsr.attr,
+	&dev_attr_safe_trim_quirk.attr,
 	NULL,
 };
 
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index ddcdf23d731c..a01c02681776 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -309,6 +309,7 @@ struct mmc_card {
 	unsigned int		state;		/* (our) card state */
 	unsigned int		quirks; 	/* card quirks */
 	unsigned int		quirk_max_rate;	/* max rate set by quirks */
+	unsigned int		safe_trim_quirk_version; /* advertise if we have protection for cards which misbehave with trim */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
 						/* for byte mode */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Zhan Liu <zhan.liu@amd.com>
Date: Thu, 27 Jan 2022 20:39:46 -0500
Subject: drm/amd/display: keep eDP Vdd on when eDP stream is already enabled

[Why]
Even if can_apply_edp_fast_boot is set to 1 at boot, this flag will
be cleared to 0 at S3 resume.

[How]
Keep eDP Vdd on when eDP stream is already enabled.

Change-Id: Idfecaac45e5ec39c5a2a4eaf9f3afa50063cfe1b
Link: https://gitlab.steamos.cloud/jupiter/tasks/uploads/d0998325ac80e21e50476749c32c16ba/0001-drm-amd-display-keep-eDP-Vdd-on-when-eDP-stream-is-a.patch
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 .../amd/display/dc/hwss/dce110/dce110_hwseq.c | 24 +++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
index 672cc5cbe647..69725b0304f1 100644
--- a/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c
@@ -1971,9 +1971,29 @@ void dce110_enable_accelerated_mode(struct dc *dc, struct dc_state *context)
 				break;
 			}
 		}
-		// We are trying to enable eDP, don't power down VDD
-		if (can_apply_edp_fast_boot)
+
+		/*
+		 * TO-DO: So far the code logic below only addresses single eDP case.
+		 * For dual eDP case, there are a few things that need to be
+		 * implemented first:
+		 *
+		 * 1. Change the fastboot logic above, so eDP link[0 or 1]'s
+		 * stream[0 or 1] will all be checked.
+		 *
+		 * 2. Change keep_edp_vdd_on to an array, and maintain keep_edp_vdd_on
+		 * for each eDP.
+		 *
+		 * Once above 2 things are completed, we can then change the logic below
+		 * correspondingly, so dual eDP case will be fully covered.
+		 */
+
+		// We are trying to enable eDP, don't power down VDD if eDP stream is existing
+		if ((edp_stream_num == 1 && edp_streams[0] != NULL) || can_apply_edp_fast_boot) {
 			keep_edp_vdd_on = true;
+			DC_LOG_EVENT_LINK_TRAINING("Keep eDP Vdd on\n");
+		} else {
+			DC_LOG_EVENT_LINK_TRAINING("No eDP stream enabled, turn eDP Vdd off\n");
+		}
 	}
 
 	// Check seamless boot support
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Swapnil Patel <Swapnil.Patel@amd.com>
Date: Thu, 29 Sep 2022 15:56:05 -0400
Subject: amd/display: Increased DP Alt mode timeout from 200ms to 500ms.
 SWDEV-358114

(cherry picked from commit 69adff1e215ea0d12569053ae2948681b80acda5)
[Fwd-ported to DC_VER 3.2.237]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/amd/display/dc/link/link_detection.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/display/dc/link/link_detection.c b/drivers/gpu/drm/amd/display/dc/link/link_detection.c
index 827b630daf49..a10242ed9598 100644
--- a/drivers/gpu/drm/amd/display/dc/link/link_detection.c
+++ b/drivers/gpu/drm/amd/display/dc/link/link_detection.c
@@ -638,7 +638,7 @@ static bool wait_for_entering_dp_alt_mode(struct dc_link *link)
 	 * 500 microseconds * 400 tries us 200 ms
 	 **/
 	unsigned int sleep_time_in_microseconds = 500;
-	unsigned int tries_allowed = 400;
+	unsigned int tries_allowed = 1000;
 	bool is_in_alt_mode;
 	unsigned long long enter_timestamp;
 	unsigned long long finish_timestamp;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Swapnil Patel <swapatel@amd.com>
Date: Thu, 2 Nov 2023 16:16:49 -0400
Subject: Disable modes with >1200 MHz Pixel clocks when connected via dock

---
 drivers/gpu/drm/amd/display/dc/link/link_validation.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/dc/link/link_validation.c b/drivers/gpu/drm/amd/display/dc/link/link_validation.c
index aecaf37eee35..58d69ddc14f9 100644
--- a/drivers/gpu/drm/amd/display/dc/link/link_validation.c
+++ b/drivers/gpu/drm/amd/display/dc/link/link_validation.c
@@ -35,6 +35,8 @@
 
 #define DC_LOGGER_INIT(logger)
 
+static const uint8_t DP_SINK_BRANCH_DEV_NAME_KT50X0[] = "KT50X0!";
+
 static uint32_t get_tmds_output_pixel_clock_100hz(const struct dc_crtc_timing *timing)
 {
 
@@ -292,6 +294,15 @@ static bool dp_validate_mode_timing(
 		timing->v_addressable == (uint32_t) 480)
 		return true;
 
+	if (link->ctx->dce_version == DCN_VERSION_3_01 &&
+	    link->dpcd_caps.sink_dev_id == DP_BRANCH_DEVICE_ID_0060AD &&
+	    memcmp(&link->dpcd_caps.branch_dev_name,
+		   DP_SINK_BRANCH_DEV_NAME_KT50X0,
+		   sizeof(link->dpcd_caps.branch_dev_name)) == 0) {
+		if (timing->pix_clk_100hz / 10 >= (uint32_t) 1200000)
+			return false; /* KT50X0 does not support Pxl clock >= 1200MHz */
+	}
+
 	link_setting = dp_get_verified_link_cap(link);
 
 	/* TODO: DYNAMIC_VALIDATION needs to be implemented */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joshua Ashton <joshua@froggi.es>
Date: Tue, 13 Feb 2024 18:28:41 +0000
Subject: drm/amd/display: Enable 3 overlay planes for Steam Deck

---
 drivers/gpu/drm/amd/display/dc/dc.h                         | 2 +-
 .../drm/amd/display/dc/resource/dcn301/dcn301_resource.c    | 6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/dc/dc.h b/drivers/gpu/drm/amd/display/dc/dc.h
index 8c230cf8939b..8ae9d550afdf 100644
--- a/drivers/gpu/drm/amd/display/dc/dc.h
+++ b/drivers/gpu/drm/amd/display/dc/dc.h
@@ -60,7 +60,7 @@ struct dmub_notification;
 /**
  * MAX_SURFACES - representative of the upper bound of surfaces that can be piped to a single CRTC
  */
-#define MAX_SURFACES 4
+#define MAX_SURFACES 6
 /**
  * MAX_PLANES - representative of the upper bound of planes that are supported by the HW
  */
diff --git a/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c b/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
index 82a205a7c25c..13e4a0e2e4df 100644
--- a/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/resource/dcn301/dcn301_resource.c
@@ -1437,9 +1437,9 @@ static bool dcn301_resource_construct(
 	dc->caps.max_cursor_size = 256;
 	dc->caps.min_horizontal_blanking_period = 80;
 	dc->caps.dmdata_alloc_size = 2048;
-	dc->caps.max_slave_planes = 2;
-	dc->caps.max_slave_yuv_planes = 2;
-	dc->caps.max_slave_rgb_planes = 2;
+	dc->caps.max_slave_planes = 3;
+	dc->caps.max_slave_yuv_planes = 3;
+	dc->caps.max_slave_rgb_planes = 3;
 	dc->caps.is_apu = true;
 	dc->caps.post_blend_color_processing = true;
 	dc->caps.force_dp_tps4_for_cp2520 = true;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Robert Beckett <bob.beckett@collabora.com>
Date: Tue, 9 Apr 2024 18:05:12 +0100
Subject: drm: fix drm lastclose ignoring closed active fbs

when fb's have been marked as closed, if there is still something active
then don't restore fbdev during lastclose

Signed-off-by: Robert Beckett <bob.beckett@collabora.com>
(cherry picked from commit b8d24b23b0f95af6e912dc0f43244f59ec083d06)
[fwd-ported on v6.11]
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/drm_fb_helper.c |  3 +++
 drivers/gpu/drm/drm_plane.c     | 21 +++++++++++++++++++++
 include/drm/drm_plane.h         |  2 ++
 3 files changed, 26 insertions(+)

diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c
index 11a5b60cb9ce..c9063355b340 100644
--- a/drivers/gpu/drm/drm_fb_helper.c
+++ b/drivers/gpu/drm/drm_fb_helper.c
@@ -1983,6 +1983,9 @@ EXPORT_SYMBOL(drm_fb_helper_hotplug_event);
  */
 void drm_fb_helper_lastclose(struct drm_device *dev)
 {
+	if (drm_has_active_plane(dev))
+		return;
+
 	drm_fb_helper_restore_fbdev_mode_unlocked(dev->fb_helper);
 }
 EXPORT_SYMBOL(drm_fb_helper_lastclose);
diff --git a/drivers/gpu/drm/drm_plane.c b/drivers/gpu/drm/drm_plane.c
index 38f82391bfda..9f992bbc02e0 100644
--- a/drivers/gpu/drm/drm_plane.c
+++ b/drivers/gpu/drm/drm_plane.c
@@ -984,6 +984,27 @@ static int __setplane_check(struct drm_plane *plane,
 	return 0;
 }
 
+/**
+ * drm_has_active_plane - check whether any planes are currently active
+ * @dev: the DRM device
+ *
+ * Return true if any planes are currently active
+ */
+bool drm_has_active_plane(struct drm_device *dev)
+{
+	struct drm_plane *plane;
+
+	drm_for_each_plane(plane, dev) {
+		if (plane->state && plane->state->crtc && plane->state->fb)
+			return true;
+		if (plane->crtc && plane->fb)
+			return true;
+	}
+
+	return false;
+}
+EXPORT_SYMBOL(drm_has_active_plane);
+
 /**
  * drm_any_plane_has_format - Check whether any plane supports this format and modifier combination
  * @dev: DRM device
diff --git a/include/drm/drm_plane.h b/include/drm/drm_plane.h
index 01479dd94e76..baa29357085a 100644
--- a/include/drm/drm_plane.h
+++ b/include/drm/drm_plane.h
@@ -989,6 +989,8 @@ static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
 #define drm_for_each_plane(plane, dev) \
 	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head)
 
+bool drm_has_active_plane(struct drm_device *dev);
+
 bool drm_plane_has_format(struct drm_plane *plane,
 			  u32 format, u64 modifier);
 bool drm_any_plane_has_format(struct drm_device *dev,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Friedrich Vock <friedrich.vock@gmx.de>
Date: Thu, 20 Jun 2024 14:12:15 +0200
Subject: drm/amdgpu: Don't use doorbells for SDMA 5.2

There seems to be a race condition and they can cause hangs in rare
scenarios.

Signed-off-by: Friedrich Vock <friedrich.vock@gmx.de>
(cherry picked from commit 9264ec783c738b272d94a72542524223b65255ef)
(cherry picked from commit beec5cbd7260be325d8b20cc5314dfbd38332aae)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
index 3bd44c24f692..f1ba6a518ee5 100644
--- a/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v5_2.c
@@ -1322,7 +1322,7 @@ static int sdma_v5_2_sw_init(struct amdgpu_ip_block *ip_block)
 		adev->sdma.instance[i].funcs = &sdma_v5_2_sdma_funcs;
 		ring = &adev->sdma.instance[i].ring;
 		ring->ring_obj = NULL;
-		ring->use_doorbell = true;
+		ring->use_doorbell = false;
 		ring->me = i;
 
 		DRM_INFO("use_doorbell being set to: [%s]\n",
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Harry Wentland <harry.wentland@amd.com>
Date: Fri, 22 Mar 2024 14:53:42 -0400
Subject: drm/amd/display: Don't limit YUV420 to HDMI

Signed-off-by: Harry Wentland <harry.wentland@amd.com>
(cherry picked from commit 56c8e3cbeb24a1f15ba764bd692d5c8807bd1d55)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 58c4e57abc9e..2ae664ebcf08 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -6349,8 +6349,7 @@ static void fill_stream_properties_from_drm_display_mode(
 	timing_out->v_border_top = 0;
 	timing_out->v_border_bottom = 0;
 	/* TODO: un-hardcode */
-	if (drm_mode_is_420_only(info, mode_in)
-			&& stream->signal == SIGNAL_TYPE_HDMI_TYPE_A)
+	if (drm_mode_is_420_only(info, mode_in))
 		timing_out->pixel_encoding = PIXEL_ENCODING_YCBCR420;
 	else if (drm_mode_is_420_also(info, mode_in)
 			&& aconnector
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Hersen Wu <hersenxs.wu@amd.com>
Date: Thu, 25 May 2023 08:37:40 -0400
Subject: drm/amd/display: edp do not add non-edid timings

[Why] most edp support only timings from edid. applying
non-edid timings, especially those timings out of edp
bandwidth, may damage edp.

[How] do not add non-edid timings for edp.

Cc: Mario Limonciello <mario.limonciello@amd.com>
Cc: Alex Deucher <alexander.deucher@amd.com>
Cc: stable@vger.kernel.org
Acked-by: Stylon Wang <stylon.wang@amd.com>
Signed-off-by: Hersen Wu <hersenxs.wu@amd.com>
Reviewed-by: Roman Li <roman.li@amd.com>
Tested-by: Daniel Wheeler <daniel.wheeler@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 2ae664ebcf08..bb2443f49e84 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -8377,7 +8377,12 @@ static int amdgpu_dm_connector_get_modes(struct drm_connector *connector)
 				drm_add_modes_noedid(connector, 1920, 1080);
 	} else {
 		amdgpu_dm_connector_ddc_get_modes(connector, drm_edid);
-		if (encoder)
+		/* most eDP supports only timings from its edid,
+		 * usually only detailed timings are available
+		 * from eDP edid. timings which are not from edid
+		 * may damage eDP
+		 */
+		if (encoder && connector->connector_type != DRM_MODE_CONNECTOR_eDP)
 			amdgpu_dm_connector_add_common_modes(encoder, connector);
 		amdgpu_dm_connector_add_freesync_modes(connector, drm_edid);
 	}
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Guilherme G. Piccoli" <gpiccoli@igalia.com>
Date: Thu, 2 Nov 2023 16:28:35 -0300
Subject: [NOT-FOR-UPSTREAM] PM: suspend: Disable s2idle on Steam Decks

Combines:

[NOT-FOR-UPSTREAM] PM: suspend: Disable s2idle on Steam Deck

Jupiter platform doesn't support s2idle - system appears to
sleep and never wakeup again. So, disable it based on DMI
checking for platforms named "Valve Jupiter".

Signed-off-by: Guilherme G. Piccoli <gpiccoli@igalia.com>
(cherry picked from commit 3956de585667cfd9f91a3ee8af34f6c0d44f4381)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>

[NOT-FOR-UPSTREAM] PM: suspend: Also disable s2idle on Galileo (OLED Deck)

Reports are that s2idle might also be bogus on Galileo - since S3/deep
is tested and working, let's include the new HW in the s2idle ban.

Signed-off-by: Guilherme G. Piccoli <gpiccoli@igalia.com>
(cherry picked from commit f65259f588545c8e811a3ca4e34c2a172969dbd7)
---
 kernel/power/suspend.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index b4ca17c2fecf..9c13e819db84 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -31,6 +31,7 @@
 #include <linux/compiler.h>
 #include <linux/moduleparam.h>
 #include <linux/fs.h>
+#include <linux/dmi.h>
 
 #include "power.h"
 
@@ -61,6 +62,7 @@ static DECLARE_SWAIT_QUEUE_HEAD(s2idle_wait_head);
 
 enum s2idle_states __read_mostly s2idle_state;
 static DEFINE_RAW_SPINLOCK(s2idle_lock);
+static bool s2idle_unsupported;
 
 /**
  * pm_suspend_default_s2idle - Check if suspend-to-idle is the default suspend.
@@ -187,6 +189,8 @@ static bool valid_state(suspend_state_t state)
 
 void __init pm_states_init(void)
 {
+	const char *sys_vendor, *product_name;
+
 	/* "mem" and "freeze" are always present in /sys/power/state. */
 	pm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];
 	pm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];
@@ -195,6 +199,21 @@ void __init pm_states_init(void)
 	 * initialize mem_sleep_states[] accordingly here.
 	 */
 	mem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];
+
+	/*
+	 * Identify here if we're running on Steam Deck - if so, we shouldn't
+	 * support s2idle mem_sleep mode, since this mode doesn't work on Deck.
+	 */
+
+	sys_vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+	product_name = dmi_get_system_info(DMI_PRODUCT_NAME);
+
+	if (sys_vendor && (!strncmp("Valve", sys_vendor, 5)) &&
+	    ((product_name && (!strncmp("Jupiter", product_name, 7))) ||
+	    (product_name && (!strncmp("Galileo", product_name, 7))))) {
+		s2idle_unsupported = true;
+		pr_info("Steam Deck quirk - no s2idle allowed!\n");
+	}
 }
 
 static int __init mem_sleep_default_setup(char *str)
@@ -579,6 +598,10 @@ static int enter_state(suspend_state_t state)
 			return -EAGAIN;
 		}
 #endif
+		if (s2idle_unsupported) {
+			pr_info("s2idle sleep is not supported\n");
+			return -EINVAL;
+		}
 	} else if (!valid_state(state)) {
 		return -EINVAL;
 	}
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Pierre-Loup A. Griffais" <pgriffais@valvesoftware.com>
Date: Tue, 14 Jun 2022 14:31:18 -0700
Subject: [NOT-FOR-UPSTREAM] drivers: video: backlight: Disable backlight
 notification events

We don't want to generate udev events for brightness changes on Steam
Deck, as some games like Celeste will re-enumerate controller devices in
response to this event.

Patch from Sam Lantinga.

(cherry picked from commit 85da5a5f7b69f22f960776cde3bf5862f3613363)
Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/video/backlight/backlight.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/video/backlight/backlight.c b/drivers/video/backlight/backlight.c
index 9dc93c5e480b..05d5800c9756 100644
--- a/drivers/video/backlight/backlight.c
+++ b/drivers/video/backlight/backlight.c
@@ -115,6 +115,7 @@ EXPORT_SYMBOL(backlight_notify_blank_all);
 static void backlight_generate_event(struct backlight_device *bd,
 				     enum backlight_update_reason reason)
 {
+#if 0 // We don't want to generate udev events for brightness changes on Steam Deck, as some games like Celeste will re-enumerate controller devices in response to this event.
 	char *envp[2];
 
 	switch (reason) {
@@ -130,6 +131,7 @@ static void backlight_generate_event(struct backlight_device *bd,
 	}
 	envp[1] = NULL;
 	kobject_uevent_env(&bd->dev.kobj, KOBJ_CHANGE, envp);
+#endif // 0
 	sysfs_notify(&bd->dev.kobj, NULL, "actual_brightness");
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
Date: Fri, 4 Mar 2022 21:20:39 +0000
Subject: [NOT-FOR-UPSTREAM] ACPICA: Limit error message flood caused by
 firmware bug

The following error messages are generated because of an infinite
recursion in the latest production BIOS:

ACPI Error: Method reached maximum reentrancy limit (255) (20210331/dsmethod-309)
ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
[...]
ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)

Let's detect this and limit the amount of errors generated.

Additionally, add a kernel parameter 'acpi_no_msg_flood_detect' to
disable the detection for debugging purposes.

https://gitlab.steamos.cloud/jupiter/linux-integration/-/issues/11

Signed-off-by: Cristian Ciocaltea <cristian.ciocaltea@collabora.com>
---
 drivers/acpi/acpica/dsmethod.c |  5 ++--
 drivers/acpi/acpica/uterror.c  | 53 ++++++++++++++++++++++++++++++++++
 2 files changed, 56 insertions(+), 2 deletions(-)

diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index fef6fb29ece4..41db4f5b8e7b 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -306,8 +306,9 @@ acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,
 	/* Prevent wraparound of thread count */
 
 	if (obj_desc->method.thread_count == ACPI_UINT8_MAX) {
-		ACPI_ERROR((AE_INFO,
-			    "Method reached maximum reentrancy limit (255)"));
+		/* Suppressing this due to firmware bug flooding the logs */
+		/*ACPI_ERROR((AE_INFO,
+			    "Method reached maximum reentrancy limit (255)"));*/
 		return_ACPI_STATUS(AE_AML_METHOD_LIMIT);
 	}
 
diff --git a/drivers/acpi/acpica/uterror.c b/drivers/acpi/acpica/uterror.c
index 918aca7c4db4..4a482de2e55d 100644
--- a/drivers/acpi/acpica/uterror.c
+++ b/drivers/acpi/acpica/uterror.c
@@ -278,6 +278,56 @@ acpi_ut_namespace_error(const char *module_name,
 }
 #endif
 
+/*******************************************************************************
+ *
+ * Limit the error message flood caused by a firmware bug:
+ *
+ * ACPI Error: Method reached maximum reentrancy limit (255) (20210331/dsmethod-309)
+ * ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
+ * [...]
+ * ACPI Error: Aborting method \_SB.PCI0.LPC0.EC0.VFCD.PDVL due to previous error (AE_AML_METHOD_LIMIT) (20210331/psparse-529)
+ *
+ ******************************************************************************/
+
+static bool acpi_disable_msg_flood_detect;
+
+static int __init acpi_no_msg_flood_detect_setup(char *s)
+{
+	acpi_disable_msg_flood_detect = true;
+	pr_info("ACPI error message flood detection disabled\n");
+
+	return 0;
+}
+
+early_param("acpi_no_msg_flood_detect", acpi_no_msg_flood_detect_setup);
+
+static bool acpi_skip_print_node(struct acpi_namespace_node *node)
+{
+	static bool skip_print = false;
+	struct acpi_buffer buffer;
+	acpi_status status;
+
+	if (acpi_disable_msg_flood_detect || !node)
+		return false;
+
+	if (!skip_print) {
+		/* Convert handle to full pathname */
+		buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;
+
+		status = acpi_ns_handle_to_pathname(node, &buffer, TRUE);
+		if (ACPI_SUCCESS(status)) {
+			skip_print = !strcmp((const char *)buffer.pointer,
+					     "\\_SB.PCI0.LPC0.EC0.VFCD.PDVL");
+			ACPI_FREE(buffer.pointer);
+
+			if (skip_print)
+				return false; /* print once */
+		}
+	}
+
+	return skip_print;
+}
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ut_method_error
@@ -305,6 +355,9 @@ acpi_ut_method_error(const char *module_name,
 	acpi_status status;
 	struct acpi_namespace_node *node = prefix_node;
 
+	if (acpi_skip_print_node(node))
+		return;
+
 	ACPI_MSG_REDIRECT_BEGIN;
 	acpi_os_printf(ACPI_MSG_ERROR);
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Felix=20H=C3=A4dicke?= <felixhaedicke@web.de>
Date: Thu, 19 Nov 2020 09:22:32 +0100
Subject: HID: quirks: Add Apple Magic Trackpad 2 to hid_have_special_driver
 list
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The Apple Magic Trackpad 2 is handled by the magicmouse driver. And
there were severe stability issues when both drivers (hid-generic and
hid-magicmouse) were loaded for this device.

Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=210241

Signed-off-by: Felix Hdicke <felixhaedicke@web.de>
---
 drivers/hid/hid-quirks.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/hid/hid-quirks.c b/drivers/hid/hid-quirks.c
index ffd034566e2e..59d75fe74f02 100644
--- a/drivers/hid/hid-quirks.c
+++ b/drivers/hid/hid-quirks.c
@@ -521,6 +521,8 @@ static const struct hid_device_id hid_have_special_driver[] = {
 #if IS_ENABLED(CONFIG_HID_MAGICMOUSE)
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICMOUSE) },
 	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD) },
+	{ HID_BLUETOOTH_DEVICE(BT_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGICTRACKPAD2) },
 #endif
 #if IS_ENABLED(CONFIG_HID_MAYFLASH)
 	{ HID_USB_DEVICE(USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_PS3) },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Javier Martinez Canillas <javierm@redhat.com>
Date: Thu, 19 May 2022 14:40:07 +0200
Subject: drivers/firmware: skip simpledrm if nvidia-drm.modeset=1 is set

The Nvidia proprietary driver has some bugs that leads to issues if used
with the simpledrm driver. The most noticeable is that does not register
an emulated fbdev device.

It just relies on a fbdev to be registered by another driver, that could
be that could be attached to the framebuffer console. On UEFI machines,
this is the efifb driver.

This means that disabling the efifb driver will cause virtual consoles to
not be present in the system when using the Nvidia driver. Legacy BIOS is
not affected just because fbcon is not used there, but instead vgacon.

Unless a VGA mode is specified using the vga= kernel command line option,
in that case the vesafb driver is used instead and its fbdev attached to
the fbcon.

This is a problem because with CONFIG_SYSFB_SIMPLEFB=y, the sysfb platform
code attempts to register a "simple-framebuffer" platform device (that is
matched against simpledrm) and only registers either an "efi-framebuffer"
or "vesa-framebuffer" if this fails to be registered due the video modes
not being compatible.

The Nvidia driver relying on another driver to register the fbdev is quite
fragile, since it can't really assume those will stick around. For example
there are patches posted to remove the EFI and VESA platform devices once
a real DRM or fbdev driver probes.

But in any case, moving to a simpledrm + emulated fbdev only breaks this
assumption and causes users to not have VT if the Nvidia driver is used.

So to prevent this, let's add a workaround and make the sysfb to skip the
"simple-framebuffer" registration when nvidia-drm.modeset=1 option is set.

This is quite horrible, but honestly I can't think of any other approach.

For this to work, the CONFIG_FB_EFI and CONFIG_FB_VESA config options must
be enabled besides CONFIG_DRM_SIMPLEDRM.

Signed-off-by: Javier Martinez Canillas <javierm@redhat.com>
Cherry-picked-for: https://bugs.archlinux.org/task/73720
---
 drivers/firmware/sysfb.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/drivers/firmware/sysfb.c b/drivers/firmware/sysfb.c
index 889e5b05c739..676f363d536c 100644
--- a/drivers/firmware/sysfb.c
+++ b/drivers/firmware/sysfb.c
@@ -35,6 +35,22 @@
 #include <linux/screen_info.h>
 #include <linux/sysfb.h>
 
+static int skip_simpledrm;
+
+static int __init simpledrm_disable(char *opt)
+{
+	if (!opt)
+                return -EINVAL;
+
+	get_option(&opt, &skip_simpledrm);
+
+	if (skip_simpledrm)
+		pr_info("The simpledrm driver will not be probed\n");
+
+	return 0;
+}
+early_param("nvidia-drm.modeset", simpledrm_disable);
+
 static struct platform_device *pd;
 static DEFINE_MUTEX(disable_lock);
 static bool disabled;
@@ -165,7 +181,7 @@ static __init int sysfb_init(void)
 
 	/* try to create a simple-framebuffer device */
 	compatible = sysfb_parse_mode(si, &mode);
-	if (compatible) {
+	if (compatible && !skip_simpledrm) {
 		pd = sysfb_create_simplefb(si, &mode, parent);
 		if (!IS_ERR(pd))
 			goto put_device;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Yaroslav Bolyukin <iam@lach.pw>
Date: Sun, 30 Oct 2022 18:59:15 +0100
Subject: drm/edid: parse DRM VESA dsc bpp target

As per DisplayID v2.0 Errata E9 spec "DSC pass-through timing support"
VESA vendor-specific data block may contain target DSC bits per pixel
fields

Signed-off-by: Yaroslav Bolyukin <iam@lach.pw>
---
 drivers/gpu/drm/drm_displayid_internal.h |  4 +++
 drivers/gpu/drm/drm_edid.c               | 42 ++++++++++++++++--------
 include/drm/drm_connector.h              |  8 ++++-
 3 files changed, 39 insertions(+), 15 deletions(-)

diff --git a/drivers/gpu/drm/drm_displayid_internal.h b/drivers/gpu/drm/drm_displayid_internal.h
index 957dd0619f5c..91a2ca4c9d3a 100644
--- a/drivers/gpu/drm/drm_displayid_internal.h
+++ b/drivers/gpu/drm/drm_displayid_internal.h
@@ -144,12 +144,16 @@ struct displayid_formula_timing_block {
 
 #define DISPLAYID_VESA_MSO_OVERLAP	GENMASK(3, 0)
 #define DISPLAYID_VESA_MSO_MODE		GENMASK(6, 5)
+#define DISPLAYID_VESA_DSC_BPP_INT	GENMASK(5, 0)
+#define DISPLAYID_VESA_DSC_BPP_FRACT GENMASK(3, 0)
 
 struct displayid_vesa_vendor_specific_block {
 	struct displayid_block base;
 	u8 oui[3];
 	u8 data_structure_type;
 	u8 mso;
+	u8 dsc_bpp_int;
+	u8 dsc_bpp_fract;
 } __packed;
 
 /*
diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c
index e2e85345aa9a..1cdb22239192 100644
--- a/drivers/gpu/drm/drm_edid.c
+++ b/drivers/gpu/drm/drm_edid.c
@@ -6541,7 +6541,7 @@ static void drm_parse_vesa_mso_data(struct drm_connector *connector,
 	if (oui(vesa->oui[0], vesa->oui[1], vesa->oui[2]) != VESA_IEEE_OUI)
 		return;
 
-	if (sizeof(*vesa) != sizeof(*block) + block->num_bytes) {
+	if (block->num_bytes < 5) {
 		drm_dbg_kms(connector->dev,
 			    "[CONNECTOR:%d:%s] Unexpected VESA vendor block size\n",
 			    connector->base.id, connector->name);
@@ -6564,24 +6564,37 @@ static void drm_parse_vesa_mso_data(struct drm_connector *connector,
 		break;
 	}
 
-	if (!info->mso_stream_count) {
-		info->mso_pixel_overlap = 0;
-		return;
-	}
+	info->mso_pixel_overlap = 0;
+
+	if (info->mso_stream_count) {
+		info->mso_pixel_overlap = FIELD_GET(DISPLAYID_VESA_MSO_OVERLAP, vesa->mso);
+
+		if (info->mso_pixel_overlap > 8) {
+			drm_dbg_kms(connector->dev,
+					"[CONNECTOR:%d:%s] Reserved MSO pixel overlap value %u\n",
+					connector->base.id, connector->name,
+					info->mso_pixel_overlap);
+			info->mso_pixel_overlap = 8;
+		}
 
-	info->mso_pixel_overlap = FIELD_GET(DISPLAYID_VESA_MSO_OVERLAP, vesa->mso);
-	if (info->mso_pixel_overlap > 8) {
 		drm_dbg_kms(connector->dev,
-			    "[CONNECTOR:%d:%s] Reserved MSO pixel overlap value %u\n",
-			    connector->base.id, connector->name,
-			    info->mso_pixel_overlap);
-		info->mso_pixel_overlap = 8;
+				"[CONNECTOR:%d:%s] MSO stream count %u, pixel overlap %u\n",
+				connector->base.id, connector->name,
+				info->mso_stream_count, info->mso_pixel_overlap);
+	}
+
+	if (block->num_bytes < 7) {
+		/* DSC bpp is optional */
+		return;
 	}
 
+	info->dp_dsc_bpp = FIELD_GET(DISPLAYID_VESA_DSC_BPP_INT, vesa->dsc_bpp_int) * 16 +
+		FIELD_GET(DISPLAYID_VESA_DSC_BPP_FRACT, vesa->dsc_bpp_fract);
+
 	drm_dbg_kms(connector->dev,
-		    "[CONNECTOR:%d:%s] MSO stream count %u, pixel overlap %u\n",
-		    connector->base.id, connector->name,
-		    info->mso_stream_count, info->mso_pixel_overlap);
+		"[CONNECTOR:%d:%s] DSC bits per pixel %u\n",
+		connector->base.id, connector->name,
+		info->dp_dsc_bpp);
 }
 
 static void drm_update_mso(struct drm_connector *connector,
@@ -6630,6 +6643,7 @@ static void drm_reset_display_info(struct drm_connector *connector)
 	info->mso_stream_count = 0;
 	info->mso_pixel_overlap = 0;
 	info->max_dsc_bpp = 0;
+	info->dp_dsc_bpp = 0;
 
 	kfree(info->vics);
 	info->vics = NULL;
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index 8f34f4b8183d..a2200aa92705 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -836,7 +836,13 @@ struct drm_display_info {
 	 * monitor's default value is used instead.
 	 */
 	u32 max_dsc_bpp;
-
+	
+	/**
+	 * @dp_dsc_bpp: DP Display-Stream-Compression (DSC) timing's target
+	 * DST bits per pixel in 6.4 fixed point format. 0 means undefined
+	 */
+	u16 dp_dsc_bpp;
+	    
 	/**
 	 * @vics: Array of vics_len VICs. Internal to EDID parsing.
 	 */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Yaroslav Bolyukin <iam@lach.pw>
Date: Sun, 30 Oct 2022 19:04:26 +0100
Subject: drm/amd: use fixed dsc bits-per-pixel from edid

VESA vendor header from DisplayID spec may contain fixed bit per pixel
rate, it should be respected by drm driver

Signed-off-by: Yaroslav Bolyukin <iam@lach.pw>
Reviewed-by: Wayne Lin <Wayne.Lin@amd.com>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c | 2 ++
 drivers/gpu/drm/amd/display/dc/core/dc_stream.c           | 2 ++
 drivers/gpu/drm/amd/display/dc/dc_types.h                 | 3 +++
 3 files changed, 7 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
index 9e3e51a2dc49..978e6e540578 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c
@@ -138,6 +138,8 @@ enum dc_edid_status dm_helpers_parse_edid_caps(
 
 	apply_edid_quirks(dev, edid_buf, edid_caps);
 
+	edid_caps->dsc_fixed_bits_per_pixel_x16 = connector->display_info.dp_dsc_bpp;
+
 	sad_count = drm_edid_to_sad((struct edid *) edid->raw_edid, &sads);
 	if (sad_count <= 0)
 		return result;
diff --git a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
index 9ac2d41f8fca..93ce0ceb3786 100644
--- a/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_stream.c
@@ -110,6 +110,8 @@ bool dc_stream_construct(struct dc_stream_state *stream,
 
 	/* EDID CAP translation for HDMI 2.0 */
 	stream->timing.flags.LTE_340MCSC_SCRAMBLE = dc_sink_data->edid_caps.lte_340mcsc_scramble;
+	stream->timing.dsc_fixed_bits_per_pixel_x16 =
+		dc_sink_data->edid_caps.dsc_fixed_bits_per_pixel_x16;
 
 	memset(&stream->timing.dsc_cfg, 0, sizeof(stream->timing.dsc_cfg));
 	stream->timing.dsc_cfg.num_slices_h = 0;
diff --git a/drivers/gpu/drm/amd/display/dc/dc_types.h b/drivers/gpu/drm/amd/display/dc/dc_types.h
index 375ca2f13b7a..6abefba6ae82 100644
--- a/drivers/gpu/drm/amd/display/dc/dc_types.h
+++ b/drivers/gpu/drm/amd/display/dc/dc_types.h
@@ -213,6 +213,9 @@ struct dc_edid_caps {
 	bool hdr_supported;
 	bool rr_capable;
 
+	/* DisplayPort caps */
+	uint32_t dsc_fixed_bits_per_pixel_x16;
+
 	struct dc_panel_patch panel_patch;
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Denis <benato.denis96@gmail.com>
Date: Thu, 28 Sep 2023 03:40:53 +0200
Subject: [NOT FOR UPSTREAM] add acpi_call module

---
 drivers/platform/x86/Kconfig     |   5 +
 drivers/platform/x86/Makefile    |   4 +
 drivers/platform/x86/acpi_call.c | 449 +++++++++++++++++++++++++++++++
 3 files changed, 458 insertions(+)
 create mode 100644 drivers/platform/x86/acpi_call.c

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 6d238e120dce..f0d9ad99cd7a 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -164,6 +164,11 @@ config ACER_WIRELESS
           If you choose to compile this driver as a module the module will be
           called acer-wireless.
 
+config ACPI_CALL
+	tristate "acpi_call module"
+	help
+	  This embeds acpi_call module into the kernel
+
 config ACER_WMI
 	tristate "Acer WMI Laptop Extras"
 	depends on BACKLIGHT_CLASS_DEVICE
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index a0c5848513e3..8b6d6feb2548 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -4,10 +4,14 @@
 # x86 Platform-Specific Drivers
 #
 
+# ACPI calls
+
 # Windows Management Interface
 obj-$(CONFIG_ACPI_WMI)		+= wmi.o
 obj-$(CONFIG_WMI_BMOF)		+= wmi-bmof.o
 
+obj-$(CONFIG_ACPI_CALL)		+= acpi_call.o
+
 # WMI drivers
 obj-$(CONFIG_HUAWEI_WMI)		+= huawei-wmi.o
 obj-$(CONFIG_MXM_WMI)			+= mxm-wmi.o
diff --git a/drivers/platform/x86/acpi_call.c b/drivers/platform/x86/acpi_call.c
new file mode 100644
index 000000000000..925e46b81f67
--- /dev/null
+++ b/drivers/platform/x86/acpi_call.c
@@ -0,0 +1,449 @@
+/* Copyright (c) 2010: Michal Kottman */
+
+#define BUILDING_ACPICA
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#include <asm/uaccess.h>
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+#include <linux/acpi.h>
+#else
+#include <acpi/acpi.h>
+#endif
+
+MODULE_LICENSE("GPL");
+
+/* Uncomment the following line to enable debug messages */
+/*
+#define DEBUG
+*/
+
+#define BUFFER_SIZE 4096
+#define INPUT_BUFFER_SIZE (2 * BUFFER_SIZE)
+#define MAX_ACPI_ARGS 16
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#define HAVE_PROC_CREATE
+#endif
+
+extern struct proc_dir_entry *acpi_root_dir;
+
+static char input_buffer[INPUT_BUFFER_SIZE];
+static char result_buffer[BUFFER_SIZE];
+static char not_called_message[11] = "not called";
+
+static u8 temporary_buffer[BUFFER_SIZE];
+
+static size_t get_avail_bytes(void) {
+    return BUFFER_SIZE - strlen(result_buffer);
+}
+static char *get_buffer_end(void) {
+    return result_buffer + strlen(result_buffer);
+}
+
+/** Appends the contents of an acpi_object to the result buffer
+@param result   An acpi object holding result data
+@returns        0 if the result could fully be saved, a higher value otherwise
+*/
+static int acpi_result_to_string(union acpi_object *result) {
+    if (result->type == ACPI_TYPE_INTEGER) {
+        snprintf(get_buffer_end(), get_avail_bytes(),
+            "0x%x", (int)result->integer.value);
+    } else if (result->type == ACPI_TYPE_STRING) {
+        snprintf(get_buffer_end(), get_avail_bytes(),
+            "\"%*s\"", result->string.length, result->string.pointer);
+    } else if (result->type == ACPI_TYPE_BUFFER) {
+        int i;
+        // do not store more than data if it does not fit. The first element is
+        // just 4 chars, but there is also two bytes from the curly brackets
+        int show_values = min((size_t)result->buffer.length, get_avail_bytes() / 6);
+
+        snprintf(get_buffer_end(), get_avail_bytes(), "{");
+        for (i = 0; i < show_values; i++)
+            sprintf(get_buffer_end(),
+                i == 0 ? "0x%02x" : ", 0x%02x", result->buffer.pointer[i]);
+
+        if (result->buffer.length > show_values) {
+            // if data was truncated, show a trailing comma if there is space
+            snprintf(get_buffer_end(), get_avail_bytes(), ",");
+            return 1;
+        } else {
+            // in case show_values == 0, but the buffer is too small to hold
+            // more values (i.e. the buffer cannot have anything more than "{")
+            snprintf(get_buffer_end(), get_avail_bytes(), "}");
+        }
+    } else if (result->type == ACPI_TYPE_PACKAGE) {
+        int i;
+        snprintf(get_buffer_end(), get_avail_bytes(), "[");
+        for (i=0; i<result->package.count; i++) {
+            if (i > 0)
+                snprintf(get_buffer_end(), get_avail_bytes(), ", ");
+
+            // abort if there is no more space available
+            if (!get_avail_bytes() || acpi_result_to_string(&result->package.elements[i]))
+                return 1;
+        }
+        snprintf(get_buffer_end(), get_avail_bytes(), "]");
+    } else {
+        snprintf(get_buffer_end(), get_avail_bytes(),
+            "Object type 0x%x\n", result->type);
+    }
+
+    // return 0 if there are still bytes available, 1 otherwise
+    return !get_avail_bytes();
+}
+
+/**
+@param method   The full name of ACPI method to call
+@param argc     The number of parameters
+@param argv     A pre-allocated array of arguments of type acpi_object
+*/
+static void do_acpi_call(const char * method, int argc, union acpi_object *argv)
+{
+    acpi_status status;
+    acpi_handle handle;
+    struct acpi_object_list arg;
+    struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+#ifdef DEBUG
+    printk(KERN_INFO "acpi_call: Calling %s\n", method);
+#endif
+
+    // get the handle of the method, must be a fully qualified path
+    status = acpi_get_handle(NULL, (acpi_string) method, &handle);
+
+    if (ACPI_FAILURE(status))
+    {
+        snprintf(result_buffer, BUFFER_SIZE, "Error: %s", acpi_format_exception(status));
+        printk(KERN_ERR "acpi_call: Cannot get handle: %s\n", result_buffer);
+        return;
+    }
+
+    // prepare parameters
+    arg.count = argc;
+    arg.pointer = argv;
+
+    // call the method
+    status = acpi_evaluate_object(handle, NULL, &arg, &buffer);
+    if (ACPI_FAILURE(status))
+    {
+        snprintf(result_buffer, BUFFER_SIZE, "Error: %s", acpi_format_exception(status));
+        printk(KERN_ERR "acpi_call: Method call failed: %s\n", result_buffer);
+        return;
+    }
+
+    // reset the result buffer
+    *result_buffer = '\0';
+    acpi_result_to_string(buffer.pointer);
+    kfree(buffer.pointer);
+
+#ifdef DEBUG
+    printk(KERN_INFO "acpi_call: Call successful: %s\n", result_buffer);
+#endif
+}
+
+/** Decodes 2 hex characters to an u8 int
+*/
+static u8 decodeHex(char *hex) {
+    char buf[3] = { hex[0], hex[1], 0};
+    return (u8) simple_strtoul(buf, NULL, 16);
+}
+
+/** Parses method name and arguments
+@param input Input string to be parsed. Modified in the process.
+@param nargs Set to number of arguments parsed (output)
+@param args
+*/
+static char *parse_acpi_args(char *input, int *nargs, union acpi_object **args)
+{
+    char *s = input;
+    int i;
+
+    *nargs = 0;
+    *args = NULL;
+
+    // the method name is separated from the arguments by a space
+    while (*s && *s != ' ')
+        s++;
+    // if no space is found, return 0 arguments
+    if (*s == 0)
+        return input;
+
+    *args = (union acpi_object *) kmalloc(MAX_ACPI_ARGS * sizeof(union acpi_object), GFP_KERNEL);
+    if (!*args) {
+        printk(KERN_ERR "acpi_call: unable to allocate buffer\n");
+        return NULL;
+    }
+
+    while (*s) {
+        if (*s == ' ') {
+            if (*nargs == 0)
+                *s = 0; // change first space to nul
+            ++ *nargs;
+            ++ s;
+        } else {
+            union acpi_object *arg = (*args) + (*nargs - 1);
+            if (*s == '"') {
+                // decode string
+                arg->type = ACPI_TYPE_STRING;
+                arg->string.pointer = ++s;
+                arg->string.length = 0;
+                while (*s && *s++ != '"')
+                    arg->string.length ++;
+                // skip the last "
+                if (*s == '"')
+                    ++s;
+            } else if (*s == 'b') {
+                // decode buffer - bXXXX
+                char *p = ++s;
+                int len = 0, i;
+                u8 *buf = NULL;
+
+                while (*p && *p!=' ')
+                    p++;
+
+                len = p - s;
+                if (len % 2 == 1) {
+                    printk(KERN_ERR "acpi_call: buffer arg%d is not multiple of 8 bits\n", *nargs);
+                    --*nargs;
+                    goto err;
+                }
+                len /= 2;
+
+                buf = (u8*) kmalloc(len, GFP_KERNEL);
+                if (!buf) {
+                    printk(KERN_ERR "acpi_call: unable to allocate buffer\n");
+                    --*nargs;
+                    goto err;
+                }
+                for (i=0; i<len; i++) {
+                    buf[i] = decodeHex(s + i*2);
+                }
+                s = p;
+
+                arg->type = ACPI_TYPE_BUFFER;
+                arg->buffer.pointer = buf;
+                arg->buffer.length = len;
+            } else if (*s == '{') {
+                // decode buffer - { b1, b2 ...}
+                u8 *buf = temporary_buffer;
+                arg->type = ACPI_TYPE_BUFFER;
+                arg->buffer.pointer = buf;
+                arg->buffer.length = 0;
+                while (*s && *s++ != '}') {
+                    if (buf >= temporary_buffer + sizeof(temporary_buffer)) {
+                        printk(KERN_ERR "acpi_call: buffer arg%d is truncated because the buffer is full\n", *nargs);
+                        // clear remaining arguments
+                        while (*s && *s != '}')
+                            ++s;
+                        break;
+                    }
+                    else if (*s >= '0' && *s <= '9') {
+                        // decode integer into buffer
+                        arg->buffer.length ++;
+                        if (s[0] == '0' && s[1] == 'x')
+                            *buf++ = simple_strtol(s+2, 0, 16);
+                        else
+                            *buf++ = simple_strtol(s, 0, 10);
+                    }
+                    // skip until space or comma or '}'
+                    while (*s && *s != ' ' && *s != ',' && *s != '}')
+                        ++s;
+                }
+                // store the result in new allocated buffer
+                buf = (u8*) kmalloc(arg->buffer.length, GFP_KERNEL);
+                if (!buf) {
+                    printk(KERN_ERR "acpi_call: unable to allocate buffer\n");
+                    --*nargs;
+                    goto err;
+                }
+                memcpy(buf, temporary_buffer, arg->buffer.length);
+                arg->buffer.pointer = buf;
+            } else {
+                // decode integer, N or 0xN
+                arg->type = ACPI_TYPE_INTEGER;
+                if (s[0] == '0' && s[1] == 'x') {
+                    arg->integer.value = simple_strtol(s+2, 0, 16);
+                } else {
+                    arg->integer.value = simple_strtol(s, 0, 10);
+                }
+                while (*s && *s != ' ') {
+                    ++s;
+                }
+            }
+        }
+    }
+
+    return input;
+
+err:
+    for (i=0; i<*nargs; i++)
+        if ((*args)[i].type == ACPI_TYPE_BUFFER && (*args)[i].buffer.pointer)
+            kfree((*args)[i].buffer.pointer);
+    kfree(*args);
+    return NULL;
+}
+
+/** procfs write callback. Called when writing into /proc/acpi/call.
+*/
+#ifdef HAVE_PROC_CREATE
+static ssize_t acpi_proc_write( struct file *filp, const char __user *buff,
+    size_t len, loff_t *data )
+#else
+static int acpi_proc_write( struct file *filp, const char __user *buff,
+    unsigned long len, void *data )
+#endif
+{
+    union acpi_object *args;
+    int nargs, i;
+    char *method;
+
+    memset(input_buffer, 0, INPUT_BUFFER_SIZE);
+    if (len > sizeof(input_buffer) - 1) {
+#ifdef HAVE_PROC_CREATE
+        printk(KERN_ERR "acpi_call: Input too long! (%zu)\n", len);
+#else
+        printk(KERN_ERR "acpi_call: Input too long! (%lu)\n", len);
+#endif
+        return -ENOSPC;
+    }
+
+    if (copy_from_user( input_buffer, buff, len )) {
+        return -EFAULT;
+    }
+    input_buffer[len] = '\0';
+    if (input_buffer[len-1] == '\n')
+        input_buffer[len-1] = '\0';
+
+    method = parse_acpi_args(input_buffer, &nargs, &args);
+    if (method) {
+        do_acpi_call(method, nargs, args);
+        if (args) {
+            for (i=0; i<nargs; i++)
+                if (args[i].type == ACPI_TYPE_BUFFER)
+                    kfree(args[i].buffer.pointer);
+        }
+    }
+    if (args)
+        kfree(args);
+
+    return len;
+}
+
+/** procfs 'call' read callback. Called when reading the content of /proc/acpi/call.
+Returns the last call status:
+- "not called" when no call was previously issued
+- "failed" if the call failed
+- "ok" if the call succeeded
+*/
+#ifdef HAVE_PROC_CREATE
+static ssize_t acpi_proc_read( struct file *filp, char __user *buff,
+            size_t count, loff_t *off )
+{
+    ssize_t ret;
+    int len = strlen(result_buffer);
+
+    if(len == 0) {
+        ret = simple_read_from_buffer(buff, count, off, not_called_message, strlen(not_called_message) + 1);
+    } else if(len + 1 > count) {
+        // user buffer is too small
+        ret = 0;
+    } else if(*off == len + 1) {
+        // we're done
+        ret = 0;
+        result_buffer[0] = '\0';
+    } else {
+        // output the current result buffer
+        ret = simple_read_from_buffer(buff, count, off, result_buffer, len + 1);
+        *off = ret;
+    }
+
+    return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static struct proc_ops proc_acpi_operations = {
+	.proc_read = acpi_proc_read,
+	.proc_write = acpi_proc_write,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 13, 0)
+	.proc_lseek = default_llseek,
+#endif
+};
+#else
+static struct file_operations proc_acpi_operations = {
+        .owner    = THIS_MODULE,
+        .read     = acpi_proc_read,
+        .write    = acpi_proc_write,
+};
+#endif
+
+#else
+static int acpi_proc_read(char *page, char **start, off_t off,
+    int count, int *eof, void *data)
+{
+    int len = 0;
+
+    if (off > 0) {
+        *eof = 1;
+        return 0;
+    }
+
+    // output the current result buffer
+    len = strlen(result_buffer);
+    memcpy(page, result_buffer, len + 1);
+
+    // initialize the result buffer for later
+    strcpy(result_buffer, "not called");
+
+    return len;
+}
+#endif
+
+/** module initialization function */
+static int __init init_acpi_call(void)
+{
+#ifdef HAVE_PROC_CREATE
+    struct proc_dir_entry *acpi_entry = proc_create("call",
+                                                    0660,
+                                                    acpi_root_dir,
+                                                    &proc_acpi_operations);
+#else
+    struct proc_dir_entry *acpi_entry = create_proc_entry("call", 0660, acpi_root_dir);
+#endif
+
+    strcpy(result_buffer, "not called");
+
+    if (acpi_entry == NULL) {
+      printk(KERN_ERR "acpi_call: Couldn't create proc entry\n");
+      return -ENOMEM;
+    }
+
+#ifndef HAVE_PROC_CREATE
+    acpi_entry->write_proc = acpi_proc_write;
+    acpi_entry->read_proc = acpi_proc_read;
+#endif
+
+#ifdef DEBUG
+    printk(KERN_INFO "acpi_call: Module loaded successfully\n");
+#endif
+
+    return 0;
+}
+
+static void __exit unload_acpi_call(void)
+{
+    remove_proc_entry("call", acpi_root_dir);
+
+#ifdef DEBUG
+    printk(KERN_INFO "acpi_call: Module unloaded successfully\n");
+#endif
+}
+
+module_init(init_acpi_call);
+module_exit(unload_acpi_call);
\ No newline at end of file
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 5 Jan 2025 22:05:29 +0100
Subject: [NOT FOR UPSTREAM] remove stupid "No IRQ Handler for vector" message

---
 arch/x86/kernel/irq.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 10721a125226..cab885efd289 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -263,9 +263,7 @@ static struct irq_desc *reevaluate_vector(int vector)
 	if (!IS_ERR_OR_NULL(desc))
 		return desc;
 
-	if (desc == VECTOR_UNUSED)
-		pr_emerg_ratelimited("No irq handler for %d.%u\n", smp_processor_id(), vector);
-	else
+	if (desc != VECTOR_UNUSED)
 		__this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
 	return NULL;
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
Date: Wed, 4 Dec 2019 18:30:54 -0800
Subject: Input: uinput - Add UI_SET_PHYS_STR and UI_SET_UNIQ_STR

The ioctl definition for UI_SET_PHYS is ambiguous because it is defined
with size = sizeof(char*) but is expected to be given a variable length
string. Add a deprecation notice for UI_SET_PHYS and provide
UI_SET_PHYS_STR(len) which expects a size from the user.

Also support setting the uniq attribute of the input device. The uniq
attribute is used as a unique identifier for the connected device.

For example, uinput devices created by BlueZ will store the address of
the connected device as the uniq property.

Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
---
 drivers/input/misc/uinput.c | 48 +++++++++++++++++++++++++------------
 include/uapi/linux/uinput.h |  5 ++++
 2 files changed, 38 insertions(+), 15 deletions(-)

diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c
index 13336a2fd49c..a8e7293ff0f2 100644
--- a/drivers/input/misc/uinput.c
+++ b/drivers/input/misc/uinput.c
@@ -20,6 +20,7 @@
  */
 #include <uapi/linux/uinput.h>
 #include <linux/poll.h>
+#include <linux/printk.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/module.h>
@@ -285,7 +286,7 @@ static int uinput_dev_flush(struct input_dev *dev, struct file *file)
 
 static void uinput_destroy_device(struct uinput_device *udev)
 {
-	const char *name, *phys;
+	const char *name, *phys, *uniq;
 	struct input_dev *dev = udev->dev;
 	enum uinput_state old_state = udev->state;
 
@@ -294,6 +295,7 @@ static void uinput_destroy_device(struct uinput_device *udev)
 	if (dev) {
 		name = dev->name;
 		phys = dev->phys;
+		uniq = dev->uniq;
 		if (old_state == UIST_CREATED) {
 			uinput_flush_requests(udev);
 			input_unregister_device(dev);
@@ -302,6 +304,7 @@ static void uinput_destroy_device(struct uinput_device *udev)
 		}
 		kfree(name);
 		kfree(phys);
+		kfree(uniq);
 		udev->dev = NULL;
 	}
 }
@@ -885,6 +888,24 @@ static int uinput_str_to_user(void __user *dest, const char *str,
 	return ret ? -EFAULT : len;
 }
 
+static int uinput_get_user_str(struct uinput_device *udev, const char **kptr,
+			       const char *uptr, unsigned int size)
+{
+	char *tmp;
+
+	if (udev->state == UIST_CREATED)
+		return -EINVAL;
+
+	tmp = strndup_user(uptr, size);
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+
+	kfree(*kptr);
+	*kptr = tmp;
+
+	return 0;
+}
+
 static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 				 unsigned long arg, void __user *p)
 {
@@ -893,7 +914,6 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 	struct uinput_ff_upload ff_up;
 	struct uinput_ff_erase  ff_erase;
 	struct uinput_request   *req;
-	char			*phys;
 	const char		*name;
 	unsigned int		size;
 
@@ -970,19 +990,8 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 		goto out;
 
 	case UI_SET_PHYS:
-		if (udev->state == UIST_CREATED) {
-			retval = -EINVAL;
-			goto out;
-		}
-
-		phys = strndup_user(p, 1024);
-		if (IS_ERR(phys)) {
-			retval = PTR_ERR(phys);
-			goto out;
-		}
-
-		kfree(udev->dev->phys);
-		udev->dev->phys = phys;
+		pr_warn_once("uinput: UI_SET_PHYS is deprecated. Use UI_SET_PHYS_STR");
+		retval = uinput_get_user_str(udev, &udev->dev->phys, p, 1024);
 		goto out;
 
 	case UI_BEGIN_FF_UPLOAD:
@@ -1077,6 +1086,15 @@ static long uinput_ioctl_handler(struct file *file, unsigned int cmd,
 	case UI_ABS_SETUP & ~IOCSIZE_MASK:
 		retval = uinput_abs_setup(udev, p, size);
 		goto out;
+
+	case UI_SET_PHYS_STR(0):
+		retval = uinput_get_user_str(udev, &udev->dev->phys, p, size);
+		goto out;
+
+	case UI_SET_UNIQ_STR(0):
+		retval = uinput_get_user_str(udev, &udev->dev->uniq, p, size);
+		goto out;
+
 	}
 
 	retval = -EINVAL;
diff --git a/include/uapi/linux/uinput.h b/include/uapi/linux/uinput.h
index c9e677e3af1d..84d4fa142830 100644
--- a/include/uapi/linux/uinput.h
+++ b/include/uapi/linux/uinput.h
@@ -142,9 +142,14 @@ struct uinput_abs_setup {
 #define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)
 #define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)
 #define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)
+
+/* DEPRECATED: Data size is ambiguous. Use UI_SET_PHYS_STR instead. */
 #define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)
+
 #define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)
 #define UI_SET_PROPBIT		_IOW(UINPUT_IOCTL_BASE, 110, int)
+#define UI_SET_PHYS_STR(len)	_IOC(_IOC_WRITE, UINPUT_IOCTL_BASE, 111, len)
+#define UI_SET_UNIQ_STR(len)	_IOC(_IOC_WRITE, UINPUT_IOCTL_BASE, 112, len)
 
 #define UI_BEGIN_FF_UPLOAD	_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload)
 #define UI_END_FF_UPLOAD	_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload)
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: xiota <>
Date: Wed, 13 Mar 2024 02:36:37 +0000
Subject: PCI: Add ACI override to allow GPU passthrough in older motherboards

---
 .../admin-guide/kernel-parameters.txt         |   8 ++
 drivers/pci/quirks.c                          | 102 ++++++++++++++++++
 2 files changed, 110 insertions(+)

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index e92c0056e4e0..32e00712d2af 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -4800,6 +4800,14 @@
 		nomsi		[MSI] If the PCI_MSI kernel config parameter is
 				enabled, this kernel boot option can be used to
 				disable the use of MSI interrupts system-wide.
+		pci_acs_override [PCIE] Override missing PCIe ACS support for:
+				downstream
+					All downstream ports - full ACS capabilities
+				multifunction
+					Add multifunction devices - multifunction ACS subset
+				id:nnnn:nnnn
+					Specific device - full ACS capabilities
+					Specified as vid:did (vendor/device ID) in hex
 		noioapicquirk	[APIC] Disable all boot interrupt quirks.
 				Safety option to keep boot IRQs enabled. This
 				should never be necessary.
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index f0b131853155..e5416a6772cb 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -5052,6 +5052,106 @@ static int  pci_quirk_wangxun_nic_acs(struct pci_dev *dev, u16 acs_flags)
 	return false;
 }
 
+static bool acs_on_downstream;
+static bool acs_on_multifunction;
+
+#define NUM_ACS_IDS 16
+struct acs_on_id {
+	unsigned short vendor;
+	unsigned short device;
+};
+static struct acs_on_id acs_on_ids[NUM_ACS_IDS];
+static u8 max_acs_id;
+
+static __init int pcie_acs_override_setup(char *p)
+{
+	if (!p)
+		return -EINVAL;
+
+	while (*p) {
+		if (!strncmp(p, "downstream", 10))
+			acs_on_downstream = true;
+		if (!strncmp(p, "multifunction", 13))
+			acs_on_multifunction = true;
+		if (!strncmp(p, "id:", 3)) {
+			char opt[5];
+			int ret;
+			long val;
+
+			if (max_acs_id >= NUM_ACS_IDS - 1) {
+				pr_warn("Out of PCIe ACS override slots (%d)\n",
+						NUM_ACS_IDS);
+				goto next;
+			}
+
+			p += 3;
+			snprintf(opt, 5, "%s", p);
+			ret = kstrtol(opt, 16, &val);
+			if (ret) {
+				pr_warn("PCIe ACS ID parse error %d\n", ret);
+				goto next;
+			}
+			acs_on_ids[max_acs_id].vendor = val;
+		p += strcspn(p, ":");
+		if (*p != ':') {
+			pr_warn("PCIe ACS invalid ID\n");
+			goto next;
+			}
+
+			p++;
+			snprintf(opt, 5, "%s", p);
+			ret = kstrtol(opt, 16, &val);
+			if (ret) {
+				pr_warn("PCIe ACS ID parse error %d\n", ret);
+				goto next;
+			}
+			acs_on_ids[max_acs_id].device = val;
+			max_acs_id++;
+		}
+next:
+		p += strcspn(p, ",");
+		if (*p == ',')
+			p++;
+	}
+
+	if (acs_on_downstream || acs_on_multifunction || max_acs_id)
+		pr_warn("Warning: PCIe ACS overrides enabled; This may allow non-IOMMU protected peer-to-peer DMA\n");
+
+	return 0;
+}
+early_param("pcie_acs_override", pcie_acs_override_setup);
+
+static int pcie_acs_overrides(struct pci_dev *dev, u16 acs_flags)
+{
+	int i;
+
+	/* Never override ACS for legacy devices or devices with ACS caps */
+	if (!pci_is_pcie(dev) ||
+		pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS))
+			return -ENOTTY;
+
+	for (i = 0; i < max_acs_id; i++)
+		if (acs_on_ids[i].vendor == dev->vendor &&
+			acs_on_ids[i].device == dev->device)
+				return 1;
+
+switch (pci_pcie_type(dev)) {
+	case PCI_EXP_TYPE_DOWNSTREAM:
+	case PCI_EXP_TYPE_ROOT_PORT:
+		if (acs_on_downstream)
+			return 1;
+		break;
+	case PCI_EXP_TYPE_ENDPOINT:
+	case PCI_EXP_TYPE_UPSTREAM:
+	case PCI_EXP_TYPE_LEG_END:
+	case PCI_EXP_TYPE_RC_END:
+		if (acs_on_multifunction && dev->multifunction)
+			return 1;
+	}
+
+	return -ENOTTY;
+}
+
 static const struct pci_dev_acs_enabled {
 	u16 vendor;
 	u16 device;
@@ -5216,6 +5316,8 @@ static const struct pci_dev_acs_enabled {
 	{ PCI_VENDOR_ID_ZHAOXIN, PCI_ANY_ID, pci_quirk_zhaoxin_pcie_ports_acs },
 	/* Wangxun nics */
 	{ PCI_VENDOR_ID_WANGXUN, PCI_ANY_ID, pci_quirk_wangxun_nic_acs },
+	/* allow acs for any */
+	{ PCI_ANY_ID, PCI_ANY_ID, pcie_acs_overrides },
 	{ 0 }
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 25 Dec 2024 16:46:03 +0100
Subject: PCI: Have ACI override bail if no parameter is provided

This is to make sure we do not taint the kernel for users
that do not need the feature.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/pci/quirks.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index e5416a6772cb..06598be9cea3 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -5052,6 +5052,7 @@ static int  pci_quirk_wangxun_nic_acs(struct pci_dev *dev, u16 acs_flags)
 	return false;
 }
 
+static bool acs_ovf_enabled;
 static bool acs_on_downstream;
 static bool acs_on_multifunction;
 
@@ -5114,8 +5115,10 @@ static __init int pcie_acs_override_setup(char *p)
 			p++;
 	}
 
-	if (acs_on_downstream || acs_on_multifunction || max_acs_id)
+	if (acs_on_downstream || acs_on_multifunction || max_acs_id) {
 		pr_warn("Warning: PCIe ACS overrides enabled; This may allow non-IOMMU protected peer-to-peer DMA\n");
+		acs_ovf_enabled = true;
+	}
 
 	return 0;
 }
@@ -5125,6 +5128,11 @@ static int pcie_acs_overrides(struct pci_dev *dev, u16 acs_flags)
 {
 	int i;
 
+	// Do not taint installations without a provided param
+	// by running the following code segment
+	if (!acs_ovf_enabled)
+		return -ENOTTY;
+
 	/* Never override ACS for legacy devices or devices with ACS caps */
 	if (!pci_is_pcie(dev) ||
 		pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ACS))
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:24:08 +0200
Subject: Fix HAINAN amdgpu card not being bootable

Link:
---
 drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c | 4 +++-
 drivers/gpu/drm/radeon/si_dpm.c            | 4 +++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
index 4236700fc1ad..127382ac8ce6 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
@@ -3462,9 +3462,11 @@ static void si_apply_state_adjust_rules(struct amdgpu_device *adev,
 	if (adev->asic_type == CHIP_HAINAN) {
 		if ((adev->pdev->revision == 0x81) ||
 		    (adev->pdev->revision == 0xC3) ||
+		    (adev->pdev->device == 0x6660) ||
 		    (adev->pdev->device == 0x6664) ||
 		    (adev->pdev->device == 0x6665) ||
-		    (adev->pdev->device == 0x6667)) {
+		    (adev->pdev->device == 0x6667) ||
+		    (adev->pdev->device == 0x666F)) {
 			max_sclk = 75000;
 		}
 		if ((adev->pdev->revision == 0xC3) ||
diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c
index 9deb91970d4d..5db16c20bd17 100644
--- a/drivers/gpu/drm/radeon/si_dpm.c
+++ b/drivers/gpu/drm/radeon/si_dpm.c
@@ -2915,9 +2915,11 @@ static void si_apply_state_adjust_rules(struct radeon_device *rdev,
 	if (rdev->family == CHIP_HAINAN) {
 		if ((rdev->pdev->revision == 0x81) ||
 		    (rdev->pdev->revision == 0xC3) ||
+		    (rdev->pdev->device == 0x6660) ||
 		    (rdev->pdev->device == 0x6664) ||
 		    (rdev->pdev->device == 0x6665) ||
-		    (rdev->pdev->device == 0x6667)) {
+		    (rdev->pdev->device == 0x6667) ||
+		    (rdev->pdev->device == 0x666F)) {
 			max_sclk = 75000;
 		}
 		if ((rdev->pdev->revision == 0xC3) ||
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon May <simon.may@protonmail.ch>
Date: Sun, 19 Sep 2021 23:45:59 +0200
Subject: Revert "PCI: Add a REBAR size quirk for Sapphire RX 5600 XT Pulse"

This reverts commit 907830b0fc9e374d00f3c83de5e426157b482c01.
---
 drivers/pci/pci.c | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index b0f4d98036cd..887c90f632fd 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3800,14 +3800,8 @@ u32 pci_rebar_get_possible_sizes(struct pci_dev *pdev, int bar)
 		return 0;
 
 	pci_read_config_dword(pdev, pos + PCI_REBAR_CAP, &cap);
-	cap = FIELD_GET(PCI_REBAR_CAP_SIZES, cap);
 
-	/* Sapphire RX 5600 XT Pulse has an invalid cap dword for BAR 0 */
-	if (pdev->vendor == PCI_VENDOR_ID_ATI && pdev->device == 0x731f &&
-	    bar == 0 && cap == 0x700)
-		return 0x3f00;
-
-	return cap;
+	return (cap & PCI_REBAR_CAP_SIZES) >> 4;
 }
 EXPORT_SYMBOL(pci_rebar_get_possible_sizes);
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: K Prateek Nayak <kprateek.nayak@amd.com>
Date: Wed, 21 Sep 2022 12:06:38 +0530
Subject: ACPI: processor_idle: Skip dummy wait for processors based on the Zen
 microarchitecture
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Processors based on the Zen microarchitecture support IOPORT based deeper
C-states. The idle driver reads the acpi_gbl_FADT.xpm_timer_block.address
in the IOPORT based C-state exit path which is claimed to be a
"Dummy wait op" and has been around since ACPI introduction to Linux
dating back to Andy Grover's Mar 14, 2002 posting [1].
The comment above the dummy operation was elaborated by Andreas Mohr back
in 2006 in commit b488f02156d3d ("ACPI: restore comment justifying 'extra'
P_LVLx access") [2] where the commit log claims:
"this dummy read was about: STPCLK# doesn't get asserted in time on
(some) chipsets, which is why we need to have a dummy I/O read to delay
further instruction processing until the CPU is fully stopped."

However, sampling certain workloads with IBS on AMD Zen3 system shows
that a significant amount of time is spent in the dummy op, which
incorrectly gets accounted as C-State residency. A large C-State
residency value can prime the cpuidle governor to recommend a deeper
C-State during the subsequent idle instances, starting a vicious cycle,
leading to performance degradation on workloads that rapidly switch
between busy and idle phases.

One such workload is tbench where a massive performance degradation can
be observed during certain runs. Following are some statistics gathered
by running tbench with 128 clients, on a dual socket (2 x 64C/128T) Zen3
system with the baseline kernel, baseline kernel keeping C2 disabled,
and baseline kernel with this patch applied keeping C2 enabled:

baseline kernel was tip:sched/core at
commit f3dd3f674555 ("sched: Remove the limitation of WF_ON_CPU on
wakelist if wakee cpu is idle")

Kernel        : baseline      baseline + C2 disabled   baseline + patch

Min (MB/s)    : 2215.06       33072.10 (+1393.05%)     33016.10 (+1390.52%)
Max (MB/s)    : 32938.80      34399.10                 34774.50
Median (MB/s) : 32191.80      33476.60                 33805.70
AMean (MB/s)  : 22448.55      33649.27 (+49.89%)       33865.43 (+50.85%)
AMean Stddev  : 17526.70      680.14                   880.72
AMean CoefVar : 78.07%        2.02%                    2.60%

The data shows there are edge cases that can cause massive regressions
in case of tbench. Profiling the bad runs with IBS shows a significant
amount of time being spent in acpi_idle_do_entry method:

Overhead  Command          Shared Object             Symbol
  74.76%  swapper          [kernel.kallsyms]         [k] acpi_idle_do_entry
   0.71%  tbench           [kernel.kallsyms]         [k] update_sd_lb_stats.constprop.0
   0.69%  tbench_srv       [kernel.kallsyms]         [k] update_sd_lb_stats.constprop.0
   0.49%  swapper          [kernel.kallsyms]         [k] psi_group_change
   ...

Annotation of acpi_idle_do_entry method reveals almost all the time in
acpi_idle_do_entry is spent on the port I/O in wait_for_freeze():

  0.14       in     (%dx),%al       # <------ First "in" corresponding to inb(cx->address)
  0.51       mov    0x144d64d(%rip),%rax
  0.00       test   $0x80000000,%eax
            jne    62 	     # <------ Skip if running in guest
  0.00       mov    0x19800c3(%rip),%rdx
 99.33       in     (%dx),%eax      # <------ Second "in" corresponding to inl(acpi_gbl_FADT.xpm_timer_block.address)
  0.00 62:   mov    -0x8(%rbp),%r12
  0.00       leave
  0.00      ret

This overhead is reflected in the C2 residency on the test system where
C2 is an IOPORT based C-State. The total C-state residency reported by
"cpupower idle-info" on CPU0 for good and bad case over the 80s tbench
run is as follows (all numbers are in microseconds):

			    Good Run 		Bad Run
			   (Baseline)

POLL: 			       43338		   6231  (-85.62%)
C1 (MWAIT Based): 	    23576156 		 363861  (-98.45%)
C2 (IOPORT Based): 	    10781218 	       77027280  (+614.45%)

The larger residency value in bad case leads to the system recommending
C2 state again for subsequent idle instances. The pattern lasts till the
end of the tbench run. Following is the breakdown of "entry_method"
passed to acpi_idle_do_entry during good run and bad run:

                                        			Good Run    Bad Run
							       (Baseline)

Number of times acpi_idle_do_entry was called:             	6149573     6149050  (-0.01%)
 |-> Number of times entry_method was "ACPI_CSTATE_FFH":        6141494       88144  (-98.56%)
 |-> Number of times entry_method was "ACPI_CSTATE_HALT":             0           0  (+0.00%)
 |-> Number of times entry_method was "ACPI_CSTATE_SYSTEMIO":      8079     6060906  (+74920.49%)

For processors based on the Zen microarchitecture, this dummy wait op is
unnecessary and can be skipped when choosing IOPORT based C-States to
avoid polluting the C-state residency information.

Link: https://git.kernel.org/pub/scm/linux/kernel/git/mpe/linux-fullhistory.git/commit/?id=972c16130d9dc182cedcdd408408d9eacc7d6a2d [1]
Link: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b488f02156d3deb08f5ad7816d565c370a8cc6f1 [2]

Suggested-by: Calvin Ong <calvin.ong@amd.com>
Cc: stable@vger.kernel.org
Cc: regressions@lists.linux.dev
Signed-off-by: K Prateek Nayak <kprateek.nayak@amd.com>
Signed-off-by: Dave Hansen <dave.hansen@linux.intel.com>
Link: https://lore.kernel.org/all/20220921063638.2489-1-kprateek.nayak@amd.com/
---
 drivers/acpi/processor_idle.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c
index d0fc045a8d31..c2f3bb3188cf 100644
--- a/drivers/acpi/processor_idle.c
+++ b/drivers/acpi/processor_idle.c
@@ -524,8 +524,11 @@ static __cpuidle void io_idle(unsigned long addr)
 	inb(addr);
 
 #ifdef	CONFIG_X86
-	/* No delay is needed if we are in guest */
-	if (boot_cpu_has(X86_FEATURE_HYPERVISOR))
+	/*
+	 * No delay is needed if we are in guest or on a processor
+	 * based on the Zen microarchitecture.
+	 */
+	if (boot_cpu_has(X86_FEATURE_HYPERVISOR) || boot_cpu_has(X86_FEATURE_ZEN))
 		return;
 	/*
 	 * Modern (>=Nehalem) Intel systems use ACPI via intel_idle,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Steven Barrett <steven@liquorix.net>
Date: Fri, 15 Mar 2024 12:36:51 -0500
Subject: Cachy: drm/amdgpu/pm: Allow override of min_power_limit with
 ignore_min_pcap

---
 drivers/gpu/drm/amd/amdgpu/amdgpu.h       |  1 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c   | 10 ++++++++++
 drivers/gpu/drm/amd/pm/amdgpu_pm.c        |  3 +++
 drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c | 14 ++++++++++++--
 4 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index ef3af170dda4..cf918b18db53 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -163,6 +163,7 @@ struct amdgpu_watchdog_timer {
  */
 extern int amdgpu_modeset;
 extern unsigned int amdgpu_vram_limit;
+extern int amdgpu_ignore_min_pcap;
 extern int amdgpu_vis_vram_limit;
 extern int amdgpu_gart_size;
 extern int amdgpu_gtt_size;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index dbbb3407fa13..1cf4bdd71969 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -148,6 +148,7 @@ enum AMDGPU_DEBUG_MASK {
 };
 
 unsigned int amdgpu_vram_limit = UINT_MAX;
+int amdgpu_ignore_min_pcap = 1; /* do not ignore by default */
 int amdgpu_vis_vram_limit;
 int amdgpu_gart_size = -1; /* auto */
 int amdgpu_gtt_size = -1; /* auto */
@@ -269,6 +270,15 @@ struct amdgpu_watchdog_timer amdgpu_watchdog_timer = {
 	.period = 0x0, /* default to 0x0 (timeout disable) */
 };
 
+/**
+ * DOC: ignore_min_pcap (int)
+ * Ignore the minimum power cap.
+ * Useful on graphics cards where the minimum power cap is very high.
+ * The default is 0 (Do not ignore).
+ */
+MODULE_PARM_DESC(ignore_min_pcap, "Ignore the minimum power cap");
+module_param_named(ignore_min_pcap, amdgpu_ignore_min_pcap, int, 0600);
+
 /**
  * DOC: vramlimit (int)
  * Restrict the total amount of VRAM in MiB for testing.  The default is 0 (Use full VRAM).
diff --git a/drivers/gpu/drm/amd/pm/amdgpu_pm.c b/drivers/gpu/drm/amd/pm/amdgpu_pm.c
index 5fbfe7333b54..9e81953043be 100644
--- a/drivers/gpu/drm/amd/pm/amdgpu_pm.c
+++ b/drivers/gpu/drm/amd/pm/amdgpu_pm.c
@@ -3073,6 +3073,9 @@ static ssize_t amdgpu_hwmon_show_power_cap_min(struct device *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
+	if (amdgpu_ignore_min_pcap)
+		return sysfs_emit(buf, "%i\n", 0);
+
 	return amdgpu_hwmon_show_power_cap_generic(dev, attr, buf, PP_PWR_LIMIT_MIN);
 }
 
diff --git a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
index 408f05dfab90..4eb99b74a04f 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
@@ -2921,7 +2921,10 @@ int smu_get_power_limit(void *handle,
 			*limit = smu->max_power_limit;
 			break;
 		case SMU_PPT_LIMIT_MIN:
-			*limit = smu->min_power_limit;
+			if (amdgpu_ignore_min_pcap)
+				*limit = 0;
+			else
+				*limit = smu->min_power_limit;
 			break;
 		default:
 			return -EINVAL;
@@ -2945,7 +2948,14 @@ static int smu_set_power_limit(void *handle, uint32_t limit)
 		if (smu->ppt_funcs->set_power_limit)
 			return smu->ppt_funcs->set_power_limit(smu, limit_type, limit);
 
-	if ((limit > smu->max_power_limit) || (limit < smu->min_power_limit)) {
+	if (amdgpu_ignore_min_pcap) {
+		if ((limit > smu->max_power_limit)) {
+			dev_err(smu->adev->dev,
+				"New power limit (%d) is over the max allowed %d\n",
+				limit, smu->max_power_limit);
+			return -EINVAL;
+		}
+	} else if ((limit > smu->max_power_limit) || (limit < smu->min_power_limit)) {
 		dev_err(smu->adev->dev,
 			"New power limit (%d) is out of range [%d,%d]\n",
 			limit, smu->min_power_limit, smu->max_power_limit);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Tue, 17 Jan 2023 12:08:46 -0700
Subject: Allow to set custom USB pollrate for specific devices like so:
 usbcore.interrupt_interval_override=045e:00db:16,1bcf:0005:1

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../admin-guide/kernel-parameters.txt         |   8 +
 drivers/usb/core/config.c                     | 171 +++++++++++++++++-
 drivers/usb/core/usb.c                        |   1 +
 drivers/usb/core/usb.h                        |   1 +
 4 files changed, 180 insertions(+), 1 deletion(-)

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 32e00712d2af..2b73a243a1bf 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -7882,6 +7882,14 @@
 					request from 5000 ms to 500 ms);
 			Example: quirks=0781:5580:bk,0a5c:5834:gij
 
+	usbcore.interrupt_interval_override=
+			[USB] A list of USB devices for which a different polling
+			interval than the default shall be used on all interrupt-type
+			endpoints. The format is VendorID:ProductID:interval, with
+			the vendor and product ids specified hexadecimally, and the
+			interval decimally in milliseconds.
+			Example: interrupt_interval_override=045e:00db:16,1bcf:0005:2
+
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 42468bbeffd2..fd2eadd2d4ee 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -19,6 +19,150 @@
 
 #define USB_MAXCONFIG			8	/* Arbitrary limit */
 
+
+/* A struct associated with the interrupt_interval_override module parameter, representing
+   an user's choice to force a specific interrupt interval upon all interrupt endpoints of
+   a certain device. */
+struct interrupt_interval_override {
+	/* The vendor ID of the device of which the interrupt interval shall be overridden */
+	u16 vendor;
+	/* The product ID of the device of which the interrupt interval shall be overridden */
+	u16 product;
+	/* The new interval measured in milliseconds that shall be given to all endpoints of type interrupt on said device */
+	unsigned int interval;
+};
+
+static DEFINE_MUTEX(interrupt_interval_override_mutex);
+static char interrupt_interval_override_param[128];
+static struct interrupt_interval_override *interrupt_interval_override_list = NULL;
+static size_t interrupt_interval_override_count = 0;
+
+static int interrupt_interval_override_param_set(const char *value, const struct kernel_param *kp)
+{
+	const char *p;
+	unsigned short vendor, product;
+	unsigned int interval;
+	struct interrupt_interval_override* list;
+	struct interrupt_interval_override param;
+	size_t count, max_count, i, len;
+	int err, res;
+
+	mutex_lock(&interrupt_interval_override_mutex);
+
+	if (!value || !*value) {
+		/* Unset the current variable. */
+		kfree(interrupt_interval_override_list);
+		interrupt_interval_override_list = NULL;
+		interrupt_interval_override_count = 0;
+		param_set_copystring(value, kp);  /* Does not fail: the empty string is short enough to fit. */
+		mutex_unlock(&interrupt_interval_override_mutex);
+		return 0;
+	}
+
+	/* Compute an upper bound on the amount of entries we need. */
+	for (max_count = 1, i = 0; value[i]; i++) {
+		if (value[i] == ',')
+			max_count++;
+	}
+
+	/* Ensure we can allocate enough memory before overwriting the global variables. */
+	list = kcalloc(max_count,
+		sizeof(struct interrupt_interval_override),
+		GFP_KERNEL);
+
+	if (!list) {
+		mutex_unlock(&interrupt_interval_override_mutex);
+		return -ENOMEM;
+	}
+
+	err = param_set_copystring(value, kp);
+	if (err) {
+		kfree(list);
+		mutex_unlock(&interrupt_interval_override_mutex);
+		return err;
+	}
+
+	/* Parse the parameter. Example of a valid parameter: 045e:00db:16,1bcf:0005:2 */
+	for (count = 0, p = (const char*)value; p && *p;) {
+		res = sscanf(p, "%hx:%hx:%d%zn", &vendor, &product, &interval, &len);
+
+		/* Check whether all variables (vendor, product, interval, len) were assigned.
+		   %zn does not increase the assignment count, so we need to check for value 3 instead of 4.
+		   %zn does not consume input either, so setting len shouldn't fail if interval has been properly set. */
+		if (res != 3) {
+			pr_warn("Error while parsing USB interrupt interval override parameter %s.\n", value);
+			break;
+		}
+
+		param.vendor = (u16)vendor;
+		param.product = (u16)product;
+		param.interval = interval;
+		list[count++] = param;
+
+		p += len;
+		if (*p == ',' && *(p+1) != '\0') {
+			p++;
+			continue;
+		} else if(*p == '\0' || (*p == '\n' && *(p+1) == '\0')) {
+			break;
+		} else {
+			pr_warn("Error while parsing USB interrupt interval override parameter %s.\n", value);
+			break;
+		}
+	}
+
+	/* Overwrite the global variables with the local ones. */
+	kfree(interrupt_interval_override_list);
+	interrupt_interval_override_list = list;
+	interrupt_interval_override_count = count;
+	mutex_unlock(&interrupt_interval_override_mutex);
+	return 0;
+}
+
+static const struct kernel_param_ops interrupt_interval_override_param_ops = {
+	.set = interrupt_interval_override_param_set,
+	.get = param_get_string,
+};
+
+static struct kparam_string interrupt_interval_override_param_string = {
+	.maxlen = sizeof(interrupt_interval_override_param),
+	.string = interrupt_interval_override_param,
+};
+
+device_param_cb(interrupt_interval_override,
+	&interrupt_interval_override_param_ops,
+	&interrupt_interval_override_param_string,
+	0644);
+MODULE_PARM_DESC(interrupt_interval_override,
+	"Override the polling interval of all interrupt-type endpoints of a specific USB"
+	" device by specifying interrupt_interval_override=vendorID:productID:interval.");
+
+/* Given an USB device, this checks whether the user has specified they want to override the interrupt
+   polling interval on all interrupt-type endpoints of said device.
+
+   This function returns the user-desired amount of milliseconds between interrupts on said endpoint.
+   If this function returns zero, the device-requested interrupt interval should be used. */
+static unsigned int usb_check_interrupt_interval_override(struct usb_device* udev)
+{
+	size_t i;
+	unsigned int res;
+	u16 vendor = le16_to_cpu(udev->descriptor.idVendor);
+	u16 product = le16_to_cpu(udev->descriptor.idProduct);
+
+	mutex_lock(&interrupt_interval_override_mutex);
+	for (i = 0; i < interrupt_interval_override_count; i++) {
+		if (interrupt_interval_override_list[i].vendor == vendor
+				&& interrupt_interval_override_list[i].product == product) {
+
+			res = interrupt_interval_override_list[i].interval;
+			mutex_unlock(&interrupt_interval_override_mutex);
+			return res;
+		}
+	}
+	mutex_unlock(&interrupt_interval_override_mutex);
+	return 0;
+}
+
 static int find_next_descriptor(unsigned char *buffer, int size,
     int dt1, int dt2, int *num_skipped)
 {
@@ -293,7 +437,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
-	unsigned int maxp;
+	unsigned int maxp, ival;
 	const unsigned short *maxpacket_maxes;
 	u16 bcdUSB;
 
@@ -432,6 +576,23 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 		endpoint->desc.bInterval = n;
 	}
 
+	/* Override the interrupt polling interval if a module parameter tells us to do so. */
+	if (usb_endpoint_xfer_int(d)) {
+		ival = usb_check_interrupt_interval_override(udev);
+		if (ival > 0) {
+			switch (udev->speed) {
+			case USB_SPEED_SUPER_PLUS:
+			case USB_SPEED_SUPER:
+			case USB_SPEED_HIGH:
+				endpoint->desc.bInterval = fls(ival) + 3;
+				break;
+			default:  /* USB_SPEED_FULL or _LOW */
+				endpoint->desc.bInterval = ival;
+				break;
+			}
+		}
+	}
+
 	/* Some buggy low-speed devices have Bulk endpoints, which is
 	 * explicitly forbidden by the USB spec.  In an attempt to make
 	 * them usable, we will try treating them as Interrupt endpoints.
@@ -1144,3 +1305,11 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	usb_release_bos_descriptor(dev);
 	return ret;
 }
+
+void usb_release_interrupt_interval_override_list(void)
+{
+	mutex_lock(&interrupt_interval_override_mutex);
+	kfree(interrupt_interval_override_list);
+	interrupt_interval_override_list = NULL;
+	mutex_unlock(&interrupt_interval_override_mutex);
+}
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index fca7735fc660..e4611ecbb17a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1221,6 +1221,7 @@ static void __exit usb_exit(void)
 		return;
 
 	usb_release_quirk_list();
+	usb_release_interrupt_interval_override_list();
 	usb_deregister_device_driver(&usb_generic_driver);
 	usb_major_cleanup();
 	usb_deregister(&usbfs_driver);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a9b37aeb515b..f46788799632 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -38,6 +38,7 @@ extern void usb_authorize_interface(struct usb_interface *);
 extern void usb_detect_quirks(struct usb_device *udev);
 extern void usb_detect_interface_quirks(struct usb_device *udev);
 extern void usb_release_quirk_list(void);
+extern void usb_release_interrupt_interval_override_list(void);
 extern bool usb_endpoint_is_ignored(struct usb_device *udev,
 		struct usb_host_interface *intf,
 		struct usb_endpoint_descriptor *epd);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GloriousEggroll <gloriouseggroll@gmail.com>
Date: Mon, 29 May 2023 17:15:14 -0600
Subject: set ds controller bluetooth pollrate to 1 ms

---
 drivers/hid/hid-playstation.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/hid/hid-playstation.c b/drivers/hid/hid-playstation.c
index 1468fb11e39d..52f48be5fc55 100644
--- a/drivers/hid/hid-playstation.c
+++ b/drivers/hid/hid-playstation.c
@@ -337,8 +337,8 @@ struct dualsense_output_report {
  * 0x3F - disabled
  */
 #define DS4_OUTPUT_HWCTL_BT_POLL_MASK	0x3F
-/* Default to 4ms poll interval, which is same as USB (not adjustable). */
-#define DS4_BT_DEFAULT_POLL_INTERVAL_MS	4
+/* Default to 1ms poll interval (1000Hz, lower latency). */
+#define DS4_BT_DEFAULT_POLL_INTERVAL_MS	1
 #define DS4_OUTPUT_HWCTL_CRC32		0x40
 #define DS4_OUTPUT_HWCTL_HID		0x80
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jan200101 <sentrycraft123@gmail.com>
Date: Mon, 27 Nov 2023 09:53:59 +0100
Subject: drm/amdgpu: enable SI and CIK support by default

Signed-off-by: Jan200101 <sentrycraft123@gmail.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c | 10 ----------
 drivers/gpu/drm/radeon/radeon_drv.c     | 10 ++++++++++
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 1cf4bdd71969..7be62b9619f9 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -639,13 +639,8 @@ module_param_named(timeout_period, amdgpu_watchdog_timer.period, uint, 0644);
  */
 #ifdef CONFIG_DRM_AMDGPU_SI
 
-#if IS_ENABLED(CONFIG_DRM_RADEON) || IS_ENABLED(CONFIG_DRM_RADEON_MODULE)
-int amdgpu_si_support;
-MODULE_PARM_DESC(si_support, "SI support (1 = enabled, 0 = disabled (default))");
-#else
 int amdgpu_si_support = 1;
 MODULE_PARM_DESC(si_support, "SI support (1 = enabled (default), 0 = disabled)");
-#endif
 
 module_param_named(si_support, amdgpu_si_support, int, 0444);
 #endif
@@ -658,13 +653,8 @@ module_param_named(si_support, amdgpu_si_support, int, 0444);
  */
 #ifdef CONFIG_DRM_AMDGPU_CIK
 
-#if IS_ENABLED(CONFIG_DRM_RADEON) || IS_ENABLED(CONFIG_DRM_RADEON_MODULE)
-int amdgpu_cik_support;
-MODULE_PARM_DESC(cik_support, "CIK support (1 = enabled, 0 = disabled (default))");
-#else
 int amdgpu_cik_support = 1;
 MODULE_PARM_DESC(cik_support, "CIK support (1 = enabled (default), 0 = disabled)");
-#endif
 
 module_param_named(cik_support, amdgpu_cik_support, int, 0444);
 #endif
diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index 88e821d67af7..16c8776dc4bf 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
@@ -241,12 +241,22 @@ module_param_named(uvd, radeon_uvd, int, 0444);
 MODULE_PARM_DESC(vce, "vce enable/disable vce support (1 = enable, 0 = disable)");
 module_param_named(vce, radeon_vce, int, 0444);
 
+#ifdef CONFIG_DRM_AMDGPU_SI
+int radeon_si_support = 0;
+MODULE_PARM_DESC(si_support, "SI support (1 = enabled, 0 = disabled (default))");
+#else
 int radeon_si_support = 1;
 MODULE_PARM_DESC(si_support, "SI support (1 = enabled (default), 0 = disabled)");
+#endif
 module_param_named(si_support, radeon_si_support, int, 0444);
 
+#ifdef CONFIG_DRM_AMDGPU_CIK
+int radeon_cik_support = 0;
+MODULE_PARM_DESC(cik_support, "CIK support (1 = enabled, 0 = disabled (default))");
+#else
 int radeon_cik_support = 1;
 MODULE_PARM_DESC(cik_support, "CIK support (1 = enabled (default), 0 = disabled)");
+#endif
 module_param_named(cik_support, radeon_cik_support, int, 0444);
 
 static const struct pci_device_id pciidlist[] = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 15 Oct 2025 13:29:06 +0200
Subject: HID: asus: simplify RGB init sequence

Currently, RGB initialization forks depending on whether a device is
NKEY. Then, NKEY devices are initialized using 0x5a, 0x5d, 0x5e
endpoints, and non-NKEY devices with 0x5a and then a
backlight check, which is omitted for NKEY devices.

Remove the fork, using a common initialization sequence for both,
where they are both only initialized with 0x5a, then checked for
backlight support. This patch should not affect existing functionality.

0x5d and 0x5e endpoint initializations are performed by Windows
userspace programs associated with different usages that reside under
the vendor HID. Specifically, 0x5d is used by Armoury Crate, which
controls RGB and 0x5e by an animation program for certain Asus laptops.
Neither is used currently in the driver.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 56 ++++++++++++++----------------------------
 1 file changed, 19 insertions(+), 37 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 8db9d4e7c3b0..6848a64245cb 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -638,50 +638,32 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	unsigned char kbd_func;
 	int ret;
 
-	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD) {
-		/* Initialize keyboard */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
-		if (ret < 0)
-			return ret;
-
-		/* The LED endpoint is initialised in two HID */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID1);
-		if (ret < 0)
-			return ret;
-
-		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID2);
-		if (ret < 0)
-			return ret;
-
-		if (dmi_match(DMI_PRODUCT_FAMILY, "ProArt P16")) {
-			ret = asus_kbd_disable_oobe(hdev);
-			if (ret < 0)
-				return ret;
-		}
-
-		if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
-			intf = to_usb_interface(hdev->dev.parent);
-			udev = interface_to_usbdev(intf);
-			validate_mcu_fw_version(hdev,
-				le16_to_cpu(udev->descriptor.idProduct));
-		}
+	ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
+	if (ret < 0)
+		return ret;
 
-	} else {
-		/* Initialize keyboard */
-		ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
-		if (ret < 0)
-			return ret;
+	/* Get keyboard functions */
+	ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
+	if (ret < 0)
+		return ret;
 
-		/* Get keyboard functions */
-		ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
+	if (dmi_match(DMI_PRODUCT_FAMILY, "ProArt P16")) {
+		ret = asus_kbd_disable_oobe(hdev);
 		if (ret < 0)
 			return ret;
+	}
 
-		/* Check for backlight support */
-		if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
-			return -ENODEV;
+	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
+		intf = to_usb_interface(hdev->dev.parent);
+		udev = interface_to_usbdev(intf);
+		validate_mcu_fw_version(
+			hdev, le16_to_cpu(udev->descriptor.idProduct));
 	}
 
+	/* Check for backlight support */
+	if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
+		return -ENODEV;
+
 	drvdata->kbd_backlight = devm_kzalloc(&hdev->dev,
 					      sizeof(struct asus_kbd_leds),
 					      GFP_KERNEL);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 15 Oct 2025 13:34:34 +0200
Subject: HID: asus: use same report_id in response

Currently, asus_kbd_get_functions prods the device using feature
report report_id, but then is hardcoded to check the response through
FEATURE_KBD_REPORT_ID. This only works if report_id is that value
(currently true). So, use report_id in the response as well to
maintain functionality if that value changes in the future.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 6848a64245cb..a9a9d208ca6c 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -422,7 +422,7 @@ static int asus_kbd_get_functions(struct hid_device *hdev,
 	if (!readbuf)
 		return -ENOMEM;
 
-	ret = hid_hw_raw_request(hdev, FEATURE_KBD_REPORT_ID, readbuf,
+	ret = hid_hw_raw_request(hdev, report_id, readbuf,
 				 FEATURE_KBD_REPORT_SIZE, HID_FEATURE_REPORT,
 				 HID_REQ_GET_REPORT);
 	if (ret < 0) {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 15 Oct 2025 13:37:55 +0200
Subject: HID: asus: fortify keyboard handshake

Handshaking with an Asus device involves sending it a feature report
with the string "ASUS Tech.Inc." and then reading it back to verify the
handshake was successful, under the feature ID the interaction will
take place.

Currently, the driver only does the first part. Add the readback to
verify the handshake was successful. As this could cause breakages,
allow the verification to fail with a dmesg error until we verify
all devices work with it (they seem to).

Since the response is more than 16 bytes, increase the buffer size
to 64 as well to avoid overflow errors.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 32 +++++++++++++++++++++++++++++---
 1 file changed, 29 insertions(+), 3 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index a9a9d208ca6c..459d91fddacb 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -48,7 +48,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
 #define FEATURE_KBD_REPORT_ID 0x5a
-#define FEATURE_KBD_REPORT_SIZE 16
+#define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 
@@ -393,14 +393,40 @@ static int asus_kbd_set_report(struct hid_device *hdev, const u8 *buf, size_t bu
 
 static int asus_kbd_init(struct hid_device *hdev, u8 report_id)
 {
+	/*
+	 * The handshake is first sent as a set_report, then retrieved
+	 * from a get_report. They should be equal.
+	 */
 	const u8 buf[] = { report_id, 0x41, 0x53, 0x55, 0x53, 0x20, 0x54,
 		     0x65, 0x63, 0x68, 0x2e, 0x49, 0x6e, 0x63, 0x2e, 0x00 };
+	u8 *readbuf;
 	int ret;
 
 	ret = asus_kbd_set_report(hdev, buf, sizeof(buf));
-	if (ret < 0)
-		hid_err(hdev, "Asus failed to send init command: %d\n", ret);
+	if (ret < 0) {
+		hid_err(hdev, "Asus failed to send handshake: %d\n", ret);
+		return ret;
+	}
+
+	readbuf = kzalloc(FEATURE_KBD_REPORT_SIZE, GFP_KERNEL);
+	if (!readbuf)
+		return -ENOMEM;
+
+	ret = hid_hw_raw_request(hdev, report_id, readbuf,
+				 FEATURE_KBD_REPORT_SIZE, HID_FEATURE_REPORT,
+				 HID_REQ_GET_REPORT);
+	if (ret < 0) {
+		hid_err(hdev, "Asus failed to receive handshake ack: %d\n", ret);
+	} else if (memcmp(readbuf, buf, sizeof(buf)) != 0) {
+		hid_warn(hdev, "Asus handshake returned invalid response: %*ph\n",
+			FEATURE_KBD_REPORT_SIZE, readbuf);
+		/*
+		 * Do not return error if handshake is wrong until this is
+		 * verified to work for all devices.
+		 */
+	}
 
+	kfree(readbuf);
 	return ret;
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:51 +0100
Subject: HID: asus: prevent binding to all HID devices on ROG

Currently, when hid-asus is not loaded, NKEY keyboards load as ~6
event devices with a pretty ASUSTEK name. When it loads, it concatenates
all applications per HID endpoint, renames them, and prints errors
when some of them do not have an input device.

Therefore, change probe so that this is no longer the case. Stop
renaming the devices, omit the check for .input which causes errors on
e.g., the Z13 for some hiddev only devices, and add
HID_QUIRK_INPUT_PER_APP so that each application gets its own event.

When this is done, the probes are called multiple times. Due to this,
the rgb check needs to be moved into probe, and the report fixup should
be skipped for non-vendor endpoints (prevents multiple prints).

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 59 +++++++++++++++++++++++++++---------------
 1 file changed, 38 insertions(+), 21 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 459d91fddacb..e575962f73c8 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -47,6 +47,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define T100CHI_MOUSE_REPORT_ID 0x06
 #define FEATURE_REPORT_ID 0x0d
 #define INPUT_REPORT_ID 0x5d
+#define HID_USAGE_PAGE_VENDOR 0xff310000
 #define FEATURE_KBD_REPORT_ID 0x5a
 #define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
@@ -89,6 +90,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
+#define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -125,7 +127,6 @@ struct asus_drvdata {
 	struct input_dev *tp_kbd_input;
 	struct asus_kbd_leds *kbd_backlight;
 	const struct asus_touchpad_info *tp;
-	bool enable_backlight;
 	struct power_supply *battery;
 	struct power_supply_desc battery_desc;
 	int battery_capacity;
@@ -316,7 +317,7 @@ static int asus_e1239t_event(struct asus_drvdata *drvdat, u8 *data, int size)
 static int asus_event(struct hid_device *hdev, struct hid_field *field,
 		      struct hid_usage *usage, __s32 value)
 {
-	if ((usage->hid & HID_USAGE_PAGE) == 0xff310000 &&
+	if ((usage->hid & HID_USAGE_PAGE) == HID_USAGE_PAGE_VENDOR &&
 	    (usage->hid & HID_USAGE) != 0x00 &&
 	    (usage->hid & HID_USAGE) != 0xff && !usage->type) {
 		hid_warn(hdev, "Unmapped Asus vendor usagepage code 0x%02x\n",
@@ -931,11 +932,6 @@ static int asus_input_configured(struct hid_device *hdev, struct hid_input *hi)
 
 	drvdata->input = input;
 
-	if (drvdata->enable_backlight &&
-	    !asus_kbd_wmi_led_control_present(hdev) &&
-	    asus_kbd_register_leds(hdev))
-		hid_warn(hdev, "Failed to initialize backlight.\n");
-
 	return 0;
 }
 
@@ -1008,15 +1004,6 @@ static int asus_input_mapping(struct hid_device *hdev,
 			return -1;
 		}
 
-		/*
-		 * Check and enable backlight only on devices with UsagePage ==
-		 * 0xff31 to avoid initializing the keyboard firmware multiple
-		 * times on devices with multiple HID descriptors but same
-		 * PID/VID.
-		 */
-		if (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT)
-			drvdata->enable_backlight = true;
-
 		set_bit(EV_REP, hi->input->evbit);
 		return 1;
 	}
@@ -1133,8 +1120,10 @@ static int __maybe_unused asus_reset_resume(struct hid_device *hdev)
 
 static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
-	int ret;
+	struct hid_report_enum *rep_enum;
 	struct asus_drvdata *drvdata;
+	struct hid_report *rep;
+	int ret, is_vendor = 0;
 
 	drvdata = devm_kzalloc(&hdev->dev, sizeof(*drvdata), GFP_KERNEL);
 	if (drvdata == NULL) {
@@ -1218,18 +1207,42 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		return ret;
 	}
 
+	/* Check for vendor for RGB init and handle generic devices properly. */
+	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		if ((rep->application & HID_USAGE_PAGE) == HID_USAGE_PAGE_VENDOR)
+			is_vendor = true;
+	}
+
+	/*
+	 * For ROG keyboards, make them HID/hiddev compliant by creating one
+	 * input per application. For interfaces other than the vendor one,
+	 * disable report fixups.
+	 */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD) {
+		if (!is_vendor)
+			drvdata->quirks |= QUIRK_SKIP_REPORT_FIXUP;
+		hdev->quirks |= HID_QUIRK_INPUT_PER_APP;
+	}
+
 	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
 	if (ret) {
 		hid_err(hdev, "Asus hw start failed: %d\n", ret);
 		return ret;
 	}
 
+	if (is_vendor && (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT) &&
+	    !asus_kbd_wmi_led_control_present(hdev) &&
+	    asus_kbd_register_leds(hdev))
+		hid_warn(hdev, "Failed to initialize backlight.\n");
+
 	/*
-	 * Check that input registration succeeded. Checking that
-	 * HID_CLAIMED_INPUT is set prevents a UAF when all input devices
-	 * were freed during registration due to no usages being mapped,
-	 * leaving drvdata->input pointing to freed memory.
+	 * For ROG keyboards, skip rename for consistency and ->input check as
+	 * some devices do not have inputs.
 	 */
+	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD)
+		return 0;
+
 	if (!drvdata->input || !(hdev->claimed & HID_CLAIMED_INPUT)) {
 		hid_err(hdev, "Asus input not registered\n");
 		ret = -ENOMEM;
@@ -1352,6 +1365,10 @@ static const __u8 *asus_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		rdesc = new_rdesc;
 	}
 
+	/* Vendor fixups should only apply to NKEY vendor devices. */
+	if (drvdata->quirks & QUIRK_SKIP_REPORT_FIXUP)
+		return rdesc;
+
 	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
 			*rsize == 331 && rdesc[190] == 0x85 && rdesc[191] == 0x5a &&
 			rdesc[204] == 0x95 && rdesc[205] == 0x05) {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 18 Oct 2025 09:21:15 +0200
Subject: platform/x86: asus-wmi: Add support for multiple kbd led handlers

Some devices, such as the Z13 have multiple Aura devices connected
to them by USB. In addition, they might have a WMI interface for
RGB. In Windows, Armoury Crate exposes a unified brightness slider
for all of them, with 3 brightness levels.

Therefore, to be synergistic in Linux, and support existing tooling
such as UPower, allow adding listeners to the RGB device of the WMI
interface. If WMI does not exist, lazy initialize the interface.

Since both hid-asus and asus-wmi can both interact with the led
objects including from an atomic context, protect the brightness
access with a spinlock and update the values from a workqueue.
Use this workqueue to process WMI keyboard events as well, so they
are processed asynchronously.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c            | 175 ++++++++++++++++++---
 include/linux/platform_data/x86/asus-wmi.h |  17 ++
 2 files changed, 168 insertions(+), 24 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index e72a2b5d158e..aab779142323 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -36,6 +36,7 @@
 #include <linux/rfkill.h>
 #include <linux/seq_file.h>
 #include <linux/slab.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/units.h>
 
@@ -258,6 +259,9 @@ struct asus_wmi {
 	int tpd_led_wk;
 	struct led_classdev kbd_led;
 	int kbd_led_wk;
+	bool kbd_led_notify;
+	bool kbd_led_avail;
+	bool kbd_led_registered;
 	struct led_classdev lightbar_led;
 	int lightbar_led_wk;
 	struct led_classdev micmute_led;
@@ -266,6 +270,7 @@ struct asus_wmi {
 	struct work_struct tpd_led_work;
 	struct work_struct wlan_led_work;
 	struct work_struct lightbar_led_work;
+	struct work_struct kbd_led_work;
 
 	struct asus_rfkill wlan;
 	struct asus_rfkill bluetooth;
@@ -1530,6 +1535,100 @@ static void asus_wmi_battery_exit(struct asus_wmi *asus)
 
 /* LEDs ***********************************************************************/
 
+struct asus_hid_ref {
+	struct list_head listeners;
+	struct asus_wmi *asus;
+	/* Protects concurrent access from hid-asus and asus-wmi to leds */
+	spinlock_t lock;
+};
+
+static struct asus_hid_ref asus_ref = {
+	.listeners = LIST_HEAD_INIT(asus_ref.listeners),
+	.asus = NULL,
+	/*
+	 * Protects .asus, .asus.kbd_led_{wk,notify}, and .listener refs. Other
+	 * asus variables are read-only after .asus is set. Except the led cdev
+	 * device if not kbd_led_avail. That becomes read-only after the
+	 * first hid-asus listener registers and triggers the work queue. It is
+	 * then not referenced again until unregistering, which happens after
+	 * .asus ref is dropped. Since .asus needs to be accessed by hid-asus
+	 * IRQs to check if forwarding events is possible, a spinlock is used.
+	 */
+	.lock = __SPIN_LOCK_UNLOCKED(asus_ref.lock),
+};
+
+/*
+ * Allows registering hid-asus listeners that want to be notified of
+ * keyboard backlight changes.
+ */
+int asus_hid_register_listener(struct asus_hid_listener *bdev)
+{
+	struct asus_wmi *asus;
+
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	list_add_tail(&bdev->list, &asus_ref.listeners);
+	asus = asus_ref.asus;
+	if (asus)
+		queue_work(asus->led_workqueue, &asus->kbd_led_work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asus_hid_register_listener);
+
+/*
+ * Allows unregistering hid-asus listeners that were added with
+ * asus_hid_register_listener().
+ */
+void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
+{
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	list_del(&bdev->list);
+}
+EXPORT_SYMBOL_GPL(asus_hid_unregister_listener);
+
+static void do_kbd_led_set(struct led_classdev *led_cdev, int value);
+
+static void kbd_led_update_all(struct work_struct *work)
+{
+	enum led_brightness value;
+	struct asus_wmi *asus;
+	bool registered, notify;
+	int ret;
+
+	asus = container_of(work, struct asus_wmi, kbd_led_work);
+
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		registered = asus->kbd_led_registered;
+		value = asus->kbd_led_wk;
+		notify = asus->kbd_led_notify;
+	}
+
+	if (!registered) {
+		/*
+		 * This workqueue runs under asus-wmi, which means probe has
+		 * completed and asus-wmi will keep running until it finishes.
+		 * Therefore, we can safely register the LED without holding
+		 * a spinlock.
+		 */
+		ret = devm_led_classdev_register(&asus->platform_device->dev,
+					    &asus->kbd_led);
+		if (!ret) {
+			scoped_guard(spinlock_irqsave, &asus_ref.lock)
+				asus->kbd_led_registered = true;
+		} else {
+			pr_warn("Failed to register keyboard backlight LED: %d\n", ret);
+			return;
+		}
+	}
+
+	if (value >= 0)
+		do_kbd_led_set(&asus->kbd_led, value);
+	if (notify) {
+		scoped_guard(spinlock_irqsave, &asus_ref.lock)
+			asus->kbd_led_notify = false;
+		led_classdev_notify_brightness_hw_changed(&asus->kbd_led, value);
+	}
+}
+
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
@@ -1576,7 +1675,8 @@ static void kbd_led_update(struct asus_wmi *asus)
 {
 	int ctrl_param = 0;
 
-	ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		ctrl_param = 0x80 | (asus->kbd_led_wk & 0x7F);
 	asus_wmi_set_devstate(ASUS_WMI_DEVID_KBD_BACKLIGHT, ctrl_param, NULL);
 }
 
@@ -1609,14 +1709,23 @@ static int kbd_led_read(struct asus_wmi *asus, int *level, int *env)
 
 static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 {
+	struct asus_hid_listener *listener;
 	struct asus_wmi *asus;
 	int max_level;
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 	max_level = asus->kbd_led.max_brightness;
 
-	asus->kbd_led_wk = clamp_val(value, 0, max_level);
-	kbd_led_update(asus);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus->kbd_led_wk = clamp_val(value, 0, max_level);
+
+	if (asus->kbd_led_avail)
+		kbd_led_update(asus);
+
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		list_for_each_entry(listener, &asus_ref.listeners, list)
+			listener->brightness_set(listener, asus->kbd_led_wk);
+	}
 }
 
 static void kbd_led_set(struct led_classdev *led_cdev,
@@ -1631,10 +1740,11 @@ static void kbd_led_set(struct led_classdev *led_cdev,
 
 static void kbd_led_set_by_kbd(struct asus_wmi *asus, enum led_brightness value)
 {
-	struct led_classdev *led_cdev = &asus->kbd_led;
-
-	do_kbd_led_set(led_cdev, value);
-	led_classdev_notify_brightness_hw_changed(led_cdev, asus->kbd_led_wk);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		asus->kbd_led_wk = value;
+		asus->kbd_led_notify = true;
+	}
+	queue_work(asus->led_workqueue, &asus->kbd_led_work);
 }
 
 static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
@@ -1644,10 +1754,18 @@ static enum led_brightness kbd_led_get(struct led_classdev *led_cdev)
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		if (!asus->kbd_led_avail)
+			return asus->kbd_led_wk;
+	}
+
 	retval = kbd_led_read(asus, &value, NULL);
 	if (retval < 0)
 		return retval;
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus->kbd_led_wk = value;
+
 	return value;
 }
 
@@ -1759,7 +1877,9 @@ static int camera_led_set(struct led_classdev *led_cdev,
 
 static void asus_wmi_led_exit(struct asus_wmi *asus)
 {
-	led_classdev_unregister(&asus->kbd_led);
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		asus_ref.asus = NULL;
+
 	led_classdev_unregister(&asus->tpd_led);
 	led_classdev_unregister(&asus->wlan_led);
 	led_classdev_unregister(&asus->lightbar_led);
@@ -1797,22 +1917,25 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 			goto error;
 	}
 
-	if (!kbd_led_read(asus, &led_val, NULL) && !dmi_check_system(asus_use_hid_led_dmi_ids)) {
-		pr_info("using asus-wmi for asus::kbd_backlight\n");
-		asus->kbd_led_wk = led_val;
-		asus->kbd_led.name = "asus::kbd_backlight";
-		asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
-		asus->kbd_led.brightness_set = kbd_led_set;
-		asus->kbd_led.brightness_get = kbd_led_get;
-		asus->kbd_led.max_brightness = 3;
+	asus->kbd_led.name = "asus::kbd_backlight";
+	asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
+	asus->kbd_led.brightness_set = kbd_led_set;
+	asus->kbd_led.brightness_get = kbd_led_get;
+	asus->kbd_led.max_brightness = 3;
+	asus->kbd_led_avail = !kbd_led_read(asus, &led_val, NULL);
+	INIT_WORK(&asus->kbd_led_work, kbd_led_update_all);
 
+	if (asus->kbd_led_avail) {
+		asus->kbd_led_wk = led_val;
 		if (num_rgb_groups != 0)
 			asus->kbd_led.groups = kbd_rgb_mode_groups;
+	} else
+		asus->kbd_led_wk = -1;
 
-		rv = led_classdev_register(&asus->platform_device->dev,
-					   &asus->kbd_led);
-		if (rv)
-			goto error;
+	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
+		asus_ref.asus = asus;
+		if (asus->kbd_led_avail || !list_empty(&asus_ref.listeners))
+			queue_work(asus->led_workqueue, &asus->kbd_led_work);
 	}
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_WIRELESS_LED)
@@ -4272,6 +4395,7 @@ static int asus_wmi_get_event_code(union acpi_object *obj)
 
 static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 {
+	enum led_brightness led_value;
 	unsigned int key_value = 1;
 	bool autorelease = 1;
 
@@ -4288,19 +4412,22 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 
+	scoped_guard(spinlock_irqsave, &asus_ref.lock)
+		led_value = asus->kbd_led_wk;
+
 	if (code == NOTIFY_KBD_BRTUP) {
-		kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
+		kbd_led_set_by_kbd(asus, led_value + 1);
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTDWN) {
-		kbd_led_set_by_kbd(asus, asus->kbd_led_wk - 1);
+		kbd_led_set_by_kbd(asus, led_value - 1);
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
-		if (asus->kbd_led_wk == asus->kbd_led.max_brightness)
+		if (led_value == asus->kbd_led.max_brightness)
 			kbd_led_set_by_kbd(asus, 0);
 		else
-			kbd_led_set_by_kbd(asus, asus->kbd_led_wk + 1);
+			kbd_led_set_by_kbd(asus, led_value + 1);
 		return;
 	}
 
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 8a515179113d..1165039013b1 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -163,11 +163,20 @@ enum asus_ally_mcu_hack {
 	ASUS_WMI_ALLY_MCU_HACK_DISABLED,
 };
 
+/* Used to notify hid-asus when asus-wmi changes keyboard backlight */
+struct asus_hid_listener {
+	struct list_head list;
+	void (*brightness_set)(struct asus_hid_listener *listener, int brightness);
+};
+
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
 void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
 void set_ally_mcu_powersave(bool enabled);
 int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval);
 int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
+
+int asus_hid_register_listener(struct asus_hid_listener *cdev);
+void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
 #else
 static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
 {
@@ -184,6 +193,14 @@ static inline int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 {
 	return -ENODEV;
 }
+
+static inline int asus_hid_register_listener(struct asus_hid_listener *bdev)
+{
+	return -ENODEV;
+}
+static inline void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
+{
+}
 #endif
 
 /* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:54 +0100
Subject: HID: asus: listen to the asus-wmi brightness device instead of
 creating one

Some ROG laptops expose multiple interfaces for controlling the
keyboard/RGB brightness. This creates a name conflict under
asus::kbd_brightness, where the second device ends up being
named asus::kbd_brightness_1 and they are both broken.

Therefore, register a listener to the asus-wmi brightness device
instead of creating a new one.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 64 +++++++-----------------------------------
 1 file changed, 10 insertions(+), 54 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index e575962f73c8..ee3387294d89 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -102,7 +102,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define TRKID_SGN       ((TRKID_MAX + 1) >> 1)
 
 struct asus_kbd_leds {
-	struct led_classdev cdev;
+	struct asus_hid_listener listener;
 	struct hid_device *hdev;
 	struct work_struct work;
 	unsigned int brightness;
@@ -494,11 +494,11 @@ static void asus_schedule_work(struct asus_kbd_leds *led)
 	spin_unlock_irqrestore(&led->lock, flags);
 }
 
-static void asus_kbd_backlight_set(struct led_classdev *led_cdev,
-				   enum led_brightness brightness)
+static void asus_kbd_backlight_set(struct asus_hid_listener *listener,
+				   int brightness)
 {
-	struct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,
-						 cdev);
+	struct asus_kbd_leds *led = container_of(listener, struct asus_kbd_leds,
+						 listener);
 	unsigned long flags;
 
 	spin_lock_irqsave(&led->lock, flags);
@@ -508,20 +508,6 @@ static void asus_kbd_backlight_set(struct led_classdev *led_cdev,
 	asus_schedule_work(led);
 }
 
-static enum led_brightness asus_kbd_backlight_get(struct led_classdev *led_cdev)
-{
-	struct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds,
-						 cdev);
-	enum led_brightness brightness;
-	unsigned long flags;
-
-	spin_lock_irqsave(&led->lock, flags);
-	brightness = led->brightness;
-	spin_unlock_irqrestore(&led->lock, flags);
-
-	return brightness;
-}
-
 static void asus_kbd_backlight_work(struct work_struct *work)
 {
 	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);
@@ -538,34 +524,6 @@ static void asus_kbd_backlight_work(struct work_struct *work)
 		hid_err(led->hdev, "Asus failed to set keyboard backlight: %d\n", ret);
 }
 
-/* WMI-based keyboard backlight LED control (via asus-wmi driver) takes
- * precedence. We only activate HID-based backlight control when the
- * WMI control is not available.
- */
-static bool asus_kbd_wmi_led_control_present(struct hid_device *hdev)
-{
-	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-	u32 value;
-	int ret;
-
-	if (!IS_ENABLED(CONFIG_ASUS_WMI))
-		return false;
-
-	if (drvdata->quirks & QUIRK_ROG_NKEY_KEYBOARD &&
-			dmi_check_system(asus_use_hid_led_dmi_ids)) {
-		hid_info(hdev, "using HID for asus::kbd_backlight\n");
-		return false;
-	}
-
-	ret = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS,
-				       ASUS_WMI_DEVID_KBD_BACKLIGHT, 0, &value);
-	hid_dbg(hdev, "WMI backlight check: rc %d value %x", ret, value);
-	if (ret)
-		return false;
-
-	return !!(value & ASUS_WMI_DSTS_PRESENCE_BIT);
-}
-
 /*
  * We don't care about any other part of the string except the version section.
  * Example strings: FGA80100.RC72LA.312_T01, FGA80100.RC71LS.318_T01
@@ -700,14 +658,11 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	drvdata->kbd_backlight->removed = false;
 	drvdata->kbd_backlight->brightness = 0;
 	drvdata->kbd_backlight->hdev = hdev;
-	drvdata->kbd_backlight->cdev.name = "asus::kbd_backlight";
-	drvdata->kbd_backlight->cdev.max_brightness = 3;
-	drvdata->kbd_backlight->cdev.brightness_set = asus_kbd_backlight_set;
-	drvdata->kbd_backlight->cdev.brightness_get = asus_kbd_backlight_get;
+	drvdata->kbd_backlight->listener.brightness_set = asus_kbd_backlight_set;
 	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_backlight_work);
 	spin_lock_init(&drvdata->kbd_backlight->lock);
 
-	ret = devm_led_classdev_register(&hdev->dev, &drvdata->kbd_backlight->cdev);
+	ret = asus_hid_register_listener(&drvdata->kbd_backlight->listener);
 	if (ret < 0) {
 		/* No need to have this still around */
 		devm_kfree(&hdev->dev, drvdata->kbd_backlight);
@@ -1096,7 +1051,7 @@ static int __maybe_unused asus_resume(struct hid_device *hdev) {
 
 	if (drvdata->kbd_backlight) {
 		const u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4,
-				drvdata->kbd_backlight->cdev.brightness };
+				drvdata->kbd_backlight->brightness };
 		ret = asus_kbd_set_report(hdev, buf, sizeof(buf));
 		if (ret < 0) {
 			hid_err(hdev, "Asus failed to set keyboard backlight: %d\n", ret);
@@ -1232,7 +1187,6 @@ static int asus_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	}
 
 	if (is_vendor && (drvdata->quirks & QUIRK_USE_KBD_BACKLIGHT) &&
-	    !asus_kbd_wmi_led_control_present(hdev) &&
 	    asus_kbd_register_leds(hdev))
 		hid_warn(hdev, "Failed to initialize backlight.\n");
 
@@ -1273,6 +1227,8 @@ static void asus_remove(struct hid_device *hdev)
 	unsigned long flags;
 
 	if (drvdata->kbd_backlight) {
+		asus_hid_unregister_listener(&drvdata->kbd_backlight->listener);
+
 		spin_lock_irqsave(&drvdata->kbd_backlight->lock, flags);
 		drvdata->kbd_backlight->removed = true;
 		spin_unlock_irqrestore(&drvdata->kbd_backlight->lock, flags);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:55 +0100
Subject: platform/x86: asus-wmi: remove unused keyboard backlight quirk

The quirk for selecting whether keyboard backlight should be controlled
by HID or WMI is not needed anymore, so remove it.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 include/linux/platform_data/x86/asus-wmi.h | 40 ----------------------
 1 file changed, 40 deletions(-)

diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 1165039013b1..d8c5269854b0 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -203,44 +203,4 @@ static inline void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
 }
 #endif
 
-/* To be used by both hid-asus and asus-wmi to determine which controls kbd_brightness */
-static const struct dmi_system_id asus_use_hid_led_dmi_ids[] = {
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Zephyrus"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Strix"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ROG Flow"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_PRODUCT_FAMILY, "ProArt P16"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GA403U"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "GU605M"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
-		},
-	},
-	{ },
-};
-
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 18 Oct 2025 09:30:17 +0200
Subject: platform/x86: asus-wmi: add keyboard brightness event handler

The keyboard brightness control of Asus WMI keyboards is handled in
kernel, which leads to the shortcut going from brightness 0, to 1,
to 2, and 3.

However, for HID keyboards it is exposed as a key and handled by the
user's desktop environment. For the toggle button, this means that
brightness control becomes on/off. In addition, in the absence of a
DE, the keyboard brightness does not work.

Therefore, expose an event handler for the keyboard brightness control
which can then be used by hid-asus. Since this handler is called from
an interrupt context, defer the actual work to a workqueue.

In the process, introduce ASUS_EV_MAX_BRIGHTNESS to hold the constant
for maximum brightness since it is shared between hid-asus/asus-wmi.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c            | 46 +++++++++++++++++++---
 include/linux/platform_data/x86/asus-wmi.h | 13 ++++++
 2 files changed, 54 insertions(+), 5 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index aab779142323..f229a50bd69e 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1629,6 +1629,44 @@ static void kbd_led_update_all(struct work_struct *work)
 	}
 }
 
+/*
+ * This function is called from hid-asus to inform asus-wmi of brightness
+ * changes initiated by the keyboard backlight keys.
+ */
+int asus_hid_event(enum asus_hid_event event)
+{
+	struct asus_wmi *asus;
+	int brightness;
+
+	guard(spinlock_irqsave)(&asus_ref.lock);
+	asus = asus_ref.asus;
+	if (!asus || !asus->kbd_led_registered)
+		return -EBUSY;
+
+	brightness = asus->kbd_led_wk;
+
+	switch (event) {
+	case ASUS_EV_BRTUP:
+		brightness += 1;
+		break;
+	case ASUS_EV_BRTDOWN:
+		brightness -= 1;
+		break;
+	case ASUS_EV_BRTTOGGLE:
+		if (brightness >= ASUS_EV_MAX_BRIGHTNESS)
+			brightness = 0;
+		else
+			brightness += 1;
+		break;
+	}
+
+	asus->kbd_led_wk = clamp_val(brightness, 0, ASUS_EV_MAX_BRIGHTNESS);
+	asus->kbd_led_notify = true;
+	queue_work(asus->led_workqueue, &asus->kbd_led_work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(asus_hid_event);
+
 /*
  * These functions actually update the LED's, and are called from a
  * workqueue. By doing this as separate work rather than when the LED
@@ -1711,13 +1749,11 @@ static void do_kbd_led_set(struct led_classdev *led_cdev, int value)
 {
 	struct asus_hid_listener *listener;
 	struct asus_wmi *asus;
-	int max_level;
 
 	asus = container_of(led_cdev, struct asus_wmi, kbd_led);
-	max_level = asus->kbd_led.max_brightness;
 
 	scoped_guard(spinlock_irqsave, &asus_ref.lock)
-		asus->kbd_led_wk = clamp_val(value, 0, max_level);
+		asus->kbd_led_wk = clamp_val(value, 0, ASUS_EV_MAX_BRIGHTNESS);
 
 	if (asus->kbd_led_avail)
 		kbd_led_update(asus);
@@ -1921,7 +1957,7 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 	asus->kbd_led.flags = LED_BRIGHT_HW_CHANGED;
 	asus->kbd_led.brightness_set = kbd_led_set;
 	asus->kbd_led.brightness_get = kbd_led_get;
-	asus->kbd_led.max_brightness = 3;
+	asus->kbd_led.max_brightness = ASUS_EV_MAX_BRIGHTNESS;
 	asus->kbd_led_avail = !kbd_led_read(asus, &led_val, NULL);
 	INIT_WORK(&asus->kbd_led_work, kbd_led_update_all);
 
@@ -4424,7 +4460,7 @@ static void asus_wmi_handle_event_code(int code, struct asus_wmi *asus)
 		return;
 	}
 	if (code == NOTIFY_KBD_BRTTOGGLE) {
-		if (led_value == asus->kbd_led.max_brightness)
+		if (led_value == ASUS_EV_MAX_BRIGHTNESS)
 			kbd_led_set_by_kbd(asus, 0);
 		else
 			kbd_led_set_by_kbd(asus, led_value + 1);
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index d8c5269854b0..3f679598b629 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -169,6 +169,14 @@ struct asus_hid_listener {
 	void (*brightness_set)(struct asus_hid_listener *listener, int brightness);
 };
 
+enum asus_hid_event {
+	ASUS_EV_BRTUP,
+	ASUS_EV_BRTDOWN,
+	ASUS_EV_BRTTOGGLE,
+};
+
+#define ASUS_EV_MAX_BRIGHTNESS 3
+
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
 void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
 void set_ally_mcu_powersave(bool enabled);
@@ -177,6 +185,7 @@ int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
 
 int asus_hid_register_listener(struct asus_hid_listener *cdev);
 void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
+int asus_hid_event(enum asus_hid_event event);
 #else
 static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
 {
@@ -201,6 +210,10 @@ static inline int asus_hid_register_listener(struct asus_hid_listener *bdev)
 static inline void asus_hid_unregister_listener(struct asus_hid_listener *bdev)
 {
 }
+static inline int asus_hid_event(enum asus_hid_event event)
+{
+	return -ENODEV;
+}
 #endif
 
 #endif	/* __PLATFORM_DATA_X86_ASUS_WMI_H */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:57 +0100
Subject: HID: asus: add support for the asus-wmi brightness handler

If the asus-wmi brightness handler is available, send the
keyboard brightness events to it instead of passing them
to userspace. If it is not, fall back to sending them to it.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Tested-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index ee3387294d89..2b04397ed571 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -324,6 +324,17 @@ static int asus_event(struct hid_device *hdev, struct hid_field *field,
 			 usage->hid & HID_USAGE);
 	}
 
+	if (usage->type == EV_KEY && value) {
+		switch (usage->code) {
+		case KEY_KBDILLUMUP:
+			return !asus_hid_event(ASUS_EV_BRTUP);
+		case KEY_KBDILLUMDOWN:
+			return !asus_hid_event(ASUS_EV_BRTDOWN);
+		case KEY_KBDILLUMTOGGLE:
+			return !asus_hid_event(ASUS_EV_BRTTOGGLE);
+		}
+	}
+
 	return 0;
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 14 Aug 2025 15:01:51 +0200
Subject: HID: asus: add Z13 folio to generic group for multitouch to work

The Asus Z13 folio has a multitouch touchpad that needs to bind
to the hid-multitouch driver in order to work properly. So bind
it to the HID_GROUP_GENERIC group to release the touchpad and
move it to the bottom so that the comment applies to it.

While at it, change the generic KEYBOARD3 name to Z13_FOLIO.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Jiri Kosina <jkosina@suse.com>
---
 drivers/hid/hid-asus.c | 6 +++---
 drivers/hid/hid-ids.h  | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 2b04397ed571..c2c25825cb42 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1379,9 +1379,6 @@ static const struct hid_device_id asus_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
-	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD3),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
@@ -1411,6 +1408,9 @@ static const struct hid_device_id asus_devices[] = {
 	 * Note bind to the HID_GROUP_GENERIC group, so that we only bind to the keyboard
 	 * part, while letting hid-multitouch.c handle the touchpad.
 	 */
+	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
+		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO),
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },
 	{ }
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index ded5348d190c..5721b8414bbd 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -223,7 +223,7 @@
 #define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD3 0x1822
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD	0x1866
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2	0x19b6
-#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD3	0x1a30
+#define USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO		0x1a30
 #define USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR		0x18c6
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY		0x1abe
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X		0x1b4c
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:58 +0100
Subject: HID: asus: add basic RGB support

Adds basic RGB support to hid-asus through multi-index. The interface
works quite well, but has not gone through much stability testing.
Applied on demand, if userspace does not touch the RGB sysfs, not
even initialization is done. Ensuring compatibility with existing
userspace programs.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/Kconfig    |   1 +
 drivers/hid/hid-asus.c | 171 +++++++++++++++++++++++++++++++++++++----
 2 files changed, 156 insertions(+), 16 deletions(-)

diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index 707983ce6854..2526d8e20b4f 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -178,6 +178,7 @@ config HID_APPLETB_KBD
 config HID_ASUS
 	tristate "Asus"
 	depends on USB_HID
+	depends on LEDS_CLASS_MULTICOLOR
 	depends on LEDS_CLASS
 	depends on ASUS_WMI || ASUS_WMI=n
 	select POWER_SUPPLY
diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index c2c25825cb42..e19edc778ca4 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -23,6 +23,7 @@
 /*
  */
 
+#include <linux/array_size.h>
 #include <linux/dmi.h>
 #include <linux/hid.h>
 #include <linux/module.h>
@@ -30,6 +31,7 @@
 #include <linux/input/mt.h>
 #include <linux/usb.h> /* For to_usb_interface for T100 touchpad intf check */
 #include <linux/power_supply.h>
+#include <linux/led-class-multicolor.h>
 #include <linux/leds.h>
 
 #include "hid-ids.h"
@@ -52,6 +54,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_KBD_REPORT_SIZE 64
 #define FEATURE_KBD_LED_REPORT_ID1 0x5d
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
+#define FEATURE_KBD_LED_REPORT_SIZE 7
 
 #define ROG_ALLY_REPORT_SIZE 64
 #define ROG_ALLY_X_MIN_MCU 313
@@ -91,6 +94,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
 #define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
+#define QUIRK_ROG_NKEY_RGB		BIT(15)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -103,9 +107,15 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 
 struct asus_kbd_leds {
 	struct asus_hid_listener listener;
+	struct led_classdev_mc mc_led;
+	struct mc_subled subled_info[3];
 	struct hid_device *hdev;
 	struct work_struct work;
 	unsigned int brightness;
+	u8 rgb_colors[3];
+	bool rgb_init;
+	bool rgb_set;
+	bool rgb_registered;
 	spinlock_t lock;
 	bool removed;
 };
@@ -505,23 +515,67 @@ static void asus_schedule_work(struct asus_kbd_leds *led)
 	spin_unlock_irqrestore(&led->lock, flags);
 }
 
-static void asus_kbd_backlight_set(struct asus_hid_listener *listener,
+static void do_asus_kbd_backlight_set(struct asus_kbd_leds *led, int brightness)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&led->lock, flags);
+	led->brightness = brightness;
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	asus_schedule_work(led);
+}
+
+static void asus_kbd_listener_set(struct asus_hid_listener *listener,
 				   int brightness)
 {
 	struct asus_kbd_leds *led = container_of(listener, struct asus_kbd_leds,
 						 listener);
+	do_asus_kbd_backlight_set(led, brightness);
+	if (led->rgb_registered) {
+		led->mc_led.led_cdev.brightness = brightness;
+		led_classdev_notify_brightness_hw_changed(&led->mc_led.led_cdev,
+							  brightness);
+	}
+}
+
+static void asus_kbd_brightness_set(struct led_classdev *led_cdev,
+				    enum led_brightness brightness)
+{
+	struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(led_cdev);
+	struct asus_kbd_leds *led = container_of(mc_cdev, struct asus_kbd_leds,
+						 mc_led);
 	unsigned long flags;
 
 	spin_lock_irqsave(&led->lock, flags);
-	led->brightness = brightness;
+	led->rgb_colors[0] = mc_cdev->subled_info[0].intensity;
+	led->rgb_colors[1] = mc_cdev->subled_info[1].intensity;
+	led->rgb_colors[2] = mc_cdev->subled_info[2].intensity;
+	led->rgb_set = true;
 	spin_unlock_irqrestore(&led->lock, flags);
 
-	asus_schedule_work(led);
+	do_asus_kbd_backlight_set(led, brightness);
+}
+
+static enum led_brightness asus_kbd_brightness_get(struct led_classdev *led_cdev)
+{
+	struct led_classdev_mc *mc_led;
+	struct asus_kbd_leds *led;
+	enum led_brightness brightness;
+	unsigned long flags;
+
+	mc_led = lcdev_to_mccdev(led_cdev);
+	led = container_of(mc_led, struct asus_kbd_leds, mc_led);
+
+	spin_lock_irqsave(&led->lock, flags);
+	brightness = led->brightness;
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	return brightness;
 }
 
-static void asus_kbd_backlight_work(struct work_struct *work)
+static void asus_kbd_backlight_work(struct asus_kbd_leds *led)
 {
-	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds, work);
 	u8 buf[] = { FEATURE_KBD_REPORT_ID, 0xba, 0xc5, 0xc4, 0x00 };
 	int ret;
 	unsigned long flags;
@@ -626,12 +680,70 @@ static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
 	}
 }
 
+static void asus_kbd_rgb_work(struct asus_kbd_leds *led)
+{
+	u8 rgb_buf[][FEATURE_KBD_LED_REPORT_SIZE] = {
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB3 }, /* set mode */
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB5 }, /* apply mode */
+		{ FEATURE_KBD_LED_REPORT_ID1, 0xB4 }, /* save to mem */
+	};
+	unsigned long flags;
+	uint8_t colors[3];
+	bool rgb_init, rgb_set;
+	int ret;
+
+	spin_lock_irqsave(&led->lock, flags);
+	rgb_init = led->rgb_init;
+	rgb_set = led->rgb_set;
+	led->rgb_set = false;
+	colors[0] = led->rgb_colors[0];
+	colors[1] = led->rgb_colors[1];
+	colors[2] = led->rgb_colors[2];
+	spin_unlock_irqrestore(&led->lock, flags);
+
+	if (!rgb_set)
+		return;
+
+	if (rgb_init) {
+		ret = asus_kbd_init(led->hdev, FEATURE_KBD_LED_REPORT_ID1);
+		if (ret < 0) {
+			hid_err(led->hdev, "Asus failed to init RGB: %d\n", ret);
+			return;
+		}
+		spin_lock_irqsave(&led->lock, flags);
+		led->rgb_init = false;
+		spin_unlock_irqrestore(&led->lock, flags);
+	}
+
+	/* Protocol is: 54b3 zone (0=all) mode (0=solid) RGB */
+	rgb_buf[0][4] = colors[0];
+	rgb_buf[0][5] = colors[1];
+	rgb_buf[0][6] = colors[2];
+
+	for (size_t i = 0; i < ARRAY_SIZE(rgb_buf); i++) {
+		ret = asus_kbd_set_report(led->hdev, rgb_buf[i], sizeof(rgb_buf[i]));
+		if (ret < 0) {
+			hid_err(led->hdev, "Asus failed to set RGB: %d\n", ret);
+			return;
+		}
+	}
+}
+
+static void asus_kbd_work(struct work_struct *work)
+{
+	struct asus_kbd_leds *led = container_of(work, struct asus_kbd_leds,
+						 work);
+	asus_kbd_backlight_work(led);
+	asus_kbd_rgb_work(led);
+}
+
 static int asus_kbd_register_leds(struct hid_device *hdev)
 {
 	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
 	struct usb_interface *intf;
 	struct usb_device *udev;
 	unsigned char kbd_func;
+	struct asus_kbd_leds *leds;
 	int ret;
 
 	ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
@@ -666,20 +778,47 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	if (!drvdata->kbd_backlight)
 		return -ENOMEM;
 
-	drvdata->kbd_backlight->removed = false;
-	drvdata->kbd_backlight->brightness = 0;
-	drvdata->kbd_backlight->hdev = hdev;
-	drvdata->kbd_backlight->listener.brightness_set = asus_kbd_backlight_set;
-	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_backlight_work);
+	leds = drvdata->kbd_backlight;
+	leds->removed = false;
+	leds->brightness = ASUS_EV_MAX_BRIGHTNESS;
+	leds->hdev = hdev;
+	leds->listener.brightness_set = asus_kbd_listener_set;
+
+	leds->rgb_colors[0] = 0;
+	leds->rgb_colors[1] = 0;
+	leds->rgb_colors[2] = 0;
+	leds->rgb_init = true;
+	leds->rgb_set = false;
+	leds->mc_led.led_cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
+					"asus-%s:rgb:peripheral",
+					strlen(hdev->uniq) ?
+					hdev->uniq : dev_name(&hdev->dev));
+	leds->mc_led.led_cdev.flags = LED_BRIGHT_HW_CHANGED;
+	leds->mc_led.led_cdev.max_brightness = ASUS_EV_MAX_BRIGHTNESS;
+	leds->mc_led.led_cdev.brightness_set = asus_kbd_brightness_set;
+	leds->mc_led.led_cdev.brightness_get = asus_kbd_brightness_get;
+	leds->mc_led.subled_info = leds->subled_info;
+	leds->mc_led.num_colors = ARRAY_SIZE(leds->subled_info);
+	leds->subled_info[0].color_index = LED_COLOR_ID_RED;
+	leds->subled_info[1].color_index = LED_COLOR_ID_GREEN;
+	leds->subled_info[2].color_index = LED_COLOR_ID_BLUE;
+
+	INIT_WORK(&drvdata->kbd_backlight->work, asus_kbd_work);
 	spin_lock_init(&drvdata->kbd_backlight->lock);
 
 	ret = asus_hid_register_listener(&drvdata->kbd_backlight->listener);
-	if (ret < 0) {
-		/* No need to have this still around */
-		devm_kfree(&hdev->dev, drvdata->kbd_backlight);
+	/* Asus-wmi might not be accessible so this is not fatal. */
+	if (!ret)
+		hid_warn(hdev, "Asus-wmi brightness listener not registered\n");
+
+	if (drvdata->quirks & QUIRK_ROG_NKEY_RGB) {
+		ret = devm_led_classdev_multicolor_register(&hdev->dev, &leds->mc_led);
+		if (!ret)
+			leds->rgb_registered = true;
+		return ret;
 	}
 
-	return ret;
+	return 0;
 }
 
 /*
@@ -1381,7 +1520,7 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
@@ -1410,7 +1549,7 @@ static const struct hid_device_id asus_devices[] = {
 	 */
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },
 	{ }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:45:59 +0100
Subject: HID: asus: add RGB support to the ROG Ally units

Apply the RGB quirk to the QOG Ally units to enable basic RGB support.

Reviewed-by: Luke D. Jones <luke@ljones.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index e19edc778ca4..3ce18d62067a 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1523,10 +1523,12 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD},
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
+		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_ALLY_XPAD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
+		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 19:46:00 +0100
Subject: HID: asus: initialize LED endpoint early for old NKEY keyboards

These keyboards have always had initialization in the kernel for 0x5d.
At this point, it is hard to verify again and we risk regressions by
removing this. Therefore, initialize with 0x5d, and skip RGB
initialization if that is enabled.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 3ce18d62067a..2c0822b46400 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -95,6 +95,7 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_ROG_ALLY_XPAD		BIT(13)
 #define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
 #define QUIRK_ROG_NKEY_RGB		BIT(15)
+#define QUIRK_ROG_NKEY_LEGACY		BIT(16)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -744,12 +745,25 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	struct usb_device *udev;
 	unsigned char kbd_func;
 	struct asus_kbd_leds *leds;
+	bool rgb_init = true;
 	int ret;
 
 	ret = asus_kbd_init(hdev, FEATURE_KBD_REPORT_ID);
 	if (ret < 0)
 		return ret;
 
+	if (drvdata->quirks & QUIRK_ROG_NKEY_LEGACY) {
+		/*
+		 * These keyboards might need 0x5d for shortcuts to work.
+		 * As it has been more than 5 years, it is hard to verify.
+		 */
+		ret = asus_kbd_init(hdev, FEATURE_KBD_LED_REPORT_ID1);
+		if (ret < 0)
+			return ret;
+
+		rgb_init = false;
+	}
+
 	/* Get keyboard functions */
 	ret = asus_kbd_get_functions(hdev, &kbd_func, FEATURE_KBD_REPORT_ID);
 	if (ret < 0)
@@ -787,7 +801,7 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 	leds->rgb_colors[0] = 0;
 	leds->rgb_colors[1] = 0;
 	leds->rgb_colors[2] = 0;
-	leds->rgb_init = true;
+	leds->rgb_init = rgb_init;
 	leds->rgb_set = false;
 	leds->mc_led.led_cdev.name = devm_kasprintf(&hdev->dev, GFP_KERNEL,
 					"asus-%s:rgb:peripheral",
@@ -1514,10 +1528,10 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_LEGACY },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_LEGACY },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 12 Jul 2025 11:35:37 +0200
Subject: HID: asus: add Zenbook Duo Keyboards

Add the initial Zenbook Duo keyboard and the 2025 variant that is
both bluetooth and USB.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 4 ++++
 drivers/hid/hid-ids.h  | 3 +++
 2 files changed, 7 insertions(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 2c0822b46400..b419d3062309 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1103,6 +1103,7 @@ static int asus_input_mapping(struct hid_device *hdev,
 		case 0x8b: asus_map_key_clear(KEY_PROG1);	break; /* ProArt Creator Hub key */
 		case 0x6b: asus_map_key_clear(KEY_F21);		break; /* ASUS touchpad toggle */
 		case 0x38: asus_map_key_clear(KEY_PROG1);	break; /* ROG key */
+		case 0x86: asus_map_key_clear(KEY_PROG1);	break; /* Zenbook Duo MyASUS */
 		case 0xba: asus_map_key_clear(KEY_PROG2);	break; /* Fn+C ASUS Splendid */
 		case 0x5c: asus_map_key_clear(KEY_PROG3);	break; /* Fn+Space Power4Gear */
 		case 0x99: asus_map_key_clear(KEY_PROG4);	break; /* Fn+F5 "fan" symbol */
@@ -1566,6 +1567,9 @@ static const struct hid_device_id asus_devices[] = {
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ROG_Z13_FOLIO),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
+	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
+		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD),
+		QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD },
 	{ HID_DEVICE(BUS_USB, HID_GROUP_GENERIC,
 		USB_VENDOR_ID_ASUSTEK, USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD) },
 	{ }
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 5721b8414bbd..304890c11fa0 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -229,6 +229,9 @@
 #define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X		0x1b4c
 #define USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD	0x196b
 #define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD	0x1869
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD		0x1b2c
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2		0x1bf2
+#define USB_DEVICE_ID_ASUSTEK_ZENBOOK_DUO_KEYBOARD_2_BLUETOOTH	0x1bf3
 
 #define USB_VENDOR_ID_ATEN		0x0557
 #define USB_DEVICE_ID_ATEN_UC100KM	0x2004
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 24 Oct 2025 17:56:17 +0200
Subject: platform/x86: asus-wmi: add early backlight init quirk

The Asus Zenbook Duo's keyboard is detacheable and when it is detached
there is no led device initialized. This prevents userspace from probing
for backlight brightness support on boot. Add a quirk to always
initialize the backlight device early so that it is always available.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-nb-wmi.c | 1 +
 drivers/platform/x86/asus-wmi.c    | 4 +++-
 drivers/platform/x86/asus-wmi.h    | 1 +
 3 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-nb-wmi.c b/drivers/platform/x86/asus-nb-wmi.c
index 6a62bc5b02fd..d9e1b2a69f11 100644
--- a/drivers/platform/x86/asus-nb-wmi.c
+++ b/drivers/platform/x86/asus-nb-wmi.c
@@ -148,6 +148,7 @@ static struct quirk_entry quirk_asus_ignore_fan = {
 
 static struct quirk_entry quirk_asus_zenbook_duo_kbd = {
 	.key_wlan_event = ASUS_WMI_KEY_IGNORE,
+	.init_backlight_early = true,
 };
 
 static struct quirk_entry quirk_asus_z13 = {
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index f229a50bd69e..c8dcc26f4065 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -1970,7 +1970,9 @@ static int asus_wmi_led_init(struct asus_wmi *asus)
 
 	scoped_guard(spinlock_irqsave, &asus_ref.lock) {
 		asus_ref.asus = asus;
-		if (asus->kbd_led_avail || !list_empty(&asus_ref.listeners))
+		if (asus->kbd_led_avail ||
+		    asus->driver->quirks->init_backlight_early ||
+		    !list_empty(&asus_ref.listeners))
 			queue_work(asus->led_workqueue, &asus->kbd_led_work);
 	}
 
diff --git a/drivers/platform/x86/asus-wmi.h b/drivers/platform/x86/asus-wmi.h
index 5cd4392b964e..73710ae9a591 100644
--- a/drivers/platform/x86/asus-wmi.h
+++ b/drivers/platform/x86/asus-wmi.h
@@ -41,6 +41,7 @@ struct quirk_entry {
 	bool wmi_force_als_set;
 	bool wmi_ignore_fan;
 	bool filter_i8042_e1_extended_codes;
+	bool init_backlight_early;
 	int key_wlan_event;
 	enum asus_wmi_tablet_switch_mode tablet_switch_mode;
 	int wapf;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:05:23 +0200
Subject: add ROG Ally devices to nct6775

---
 drivers/hwmon/nct6775-platform.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/hwmon/nct6775-platform.c b/drivers/hwmon/nct6775-platform.c
index 0a040364b512..f81bf8dc4f72 100644
--- a/drivers/hwmon/nct6775-platform.c
+++ b/drivers/hwmon/nct6775-platform.c
@@ -1362,6 +1362,8 @@ static const char * const asus_msi_boards[] = {
 	"ProArt X670E-CREATOR WIFI",
 	"ProArt Z690-CREATOR WIFI",
 	"ProArt Z790-CREATOR WIFI",
+	"RC71L",
+	"RC72LA",
 	"ROG CROSSHAIR X670E EXTREME",
 	"ROG CROSSHAIR X670E GENE",
 	"ROG CROSSHAIR X670E HERO",
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 17:31:06 +0200
Subject: Revert "platform/x86: asus-wmi: Refactor Ally suspend/resume"

This reverts commit feea7bd6b02d43a794e3f065650d89cf8d8e8e59.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c                     |   4 -
 drivers/platform/x86/asus-wmi.c            | 156 ++++++---------------
 include/linux/platform_data/x86/asus-wmi.h |  19 ---
 3 files changed, 40 insertions(+), 139 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index b419d3062309..1501c0564fa5 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -675,9 +675,6 @@ static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
 		hid_warn(hdev,
 			"The MCU firmware version must be %d or greater to avoid issues with suspend.\n",
 			min_version);
-	} else {
-		set_ally_mcu_hack(ASUS_WMI_ALLY_MCU_HACK_DISABLED);
-		set_ally_mcu_powersave(true);
 	}
 }
 
@@ -1593,5 +1590,4 @@ static struct hid_driver asus_driver = {
 };
 module_hid_driver(asus_driver);
 
-MODULE_IMPORT_NS("ASUS_WMI");
 MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index c8dcc26f4065..6d5da5c97920 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -143,20 +143,16 @@ module_param(fnlock_default, bool, 0444);
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
+/* Controls the power state of the USB0 hub on ROG Ally which input is on */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/*
- * The period required to wait after screen off/on/s2idle.check in MS.
- * Time here greatly impacts the wake behaviour. Used in suspend/wake.
- */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT	600
-#define ASUS_USB0_PWR_EC0_CSEE_OFF	0xB7
-#define ASUS_USB0_PWR_EC0_CSEE_ON	0xB8
+/* 300ms so far seems to produce a reliable result on AC and battery */
+#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static int throttle_thermal_policy_write(struct asus_wmi *);
 
-static const struct dmi_system_id asus_rog_ally_device[] = {
+static const struct dmi_system_id asus_ally_mcu_quirk[] = {
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
@@ -283,6 +279,9 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
+	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
+	bool ally_mcu_usb_switch;
+
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -342,9 +341,6 @@ struct asus_wmi {
 	struct asus_wmi_driver *driver;
 };
 
-/* Global to allow setting externally without requiring driver data */
-static enum asus_ally_mcu_hack use_ally_mcu_hack = ASUS_WMI_ALLY_MCU_HACK_INIT;
-
 /* WMI ************************************************************************/
 
 static int asus_wmi_evaluate_method3(u32 method_id,
@@ -559,7 +555,7 @@ static int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)
 	return 0;
 }
 
-int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
+static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
 				 u32 *retval)
 {
 	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,
@@ -1353,44 +1349,6 @@ static ssize_t nv_temp_target_show(struct device *dev,
 static DEVICE_ATTR_RW(nv_temp_target);
 
 /* Ally MCU Powersave ********************************************************/
-
-/*
- * The HID driver needs to check MCU version and set this to false if the MCU FW
- * version is >= the minimum requirements. New FW do not need the hacks.
- */
-void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
-{
-	use_ally_mcu_hack = status;
-	pr_debug("%s Ally MCU suspend quirk\n",
-		 status == ASUS_WMI_ALLY_MCU_HACK_ENABLED ? "Enabled" : "Disabled");
-}
-EXPORT_SYMBOL_NS_GPL(set_ally_mcu_hack, "ASUS_WMI");
-
-/*
- * mcu_powersave should be enabled always, as it is fixed in MCU FW versions:
- * - v313 for Ally X
- * - v319 for Ally 1
- * The HID driver checks MCU versions and so should set this if requirements match
- */
-void set_ally_mcu_powersave(bool enabled)
-{
-	int result, err;
-
-	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_MCU_POWERSAVE, enabled, &result);
-	if (err) {
-		pr_warn("Failed to set MCU powersave: %d\n", err);
-		return;
-	}
-	if (result > 1) {
-		pr_warn("Failed to set MCU powersave (result): 0x%x\n", result);
-		return;
-	}
-
-	pr_debug("%s MCU Powersave\n",
-		 enabled ? "Enabled" : "Disabled");
-}
-EXPORT_SYMBOL_NS_GPL(set_ally_mcu_powersave, "ASUS_WMI");
-
 static ssize_t mcu_powersave_show(struct device *dev,
 				   struct device_attribute *attr, char *buf)
 {
@@ -4919,21 +4877,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 	if (err)
 		goto fail_platform;
 
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_INIT) {
-		if (acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-					&& dmi_check_system(asus_rog_ally_device))
-			use_ally_mcu_hack = ASUS_WMI_ALLY_MCU_HACK_ENABLED;
-		if (dmi_match(DMI_BOARD_NAME, "RC71")) {
-			/*
-			 * These steps ensure the device is in a valid good state, this is
-			 * especially important for the Ally 1 after a reboot.
-			 */
-			acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-						   ASUS_USB0_PWR_EC0_CSEE_ON);
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-		}
-	}
-
 	/* ensure defaults for tunables */
 	asus->ppt_pl2_sppt = 5;
 	asus->ppt_pl1_spl = 5;
@@ -4947,6 +4890,8 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
 	asus->oobe_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_OOBE);
+	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
+						&& dmi_check_system(asus_ally_mcu_quirk);
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -5133,6 +5078,34 @@ static int asus_hotk_resume(struct device *device)
 	return 0;
 }
 
+static int asus_hotk_resume_early(struct device *device)
+{
+	struct asus_wmi *asus = dev_get_drvdata(device);
+
+	if (asus->ally_mcu_usb_switch) {
+		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
+		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
+			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
+		else
+			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
+static int asus_hotk_prepare(struct device *device)
+{
+	struct asus_wmi *asus = dev_get_drvdata(device);
+
+	if (asus->ally_mcu_usb_switch) {
+		/* sleep required to ensure USB0 is disabled before sleep continues */
+		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
+			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
+		else
+			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
+	}
+	return 0;
+}
+
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -5180,51 +5153,11 @@ static int asus_hotk_restore(struct device *device)
 	return 0;
 }
 
-static int asus_hotk_prepare(struct device *device)
-{
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_ENABLED) {
-		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-					   ASUS_USB0_PWR_EC0_CSEE_OFF);
-		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-#if defined(CONFIG_SUSPEND)
-static void asus_ally_s2idle_restore(void)
-{
-	if (use_ally_mcu_hack == ASUS_WMI_ALLY_MCU_HACK_ENABLED) {
-		acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE,
-					   ASUS_USB0_PWR_EC0_CSEE_ON);
-		msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-}
-
-/* Use only for Ally devices due to the wake_on_ac */
-static struct acpi_s2idle_dev_ops asus_ally_s2idle_dev_ops = {
-	.restore = asus_ally_s2idle_restore,
-};
-
-static void asus_s2idle_check_register(void)
-{
-	if (acpi_register_lps0_dev(&asus_ally_s2idle_dev_ops))
-		pr_warn("failed to register LPS0 sleep handler in asus-wmi\n");
-}
-
-static void asus_s2idle_check_unregister(void)
-{
-	acpi_unregister_lps0_dev(&asus_ally_s2idle_dev_ops);
-}
-#else
-static void asus_s2idle_check_register(void) {}
-static void asus_s2idle_check_unregister(void) {}
-#endif /* CONFIG_SUSPEND */
-
 static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.prepare = asus_hotk_prepare,
+	.resume_early = asus_hotk_resume_early,
 };
 
 /* Registration ***************************************************************/
@@ -5251,13 +5184,7 @@ static int asus_wmi_probe(struct platform_device *pdev)
 			return ret;
 	}
 
-	asus_s2idle_check_register();
-
-	ret = asus_wmi_add(pdev);
-	if (ret)
-		asus_s2idle_check_unregister();
-
-	return ret;
+	return asus_wmi_add(pdev);
 }
 
 static bool used;
@@ -5291,9 +5218,6 @@ EXPORT_SYMBOL_GPL(asus_wmi_register_driver);
 
 void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
-	guard(mutex)(&register_mutex);
-	asus_s2idle_check_unregister();
-
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
 	used = false;
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 3f679598b629..bfb42318cbdf 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -157,12 +157,6 @@
 #define ASUS_WMI_DSTS_MAX_BRIGTH_MASK	0x0000FF00
 #define ASUS_WMI_DSTS_LIGHTBAR_MASK	0x0000000F
 
-enum asus_ally_mcu_hack {
-	ASUS_WMI_ALLY_MCU_HACK_INIT,
-	ASUS_WMI_ALLY_MCU_HACK_ENABLED,
-	ASUS_WMI_ALLY_MCU_HACK_DISABLED,
-};
-
 /* Used to notify hid-asus when asus-wmi changes keyboard backlight */
 struct asus_hid_listener {
 	struct list_head list;
@@ -178,25 +172,12 @@ enum asus_hid_event {
 #define ASUS_EV_MAX_BRIGHTNESS 3
 
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
-void set_ally_mcu_hack(enum asus_ally_mcu_hack status);
-void set_ally_mcu_powersave(bool enabled);
-int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval);
 int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
 
 int asus_hid_register_listener(struct asus_hid_listener *cdev);
 void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
 int asus_hid_event(enum asus_hid_event event);
 #else
-static inline void set_ally_mcu_hack(enum asus_ally_mcu_hack status)
-{
-}
-static inline void set_ally_mcu_powersave(bool enabled)
-{
-}
-static inline int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval)
-{
-	return -ENODEV;
-}
 static inline int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 					   u32 *retval)
 {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 17:32:54 +0200
Subject: Revert "platform/x86: asus-wmi: Refactor Ally suspend/resume"

This reverts commit feea7bd6b02d43a794e3f065650d89cf8d8e8e59.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 6d5da5c97920..9ad7087d6c19 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -5158,6 +5158,7 @@ static const struct dev_pm_ops asus_pm_ops = {
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
 	.resume_early = asus_hotk_resume_early,
+	.prepare = asus_hotk_prepare,
 };
 
 /* Registration ***************************************************************/
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 17:35:01 +0200
Subject: Revert "hid-asus: check ROG Ally MCU version and warn"

This reverts commit 00e005c952f74f50a3f86af96f56877be4685e14.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-asus.c | 114 ++---------------------------------------
 1 file changed, 5 insertions(+), 109 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 1501c0564fa5..14ae1c5006a0 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -56,10 +56,6 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define FEATURE_KBD_LED_REPORT_ID2 0x5e
 #define FEATURE_KBD_LED_REPORT_SIZE 7
 
-#define ROG_ALLY_REPORT_SIZE 64
-#define ROG_ALLY_X_MIN_MCU 313
-#define ROG_ALLY_MIN_MCU 319
-
 #define SUPPORT_KBD_BACKLIGHT BIT(0)
 
 #define MAX_TOUCH_MAJOR 8
@@ -92,10 +88,9 @@ MODULE_DESCRIPTION("Asus HID Keyboard and TouchPad");
 #define QUIRK_MEDION_E1239T		BIT(10)
 #define QUIRK_ROG_NKEY_KEYBOARD		BIT(11)
 #define QUIRK_ROG_CLAYMORE_II_KEYBOARD BIT(12)
-#define QUIRK_ROG_ALLY_XPAD		BIT(13)
-#define QUIRK_SKIP_REPORT_FIXUP		BIT(14)
-#define QUIRK_ROG_NKEY_RGB		BIT(15)
-#define QUIRK_ROG_NKEY_LEGACY		BIT(16)
+#define QUIRK_SKIP_REPORT_FIXUP		BIT(13)
+#define QUIRK_ROG_NKEY_RGB		BIT(14)
+#define QUIRK_ROG_NKEY_LEGACY		BIT(15)
 
 #define I2C_KEYBOARD_QUIRKS			(QUIRK_FIX_NOTEBOOK_REPORT | \
 						 QUIRK_NO_INIT_REPORTS | \
@@ -590,94 +585,6 @@ static void asus_kbd_backlight_work(struct asus_kbd_leds *led)
 		hid_err(led->hdev, "Asus failed to set keyboard backlight: %d\n", ret);
 }
 
-/*
- * We don't care about any other part of the string except the version section.
- * Example strings: FGA80100.RC72LA.312_T01, FGA80100.RC71LS.318_T01
- * The bytes "5a 05 03 31 00 1a 13" and possibly more come before the version
- * string, and there may be additional bytes after the version string such as
- * "75 00 74 00 65 00" or a postfix such as "_T01"
- */
-static int mcu_parse_version_string(const u8 *response, size_t response_size)
-{
-	const u8 *end = response + response_size;
-	const u8 *p = response;
-	int dots, err, version;
-	char buf[4];
-
-	dots = 0;
-	while (p < end && dots < 2) {
-		if (*p++ == '.')
-			dots++;
-	}
-
-	if (dots != 2 || p >= end || (p + 3) >= end)
-		return -EINVAL;
-
-	memcpy(buf, p, 3);
-	buf[3] = '\0';
-
-	err = kstrtoint(buf, 10, &version);
-	if (err || version < 0)
-		return -EINVAL;
-
-	return version;
-}
-
-static int mcu_request_version(struct hid_device *hdev)
-{
-	u8 *response __free(kfree) = kzalloc(ROG_ALLY_REPORT_SIZE, GFP_KERNEL);
-	const u8 request[] = { 0x5a, 0x05, 0x03, 0x31, 0x00, 0x20 };
-	int ret;
-
-	if (!response)
-		return -ENOMEM;
-
-	ret = asus_kbd_set_report(hdev, request, sizeof(request));
-	if (ret < 0)
-		return ret;
-
-	ret = hid_hw_raw_request(hdev, FEATURE_REPORT_ID, response,
-				ROG_ALLY_REPORT_SIZE, HID_FEATURE_REPORT,
-				HID_REQ_GET_REPORT);
-	if (ret < 0)
-		return ret;
-
-	ret = mcu_parse_version_string(response, ROG_ALLY_REPORT_SIZE);
-	if (ret < 0) {
-		pr_err("Failed to parse MCU version: %d\n", ret);
-		print_hex_dump(KERN_ERR, "MCU: ", DUMP_PREFIX_NONE,
-			      16, 1, response, ROG_ALLY_REPORT_SIZE, false);
-	}
-
-	return ret;
-}
-
-static void validate_mcu_fw_version(struct hid_device *hdev, int idProduct)
-{
-	int min_version, version;
-
-	version = mcu_request_version(hdev);
-	if (version < 0)
-		return;
-
-	switch (idProduct) {
-	case USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY:
-		min_version = ROG_ALLY_MIN_MCU;
-		break;
-	case USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X:
-		min_version = ROG_ALLY_X_MIN_MCU;
-		break;
-	default:
-		min_version = 0;
-	}
-
-	if (version < min_version) {
-		hid_warn(hdev,
-			"The MCU firmware version must be %d or greater to avoid issues with suspend.\n",
-			min_version);
-	}
-}
-
 static void asus_kbd_rgb_work(struct asus_kbd_leds *led)
 {
 	u8 rgb_buf[][FEATURE_KBD_LED_REPORT_SIZE] = {
@@ -738,8 +645,6 @@ static void asus_kbd_work(struct work_struct *work)
 static int asus_kbd_register_leds(struct hid_device *hdev)
 {
 	struct asus_drvdata *drvdata = hid_get_drvdata(hdev);
-	struct usb_interface *intf;
-	struct usb_device *udev;
 	unsigned char kbd_func;
 	struct asus_kbd_leds *leds;
 	bool rgb_init = true;
@@ -772,13 +677,6 @@ static int asus_kbd_register_leds(struct hid_device *hdev)
 			return ret;
 	}
 
-	if (drvdata->quirks & QUIRK_ROG_ALLY_XPAD) {
-		intf = to_usb_interface(hdev->dev.parent);
-		udev = interface_to_usbdev(intf);
-		validate_mcu_fw_version(
-			hdev, le16_to_cpu(udev->descriptor.idProduct));
-	}
-
 	/* Check for backlight support */
 	if (!(kbd_func & SUPPORT_KBD_BACKLIGHT))
 		return -ENODEV;
@@ -1535,12 +1433,10 @@ static const struct hid_device_id asus_devices[] = {
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
-		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD
-		| QUIRK_ROG_ALLY_XPAD | QUIRK_ROG_NKEY_RGB },
+	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:07:48 +0200
Subject: [NOT FOR UPSTREAM] remove ally quirk from asus_hid

Unfortunately it bails with ENOMEM preventing the controller which
might cause issues and sends random initialization commands not meant
for the platform (should NOOP though).
---
 drivers/hid/hid-asus.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 14ae1c5006a0..8d9c4fbd1a96 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1431,12 +1431,6 @@ static const struct hid_device_id asus_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_Z13_LIGHTBAR),
 	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
-	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
-	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
-	    USB_DEVICE_ID_ASUSTEK_ROG_NKEY_ALLY_X),
-	  QUIRK_USE_KBD_BACKLIGHT | QUIRK_ROG_NKEY_KEYBOARD | QUIRK_ROG_NKEY_RGB },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ASUSTEK,
 	    USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD),
 	  QUIRK_ROG_CLAYMORE_II_KEYBOARD },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 12 Oct 2024 19:11:05 +0200
Subject: [NOT FOR UPSTREAM] Add DSDT config for original Ally older BIOSes

Older ROG Ally BIOSes do not have a speaker configuration in the DSDT.
Patch is originally by Jonathan LoBue <jlobue10@gmail.com>.
---
 .../codecs/side-codecs/cs35l41_hda_property.c | 39 ++++++++++++++++++-
 1 file changed, 38 insertions(+), 1 deletion(-)

diff --git a/sound/hda/codecs/side-codecs/cs35l41_hda_property.c b/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
index 16d5ea77192f..1997c1aaaafd 100644
--- a/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
+++ b/sound/hda/codecs/side-codecs/cs35l41_hda_property.c
@@ -6,8 +6,10 @@
 //
 // Author: Stefan Binding <sbinding@opensource.cirrus.com>
 
+#include <linux/dmi.h>
 #include <linux/acpi.h>
 #include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
 #include <linux/string.h>
 #include "cs35l41_hda_property.h"
 #include <linux/spi/spi.h>
@@ -30,6 +32,41 @@ struct cs35l41_config {
 	int boost_cap_microfarad; /* Required if boost_type == Internal */
 };
 
+static int asus_rog_2023_ally_fix(struct cs35l41_hda *cs35l41, struct device *physdev, int id,
+				const char *hid)
+{
+	const char *rog_ally_bios_ver = dmi_get_system_info(DMI_BIOS_VERSION);
+	const char *rog_ally_bios_num = rog_ally_bios_ver + 6; // Dropping the RC71L. part before the number
+	int rog_ally_bios_int, err;
+	
+	err = kstrtoint(rog_ally_bios_num, 10, &rog_ally_bios_int);
+	if(err || rog_ally_bios_int >= 330){
+		printk(KERN_INFO "DSD properties exist in the %d BIOS. Not applying DSD override...\n", rog_ally_bios_int);
+		return -ENOENT; //Patch not applicable. Exiting...
+	}
+
+	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
+
+	dev_info(cs35l41->dev, "Adding DSD properties for %s\n", cs35l41->acpi_subsystem_id);
+
+	cs35l41->index = id == 0x40 ? 0 : 1;
+	cs35l41->channel_index = 0;
+	cs35l41->reset_gpio = gpiod_get_index(physdev, NULL, 0, GPIOD_OUT_HIGH);
+	cs35l41->speaker_id = cs35l41_get_speaker_id(physdev, 0, 0, 2);
+	hw_cfg->spk_pos = cs35l41->index;
+	hw_cfg->gpio1.func = CS35L41_NOT_USED;
+	hw_cfg->gpio1.valid = true;
+	hw_cfg->gpio2.func = CS35L41_INTERRUPT;
+	hw_cfg->gpio2.valid = true;
+	hw_cfg->bst_type = CS35L41_INT_BOOST;
+	hw_cfg->bst_ind = 1000; /* 1,000nH Inductance value */
+	hw_cfg->bst_ipk = 4500; /* 4,500mA peak current */
+	hw_cfg->bst_cap = 24; /* 24 microFarad cap value */
+	hw_cfg->valid = true;
+
+	return 0;
+}
+
 static const struct cs35l41_config cs35l41_config_table[] = {
 	{ "10251826", 2, EXTERNAL, { CS35L41_LEFT, CS35L41_RIGHT, 0, 0 }, 0, -1, -1, 0, 0, 0 },
 	{ "1025182C", 2, EXTERNAL, { CS35L41_LEFT, CS35L41_RIGHT, 0, 0 }, 0, -1, -1, 0, 0, 0 },
@@ -520,7 +557,7 @@ static const struct cs35l41_prop_model cs35l41_prop_model_table[] = {
 	{ "CSC3551", "104316A3", generic_dsd_config },
 	{ "CSC3551", "104316D3", generic_dsd_config },
 	{ "CSC3551", "104316F3", generic_dsd_config },
-	{ "CSC3551", "104317F3", generic_dsd_config },
+	{ "CSC3551", "104317F3", asus_rog_2023_ally_fix },
 	{ "CSC3551", "10431863", generic_dsd_config },
 	{ "CSC3551", "104318D3", generic_dsd_config },
 	{ "CSC3551", "10431A63", missing_speaker_id_gpio2 },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Apr 2025 11:41:53 +0200
Subject: Revert "platform/x86: firmware_attributes_class: Drop lifecycle
 functions"

This reverts commit 6af39604c788d9df0ca697bab603202cf74c1a8c.
---
 drivers/platform/x86/firmware_attributes_class.c | 13 +++++++++++++
 drivers/platform/x86/firmware_attributes_class.h |  2 ++
 2 files changed, 15 insertions(+)

diff --git a/drivers/platform/x86/firmware_attributes_class.c b/drivers/platform/x86/firmware_attributes_class.c
index 736e96c186d9..87672c49e86a 100644
--- a/drivers/platform/x86/firmware_attributes_class.c
+++ b/drivers/platform/x86/firmware_attributes_class.c
@@ -22,6 +22,19 @@ static __exit void fw_attributes_class_exit(void)
 }
 module_exit(fw_attributes_class_exit);
 
+int fw_attributes_class_get(const struct class **fw_attr_class)
+{
+	*fw_attr_class = &firmware_attributes_class;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fw_attributes_class_get);
+
+int fw_attributes_class_put(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fw_attributes_class_put);
+
 MODULE_AUTHOR("Mark Pearson <markpearson@lenovo.com>");
 MODULE_DESCRIPTION("Firmware attributes class helper module");
 MODULE_LICENSE("GPL");
diff --git a/drivers/platform/x86/firmware_attributes_class.h b/drivers/platform/x86/firmware_attributes_class.h
index d27abe54fcf9..ef6c3764a834 100644
--- a/drivers/platform/x86/firmware_attributes_class.h
+++ b/drivers/platform/x86/firmware_attributes_class.h
@@ -8,5 +8,7 @@
 #include <linux/device/class.h>
 
 extern const struct class firmware_attributes_class;
+int fw_attributes_class_get(const struct class **fw_attr_class);
+int fw_attributes_class_put(void);
 
 #endif /* FW_ATTR_CLASS_H */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Fri, 24 May 2024 10:54:36 +1200
Subject: platform/x86: asus-wmi: don't fail if platform_profile already
 registered

On some newer laptops it appears that an AMD driver can register a
platform_profile handler. If this happens then the asus_wmi driver would
error with -EEXIST when trying to register its own handler leaving the
user with a possibly unusable system - this is especially true for
laptops with an MCU that emit a stream of HID packets, some of which can
be misinterpreted as shutdown signals.

We can safely continue loading the driver instead of bombing out.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/asus-wmi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 9ad7087d6c19..53632585bc01 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -4918,7 +4918,7 @@ static int asus_wmi_add(struct platform_device *pdev)
 		goto fail_fan_boost_mode;
 
 	err = platform_profile_setup(asus);
-	if (err)
+	if (err && err != -EEXIST)
 		goto fail_platform_profile_setup;
 
 	err = asus_wmi_sysfs_init(asus->platform_device);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sun, 22 Sep 2024 21:40:46 +1200
Subject: platform/x86: asus-wmi: export symbols used for read/write WMI

Export some rather helpful read/write WMI symbols using a namespace.
These are DEVS and DSTS only, or require the arg0 input.

Also does a slight refactor of internals of these functions.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/platform/x86/asus-wmi.c            | 44 ++++++++++++++++++++--
 include/linux/platform_data/x86/asus-wmi.h | 10 +++++
 2 files changed, 51 insertions(+), 3 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 53632585bc01..ab6fcd2ea8b2 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -391,7 +391,7 @@ int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval)
 {
 	return asus_wmi_evaluate_method3(method_id, arg0, arg1, 0, retval);
 }
-EXPORT_SYMBOL_GPL(asus_wmi_evaluate_method);
+EXPORT_SYMBOL_NS_GPL(asus_wmi_evaluate_method, "ASUS_WMI");
 
 static int asus_wmi_evaluate_method5(u32 method_id,
 		u32 arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4, u32 *retval)
@@ -555,12 +555,50 @@ static int asus_wmi_get_devstate(struct asus_wmi *asus, u32 dev_id, u32 *retval)
 	return 0;
 }
 
-static int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param,
-				 u32 *retval)
+/**
+ * asus_wmi_get_devstate_dsts() - Get the WMI function state.
+ * @dev_id: The WMI method ID to call.
+ * @retval: A pointer to where to store the value returned from WMI.
+ *
+ * On success the return value is 0, and the retval is a valid value returned
+ * by the successful WMI function call otherwise an error is returned if the
+ * call failed, or if the WMI method ID is unsupported.
+ */
+int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval)
+{
+	int err;
+
+	err = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id, 0, retval);
+	if (err)
+		return err;
+
+	if (*retval == ASUS_WMI_UNSUPPORTED_METHOD)
+		return -ENODEV;
+
+	return 0;
+}
+EXPORT_SYMBOL_NS_GPL(asus_wmi_get_devstate_dsts, "ASUS_WMI");
+
+/**
+ * asus_wmi_set_devstate() - Set the WMI function state.
+ * @dev_id: The WMI function to call.
+ * @ctrl_param: The argument to be used for this WMI function.
+ * @retval: A pointer to where to store the value returned from WMI.
+ *
+ * The returned WMI function state if not checked here for error as
+ * asus_wmi_set_devstate() is not called unless first paired with a call to
+ * asus_wmi_get_devstate_dsts() to check that the WMI function is supported.
+ *
+ * On success the return value is 0, and the retval is a valid value returned
+ * by the successful WMI function call. An error value is returned only if the
+ * WMI function failed.
+ */
+int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval)
 {
 	return asus_wmi_evaluate_method(ASUS_WMI_METHODID_DEVS, dev_id,
 					ctrl_param, retval);
 }
+EXPORT_SYMBOL_NS_GPL(asus_wmi_set_devstate, "ASUS_WMI");
 
 /* Helper for special devices with magic return codes */
 static int asus_wmi_get_devstate_bits(struct asus_wmi *asus,
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index bfb42318cbdf..eb0395edde4c 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -172,12 +172,22 @@ enum asus_hid_event {
 #define ASUS_EV_MAX_BRIGHTNESS 3
 
 #if IS_REACHABLE(CONFIG_ASUS_WMI)
+int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval);
+int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval);
 int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1, u32 *retval);
 
 int asus_hid_register_listener(struct asus_hid_listener *cdev);
 void asus_hid_unregister_listener(struct asus_hid_listener *cdev);
 int asus_hid_event(enum asus_hid_event event);
 #else
+static inline int asus_wmi_get_devstate_dsts(u32 dev_id, u32 *retval)
+{
+	return -ENODEV;
+}
+static inline int asus_wmi_set_devstate(u32 dev_id, u32 ctrl_param, u32 *retval)
+{
+	return -ENODEV;
+}
 static inline int asus_wmi_evaluate_method(u32 method_id, u32 arg0, u32 arg1,
 					   u32 *retval)
 {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sun, 22 Sep 2024 21:39:43 +1200
Subject: platform/x86: asus-armoury: move existing tunings to asus-armoury
 module
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The fw_attributes_class provides a much cleaner interface to all of the
attributes introduced to asus-wmi. This patch moves all of these extra
attributes over to fw_attributes_class, and shifts the bulk of these
definitions to a new kernel module to reduce the clutter of asus-wmi
with the intention of deprecating the asus-wmi attributes in future.

The work applies only to WMI methods which don't have a clearly defined
place within the sysfs and as a result ended up lumped together in
/sys/devices/platform/asus-nb-wmi/ with no standard API.

Where possible the fw attrs now implement defaults, min, max, scalar,
choices, etc. As en example dgpu_disable becomes:

/sys/class/firmware-attributes/asus-armoury/attributes/dgpu_disable/
 current_value
 display_name
 possible_values
 type

as do other attributes.

The ppt_* based attributes are removed in this initial patch as the
implementation is somewhat broken due to the WMI methods requiring a
set of limits on the values accepted (which is not provided by WMI).

Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/Kconfig               |  12 +
 drivers/platform/x86/Makefile              |   1 +
 drivers/platform/x86/asus-armoury.c        | 573 +++++++++++++++++++++
 drivers/platform/x86/asus-armoury.h        | 147 ++++++
 drivers/platform/x86/asus-wmi.c            |   4 -
 include/linux/platform_data/x86/asus-wmi.h |   3 +
 6 files changed, 736 insertions(+), 4 deletions(-)
 create mode 100644 drivers/platform/x86/asus-armoury.c
 create mode 100644 drivers/platform/x86/asus-armoury.h

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index f0d9ad99cd7a..34528f85e632 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -255,6 +255,18 @@ config ASUS_WIRELESS
 	  If you choose to compile this driver as a module the module will be
 	  called asus-wireless.
 
+config ASUS_ARMOURY
+	tristate "ASUS Armoury driver"
+	depends on ASUS_WMI
+	select FW_ATTR_CLASS
+	help
+	  Say Y here if you have a WMI aware Asus machine and would like to use the
+	  firmware_attributes API to control various settings typically exposed in
+	  the ASUS Armoury Crate application available on Windows.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called asus-armoury.
+
 config ASUS_WMI
 	tristate "ASUS WMI Driver"
 	depends on ACPI_WMI
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 8b6d6feb2548..62a763bec617 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
 # ASUS
 obj-$(CONFIG_ASUS_LAPTOP)	+= asus-laptop.o
 obj-$(CONFIG_ASUS_WIRELESS)	+= asus-wireless.o
+obj-$(CONFIG_ASUS_ARMOURY)	+= asus-armoury.o
 obj-$(CONFIG_ASUS_WMI)		+= asus-wmi.o
 obj-$(CONFIG_ASUS_NB_WMI)	+= asus-nb-wmi.o
 obj-$(CONFIG_ASUS_TF103C_DOCK)	+= asus-tf103c-dock.o
diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
new file mode 100644
index 000000000000..e6b64418f77b
--- /dev/null
+++ b/drivers/platform/x86/asus-armoury.c
@@ -0,0 +1,573 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Asus Armoury (WMI) attributes driver. This driver uses the fw_attributes
+ * class to expose the various WMI functions that many gaming and some
+ * non-gaming ASUS laptops have available.
+ * These typically don't fit anywhere else in the sysfs such as under LED class,
+ * hwmon or other, and are set in Windows using the ASUS Armoury Crate tool.
+ *
+ * Copyright(C) 2024 Luke Jones <luke@ljones.dev>
+ */
+
+#include "linux/cleanup.h"
+#include <linux/bitfield.h>
+#include <linux/device.h>
+#include <linux/dmi.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/kobject.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_data/x86/asus-wmi.h>
+#include <linux/types.h>
+#include <linux/acpi.h>
+
+#include "asus-armoury.h"
+#include "firmware_attributes_class.h"
+
+#define ASUS_NB_WMI_EVENT_GUID "0B3CBB35-E3C2-45ED-91C2-4C5A6D195D1C"
+
+#define ASUS_MINI_LED_MODE_MASK   0x03
+/* Standard modes for devices with only on/off */
+#define ASUS_MINI_LED_OFF         0x00
+#define ASUS_MINI_LED_ON          0x01
+/* Like "on" but the effect is more vibrant or brighter */
+#define ASUS_MINI_LED_STRONG_MODE 0x02
+/* New modes for devices with 3 mini-led mode types */
+#define ASUS_MINI_LED_2024_WEAK   0x00
+#define ASUS_MINI_LED_2024_STRONG 0x01
+#define ASUS_MINI_LED_2024_OFF    0x02
+
+/* Default limits for tunables available on ASUS ROG laptops */
+#define NVIDIA_BOOST_MIN      5
+#define NVIDIA_BOOST_MAX      25
+#define NVIDIA_TEMP_MIN       75
+#define NVIDIA_TEMP_MAX       87
+#define PPT_CPU_LIMIT_MIN     5
+#define PPT_CPU_LIMIT_MAX     150
+#define PPT_CPU_LIMIT_DEFAULT 80
+#define PPT_PLATFORM_MIN      5
+#define PPT_PLATFORM_MAX      100
+#define PPT_PLATFORM_DEFAULT  80
+
+static const struct class *fw_attr_class;
+
+struct asus_armoury_priv {
+	struct device *fw_attr_dev;
+	struct kset *fw_attr_kset;
+
+	u32 mini_led_dev_id;
+	u32 gpu_mux_dev_id;
+
+	struct mutex mutex;
+};
+
+static struct asus_armoury_priv asus_armoury = {
+	.mutex = __MUTEX_INITIALIZER(asus_armoury.mutex)
+};
+
+struct fw_attrs_group {
+	bool pending_reboot;
+};
+
+static struct fw_attrs_group fw_attrs = {
+	.pending_reboot = false,
+};
+
+struct asus_attr_group {
+	const struct attribute_group *attr_group;
+	u32 wmi_devid;
+};
+
+static bool asus_wmi_is_present(u32 dev_id)
+{
+	u32 retval;
+	int status;
+
+	status = asus_wmi_evaluate_method(ASUS_WMI_METHODID_DSTS, dev_id, 0, &retval);
+	pr_debug("%s called (0x%08x), retval: 0x%08x\n", __func__, dev_id, retval);
+
+	return status == 0 && (retval & ASUS_WMI_DSTS_PRESENCE_BIT);
+}
+
+static void asus_set_reboot_and_signal_event(void)
+{
+	fw_attrs.pending_reboot = true;
+	kobject_uevent(&asus_armoury.fw_attr_dev->kobj, KOBJ_CHANGE);
+}
+
+static ssize_t pending_reboot_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "%d\n", fw_attrs.pending_reboot);
+}
+
+static struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);
+
+static bool asus_bios_requires_reboot(struct kobj_attribute *attr)
+{
+	return !strcmp(attr->attr.name, "gpu_mux_mode");
+}
+
+static int armoury_wmi_set_devstate(struct kobj_attribute *attr, u32 value, u32 wmi_dev)
+{
+	u32 result;
+	int err;
+
+	guard(mutex)(&asus_armoury.mutex);
+	err = asus_wmi_set_devstate(wmi_dev, value, &result);
+	if (err) {
+		pr_err("Failed to set %s: %d\n", attr->attr.name, err);
+		return err;
+	}
+	/*
+	 * !1 is usually considered a fail by ASUS, but some WMI methods do use > 1
+	 * to return a status code or similar.
+	 */
+	if (result < 1) {
+		pr_err("Failed to set %s: (result): 0x%x\n", attr->attr.name, result);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/**
+ * attr_int_store() - Send an int to wmi method, checks if within min/max exclusive.
+ * @kobj: Pointer to the driver object.
+ * @attr: Pointer to the attribute calling this function.
+ * @buf: The buffer to read from, this is parsed to `int` type.
+ * @count: Required by sysfs attribute macros, pass in from the callee attr.
+ * @min: Minimum accepted value. Below this returns -EINVAL.
+ * @max: Maximum accepted value. Above this returns -EINVAL.
+ * @store_value: Pointer to where the parsed value should be stored.
+ * @wmi_dev: The WMI function ID to use.
+ *
+ * This function is intended to be generic so it can be called from any "_store"
+ * attribute which works only with integers. The integer to be sent to the WMI method
+ * is range checked and an error returned if out of range.
+ *
+ * If the value is valid and WMI is success, then the sysfs attribute is notified
+ * and if asus_bios_requires_reboot() is true then reboot attribute is also notified.
+ *
+ * Returns: Either count, or an error.
+ */
+static ssize_t attr_uint_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf,
+			      size_t count, u32 min, u32 max, u32 *store_value, u32 wmi_dev)
+{
+	u32 value;
+	int err;
+
+	err = kstrtouint(buf, 10, &value);
+	if (err)
+		return err;
+
+	if (value < min || value > max)
+		return -EINVAL;
+
+	err = armoury_wmi_set_devstate(attr, value, wmi_dev);
+	if (err)
+		return err;
+
+	if (store_value != NULL)
+		*store_value = value;
+	sysfs_notify(kobj, NULL, attr->attr.name);
+
+	if (asus_bios_requires_reboot(attr))
+		asus_set_reboot_and_signal_event();
+
+	return count;
+}
+
+/* Mini-LED mode **************************************************************/
+static ssize_t mini_led_mode_current_value_show(struct kobject *kobj,
+						struct kobj_attribute *attr, char *buf)
+{
+	u32 value;
+	int err;
+
+	err = asus_wmi_get_devstate_dsts(asus_armoury.mini_led_dev_id, &value);
+	if (err)
+		return err;
+
+	value &= ASUS_MINI_LED_MODE_MASK;
+
+	/*
+	 * Remap the mode values to match previous generation mini-LED. The last gen
+	 * WMI 0 == off, while on this version WMI 2 == off (flipped).
+	 */
+	if (asus_armoury.mini_led_dev_id == ASUS_WMI_DEVID_MINI_LED_MODE2) {
+		switch (value) {
+		case ASUS_MINI_LED_2024_WEAK:
+			value = ASUS_MINI_LED_ON;
+			break;
+		case ASUS_MINI_LED_2024_STRONG:
+			value = ASUS_MINI_LED_STRONG_MODE;
+			break;
+		case ASUS_MINI_LED_2024_OFF:
+			value = ASUS_MINI_LED_OFF;
+			break;
+		}
+	}
+
+	return sysfs_emit(buf, "%u\n", value);
+}
+
+static ssize_t mini_led_mode_current_value_store(struct kobject *kobj,
+						 struct kobj_attribute *attr,
+						const char *buf, size_t count)
+{
+	u32 mode;
+	int err;
+
+	err = kstrtou32(buf, 10, &mode);
+	if (err)
+		return err;
+
+	if (asus_armoury.mini_led_dev_id == ASUS_WMI_DEVID_MINI_LED_MODE &&
+	    mode > ASUS_MINI_LED_ON)
+		return -EINVAL;
+	if (asus_armoury.mini_led_dev_id == ASUS_WMI_DEVID_MINI_LED_MODE2 &&
+	    mode > ASUS_MINI_LED_STRONG_MODE)
+		return -EINVAL;
+
+	/*
+	 * Remap the mode values so expected behaviour is the same as the last
+	 * generation of mini-LED with 0 == off, 1 == on.
+	 */
+	if (asus_armoury.mini_led_dev_id == ASUS_WMI_DEVID_MINI_LED_MODE2) {
+		switch (mode) {
+		case ASUS_MINI_LED_OFF:
+			mode = ASUS_MINI_LED_2024_OFF;
+			break;
+		case ASUS_MINI_LED_ON:
+			mode = ASUS_MINI_LED_2024_WEAK;
+			break;
+		case ASUS_MINI_LED_STRONG_MODE:
+			mode = ASUS_MINI_LED_2024_STRONG;
+			break;
+		}
+	}
+
+	err = armoury_wmi_set_devstate(attr, mode, asus_armoury.mini_led_dev_id);
+	if (err)
+		return err;
+
+	sysfs_notify(kobj, NULL, attr->attr.name);
+
+	return count;
+}
+
+static ssize_t mini_led_mode_possible_values_show(struct kobject *kobj,
+						  struct kobj_attribute *attr, char *buf)
+{
+	switch (asus_armoury.mini_led_dev_id) {
+	case ASUS_WMI_DEVID_MINI_LED_MODE:
+		return sysfs_emit(buf, "0;1\n");
+	case ASUS_WMI_DEVID_MINI_LED_MODE2:
+		return sysfs_emit(buf, "0;1;2\n");
+	}
+
+	return sysfs_emit(buf, "0\n");
+}
+
+ATTR_GROUP_ENUM_CUSTOM(mini_led_mode, "mini_led_mode", "Set the mini-LED backlight mode");
+
+static ssize_t gpu_mux_mode_current_value_store(struct kobject *kobj,
+						struct kobj_attribute *attr, const char *buf,
+						size_t count)
+{
+	int result, err;
+	u32 optimus;
+
+	err = kstrtou32(buf, 10, &optimus);
+	if (err)
+		return err;
+
+	if (optimus > 1)
+		return -EINVAL;
+
+	if (asus_wmi_is_present(ASUS_WMI_DEVID_DGPU)) {
+		err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_DGPU, &result);
+		if (err)
+			return err;
+		if (result && !optimus) {
+			err = -ENODEV;
+			pr_warn("Can not switch MUX to dGPU mode when dGPU is disabled: %02X %02X %d\n",
+				result, optimus, err);
+			return err;
+		}
+	}
+
+	if (asus_wmi_is_present(ASUS_WMI_DEVID_EGPU)) {
+		err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_EGPU, &result);
+		if (err)
+			return err;
+		if (result && !optimus) {
+			err = -ENODEV;
+			pr_warn("Can not switch MUX to dGPU mode when eGPU is enabled: %d\n",
+				err);
+			return err;
+		}
+	}
+
+	err = armoury_wmi_set_devstate(attr, optimus, asus_armoury.gpu_mux_dev_id);
+	if (err)
+		return err;
+
+	sysfs_notify(kobj, NULL, attr->attr.name);
+	asus_set_reboot_and_signal_event();
+
+	return count;
+}
+WMI_SHOW_INT(gpu_mux_mode_current_value, "%d\n", asus_armoury.gpu_mux_dev_id);
+ATTR_GROUP_BOOL_CUSTOM(gpu_mux_mode, "gpu_mux_mode", "Set the GPU display MUX mode");
+
+/*
+ * A user may be required to store the value twice, typical store first, then
+ * rescan PCI bus to activate power, then store a second time to save correctly.
+ */
+static ssize_t dgpu_disable_current_value_store(struct kobject *kobj,
+						struct kobj_attribute *attr, const char *buf,
+						size_t count)
+{
+	int result, err;
+	u32 disable;
+
+	err = kstrtou32(buf, 10, &disable);
+	if (err)
+		return err;
+
+	if (disable > 1)
+		return -EINVAL;
+
+	if (asus_armoury.gpu_mux_dev_id) {
+		err = asus_wmi_get_devstate_dsts(asus_armoury.gpu_mux_dev_id, &result);
+		if (err)
+			return err;
+		if (!result && disable) {
+			err = -ENODEV;
+			pr_warn("Can not disable dGPU when the MUX is in dGPU mode: %d\n", err);
+			return err;
+		}
+		// TODO: handle a > 1 result, shouold do a PCI rescan and run again
+	}
+
+	err = armoury_wmi_set_devstate(attr, disable, ASUS_WMI_DEVID_DGPU);
+	if (err)
+		return err;
+
+	sysfs_notify(kobj, NULL, attr->attr.name);
+
+	return count;
+}
+WMI_SHOW_INT(dgpu_disable_current_value, "%d\n", ASUS_WMI_DEVID_DGPU);
+ATTR_GROUP_BOOL_CUSTOM(dgpu_disable, "dgpu_disable", "Disable the dGPU");
+
+/* The ACPI call to enable the eGPU also disables the internal dGPU */
+static ssize_t egpu_enable_current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
+					       const char *buf, size_t count)
+{
+	int result, err;
+	u32 enable;
+
+	err = kstrtou32(buf, 10, &enable);
+	if (err)
+		return err;
+
+	if (enable > 1)
+		return -EINVAL;
+
+	err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_EGPU_CONNECTED, &result);
+	if (err) {
+		pr_warn("Failed to get eGPU connection status: %d\n", err);
+		return err;
+	}
+
+	if (asus_armoury.gpu_mux_dev_id) {
+		err = asus_wmi_get_devstate_dsts(asus_armoury.gpu_mux_dev_id, &result);
+		if (err) {
+			pr_warn("Failed to get GPU MUX status: %d\n", result);
+			return result;
+		}
+		if (!result && enable) {
+			err = -ENODEV;
+			pr_warn("Can not enable eGPU when the MUX is in dGPU mode: %d\n", err);
+			return err;
+		}
+	}
+
+	err = armoury_wmi_set_devstate(attr, enable, ASUS_WMI_DEVID_EGPU);
+	if (err)
+		return err;
+
+	sysfs_notify(kobj, NULL, attr->attr.name);
+
+	return count;
+}
+WMI_SHOW_INT(egpu_enable_current_value, "%d\n", ASUS_WMI_DEVID_EGPU);
+ATTR_GROUP_BOOL_CUSTOM(egpu_enable, "egpu_enable", "Enable the eGPU (also disables dGPU)");
+
+/* Simple attribute creation */
+ATTR_GROUP_ENUM_INT_RO(charge_mode, "charge_mode", ASUS_WMI_DEVID_CHARGE_MODE, "0;1;2",
+		       "Show the current mode of charging");
+
+ATTR_GROUP_BOOL_RW(boot_sound, "boot_sound", ASUS_WMI_DEVID_BOOT_SOUND,
+		   "Set the boot POST sound");
+ATTR_GROUP_BOOL_RW(mcu_powersave, "mcu_powersave", ASUS_WMI_DEVID_MCU_POWERSAVE,
+		   "Set MCU powersaving mode");
+ATTR_GROUP_BOOL_RW(panel_od, "panel_overdrive", ASUS_WMI_DEVID_PANEL_OD,
+		   "Set the panel refresh overdrive");
+ATTR_GROUP_BOOL_RO(egpu_connected, "egpu_connected", ASUS_WMI_DEVID_EGPU_CONNECTED,
+		   "Show the eGPU connection status");
+
+/* If an attribute does not require any special case handling add it here */
+static const struct asus_attr_group armoury_attr_groups[] = {
+	{ &egpu_connected_attr_group, ASUS_WMI_DEVID_EGPU_CONNECTED },
+	{ &egpu_enable_attr_group, ASUS_WMI_DEVID_EGPU },
+	{ &dgpu_disable_attr_group, ASUS_WMI_DEVID_DGPU },
+
+	{ &charge_mode_attr_group, ASUS_WMI_DEVID_CHARGE_MODE },
+	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
+	{ &mcu_powersave_attr_group, ASUS_WMI_DEVID_MCU_POWERSAVE },
+	{ &panel_od_attr_group, ASUS_WMI_DEVID_PANEL_OD },
+};
+
+static int asus_fw_attr_add(void)
+{
+	int err, i;
+
+	err = fw_attributes_class_get(&fw_attr_class);
+	if (err)
+		return err;
+
+	asus_armoury.fw_attr_dev = device_create(fw_attr_class, NULL, MKDEV(0, 0),
+						NULL, "%s", DRIVER_NAME);
+	if (IS_ERR(asus_armoury.fw_attr_dev)) {
+		err = PTR_ERR(asus_armoury.fw_attr_dev);
+		goto fail_class_get;
+	}
+
+	asus_armoury.fw_attr_kset = kset_create_and_add("attributes", NULL,
+						&asus_armoury.fw_attr_dev->kobj);
+	if (!asus_armoury.fw_attr_kset) {
+		err = -ENOMEM;
+		goto err_destroy_classdev;
+	}
+
+	err = sysfs_create_file(&asus_armoury.fw_attr_kset->kobj, &pending_reboot.attr);
+	if (err) {
+		pr_err("Failed to create sysfs level attributes\n");
+		goto err_destroy_kset;
+	}
+
+	asus_armoury.mini_led_dev_id = 0;
+	if (asus_wmi_is_present(ASUS_WMI_DEVID_MINI_LED_MODE)) {
+		asus_armoury.mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
+	} else if (asus_wmi_is_present(ASUS_WMI_DEVID_MINI_LED_MODE2)) {
+		asus_armoury.mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE2;
+	}
+
+	if (asus_armoury.mini_led_dev_id) {
+		err = sysfs_create_group(&asus_armoury.fw_attr_kset->kobj, &mini_led_mode_attr_group);
+		if (err) {
+			pr_err("Failed to create sysfs-group for mini_led\n");
+			goto err_remove_file;
+		}
+	}
+
+	asus_armoury.gpu_mux_dev_id = 0;
+	if (asus_wmi_is_present(ASUS_WMI_DEVID_GPU_MUX)) {
+		asus_armoury.gpu_mux_dev_id = ASUS_WMI_DEVID_GPU_MUX;
+	} else if (asus_wmi_is_present(ASUS_WMI_DEVID_GPU_MUX_VIVO)) {
+		asus_armoury.gpu_mux_dev_id = ASUS_WMI_DEVID_GPU_MUX_VIVO;
+	}
+
+	if (asus_armoury.gpu_mux_dev_id) {
+		err = sysfs_create_group(&asus_armoury.fw_attr_kset->kobj, &gpu_mux_mode_attr_group);
+		if (err) {
+			pr_err("Failed to create sysfs-group for gpu_mux\n");
+			goto err_remove_mini_led_group;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(armoury_attr_groups); i++) {
+		if (!asus_wmi_is_present(armoury_attr_groups[i].wmi_devid))
+			continue;
+
+		err = sysfs_create_group(&asus_armoury.fw_attr_kset->kobj,
+					 armoury_attr_groups[i].attr_group);
+		if (err) {
+			pr_err("Failed to create sysfs-group for %s\n",
+			       armoury_attr_groups[i].attr_group->name);
+			goto err_remove_groups;
+		}
+	}
+
+	return 0;
+
+err_remove_groups:
+	while (--i >= 0) {
+		if (asus_wmi_is_present(armoury_attr_groups[i].wmi_devid))
+			sysfs_remove_group(&asus_armoury.fw_attr_kset->kobj, armoury_attr_groups[i].attr_group);
+	}
+	sysfs_remove_group(&asus_armoury.fw_attr_kset->kobj, &gpu_mux_mode_attr_group);
+err_remove_mini_led_group:
+	sysfs_remove_group(&asus_armoury.fw_attr_kset->kobj, &mini_led_mode_attr_group);
+err_remove_file:
+	sysfs_remove_file(&asus_armoury.fw_attr_kset->kobj, &pending_reboot.attr);
+err_destroy_kset:
+	kset_unregister(asus_armoury.fw_attr_kset);
+err_destroy_classdev:
+	device_destroy(fw_attr_class, MKDEV(0, 0));
+fail_class_get:
+	fw_attributes_class_put();
+	return err;
+}
+
+/* Init / exit ****************************************************************/
+
+static int __init asus_fw_init(void)
+{
+	char *wmi_uid;
+	int err;
+
+	wmi_uid = wmi_get_acpi_device_uid(ASUS_WMI_MGMT_GUID);
+	if (!wmi_uid)
+		return -ENODEV;
+
+	/*
+	 * if equal to "ASUSWMI" then it's DCTS that can't be used for this
+	 * driver, DSTS is required.
+	 */
+	if (!strcmp(wmi_uid, ASUS_ACPI_UID_ASUSWMI))
+		return -ENODEV;
+
+	err = asus_fw_attr_add();
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void __exit asus_fw_exit(void)
+{
+	mutex_lock(&asus_armoury.mutex);
+
+	sysfs_remove_file(&asus_armoury.fw_attr_kset->kobj, &pending_reboot.attr);
+	kset_unregister(asus_armoury.fw_attr_kset);
+	device_destroy(fw_attr_class, MKDEV(0, 0));
+	fw_attributes_class_put();
+
+	mutex_unlock(&asus_armoury.mutex);
+}
+
+module_init(asus_fw_init);
+module_exit(asus_fw_exit);
+
+MODULE_IMPORT_NS("ASUS_WMI");
+MODULE_AUTHOR("Luke Jones <luke@ljones.dev>");
+MODULE_DESCRIPTION("ASUS BIOS Configuration Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("wmi:" ASUS_NB_WMI_EVENT_GUID);
diff --git a/drivers/platform/x86/asus-armoury.h b/drivers/platform/x86/asus-armoury.h
new file mode 100644
index 000000000000..b00d829c9da0
--- /dev/null
+++ b/drivers/platform/x86/asus-armoury.h
@@ -0,0 +1,147 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Definitions for kernel modules using asus-armoury driver
+ *
+ *  Copyright (c) 2024 Luke Jones <luke@ljones.dev>
+ */
+
+#ifndef _ASUS_ARMOURY_H_
+#define _ASUS_ARMOURY_H_
+
+#include <linux/types.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "asus-armoury"
+
+static ssize_t attr_uint_store(struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t count, u32 min, u32 max,
+			      u32 *store_value, u32 wmi_dev);
+
+static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	return sysfs_emit(buf, "enumeration\n");
+}
+
+#define __ASUS_ATTR_RO(_func, _name)                                  \
+	{                                                             \
+		.attr = { .name = __stringify(_name), .mode = 0444 }, \
+		.show = _func##_##_name##_show,                       \
+	}
+
+#define __ASUS_ATTR_RO_AS(_name, _show)                               \
+	{                                                             \
+		.attr = { .name = __stringify(_name), .mode = 0444 }, \
+		.show = _show,                                        \
+	}
+
+#define __ASUS_ATTR_RW(_func, _name) \
+	__ATTR(_name, 0644, _func##_##_name##_show, _func##_##_name##_store)
+
+#define __WMI_STORE_INT(_attr, _min, _max, _wmi)                          \
+	static ssize_t _attr##_store(struct kobject *kobj,                \
+				     struct kobj_attribute *attr,         \
+				     const char *buf, size_t count)       \
+	{                                                                 \
+		return attr_uint_store(kobj, attr, buf, count, _min, _max, \
+				      NULL, _wmi);                        \
+	}
+
+#define WMI_SHOW_INT(_attr, _fmt, _wmi)                                     \
+	static ssize_t _attr##_show(struct kobject *kobj,                   \
+				    struct kobj_attribute *attr, char *buf) \
+	{                                                                   \
+		u32 result;                                                 \
+		int err;                                                    \
+		                                                            \
+		err = asus_wmi_get_devstate_dsts(_wmi, &result);            \
+		if (err)                                                    \
+			return err;                                         \
+		return sysfs_emit(buf, _fmt,                                \
+				  result & ~ASUS_WMI_DSTS_PRESENCE_BIT);    \
+	}
+
+/* Create functions and attributes for use in other macros or on their own */
+
+#define __ATTR_CURRENT_INT_RO(_attr, _wmi)                          \
+	WMI_SHOW_INT(_attr##_current_value, "%d\n", _wmi);          \
+	static struct kobj_attribute attr_##_attr##_current_value = \
+		__ASUS_ATTR_RO(_attr, current_value)
+
+#define __ATTR_CURRENT_INT_RW(_attr, _minv, _maxv, _wmi)            \
+	__WMI_STORE_INT(_attr##_current_value, _minv, _maxv, _wmi); \
+	WMI_SHOW_INT(_attr##_current_value, "%d\n", _wmi);          \
+	static struct kobj_attribute attr_##_attr##_current_value = \
+		__ASUS_ATTR_RW(_attr, current_value)
+
+/* Shows a formatted static variable */
+#define __ATTR_SHOW_FMT(_prop, _attrname, _fmt, _val)                         \
+	static ssize_t _attrname##_##_prop##_show(                            \
+		struct kobject *kobj, struct kobj_attribute *attr, char *buf) \
+	{                                                                     \
+		return sysfs_emit(buf, _fmt, _val);                           \
+	}                                                                     \
+	static struct kobj_attribute attr_##_attrname##_##_prop =             \
+		__ASUS_ATTR_RO(_attrname, _prop)
+
+/* Boolean style enumeration, base macro. Requires adding show/store */
+#define __ATTR_GROUP_ENUM(_attrname, _fsname, _possible, _dispname)     \
+	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);    \
+	__ATTR_SHOW_FMT(possible_values, _attrname, "%s\n", _possible); \
+	static struct kobj_attribute attr_##_attrname##_type =          \
+		__ASUS_ATTR_RO_AS(type, enum_type_show);                \
+	static struct attribute *_attrname##_attrs[] = {                \
+		&attr_##_attrname##_current_value.attr,                 \
+		&attr_##_attrname##_display_name.attr,                  \
+		&attr_##_attrname##_possible_values.attr,               \
+		&attr_##_attrname##_type.attr,                          \
+		NULL                                                    \
+	};                                                              \
+	static const struct attribute_group _attrname##_attr_group = {  \
+		.name = _fsname, .attrs = _attrname##_attrs             \
+	}
+
+#define ATTR_GROUP_BOOL_RO(_attrname, _fsname, _wmi, _dispname) \
+	__ATTR_CURRENT_INT_RO(_attrname, _wmi);                 \
+	__ATTR_GROUP_ENUM(_attrname, _fsname, "0;1", _dispname)
+
+#define ATTR_GROUP_BOOL_RW(_attrname, _fsname, _wmi, _dispname) \
+	__ATTR_CURRENT_INT_RW(_attrname, 0, 1, _wmi);           \
+	__ATTR_GROUP_ENUM(_attrname, _fsname, "0;1", _dispname)
+
+/*
+ * Requires <name>_current_value_show(), <name>_current_value_show()
+ */
+#define ATTR_GROUP_BOOL_CUSTOM(_attrname, _fsname, _dispname)           \
+	static struct kobj_attribute attr_##_attrname##_current_value = \
+		__ASUS_ATTR_RW(_attrname, current_value);               \
+	__ATTR_GROUP_ENUM(_attrname, _fsname, "0;1", _dispname)
+
+#define ATTR_GROUP_ENUM_INT_RO(_attrname, _fsname, _wmi, _possible, _dispname) \
+	__ATTR_CURRENT_INT_RO(_attrname, _wmi);                                \
+	__ATTR_GROUP_ENUM(_attrname, _fsname, _possible, _dispname)
+
+/*
+ * Requires <name>_current_value_show(), <name>_current_value_show()
+ * and <name>_possible_values_show()
+ */
+#define ATTR_GROUP_ENUM_CUSTOM(_attrname, _fsname, _dispname)             \
+	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);      \
+	static struct kobj_attribute attr_##_attrname##_current_value =   \
+		__ASUS_ATTR_RW(_attrname, current_value);                 \
+	static struct kobj_attribute attr_##_attrname##_possible_values = \
+		__ASUS_ATTR_RO(_attrname, possible_values);               \
+	static struct kobj_attribute attr_##_attrname##_type =            \
+		__ASUS_ATTR_RO_AS(type, enum_type_show);                  \
+	static struct attribute *_attrname##_attrs[] = {                  \
+		&attr_##_attrname##_current_value.attr,                   \
+		&attr_##_attrname##_display_name.attr,                    \
+		&attr_##_attrname##_possible_values.attr,                 \
+		&attr_##_attrname##_type.attr,                            \
+		NULL                                                      \
+	};                                                                \
+	static const struct attribute_group _attrname##_attr_group = {    \
+		.name = _fsname, .attrs = _attrname##_attrs               \
+	}
+
+#endif /* _ASUS_BIOSCFG_H_ */
diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index ab6fcd2ea8b2..2bccb28d8e41 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -56,8 +56,6 @@ module_param(fnlock_default, bool, 0444);
 #define to_asus_wmi_driver(pdrv)					\
 	(container_of((pdrv), struct asus_wmi_driver, platform_driver))
 
-#define ASUS_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
-
 #define NOTIFY_BRNUP_MIN		0x11
 #define NOTIFY_BRNUP_MAX		0x1f
 #define NOTIFY_BRNDOWN_MIN		0x20
@@ -106,8 +104,6 @@ module_param(fnlock_default, bool, 0444);
 #define USB_INTEL_XUSB2PR		0xD0
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
 
-#define ASUS_ACPI_UID_ASUSWMI		"ASUSWMI"
-
 #define WMI_EVENT_MASK			0xFFFF
 
 #define FAN_CURVE_POINTS		8
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index eb0395edde4c..88f107eb54ea 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -6,6 +6,9 @@
 #include <linux/types.h>
 #include <linux/dmi.h>
 
+#define ASUS_WMI_MGMT_GUID	"97845ED0-4E6D-11DE-8A39-0800200C9A66"
+#define ASUS_ACPI_UID_ASUSWMI	"ASUSWMI"
+
 /* WMI Methods */
 #define ASUS_WMI_METHODID_SPEC	        0x43455053 /* BIOS SPECification */
 #define ASUS_WMI_METHODID_SFBD		0x44424653 /* Set First Boot Device */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Thu, 19 Sep 2024 17:23:35 +1200
Subject: platform/x86: asus-armoury: add panel_hd_mode attribute

Add panel_hd_mode to toggle the panel mode between single and high
definition modes.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/platform/x86/asus-armoury.c        | 6 +++++-
 include/linux/platform_data/x86/asus-wmi.h | 1 +
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index e6b64418f77b..b8b9440e0c31 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -107,7 +107,8 @@ static struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);
 
 static bool asus_bios_requires_reboot(struct kobj_attribute *attr)
 {
-	return !strcmp(attr->attr.name, "gpu_mux_mode");
+	return !strcmp(attr->attr.name, "gpu_mux_mode") ||
+	       !strcmp(attr->attr.name, "panel_hd_mode");
 }
 
 static int armoury_wmi_set_devstate(struct kobj_attribute *attr, u32 value, u32 wmi_dev)
@@ -419,6 +420,8 @@ ATTR_GROUP_BOOL_RW(mcu_powersave, "mcu_powersave", ASUS_WMI_DEVID_MCU_POWERSAVE,
 		   "Set MCU powersaving mode");
 ATTR_GROUP_BOOL_RW(panel_od, "panel_overdrive", ASUS_WMI_DEVID_PANEL_OD,
 		   "Set the panel refresh overdrive");
+ATTR_GROUP_BOOL_RW(panel_hd_mode, "panel_hd_mode", ASUS_WMI_DEVID_PANEL_HD,
+		   "Set the panel HD mode to UHD<0> or FHD<1>");
 ATTR_GROUP_BOOL_RO(egpu_connected, "egpu_connected", ASUS_WMI_DEVID_EGPU_CONNECTED,
 		   "Show the eGPU connection status");
 
@@ -432,6 +435,7 @@ static const struct asus_attr_group armoury_attr_groups[] = {
 	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
 	{ &mcu_powersave_attr_group, ASUS_WMI_DEVID_MCU_POWERSAVE },
 	{ &panel_od_attr_group, ASUS_WMI_DEVID_PANEL_OD },
+	{ &panel_hd_mode_attr_group, ASUS_WMI_DEVID_PANEL_HD },
 };
 
 static int asus_fw_attr_add(void)
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 88f107eb54ea..4408f8171c8e 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -76,6 +76,7 @@
 #define ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY_VIVO 0x00110019
 
 /* Misc */
+#define ASUS_WMI_DEVID_PANEL_HD		0x0005001C
 #define ASUS_WMI_DEVID_PANEL_OD		0x00050019
 #define ASUS_WMI_DEVID_CAMERA		0x00060013
 #define ASUS_WMI_DEVID_LID_FLIP		0x00060062
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Thu, 19 Sep 2024 17:19:37 +1200
Subject: platform/x86: asus-armoury: add the ppt_* and nv_* tuning knobs

Adds the ppt_* and nv_* tuning knobs that are available via WMI methods
and adds proper min/max levels plus defaults.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/platform/x86/asus-armoury.c | 134 ++++++++++++++++++++++++++++
 drivers/platform/x86/asus-armoury.h |  65 ++++++++++++++
 2 files changed, 199 insertions(+)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index b8b9440e0c31..9e9c57cc742f 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -52,12 +52,40 @@
 #define PPT_PLATFORM_MAX      100
 #define PPT_PLATFORM_DEFAULT  80
 
+/* Tunables provided by ASUS for gaming laptops */
+struct rog_tunables {
+	u32 cpu_default;
+	u32 cpu_min;
+	u32 cpu_max;
+
+	u32 platform_default;
+	u32 platform_min;
+	u32 platform_max;
+
+	u32 ppt_pl1_spl; // cpu
+	u32 ppt_pl2_sppt; // cpu
+	u32 ppt_pl3_fppt; // cpu
+	u32 ppt_apu_sppt; // plat
+	u32 ppt_platform_sppt; // plat
+
+	u32 nv_boost_default;
+	u32 nv_boost_min;
+	u32 nv_boost_max;
+	u32 nv_dynamic_boost;
+
+	u32 nv_temp_default;
+	u32 nv_temp_min;
+	u32 nv_temp_max;
+	u32 nv_temp_target;
+};
+
 static const struct class *fw_attr_class;
 
 struct asus_armoury_priv {
 	struct device *fw_attr_dev;
 	struct kset *fw_attr_kset;
 
+	struct rog_tunables *rog_tunables;
 	u32 mini_led_dev_id;
 	u32 gpu_mux_dev_id;
 
@@ -411,6 +439,25 @@ WMI_SHOW_INT(egpu_enable_current_value, "%d\n", ASUS_WMI_DEVID_EGPU);
 ATTR_GROUP_BOOL_CUSTOM(egpu_enable, "egpu_enable", "Enable the eGPU (also disables dGPU)");
 
 /* Simple attribute creation */
+ATTR_GROUP_ROG_TUNABLE(ppt_pl1_spl, "ppt_pl1_spl", ASUS_WMI_DEVID_PPT_PL1_SPL, cpu_default,
+		       cpu_min, cpu_max, 1, "Set the CPU slow package limit");
+ATTR_GROUP_ROG_TUNABLE(ppt_pl2_sppt, "ppt_pl2_sppt", ASUS_WMI_DEVID_PPT_PL2_SPPT, cpu_default,
+		       cpu_min, cpu_max, 1, "Set the CPU fast package limit");
+ATTR_GROUP_ROG_TUNABLE(ppt_pl3_fppt, "ppt_pl3_fppt", ASUS_WMI_DEVID_PPT_FPPT, cpu_default, cpu_min,
+		       cpu_max, 1, "Set the CPU slow package limit");
+ATTR_GROUP_ROG_TUNABLE(ppt_apu_sppt, "ppt_apu_sppt", ASUS_WMI_DEVID_PPT_APU_SPPT,
+		       platform_default, platform_min, platform_max, 1,
+		       "Set the CPU slow package limit");
+ATTR_GROUP_ROG_TUNABLE(ppt_platform_sppt, "ppt_platform_sppt", ASUS_WMI_DEVID_PPT_PLAT_SPPT,
+		       platform_default, platform_min, platform_max, 1,
+		       "Set the CPU slow package limit");
+ATTR_GROUP_ROG_TUNABLE(nv_dynamic_boost, "nv_dynamic_boost", ASUS_WMI_DEVID_NV_DYN_BOOST,
+		       nv_boost_default, nv_boost_min, nv_boost_max, 1,
+		       "Set the Nvidia dynamic boost limit");
+ATTR_GROUP_ROG_TUNABLE(nv_temp_target, "nv_temp_target", ASUS_WMI_DEVID_NV_THERM_TARGET,
+		       nv_temp_default, nv_boost_min, nv_temp_max, 1,
+		       "Set the Nvidia max thermal limit");
+
 ATTR_GROUP_ENUM_INT_RO(charge_mode, "charge_mode", ASUS_WMI_DEVID_CHARGE_MODE, "0;1;2",
 		       "Show the current mode of charging");
 
@@ -431,6 +478,14 @@ static const struct asus_attr_group armoury_attr_groups[] = {
 	{ &egpu_enable_attr_group, ASUS_WMI_DEVID_EGPU },
 	{ &dgpu_disable_attr_group, ASUS_WMI_DEVID_DGPU },
 
+	{ &ppt_pl1_spl_attr_group, ASUS_WMI_DEVID_PPT_PL1_SPL },
+	{ &ppt_pl2_sppt_attr_group, ASUS_WMI_DEVID_PPT_PL2_SPPT },
+	{ &ppt_pl3_fppt_attr_group, ASUS_WMI_DEVID_PPT_FPPT },
+	{ &ppt_apu_sppt_attr_group, ASUS_WMI_DEVID_PPT_APU_SPPT },
+	{ &ppt_platform_sppt_attr_group, ASUS_WMI_DEVID_PPT_PLAT_SPPT },
+	{ &nv_dynamic_boost_attr_group, ASUS_WMI_DEVID_NV_DYN_BOOST },
+	{ &nv_temp_target_attr_group, ASUS_WMI_DEVID_NV_THERM_TARGET },
+
 	{ &charge_mode_attr_group, ASUS_WMI_DEVID_CHARGE_MODE },
 	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
 	{ &mcu_powersave_attr_group, ASUS_WMI_DEVID_MCU_POWERSAVE },
@@ -532,6 +587,79 @@ static int asus_fw_attr_add(void)
 
 /* Init / exit ****************************************************************/
 
+/* Set up the min/max and defaults for ROG tunables */
+static void init_rog_tunables(struct rog_tunables *rog)
+{
+	u32 platform_default = PPT_PLATFORM_DEFAULT;
+	u32 cpu_default = PPT_CPU_LIMIT_DEFAULT;
+	u32 platform_max = PPT_PLATFORM_MAX;
+	u32 max_boost = NVIDIA_BOOST_MAX;
+	u32 cpu_max = PPT_CPU_LIMIT_MAX;
+	const char *product;
+
+	/*
+	 * ASUS product_name contains everything required, e.g,
+	 * "ROG Flow X16 GV601VV_GV601VV_00185149B".
+	 * The bulk of these defaults are gained from users reporting what
+	 * ASUS Armoury Crate in Windows provides them.
+	 * This should be turned in to a table eventually.
+	 */
+	product = dmi_get_system_info(DMI_PRODUCT_NAME);
+
+	if (strstr(product, "GA402R")) {
+		cpu_default = 125;
+	} else if (strstr(product, "13QY")) {
+		cpu_max = 250;
+	} else if (strstr(product, "X13")) {
+		cpu_max = 75;
+		cpu_default = 50;
+	} else if (strstr(product, "RC71") || strstr(product, "RC72")) {
+		cpu_max = 50;
+		cpu_default = 30;
+	} else if (strstr(product, "G814") || strstr(product, "G614") ||
+		   strstr(product, "G834") || strstr(product, "G634")) {
+		cpu_max = 175;
+	} else if (strstr(product, "GA402X") || strstr(product, "GA403") ||
+		   strstr(product, "FA507N") || strstr(product, "FA507X") ||
+		   strstr(product, "FA707N") || strstr(product, "FA707X")) {
+		cpu_max = 90;
+	} else {
+		pr_notice("Using default CPU limits. Please report if these are not correct.\n");
+	}
+
+	if (strstr(product, "GZ301ZE"))
+		max_boost = 5;
+	else if (strstr(product, "FX507ZC4"))
+		max_boost = 15;
+	else if (strstr(product, "GU605"))
+		max_boost = 20;
+
+	/* ensure defaults for tunables */
+	rog->cpu_default = cpu_default;
+	rog->cpu_min = PPT_CPU_LIMIT_MIN;
+	rog->cpu_max = cpu_max;
+
+	rog->platform_default = platform_default;
+	rog->platform_max = PPT_PLATFORM_MIN;
+	rog->platform_max = platform_max;
+
+	rog->ppt_pl1_spl = cpu_default;
+	rog->ppt_pl2_sppt = cpu_default;
+	rog->ppt_pl3_fppt = cpu_default;
+	rog->ppt_apu_sppt = cpu_default;
+	rog->ppt_platform_sppt = platform_default;
+
+	rog->nv_boost_default = NVIDIA_BOOST_MAX;
+	rog->nv_boost_min = NVIDIA_BOOST_MIN;
+	rog->nv_boost_max = max_boost;
+	rog->nv_dynamic_boost = NVIDIA_BOOST_MIN;
+
+	rog->nv_temp_default = NVIDIA_TEMP_MAX;
+	rog->nv_temp_min = NVIDIA_TEMP_MIN;
+	rog->nv_temp_max = NVIDIA_TEMP_MAX;
+	rog->nv_temp_target = NVIDIA_TEMP_MIN;
+}
+
 static int __init asus_fw_init(void)
 {
 	char *wmi_uid;
@@ -548,6 +676,12 @@ static int __init asus_fw_init(void)
 	if (!strcmp(wmi_uid, ASUS_ACPI_UID_ASUSWMI))
 		return -ENODEV;
 
+	asus_armoury.rog_tunables = kzalloc(sizeof(struct rog_tunables), GFP_KERNEL);
+	if (!asus_armoury.rog_tunables)
+		return -ENOMEM;
+
+	init_rog_tunables(asus_armoury.rog_tunables);
+
 	err = asus_fw_attr_add();
 	if (err)
 		return err;
diff --git a/drivers/platform/x86/asus-armoury.h b/drivers/platform/x86/asus-armoury.h
index b00d829c9da0..91ec6f4cb149 100644
--- a/drivers/platform/x86/asus-armoury.h
+++ b/drivers/platform/x86/asus-armoury.h
@@ -17,6 +17,12 @@ static ssize_t attr_uint_store(struct kobject *kobj, struct kobj_attribute *attr
 			      const char *buf, size_t count, u32 min, u32 max,
 			      u32 *store_value, u32 wmi_dev);
 
+static ssize_t int_type_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	return sysfs_emit(buf, "integer\n");
+}
+
 static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
 			      char *buf)
 {
@@ -144,4 +150,63 @@ static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
 		.name = _fsname, .attrs = _attrname##_attrs               \
 	}
 
+/*
+ * ROG PPT attributes need a little different in setup as they
+ * require rog_tunables members.
+ */
+
+#define __ROG_TUNABLE_RW(_attr, _min, _max, _wmi)                             \
+	static ssize_t _attr##_current_value_store(                           \
+		struct kobject *kobj, struct kobj_attribute *attr,            \
+		const char *buf, size_t count)                                \
+	{                                                                     \
+		return attr_uint_store(kobj, attr, buf, count,                 \
+				      asus_armoury.rog_tunables->_min,        \
+				      asus_armoury.rog_tunables->_max,        \
+				      &asus_armoury.rog_tunables->_attr,      \
+				      _wmi);                                  \
+	}                                                                     \
+	static ssize_t _attr##_current_value_show(                            \
+		struct kobject *kobj, struct kobj_attribute *attr, char *buf) \
+	{                                                                     \
+		return sysfs_emit(buf, "%u\n",                                \
+				  asus_armoury.rog_tunables->_attr);          \
+	}                                                                     \
+	static struct kobj_attribute attr_##_attr##_current_value =           \
+		__ASUS_ATTR_RW(_attr, current_value)
+
+#define __ROG_TUNABLE_SHOW(_prop, _attrname, _val)                            \
+	static ssize_t _attrname##_##_prop##_show(                            \
+		struct kobject *kobj, struct kobj_attribute *attr, char *buf) \
+	{                                                                     \
+		return sysfs_emit(buf, "%d\n",                                \
+				  asus_armoury.rog_tunables->_val);           \
+	}                                                                     \
+	static struct kobj_attribute attr_##_attrname##_##_prop =             \
+		__ASUS_ATTR_RO(_attrname, _prop)
+
+#define ATTR_GROUP_ROG_TUNABLE(_attrname, _fsname, _wmi, _default, _min, _max, \
+			       _incstep, _dispname)                            \
+	__ROG_TUNABLE_SHOW(default_value, _attrname, _default);                \
+	__ROG_TUNABLE_RW(_attrname, _min, _max, _wmi);                         \
+	__ROG_TUNABLE_SHOW(min_value, _attrname, _min);                        \
+	__ROG_TUNABLE_SHOW(max_value, _attrname, _max);                        \
+	__ATTR_SHOW_FMT(scalar_increment, _attrname, "%d\n", _incstep);        \
+	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);           \
+	static struct kobj_attribute attr_##_attrname##_type =                 \
+		__ASUS_ATTR_RO_AS(type, int_type_show);                        \
+	static struct attribute *_attrname##_attrs[] = {                       \
+		&attr_##_attrname##_current_value.attr,                        \
+		&attr_##_attrname##_default_value.attr,                        \
+		&attr_##_attrname##_min_value.attr,                            \
+		&attr_##_attrname##_max_value.attr,                            \
+		&attr_##_attrname##_scalar_increment.attr,                     \
+		&attr_##_attrname##_display_name.attr,                         \
+		&attr_##_attrname##_type.attr,                                 \
+		NULL                                                           \
+	};                                                                     \
+	static const struct attribute_group _attrname##_attr_group = {         \
+		.name = _fsname, .attrs = _attrname##_attrs                    \
+	}
+
 #endif /* _ASUS_BIOSCFG_H_ */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sun, 2 Jun 2024 14:32:15 +1200
Subject: platform/x86: asus-armoury: add dgpu tgp control

Implement the dgpu TGP control under the asus-armoury module using the
fw_attributes class.

Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Luke D. Jones <luke@ljones.dev>
---
 drivers/platform/x86/asus-armoury.c        | 21 +++++++++++++++++++++
 drivers/platform/x86/asus-armoury.h        | 18 ++++++++++++++++++
 include/linux/platform_data/x86/asus-wmi.h |  3 +++
 3 files changed, 42 insertions(+)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index 9e9c57cc742f..5d7e4643813e 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -45,6 +45,9 @@
 #define NVIDIA_BOOST_MAX      25
 #define NVIDIA_TEMP_MIN       75
 #define NVIDIA_TEMP_MAX       87
+#define NVIDIA_POWER_MIN      0
+#define NVIDIA_POWER_MAX      70
+#define NVIDIA_POWER_DEFAULT  70
 #define PPT_CPU_LIMIT_MIN     5
 #define PPT_CPU_LIMIT_MAX     150
 #define PPT_CPU_LIMIT_DEFAULT 80
@@ -77,6 +80,11 @@ struct rog_tunables {
 	u32 nv_temp_min;
 	u32 nv_temp_max;
 	u32 nv_temp_target;
+
+	u32 dgpu_tgp_default;
+	u32 dgpu_tgp_min;
+	u32 dgpu_tgp_max;
+	u32 dgpu_tgp;
 };
 
 static const struct class *fw_attr_class;
@@ -457,6 +465,12 @@ ATTR_GROUP_ROG_TUNABLE(nv_dynamic_boost, "nv_dynamic_boost", ASUS_WMI_DEVID_NV_D
 ATTR_GROUP_ROG_TUNABLE(nv_temp_target, "nv_temp_target", ASUS_WMI_DEVID_NV_THERM_TARGET,
 		       nv_temp_default, nv_boost_min, nv_temp_max, 1,
 		       "Set the Nvidia max thermal limit");
+ATTR_GROUP_ROG_TUNABLE(dgpu_tgp, "dgpu_tgp", ASUS_WMI_DEVID_DGPU_SET_TGP, dgpu_tgp_default,
+		       dgpu_tgp_min, dgpu_tgp_max, 1,
+		       "Set the additional TGP on top of the base TGP");
+
+ATTR_GROUP_INT_VALUE_ONLY_RO(dgpu_base_tgp, "dgpu_base_tgp", ASUS_WMI_DEVID_DGPU_BASE_TGP,
+			     "Read the base TGP value");
 
 ATTR_GROUP_ENUM_INT_RO(charge_mode, "charge_mode", ASUS_WMI_DEVID_CHARGE_MODE, "0;1;2",
 		       "Show the current mode of charging");
@@ -485,6 +499,8 @@ static const struct asus_attr_group armoury_attr_groups[] = {
 	{ &ppt_platform_sppt_attr_group, ASUS_WMI_DEVID_PPT_PLAT_SPPT },
 	{ &nv_dynamic_boost_attr_group, ASUS_WMI_DEVID_NV_DYN_BOOST },
 	{ &nv_temp_target_attr_group, ASUS_WMI_DEVID_NV_THERM_TARGET },
+	{ &dgpu_base_tgp_attr_group, ASUS_WMI_DEVID_DGPU_BASE_TGP },
+	{ &dgpu_tgp_attr_group, ASUS_WMI_DEVID_DGPU_SET_TGP },
 
 	{ &charge_mode_attr_group, ASUS_WMI_DEVID_CHARGE_MODE },
 	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
@@ -658,6 +674,11 @@ static void init_rog_tunables(struct rog_tunables *rog)
 	rog->nv_temp_min = NVIDIA_TEMP_MIN;
 	rog->nv_temp_max = NVIDIA_TEMP_MAX;
 	rog->nv_temp_target = NVIDIA_TEMP_MIN;
+
+	rog->dgpu_tgp_default = NVIDIA_POWER_DEFAULT;
+	rog->dgpu_tgp_min = NVIDIA_POWER_MIN;
+	rog->dgpu_tgp_max = NVIDIA_POWER_MAX;
+	rog->dgpu_tgp = NVIDIA_POWER_MAX;
 }
 
 static int __init asus_fw_init(void)
diff --git a/drivers/platform/x86/asus-armoury.h b/drivers/platform/x86/asus-armoury.h
index 91ec6f4cb149..9639e7ca772f 100644
--- a/drivers/platform/x86/asus-armoury.h
+++ b/drivers/platform/x86/asus-armoury.h
@@ -90,6 +90,20 @@ static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
 	static struct kobj_attribute attr_##_attrname##_##_prop =             \
 		__ASUS_ATTR_RO(_attrname, _prop)
 
+/* Requires current_value_show */
+#define __ATTR_GROUP_INT_VALUE_ONLY(_attrname, _fsname, _dispname)     \
+	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);   \
+	static struct kobj_attribute attr_##_attrname##_type =         \
+		__ASUS_ATTR_RO_AS(type, int_type_show);                \
+	static struct attribute *_attrname##_attrs[] = {               \
+		&attr_##_attrname##_current_value.attr,                \
+		&attr_##_attrname##_display_name.attr,                 \
+		&attr_##_attrname##_type.attr, NULL                    \
+	};                                                             \
+	static const struct attribute_group _attrname##_attr_group = { \
+		.name = _fsname, .attrs = _attrname##_attrs            \
+	}
+
 /* Boolean style enumeration, base macro. Requires adding show/store */
 #define __ATTR_GROUP_ENUM(_attrname, _fsname, _possible, _dispname)     \
 	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);    \
@@ -107,6 +121,10 @@ static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
 		.name = _fsname, .attrs = _attrname##_attrs             \
 	}
 
+#define ATTR_GROUP_INT_VALUE_ONLY_RO(_attrname, _fsname, _wmi, _dispname) \
+	__ATTR_CURRENT_INT_RO(_attrname, _wmi);                           \
+	__ATTR_GROUP_INT_VALUE_ONLY(_attrname, _fsname, _dispname)
+
 #define ATTR_GROUP_BOOL_RO(_attrname, _fsname, _wmi, _dispname) \
 	__ATTR_CURRENT_INT_RO(_attrname, _wmi);                 \
 	__ATTR_GROUP_ENUM(_attrname, _fsname, "0;1", _dispname)
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 4408f8171c8e..291a8314d0f5 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -137,6 +137,9 @@
 /* dgpu on/off */
 #define ASUS_WMI_DEVID_DGPU		0x00090020
 
+#define ASUS_WMI_DEVID_DGPU_BASE_TGP	0x00120099
+#define ASUS_WMI_DEVID_DGPU_SET_TGP	0x00120098
+
 /* gpu mux switch, 0 = dGPU, 1 = Optimus */
 #define ASUS_WMI_DEVID_GPU_MUX		0x00090016
 #define ASUS_WMI_DEVID_GPU_MUX_VIVO	0x00090026
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sun, 2 Jun 2024 14:44:31 +1200
Subject: platform/x86: asus-armoury: add apu-mem control support

Implement the APU memory size control under the asus-armoury module using
the fw_attributes class.

This allows the APU allocated memory size to be adjusted depending on
the users priority. A reboot is required after change.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/platform/x86/asus-armoury.c        | 114 +++++++++++++++++++++
 include/linux/platform_data/x86/asus-wmi.h |   1 +
 2 files changed, 115 insertions(+)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index 5d7e4643813e..386f4236f5f8 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -446,6 +446,119 @@ static ssize_t egpu_enable_current_value_store(struct kobject *kobj, struct kobj
 WMI_SHOW_INT(egpu_enable_current_value, "%d\n", ASUS_WMI_DEVID_EGPU);
 ATTR_GROUP_BOOL_CUSTOM(egpu_enable, "egpu_enable", "Enable the eGPU (also disables dGPU)");
 
+/* Device memory available to APU */
+
+static ssize_t apu_mem_current_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+					  char *buf)
+{
+	int err;
+	u32 mem;
+
+	err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_APU_MEM, &mem);
+	if (err)
+		return err;
+
+	switch (mem) {
+	case 0x100:
+		mem = 0;
+		break;
+	case 0x102:
+		mem = 1;
+		break;
+	case 0x103:
+		mem = 2;
+		break;
+	case 0x104:
+		mem = 3;
+		break;
+	case 0x105:
+		mem = 4;
+		break;
+	case 0x106:
+		/* This is out of order and looks wrong but is correct */
+		mem = 8;
+		break;
+	case 0x107:
+		mem = 5;
+		break;
+	case 0x108:
+		mem = 6;
+		break;
+	case 0x109:
+		mem = 7;
+		break;
+	default:
+		mem = 4;
+		break;
+	}
+
+	return sysfs_emit(buf, "%u\n", mem);
+}
+
+static ssize_t apu_mem_current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
+					   const char *buf, size_t count)
+{
+	int result, err;
+	u32 requested, mem;
+
+	result = kstrtou32(buf, 10, &requested);
+	if (result)
+		return result;
+
+	switch (requested) {
+	case 0:
+		mem = 0x000;
+		break;
+	case 1:
+		mem = 0x102;
+		break;
+	case 2:
+		mem = 0x103;
+		break;
+	case 3:
+		mem = 0x104;
+		break;
+	case 4:
+		mem = 0x105;
+		break;
+	case 5:
+		mem = 0x107;
+		break;
+	case 6:
+		mem = 0x108;
+		break;
+	case 7:
+		mem = 0x109;
+		break;
+	case 8:
+		/* This is out of order and looks wrong but is correct */
+		mem = 0x106;
+		break;
+	default:
+		return -EIO;
+	}
+
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_APU_MEM, mem, &result);
+	if (err) {
+		pr_warn("Failed to set apu_mem: %d\n", err);
+		return err;
+	}
+
+	pr_info("APU memory changed to %uGB, reboot required\n", requested);
+	sysfs_notify(kobj, NULL, attr->attr.name);
+
+	asus_set_reboot_and_signal_event();
+
+	return count;
+}
+
+static ssize_t apu_mem_possible_values_show(struct kobject *kobj, struct kobj_attribute *attr,
+					    char *buf)
+{
+	return sysfs_emit(buf, "0;1;2;3;4;5;6;7;8\n");
+}
+ATTR_GROUP_ENUM_CUSTOM(apu_mem, "apu_mem", "Set available system RAM (in GB) for the APU to use");
+
 /* Simple attribute creation */
 ATTR_GROUP_ROG_TUNABLE(ppt_pl1_spl, "ppt_pl1_spl", ASUS_WMI_DEVID_PPT_PL1_SPL, cpu_default,
 		       cpu_min, cpu_max, 1, "Set the CPU slow package limit");
@@ -501,6 +614,7 @@ static const struct asus_attr_group armoury_attr_groups[] = {
 	{ &nv_temp_target_attr_group, ASUS_WMI_DEVID_NV_THERM_TARGET },
 	{ &dgpu_base_tgp_attr_group, ASUS_WMI_DEVID_DGPU_BASE_TGP },
 	{ &dgpu_tgp_attr_group, ASUS_WMI_DEVID_DGPU_SET_TGP },
+	{ &apu_mem_attr_group, ASUS_WMI_DEVID_APU_MEM },
 
 	{ &charge_mode_attr_group, ASUS_WMI_DEVID_CHARGE_MODE },
 	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 291a8314d0f5..25b048522b8e 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -139,6 +139,7 @@
 
 #define ASUS_WMI_DEVID_DGPU_BASE_TGP	0x00120099
 #define ASUS_WMI_DEVID_DGPU_SET_TGP	0x00120098
+#define ASUS_WMI_DEVID_APU_MEM		0x000600C1
 
 /* gpu mux switch, 0 = dGPU, 1 = Optimus */
 #define ASUS_WMI_DEVID_GPU_MUX		0x00090016
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Wed, 18 Sep 2024 21:19:12 +1200
Subject: platform/x86: asus-armoury: add core count control

Implement Intel core enablement under the asus-armoury module using the
fw_attributes class.

This allows users to enable or disable preformance or efficiency cores
depending on their requirements. After change a reboot is required.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/platform/x86/asus-armoury.c        | 226 +++++++++++++++++++++
 drivers/platform/x86/asus-armoury.h        |  28 +++
 include/linux/platform_data/x86/asus-wmi.h |   4 +
 3 files changed, 258 insertions(+)

diff --git a/drivers/platform/x86/asus-armoury.c b/drivers/platform/x86/asus-armoury.c
index 386f4236f5f8..f09811d76b45 100644
--- a/drivers/platform/x86/asus-armoury.c
+++ b/drivers/platform/x86/asus-armoury.c
@@ -40,6 +40,24 @@
 #define ASUS_MINI_LED_2024_STRONG 0x01
 #define ASUS_MINI_LED_2024_OFF    0x02
 
+#define ASUS_POWER_CORE_MASK GENMASK(15, 8)
+#define ASUS_PERF_CORE_MASK GENMASK(7, 0)
+
+enum cpu_core_type {
+	CPU_CORE_PERF = 0,
+	CPU_CORE_POWER,
+};
+
+enum cpu_core_value {
+	CPU_CORE_DEFAULT = 0,
+	CPU_CORE_MIN,
+	CPU_CORE_MAX,
+	CPU_CORE_CURRENT,
+};
+
+#define CPU_PERF_CORE_COUNT_MIN 4
+#define CPU_POWR_CORE_COUNT_MIN 0
+
 /* Default limits for tunables available on ASUS ROG laptops */
 #define NVIDIA_BOOST_MIN      5
 #define NVIDIA_BOOST_MAX      25
@@ -85,6 +103,13 @@ struct rog_tunables {
 	u32 dgpu_tgp_min;
 	u32 dgpu_tgp_max;
 	u32 dgpu_tgp;
+
+	u32 cur_perf_cores;
+	u32 min_perf_cores;
+	u32 max_perf_cores;
+	u32 cur_power_cores;
+	u32 min_power_cores;
+	u32 max_power_cores;
 };
 
 static const struct class *fw_attr_class;
@@ -144,6 +169,8 @@ static struct kobj_attribute pending_reboot = __ATTR_RO(pending_reboot);
 static bool asus_bios_requires_reboot(struct kobj_attribute *attr)
 {
 	return !strcmp(attr->attr.name, "gpu_mux_mode") ||
+	       !strcmp(attr->attr.name, "cores_performance") ||
+	       !strcmp(attr->attr.name, "cores_efficiency") ||
 	       !strcmp(attr->attr.name, "panel_hd_mode");
 }
 
@@ -559,6 +586,195 @@ static ssize_t apu_mem_possible_values_show(struct kobject *kobj, struct kobj_at
 }
 ATTR_GROUP_ENUM_CUSTOM(apu_mem, "apu_mem", "Set available system RAM (in GB) for the APU to use");
 
+static int init_max_cpu_cores(void)
+{
+	u32 cores;
+	int err;
+
+	err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_CORES_MAX, &cores);
+	if (err)
+		return err;
+
+	cores &= ~ASUS_WMI_DSTS_PRESENCE_BIT;
+	asus_armoury.rog_tunables->max_power_cores = FIELD_GET(ASUS_POWER_CORE_MASK, cores);
+	asus_armoury.rog_tunables->max_perf_cores = FIELD_GET(ASUS_PERF_CORE_MASK, cores);
+
+	err = asus_wmi_get_devstate_dsts(ASUS_WMI_DEVID_CORES, &cores);
+	if (err) {
+		pr_err("Could not get CPU core count: error %d", err);
+		return err;
+	}
+
+	asus_armoury.rog_tunables->cur_perf_cores = FIELD_GET(ASUS_PERF_CORE_MASK, cores);
+	asus_armoury.rog_tunables->cur_power_cores = FIELD_GET(ASUS_POWER_CORE_MASK, cores);
+
+	asus_armoury.rog_tunables->min_perf_cores = CPU_PERF_CORE_COUNT_MIN;
+	asus_armoury.rog_tunables->min_power_cores = CPU_POWR_CORE_COUNT_MIN;
+
+	return 0;
+}
+
+static ssize_t cores_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf,
+				enum cpu_core_type core_type, enum cpu_core_value core_value)
+{
+	u32 cores;
+
+	switch (core_value) {
+	case CPU_CORE_DEFAULT:
+	case CPU_CORE_MAX:
+		if (core_type == CPU_CORE_PERF)
+			return sysfs_emit(buf, "%d\n",
+					  asus_armoury.rog_tunables->max_perf_cores);
+		else
+			return sysfs_emit(buf, "%d\n",
+					  asus_armoury.rog_tunables->max_power_cores);
+	case CPU_CORE_MIN:
+		if (core_type == CPU_CORE_PERF)
+			return sysfs_emit(buf, "%d\n",
+					  asus_armoury.rog_tunables->min_perf_cores);
+		else
+			return sysfs_emit(buf, "%d\n",
+					  asus_armoury.rog_tunables->min_power_cores);
+	default:
+		break;
+	}
+
+	if (core_type == CPU_CORE_PERF)
+		cores = asus_armoury.rog_tunables->cur_perf_cores;
+	else
+		cores = asus_armoury.rog_tunables->cur_power_cores;
+
+	return sysfs_emit(buf, "%d\n", cores);
+}
+
+static ssize_t cores_current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
+					 const char *buf, enum cpu_core_type core_type)
+{
+	u32 new_cores, perf_cores, power_cores, out_val, min, max;
+	int result, err;
+
+	result = kstrtou32(buf, 10, &new_cores);
+	if (result)
+		return result;
+
+	if (core_type == CPU_CORE_PERF) {
+		perf_cores = new_cores;
+		power_cores = out_val = asus_armoury.rog_tunables->cur_power_cores;
+		min = asus_armoury.rog_tunables->min_perf_cores;
+		max = asus_armoury.rog_tunables->max_perf_cores;
+	} else {
+		perf_cores = asus_armoury.rog_tunables->cur_perf_cores;
+		power_cores = out_val = new_cores;
+		min = asus_armoury.rog_tunables->min_power_cores;
+		max = asus_armoury.rog_tunables->max_power_cores;
+	}
+
+	if (new_cores < min || new_cores > max)
+		return -EINVAL;
+
+	out_val = 0;
+	out_val |= FIELD_PREP(ASUS_PERF_CORE_MASK, perf_cores);
+	out_val |= FIELD_PREP(ASUS_POWER_CORE_MASK, power_cores);
+
+	mutex_lock(&asus_armoury.mutex);
+	err = asus_wmi_set_devstate(ASUS_WMI_DEVID_CORES, out_val, &result);
+	mutex_unlock(&asus_armoury.mutex);
+
+	if (err) {
+		pr_warn("Failed to set CPU core count: %d\n", err);
+		return err;
+	}
+
+	if (result > 1) {
+		pr_warn("Failed to set CPU core count (result): 0x%x\n", result);
+		return -EIO;
+	}
+
+	pr_info("CPU core count changed, reboot required\n");
+	sysfs_notify(kobj, NULL, attr->attr.name);
+	asus_set_reboot_and_signal_event();
+
+	return 0;
+}
+
+static ssize_t cores_performance_min_value_show(struct kobject *kobj,
+						struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_PERF, CPU_CORE_MIN);
+}
+
+static ssize_t cores_performance_max_value_show(struct kobject *kobj,
+						struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_PERF, CPU_CORE_MAX);
+}
+
+static ssize_t cores_performance_default_value_show(struct kobject *kobj,
+						    struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_PERF, CPU_CORE_DEFAULT);
+}
+
+static ssize_t cores_performance_current_value_show(struct kobject *kobj,
+						    struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_PERF, CPU_CORE_CURRENT);
+}
+
+static ssize_t cores_performance_current_value_store(struct kobject *kobj,
+						     struct kobj_attribute *attr,
+						     const char *buf, size_t count)
+{
+	int err;
+
+	err = cores_current_value_store(kobj, attr, buf, CPU_CORE_PERF);
+	if (err)
+		return err;
+
+	return count;
+}
+ATTR_GROUP_CORES_RW(cores_performance, "cores_performance",
+		    "Set the max available performance cores");
+
+static ssize_t cores_efficiency_min_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+					       char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_POWER, CPU_CORE_MIN);
+}
+
+static ssize_t cores_efficiency_max_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+					       char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_POWER, CPU_CORE_MAX);
+}
+
+static ssize_t cores_efficiency_default_value_show(struct kobject *kobj,
+						   struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_POWER, CPU_CORE_DEFAULT);
+}
+
+static ssize_t cores_efficiency_current_value_show(struct kobject *kobj,
+						   struct kobj_attribute *attr, char *buf)
+{
+	return cores_value_show(kobj, attr, buf, CPU_CORE_POWER, CPU_CORE_CURRENT);
+}
+
+static ssize_t cores_efficiency_current_value_store(struct kobject *kobj,
+						    struct kobj_attribute *attr, const char *buf,
+						    size_t count)
+{
+	int err;
+
+	err = cores_current_value_store(kobj, attr, buf, CPU_CORE_POWER);
+	if (err)
+		return err;
+
+	return count;
+}
+ATTR_GROUP_CORES_RW(cores_efficiency, "cores_efficiency",
+		    "Set the max available efficiency cores");
+
 /* Simple attribute creation */
 ATTR_GROUP_ROG_TUNABLE(ppt_pl1_spl, "ppt_pl1_spl", ASUS_WMI_DEVID_PPT_PL1_SPL, cpu_default,
 		       cpu_min, cpu_max, 1, "Set the CPU slow package limit");
@@ -615,6 +831,8 @@ static const struct asus_attr_group armoury_attr_groups[] = {
 	{ &dgpu_base_tgp_attr_group, ASUS_WMI_DEVID_DGPU_BASE_TGP },
 	{ &dgpu_tgp_attr_group, ASUS_WMI_DEVID_DGPU_SET_TGP },
 	{ &apu_mem_attr_group, ASUS_WMI_DEVID_APU_MEM },
+	{ &cores_efficiency_attr_group, ASUS_WMI_DEVID_CORES_MAX },
+	{ &cores_performance_attr_group, ASUS_WMI_DEVID_CORES_MAX },
 
 	{ &charge_mode_attr_group, ASUS_WMI_DEVID_CHARGE_MODE },
 	{ &boot_sound_attr_group, ASUS_WMI_DEVID_BOOT_SOUND },
@@ -816,6 +1034,14 @@ static int __init asus_fw_init(void)
 		return -ENOMEM;
 
 	init_rog_tunables(asus_armoury.rog_tunables);
+	if (asus_wmi_is_present(ASUS_WMI_DEVID_CORES_MAX)) {
+		err = init_max_cpu_cores();
+		if (err) {
+			kfree(asus_armoury.rog_tunables);
+			pr_err("Could not initialise CPU core control %d\n", err);
+			return err;
+		}
+	}
 
 	err = asus_fw_attr_add();
 	if (err)
diff --git a/drivers/platform/x86/asus-armoury.h b/drivers/platform/x86/asus-armoury.h
index 9639e7ca772f..2620708d3994 100644
--- a/drivers/platform/x86/asus-armoury.h
+++ b/drivers/platform/x86/asus-armoury.h
@@ -168,6 +168,34 @@ static ssize_t enum_type_show(struct kobject *kobj, struct kobj_attribute *attr,
 		.name = _fsname, .attrs = _attrname##_attrs               \
 	}
 
+/* CPU core attributes need a little different in setup */
+#define ATTR_GROUP_CORES_RW(_attrname, _fsname, _dispname)              \
+	__ATTR_SHOW_FMT(scalar_increment, _attrname, "%d\n", 1);        \
+	__ATTR_SHOW_FMT(display_name, _attrname, "%s\n", _dispname);    \
+	static struct kobj_attribute attr_##_attrname##_current_value = \
+		__ASUS_ATTR_RW(_attrname, current_value);               \
+	static struct kobj_attribute attr_##_attrname##_default_value = \
+		__ASUS_ATTR_RO(_attrname, default_value);               \
+	static struct kobj_attribute attr_##_attrname##_min_value =     \
+		__ASUS_ATTR_RO(_attrname, min_value);                   \
+	static struct kobj_attribute attr_##_attrname##_max_value =     \
+		__ASUS_ATTR_RO(_attrname, max_value);                   \
+	static struct kobj_attribute attr_##_attrname##_type =          \
+		__ASUS_ATTR_RO_AS(type, int_type_show);                 \
+	static struct attribute *_attrname##_attrs[] = {                \
+		&attr_##_attrname##_current_value.attr,                 \
+		&attr_##_attrname##_default_value.attr,                 \
+		&attr_##_attrname##_min_value.attr,                     \
+		&attr_##_attrname##_max_value.attr,                     \
+		&attr_##_attrname##_scalar_increment.attr,              \
+		&attr_##_attrname##_display_name.attr,                  \
+		&attr_##_attrname##_type.attr,                          \
+		NULL                                                    \
+	};                                                              \
+	static const struct attribute_group _attrname##_attr_group = {  \
+		.name = _fsname, .attrs = _attrname##_attrs             \
+	}
+
 /*
  * ROG PPT attributes need a little different in setup as they
  * require rog_tunables members.
diff --git a/include/linux/platform_data/x86/asus-wmi.h b/include/linux/platform_data/x86/asus-wmi.h
index 25b048522b8e..6d6ac0561ee2 100644
--- a/include/linux/platform_data/x86/asus-wmi.h
+++ b/include/linux/platform_data/x86/asus-wmi.h
@@ -137,6 +137,10 @@
 /* dgpu on/off */
 #define ASUS_WMI_DEVID_DGPU		0x00090020
 
+/* Intel E-core and P-core configuration in a format 0x0[E]0[P] */
+#define ASUS_WMI_DEVID_CORES		0x001200D2
+ /* Maximum Intel E-core and P-core availability */
+#define ASUS_WMI_DEVID_CORES_MAX	0x001200D3
 #define ASUS_WMI_DEVID_DGPU_BASE_TGP	0x00120099
 #define ASUS_WMI_DEVID_DGPU_SET_TGP	0x00120098
 #define ASUS_WMI_DEVID_APU_MEM		0x000600C1
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "Luke D. Jones" <luke@ljones.dev>
Date: Sat, 21 Sep 2024 16:04:58 +1200
Subject: hid-asus: Add MODULE_IMPORT_NS(ASUS_WMI)

A small change to asus_wmi_evaluate_method() was introduced during
asus-armoury driver development to put the exports behind a namespace.

Import that namespace here.

Signed-off-by: Luke D. Jones <luke@ljones.dev>
Acked-by: Jiri Kosina <jkosina@suse.com>
---
 drivers/hid/hid-asus.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/hid/hid-asus.c b/drivers/hid/hid-asus.c
index 8d9c4fbd1a96..1daf7e186f27 100644
--- a/drivers/hid/hid-asus.c
+++ b/drivers/hid/hid-asus.c
@@ -1480,4 +1480,5 @@ static struct hid_driver asus_driver = {
 };
 module_hid_driver(asus_driver);
 
+MODULE_IMPORT_NS("ASUS_WMI");
 MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alesh Slovak <alesh@playtron.one>
Date: Tue, 30 Jul 2024 20:40:06 -0400
Subject: drm: panel-orientation-quirks: Add Aya Neo 2S orientation quirk

---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3a218fb592ce..734a49b9fdcf 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -203,6 +203,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_MATCH(DMI_PRODUCT_NAME, "AYANEO 2"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYA NEO AYANEO 2S */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
+		},
+		.driver_data = (void *)&lcd1200x1920_rightside_up,
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
Date: Thu, 8 Aug 2024 15:19:32 +0200
Subject: drm: panel-orientation-quirks: Add AYANEO FLIP DS quirk

---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 734a49b9fdcf..aae1634f52ee 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -209,6 +209,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYA NEO FLIP DS */
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "FLIP DS"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:15:12 +0100
Subject: drm: panel-orientation-quirks: Add OneXPlayer X1 AMD and Intel quirk

The OneXPlayer X1 series features a 2k 10.95 display with a portrait
orientation. Add a quirk to set the panel orientation to portrait mode
to both the Intel and AMD variants.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index aae1634f52ee..a32017d18474 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -498,6 +498,24 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONE XPLAYER"),
 		},
 		.driver_data = (void *)&lcd1200x1920_leftside_up,
+	}, {	/* OneXPlayer X1 AMD */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 A"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 AMD Strix Point */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:18:09 +0100
Subject: drm: panel-orientation-quirks: Add OneXPlayer X1 Mini (AMD) quirk

The OneXPlayer X1 mini features a 2k 8.8 display with a portrait
orientation. Add a quirk to set the panel orientation to portrait
mode. There is no Intel variant.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index a32017d18474..3c86f9be5e83 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -516,6 +516,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 mini (AMD) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 mini"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Mon, 23 Jun 2025 18:23:22 +0200
Subject: drm: panel-orientation-quirks: Add OneXPlayer X1Mini Pro quirk

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3c86f9be5e83..5dffb1bdc5e2 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -522,6 +522,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 mini"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 mini pro (AMD Strix Point) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:19:28 +0100
Subject: drm: panel-orientation-quirks: Add OneXPlayer F1Pro quirk

The OneXPlayer F1Pro has a 144hz 1920x1080 portrait OLED panel.
Add a quirk to correct the panel portrait orientation. In addition,
it comes with a red limited edition variant in the Chinese market,
so add that as well.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 5dffb1bdc5e2..fd159709d00e 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -528,6 +528,18 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1Pro"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) LE Red variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Wed, 2 Oct 2024 22:17:26 +0200
Subject: HID: Add quirk to ignore the touchscreen battery on OneXPlayer X1

The X1 devices come with a pen-capable touchscreen, in which the HID
descriptor reports there is always a battery at 100% charge. Quirk it
to not report the battery status.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-ids.h   | 1 +
 drivers/hid/hid-input.c | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 304890c11fa0..bac60ff9ede5 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -1054,6 +1054,7 @@
 #define USB_VENDOR_ID_NOVATEK		0x0603
 #define USB_DEVICE_ID_NOVATEK_PCT	0x0600
 #define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
+#define I2C_DEVICE_ID_ONEXPLAYER_X1    0xF001
 
 #define USB_VENDOR_ID_NTI               0x0757
 #define USB_DEVICE_ID_USB_SUN           0x0a00
diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c
index e4eb0703a14d..004dfc79346f 100644
--- a/drivers/hid/hid-input.c
+++ b/drivers/hid/hid-input.c
@@ -392,6 +392,8 @@ static const struct hid_device_id hid_battery_quirks[] = {
 	 * set HID_BATTERY_QUIRK_IGNORE for all Elan I2C-HID devices.
 	 */
 	{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, HID_ANY_ID), HID_BATTERY_QUIRK_IGNORE },
+	{ HID_I2C_DEVICE(USB_VENDOR_ID_NOVATEK, I2C_DEVICE_ID_ONEXPLAYER_X1),
+	  HID_BATTERY_QUIRK_IGNORE },
 	{}
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 22 Dec 2024 18:04:42 +0100
Subject: drm: panel-orientation-quirks: Add Zotac Gaming Zone quirk

The Zotac Gaming Zone handheld features a 1080p portrait OLED screen.
Add the rotation to the panel orientation quirks.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index fd159709d00e..b06ab3cd0fd5 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* Zotac Gaming Zone (OLED) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ZOTAC GAMING ZONE"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* OrangePi Neo */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "OrangePi"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 18 Mar 2025 20:38:27 +0100
Subject: drm: panel-orientation-quirks: Add OneXPlayer F1 Hawk Point

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index b06ab3cd0fd5..3ec26fadec93 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -528,7 +528,7 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Mini Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
-	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) */
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) Strix Point */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1Pro"),
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 EVA-02"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly F1 Pro (OLED) Hawk Point */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 OLED"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Zotac Gaming Zone (OLED) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 25 Mar 2025 23:42:51 +0100
Subject: drm: panel-orientation-quirks: Add OneXPlayer G1 Amd & Intel

Add quirks for the new clamshell device OneXPlayer G1 for both AMD
and Intel. The device has a 1600x2560p 144hz LCD panel.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 3ec26fadec93..96f2c435e970 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -546,6 +546,18 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER F1 OLED"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {	/* OneXPlayer OneXFly G1 AMD */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER G1 A"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer OneXFly G1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER G1 i"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* Zotac Gaming Zone (OLED) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ZOTAC"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 23 Apr 2025 10:19:53 +0200
Subject: drm: panel-orientation-quirks: Add GPD Win Max (2021)

Right side up, DSI-1, 800x1280 screen.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 96f2c435e970..05b1c993c645 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -321,6 +321,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1619-01"),
 		},
 		.driver_data = (void *)&lcd800x1280_rightside_up,
+	}, {	/* GPD Win Max (2021) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "GPD"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1619-03"),
+		},
+		.driver_data = (void *)&lcd800x1280_rightside_up,
 	}, {	/*
 		 * GPD Pocket, note that the DMI data is less generic then
 		 * it seems, devices with a board-vendor of "AMI Corporation"
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 01:07:55 +0200
Subject: drm: panel-orientation-quirks: Add Steamfork quirks

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../gpu/drm/drm_panel_orientation_quirks.c    | 26 ++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 05b1c993c645..79d89b17b12a 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -179,6 +179,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Win600"),
 		},
 		.driver_data = (void *)&lcd720x1280_rightside_up,
+	}, {	/* AOKZOE A1 Pro */
+		.matches = {
+		 DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AOKZOE"),
+		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A1 Pro"),
+		},
+		.driver_data = (void *)&lcd1200x1920_leftside_up,
 	}, {	/* Asus T100HA */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
@@ -218,9 +224,15 @@ static const struct dmi_system_id orientation_data[] = {
 	}, {	/* AYA NEO 2021 */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYADEVICE"),
-		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYA NEO 2021"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "AYA NEO"),
 		},
 		.driver_data = (void *)&lcd800x1280_rightside_up,
+	}, {	/* AYA NEO 2021 series (alternate vendor id) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "NEO 2021"),
+ 		},
+ 		.driver_data = (void *)&lcd800x1280_rightside_up,
 	}, {	/* AYA NEO AIR */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
@@ -348,6 +360,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_BOARD_NAME, "Default string"),
 		},
 		.driver_data = (void *)&gpd_pocket2,
+	}, {	/* GPD Pocket 4 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "GPD"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "G1628-04"),
+		},
+		.driver_data = (void *)&lcd1600x2560_rightside_up,
 	}, {	/* GPD Win (same note on DMI match as GPD Pocket) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
@@ -582,6 +600,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Galaxy Book 10.6"),
 		},
 		.driver_data = (void *)&lcd1280x1920_rightside_up,
+	}, {    /* Tectoy Zeenix Lite (AYN Loki Zero Rebadge) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Tectoy"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Lite"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Valve Steam Deck (Jupiter) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 22 Aug 2025 23:20:49 +0200
Subject: drm: panel-orientation-quirks: Add Ayaneo 3

The Ayaneo 3 comes with two panels, an OLED right side up 1080p panel
and an IPS landscape 1080p panel. However, both have the same DMI data.

As the landscape panel is 1920x1080 and the right side up panel is
1080x1920, the width and height arguments are used to differentiate
the panels.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 79d89b17b12a..7590b804d805 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -215,6 +215,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 2S"),
 		},
 		.driver_data = (void *)&lcd1200x1920_rightside_up,
+	}, {	/* AYANEO 3 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AYANEO 3"),
+		},
+		.driver_data = (void *)&lcd1080x1920_rightside_up,
 	}, {	/* AYA NEO FLIP DS */
 		.matches = {
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 00:17:26 +0200
Subject: drm: panel-orientation-quirks: Add Zeenix Pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 7590b804d805..f508ffbd6d20 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -612,6 +612,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Lite"),
 		},
 		.driver_data = (void *)&lcd1080x1920_leftside_up,
+	}, {    /* Tectoy Zeenix Pro (AYN Loki Max Rebadge) */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Tectoy"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Zeenix Pro"),
+		},
+		.driver_data = (void *)&lcd1080x1920_leftside_up,
 	}, {	/* Valve Steam Deck (Jupiter) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Valve"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 20 Jul 2025 03:01:58 +0200
Subject: =?UTF-8?q?drm:=20panel-orientation-quirks:=20Add=20OneXPlayer=20X?=
 =?UTF-8?q?1Pro=20EVA-2=20quirk=0AThis=20is=20a=20special=20edition=20of?=
 =?UTF-8?q?=20the=20X1=20that=20uses=20this=20year's=20Intel=20CPU.?=

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index f508ffbd6d20..ed1901de4a8e 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1Pro EVA variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Pro EVA-02"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 Intel */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 01:11:23 +0200
Subject: Input: goodix - add support for ACPI ID GDIX1003

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/input/touchscreen/goodix.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index 252dcae039f8..a53b9bb7de4c 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -1549,6 +1549,7 @@ static DEFINE_SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume);
 
 static const struct i2c_device_id goodix_ts_id[] = {
 	{ "GDIX1001:00" },
+	{ "GDIX1003:00" },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, goodix_ts_id);
@@ -1557,6 +1558,7 @@ MODULE_DEVICE_TABLE(i2c, goodix_ts_id);
 static const struct acpi_device_id goodix_acpi_match[] = {
 	{ "GDIX1001", 0 },
 	{ "GDIX1002", 0 },
+	{ "GDIX1003", 0 },
 	{ "GDX9110", 0 },
 	{ }
 };
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: CVMagic <546352+CVMagic@users.noreply.github.com>
Date: Thu, 25 Apr 2024 09:39:40 -0500
Subject: Codec: Add aw87xxx codec with ACPI implementation

Full implementation including all commits.

Bouhaa fixed some warnings.

Co-developed-by: bouhaa <boukehaarsma23@gmail.com>
---
 sound/soc/codecs/Kconfig                      |    2 +
 sound/soc/codecs/Makefile                     |    1 +
 sound/soc/codecs/aw87xxx/Kconfig              |    5 +
 sound/soc/codecs/aw87xxx/Makefile             |    4 +
 sound/soc/codecs/aw87xxx/aw87xxx.c            | 1554 +++++
 sound/soc/codecs/aw87xxx/aw87xxx.h            |  130 +
 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c    | 1558 +++++
 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h    |  191 +
 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c  |  515 ++
 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h  |   73 +
 sound/soc/codecs/aw87xxx/aw87xxx_device.c     |  977 +++
 sound/soc/codecs/aw87xxx/aw87xxx_device.h     |  149 +
 sound/soc/codecs/aw87xxx/aw87xxx_dsp.c        |  355 ++
 sound/soc/codecs/aw87xxx/aw87xxx_dsp.h        |   65 +
 sound/soc/codecs/aw87xxx/aw87xxx_log.h        |   33 +
 sound/soc/codecs/aw87xxx/aw87xxx_monitor.c    | 1208 ++++
 sound/soc/codecs/aw87xxx/aw87xxx_monitor.h    |   96 +
 sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h | 2315 ++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h |   67 +
 .../codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h   |   93 +
 .../codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h   |   94 +
 sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h | 4124 +++++++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h | 5246 +++++++++++++++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h | 1205 ++++
 sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h |   81 +
 25 files changed, 20141 insertions(+)
 create mode 100644 sound/soc/codecs/aw87xxx/Kconfig
 create mode 100644 sound/soc/codecs/aw87xxx/Makefile
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_device.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_device.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_log.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
 create mode 100644 sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 6d7e4725d89c..f5e096380ed5 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -2723,4 +2723,6 @@ config SND_SOC_LPASS_TX_MACRO
 	select SND_SOC_LPASS_MACRO_COMMON
 	tristate "Qualcomm TX Macro in LPASS(Low Power Audio SubSystem)"
 
+source "sound/soc/codecs/aw87xxx/Kconfig"
+
 endmenu
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a68c3d192a1b..f5b6edd446bb 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -844,6 +844,7 @@ obj-$(CONFIG_SND_SOC_WSA884X)	+= snd-soc-wsa884x.o
 obj-$(CONFIG_SND_SOC_ZL38060)	+= snd-soc-zl38060.o
 
 # Amp
+obj-$(CONFIG_SND_SOC_AW87XXX)    += aw87xxx/
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_MAX98504)	+= snd-soc-max98504.o
 obj-$(CONFIG_SND_SOC_SIMPLE_AMPLIFIER)	+= snd-soc-simple-amplifier.o
diff --git a/sound/soc/codecs/aw87xxx/Kconfig b/sound/soc/codecs/aw87xxx/Kconfig
new file mode 100644
index 000000000000..bd0f208e2cfe
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/Kconfig
@@ -0,0 +1,5 @@
+config SND_SOC_AW87XXX
+	tristate "SoC Audio for awinic AW87XXX Smart K PA"
+	depends on I2C
+	help
+	  This option enables support for AW87XXX Smart K PA.
diff --git a/sound/soc/codecs/aw87xxx/Makefile b/sound/soc/codecs/aw87xxx/Makefile
new file mode 100644
index 000000000000..d32f319a5b01
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/Makefile
@@ -0,0 +1,4 @@
+#for AWINIC AW87XXX Smart K PA
+snd-soc-aw87xxx-objs := aw87xxx.o aw87xxx_device.o aw87xxx_monitor.o aw87xxx_bin_parse.o aw87xxx_dsp.o aw87xxx_acf_bin.o
+obj-$(CONFIG_SND_SOC_AW87XXX) += snd-soc-aw87xxx.o
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.c b/sound/soc/codecs/aw87xxx/aw87xxx.c
new file mode 100644
index 000000000000..837a60deab9d
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.c
@@ -0,0 +1,1554 @@
+/*
+ * aw87xxx.c  aw87xxx pa module
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kthread.h>
+#include <linux/vmalloc.h>
+#include <uapi/sound/asound.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw87xxx.h"
+#include "aw87xxx_device.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_acf_bin.h"
+#include "aw87xxx_bin_parse.h"
+#include "aw87xxx_dsp.h"
+
+/*****************************************************************
+* aw87xxx marco
+******************************************************************/
+#define AW87XXX_I2C_NAME	"aw87xxx_pa"
+#define AW87XXX_DRIVER_VERSION	"v2.7.0"
+#define AW87XXX_FW_BIN_NAME	"aw87xxx_acf.bin"
+#define AW87XXX_PROF_MUSIC	"Music"
+/*************************************************************************
+ * aw87xxx variable
+ ************************************************************************/
+static LIST_HEAD(g_aw87xxx_list);
+static DEFINE_MUTEX(g_aw87xxx_mutex_lock);
+unsigned int g_aw87xxx_dev_cnt = 0;
+
+static const char *const aw87xxx_monitor_switch[] = {"Disable", "Enable"};
+static const char *const aw87xxx_spin_switch[] = {"spin_0", "spin_90",
+					 "spin_180", "spin_270"};
+#if defined(AW_KERNEL_VER_OVER_6_16_1)
+static void new_snd_soc_unregister_component(struct device *dev)
+{
+	return snd_soc_unregister_component_by_driver(dev, NULL);
+}
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_component_controls,
+	.unregister_codec = new_snd_soc_unregister_component,
+};
+#elif defined(AW_KERNEL_VER_OVER_4_19_1)
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_component_controls,
+	.unregister_codec = snd_soc_unregister_component,
+};
+#else
+static struct aw_componet_codec_ops aw_componet_codec_ops = {
+	.add_codec_controls = snd_soc_add_codec_controls,
+	.unregister_codec = snd_soc_unregister_codec,
+};
+#endif
+
+enum smi_bus_type {
+	SMI_I2C,
+	SMI_SPI,
+	SMI_AUTO_DETECT,
+};
+
+struct smi_instance {
+	const char *type;
+	unsigned int flags;
+	int irq_idx;
+};
+
+struct smi_node {
+	enum smi_bus_type bus_type;
+	struct smi_instance instances[];
+};
+
+/************************************************************************
+ *
+ * aw87xxx device update profile
+ *
+ ************************************************************************/
+static int aw87xxx_power_down(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = 0;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+	struct aw_data_container *data_container = NULL;
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!prof_info->status) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	prof_desc = aw87xxx_acf_get_prof_desc_form_name(aw87xxx->dev, &aw87xxx->acf_info, profile);
+	if (prof_desc == NULL)
+		goto no_bin_pwr_off;
+
+	if (!prof_desc->prof_st)
+		goto no_bin_pwr_off;
+
+
+	data_container = &prof_desc->data_container;
+	AW_DEV_LOGD(aw87xxx->dev, "get profile[%s] data len [%d]",
+			profile, data_container->len);
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGI(aw87xxx->dev, "profile[%s] has already load ", profile);
+	} else {
+		if (aw_dev->ops.pwr_off_func) {
+			ret = aw_dev->ops.pwr_off_func(aw_dev, data_container);
+			if (ret < 0) {
+				AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ", profile);
+				goto pwr_off_failed;
+			}
+		} else {
+			ret = aw87xxx_dev_default_pwr_off(aw_dev, data_container);
+			if (ret < 0) {
+				AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ", profile);
+				goto pwr_off_failed;
+			}
+		}
+	}
+
+	aw87xxx->current_profile = prof_desc->prof_name;
+	return 0;
+
+pwr_off_failed:
+no_bin_pwr_off:
+	aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false);
+	aw87xxx->current_profile = aw87xxx->prof_off_name;
+	return ret;
+}
+
+static int aw87xxx_power_on(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -EINVAL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+	struct aw_data_container *data_container = NULL;
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!prof_info->status) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX))
+		return aw87xxx_power_down(aw87xxx, profile);
+
+	prof_desc = aw87xxx_acf_get_prof_desc_form_name(aw87xxx->dev, &aw87xxx->acf_info, profile);
+	if (prof_desc == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found [%s] parameter", profile);
+		return -EINVAL;
+	}
+
+	if (!prof_desc->prof_st) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found data container");
+		return -EINVAL;
+	}
+
+	data_container = &prof_desc->data_container;
+	AW_DEV_LOGD(aw87xxx->dev, "get profile[%s] data len [%d]",
+			profile, data_container->len);
+
+	if (aw_dev->ops.pwr_on_func) {
+		ret = aw_dev->ops.pwr_on_func(aw_dev, data_container);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+				profile);
+			return aw87xxx_power_down(aw87xxx, aw87xxx->prof_off_name);
+		}
+	} else {
+		ret = aw87xxx_dev_default_pwr_on(aw_dev, data_container);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+				profile);
+			return aw87xxx_power_down(aw87xxx, aw87xxx->prof_off_name);
+		}
+	}
+
+	aw87xxx->current_profile = prof_desc->prof_name;
+	AW_DEV_LOGD(aw87xxx->dev, "load profile[%s] succeed", profile);
+
+	return 0;
+}
+
+
+
+int aw87xxx_update_profile(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "load profile[%s] enter", profile);
+	mutex_lock(&aw87xxx->reg_lock);
+	aw87xxx_monitor_stop(&aw87xxx->monitor);
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX)) {
+		ret = aw87xxx_power_down(aw87xxx, profile);
+	} else {
+		ret = aw87xxx_power_on(aw87xxx, profile);
+		if (!ret)
+			aw87xxx_monitor_start(&aw87xxx->monitor);
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return ret;
+}
+
+int aw87xxx_update_profile_esd(struct aw87xxx *aw87xxx, char *profile)
+{
+	int ret = -1;
+
+	if (0 == strncmp(profile, aw87xxx->prof_off_name, AW_PROFILE_STR_MAX))
+		ret = aw87xxx_power_down(aw87xxx, profile);
+	else
+		ret = aw87xxx_power_on(aw87xxx, profile);
+
+	return ret;
+}
+
+char *aw87xxx_show_current_profile(int dev_index)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		if (aw87xxx->dev_index == dev_index) {
+			AW_DEV_LOGI(aw87xxx->dev, "current profile is [%s]",
+				aw87xxx->current_profile);
+			return aw87xxx->current_profile;
+		}
+	}
+
+	AW_LOGE("not found struct aw87xxx, dev_index = [%d]", dev_index);
+	return NULL;
+}
+EXPORT_SYMBOL(aw87xxx_show_current_profile);
+
+int aw87xxx_set_profile(int dev_index, char *profile)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		if (profile && aw87xxx->dev_index == dev_index) {
+			AW_DEV_LOGD(aw87xxx->dev, "set dev_index = %d, profile = %s",
+				dev_index, profile);
+			return aw87xxx_update_profile(aw87xxx, profile);
+		}
+	}
+
+	AW_LOGE("not found struct aw87xxx, dev_index = [%d]", dev_index);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(aw87xxx_set_profile);
+
+int aw87xxx_set_profile_by_id(int dev_index, int profile_id)
+{
+	char *profile = NULL;
+
+	profile = aw87xxx_ctos_get_prof_name(profile_id);
+	if (profile == NULL) {
+		AW_LOGE("aw87xxx, dev_index[%d] profile[%d] not support!",
+					dev_index, profile_id);
+		return -EINVAL;
+	}
+
+	AW_LOGI("aw87xxx, dev_index[%d] set profile[%s] by id[%d]",
+					dev_index, profile, profile_id);
+	return aw87xxx_set_profile(dev_index, profile);
+}
+EXPORT_SYMBOL(aw87xxx_set_profile_by_id);
+
+/****************************************************************************
+ *
+ * aw87xxx Kcontrols
+ *
+ ****************************************************************************/
+static int aw87xxx_profile_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count = 0;
+	char *name = NULL;
+	char *profile_name = NULL;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+
+	/*make sure have prof */
+	count = aw87xxx_acf_get_profile_count(aw87xxx->dev, &aw87xxx->acf_info);
+	if (count <= 0) {
+		uinfo->value.enumerated.items = 0;
+		AW_DEV_LOGE(aw87xxx->dev, "get count[%d] failed", count);
+		return 0;
+	}
+
+	uinfo->value.enumerated.items = count;
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	name = uinfo->value.enumerated.name;
+	count = uinfo->value.enumerated.item;
+	profile_name = aw87xxx_acf_get_prof_name_form_index(aw87xxx->dev,
+		&aw87xxx->acf_info, count);
+	if (profile_name == NULL) {
+		strscpy(uinfo->value.enumerated.name, "NULL",
+			strlen("NULL") + 1);
+		return 0;
+	}
+
+	strscpy(name, profile_name, sizeof(uinfo->value.enumerated.name));
+
+	return 0;
+}
+
+static int aw87xxx_profile_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = -1;
+	char *profile_name = NULL;
+	int index = ucontrol->value.integer.value[0];
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct acf_bin_info *acf_info = NULL;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	acf_info = &aw87xxx->acf_info;
+
+	profile_name = aw87xxx_acf_get_prof_name_form_index(aw87xxx->dev, acf_info, index);
+	if (!profile_name) {
+		AW_DEV_LOGE(aw87xxx->dev, "not found profile name,index=[%d]",
+				index);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "set profile [%s]", profile_name);
+
+	ret = aw87xxx_update_profile(aw87xxx, profile_name);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "set dev_index[%d] profile failed, profile = %s",
+			aw87xxx->dev_index, profile_name);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int aw87xxx_profile_switch_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int index = 0;
+	char *profile;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	if (!aw87xxx->current_profile) {
+		AW_DEV_LOGE(aw87xxx->dev, "profile not init");
+		return -EINVAL;
+	}
+
+	profile = aw87xxx->current_profile;
+	AW_DEV_LOGI(aw87xxx->dev, "current profile:[%s]",
+		aw87xxx->current_profile);
+
+
+	index = aw87xxx_acf_get_prof_index_form_name(aw87xxx->dev,
+		&aw87xxx->acf_info, aw87xxx->current_profile);
+	if (index < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "get profile index failed");
+		return index;
+	}
+
+	ucontrol->value.integer.value[0] = index;
+
+	return 0;
+}
+
+static int aw87xxx_vmax_get_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = INT_MIN;
+	uinfo->value.integer.max = AW_VMAX_MAX;
+
+	return 0;
+}
+
+static int aw87xxx_vmax_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = -1;
+	int vmax_val = 0;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	if (aw87xxx == NULL) {
+		AW_LOGE("get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_monitor_no_dsp_get_vmax(&aw87xxx->monitor, &vmax_val);
+	if (ret < 0)
+		return ret;
+
+	ucontrol->value.integer.value[0] = vmax_val;
+	AW_DEV_LOGI(aw87xxx->dev, "get vmax = [0x%x]", vmax_val);
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	count = ARRAY_SIZE(aw87xxx_monitor_switch);
+
+	uinfo->value.enumerated.items = count;
+
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	strscpy(uinfo->value.enumerated.name,
+		aw87xxx_monitor_switch[uinfo->value.enumerated.item],
+		strlen(aw87xxx_monitor_switch[uinfo->value.enumerated.item]) + 1);
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	uint32_t ctrl_value = ucontrol->value.integer.value[0];
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct aw_monitor *aw_monitor = &aw87xxx->monitor;
+	int ret = -1;
+
+	ret = aw87xxx_dev_monitor_switch_set(aw_monitor, ctrl_value);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int aw87xxx_monitor_switch_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	struct aw_monitor *aw_monitor = &aw87xxx->monitor;
+
+	ucontrol->value.integer.value[0] = aw_monitor->monitor_hdr.monitor_switch;
+
+	AW_DEV_LOGI(aw87xxx->dev, "monitor switch is %ld", ucontrol->value.integer.value[0]);
+	return 0;
+}
+
+static int aw87xxx_spin_switch_info(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *uinfo)
+{
+	int count;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	count = ARRAY_SIZE(aw87xxx_spin_switch);
+
+	uinfo->value.enumerated.items = count;
+
+	if (uinfo->value.enumerated.item >= count)
+		uinfo->value.enumerated.item = count - 1;
+
+	strscpy(uinfo->value.enumerated.name,
+		aw87xxx_spin_switch[uinfo->value.enumerated.item],
+		strlen(aw87xxx_spin_switch[uinfo->value.enumerated.item]) + 1);
+
+	return 0;
+}
+
+static int aw87xxx_spin_switch_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	uint32_t ctrl_value = 0;
+	int ret = 0;
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+	ctrl_value = ucontrol->value.integer.value[0];
+
+	ret = aw87xxx_dsp_set_spin(ctrl_value);
+	if (ret) {
+		AW_DEV_LOGE(aw87xxx->dev, "write spin failed");
+		return ret;
+	}
+	AW_DEV_LOGD(aw87xxx->dev, "write spin done ctrl_value=%d", ctrl_value);
+	return 0;
+}
+
+static int aw87xxx_spin_switch_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct aw87xxx *aw87xxx = (struct aw87xxx *)kcontrol->private_value;
+
+	ucontrol->value.integer.value[0] = aw87xxx_dsp_get_spin();
+	AW_DEV_LOGD(aw87xxx->dev, "current spin is %ld", ucontrol->value.integer.value[0]);
+
+	return 0;
+}
+
+
+static int aw87xxx_kcontrol_dynamic_create(struct aw87xxx *aw87xxx,
+						void *codec)
+{
+	struct snd_kcontrol_new *aw87xxx_kcontrol = NULL;
+	aw_snd_soc_codec_t *soc_codec = (aw_snd_soc_codec_t *)codec;
+	char *kctl_name[AW87XXX_PRIVATE_KCONTROL_NUM];
+	int kcontrol_num = AW87XXX_PRIVATE_KCONTROL_NUM;
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx->codec = soc_codec;
+
+	aw87xxx_kcontrol = devm_kzalloc(aw87xxx->dev,
+			sizeof(struct snd_kcontrol_new) * kcontrol_num,
+			GFP_KERNEL);
+	if (aw87xxx_kcontrol == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "aw87xxx_kcontrol devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	kctl_name[0] = devm_kzalloc(aw87xxx->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[0] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[0], AW_NAME_BUF_MAX, "aw87xxx_profile_switch_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[0].name = kctl_name[0];
+	aw87xxx_kcontrol[0].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[0].info = aw87xxx_profile_switch_info;
+	aw87xxx_kcontrol[0].get = aw87xxx_profile_switch_get;
+	aw87xxx_kcontrol[0].put = aw87xxx_profile_switch_put;
+	aw87xxx_kcontrol[0].private_value = (unsigned long)aw87xxx;
+
+	kctl_name[1] = devm_kzalloc(aw87xxx->codec->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[1] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[1], AW_NAME_BUF_MAX, "aw87xxx_vmax_get_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[1].name = kctl_name[1];
+	aw87xxx_kcontrol[1].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[1].access = SNDRV_CTL_ELEM_ACCESS_READ;
+	aw87xxx_kcontrol[1].info = aw87xxx_vmax_get_info;
+	aw87xxx_kcontrol[1].get = aw87xxx_vmax_get;
+	aw87xxx_kcontrol[1].private_value = (unsigned long)aw87xxx;
+
+	kctl_name[2] = devm_kzalloc(aw87xxx->codec->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[2] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[2], AW_NAME_BUF_MAX, "aw87xxx_monitor_switch_%d",
+			aw87xxx->dev_index);
+
+	aw87xxx_kcontrol[2].name = kctl_name[2];
+	aw87xxx_kcontrol[2].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[2].info = aw87xxx_monitor_switch_info;
+	aw87xxx_kcontrol[2].get = aw87xxx_monitor_switch_get;
+	aw87xxx_kcontrol[2].put = aw87xxx_monitor_switch_put;
+	aw87xxx_kcontrol[2].private_value = (unsigned long)aw87xxx;
+
+	ret = aw_componet_codec_ops.add_codec_controls(aw87xxx->codec,
+				aw87xxx_kcontrol, kcontrol_num);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "add codec controls failed, ret = %d",
+			ret);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "add codec controls[%s,%s,%s]",
+		aw87xxx_kcontrol[0].name,
+		aw87xxx_kcontrol[1].name,
+		aw87xxx_kcontrol[2].name);
+
+	return 0;
+}
+
+static int aw87xxx_public_kcontrol_create(struct aw87xxx *aw87xxx,
+						void *codec)
+{
+	struct snd_kcontrol_new *aw87xxx_kcontrol = NULL;
+	aw_snd_soc_codec_t *soc_codec = (aw_snd_soc_codec_t *)codec;
+	char *kctl_name[AW87XXX_PUBLIC_KCONTROL_NUM];
+	int kcontrol_num = AW87XXX_PUBLIC_KCONTROL_NUM;
+	int ret = -1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx->codec = soc_codec;
+
+	aw87xxx_kcontrol = devm_kzalloc(aw87xxx->dev,
+			sizeof(struct snd_kcontrol_new) * kcontrol_num,
+			GFP_KERNEL);
+	if (aw87xxx_kcontrol == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "aw87xxx_kcontrol devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	kctl_name[0] = devm_kzalloc(aw87xxx->dev, AW_NAME_BUF_MAX,
+			GFP_KERNEL);
+	if (kctl_name[0] == NULL)
+		return -ENOMEM;
+
+	snprintf(kctl_name[0], AW_NAME_BUF_MAX, "aw87xxx_spin_switch");
+
+	aw87xxx_kcontrol[0].name = kctl_name[0];
+	aw87xxx_kcontrol[0].iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+	aw87xxx_kcontrol[0].info = aw87xxx_spin_switch_info;
+	aw87xxx_kcontrol[0].get = aw87xxx_spin_switch_get;
+	aw87xxx_kcontrol[0].put = aw87xxx_spin_switch_put;
+	aw87xxx_kcontrol[0].private_value = (unsigned long)aw87xxx;
+
+	ret = aw_componet_codec_ops.add_codec_controls(aw87xxx->codec,
+				aw87xxx_kcontrol, kcontrol_num);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "add codec controls failed, ret = %d",
+			ret);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "add public codec controls[%s]",
+		aw87xxx_kcontrol[0].name);
+
+	return 0;
+}
+
+/****************************************************************************
+ *
+ *aw87xxx kcontrol create
+ *
+ ****************************************************************************/
+int aw87xxx_add_codec_controls(void *codec)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = NULL;
+	int ret = -1;
+
+	list_for_each(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		ret = aw87xxx_kcontrol_dynamic_create(aw87xxx, codec);
+		if (ret < 0)
+			return ret;
+
+		if (aw87xxx->dev_index == 0) {
+			ret = aw87xxx_public_kcontrol_create(aw87xxx, codec);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(aw87xxx_add_codec_controls);
+
+
+/****************************************************************************
+ *
+ * aw87xxx firmware cfg load
+ *
+ ***************************************************************************/
+static void aw87xxx_fw_cfg_free(struct aw87xxx *aw87xxx)
+{
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	aw87xxx_acf_profile_free(aw87xxx->dev, &aw87xxx->acf_info);
+	aw87xxx_monitor_cfg_free(&aw87xxx->monitor);
+}
+
+static int aw87xxx_init_default_prof(struct aw87xxx *aw87xxx)
+{
+	char *profile = NULL;
+
+	profile = aw87xxx_acf_get_prof_off_name(aw87xxx->dev, &aw87xxx->acf_info);
+	if (profile == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "get profile off name failed");
+		return -EINVAL;
+	}
+
+	snprintf(aw87xxx->prof_off_name, AW_PROFILE_STR_MAX, "%s", profile);
+	aw87xxx->current_profile = profile;
+	AW_DEV_LOGI(aw87xxx->dev, "init profile name [%s]",
+		aw87xxx->current_profile);
+
+	return 0;
+}
+
+static void aw87xxx_fw_load_retry(struct aw87xxx *aw87xxx)
+{
+	struct acf_bin_info *acf_info = &aw87xxx->acf_info;
+	int ram_timer_val = 2000;
+
+	AW_DEV_LOGD(aw87xxx->dev, "failed to read [%s]",
+			aw87xxx->fw_name);
+
+	if (acf_info->load_count < AW_LOAD_FW_RETRIES) {
+		AW_DEV_LOGD(aw87xxx->dev,
+			"restart hrtimer to load firmware");
+		schedule_delayed_work(&aw87xxx->fw_load_work,
+			msecs_to_jiffies(ram_timer_val));
+	} else {
+		acf_info->load_count = 0;
+		AW_DEV_LOGE(aw87xxx->dev,
+			"can not load firmware,please check name or file exists");
+		return;
+	}
+	acf_info->load_count++;
+}
+
+static void aw87xxx_fw_load(const struct firmware *fw, void *context)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx = context;
+	struct acf_bin_info *acf_info = &aw87xxx->acf_info;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (!fw) {
+		aw87xxx_fw_load_retry(aw87xxx);
+		return;
+	}
+
+	AW_DEV_LOGD(aw87xxx->dev, "loaded %s - size: %ld",
+		aw87xxx->fw_name, (u_long)(fw ? fw->size : 0));
+
+	mutex_lock(&aw87xxx->reg_lock);
+	acf_info->fw_data = vmalloc(fw->size);
+	if (!acf_info->fw_data) {
+		AW_DEV_LOGE(aw87xxx->dev, "fw_data kzalloc memory failed");
+		goto exit_vmalloc_failed;
+	}
+	memset(acf_info->fw_data, 0, fw->size);
+	memcpy(acf_info->fw_data, fw->data, fw->size);
+	acf_info->fw_size = fw->size;
+
+	ret = aw87xxx_acf_parse(aw87xxx->dev, &aw87xxx->acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "fw_data parse failed");
+		goto exit_acf_parse_failed;
+	}
+
+	ret = aw87xxx_init_default_prof(aw87xxx);
+	if (ret < 0) {
+		aw87xxx_fw_cfg_free(aw87xxx);
+		goto exit_acf_parse_failed;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "acf parse succeed");
+	mutex_unlock(&aw87xxx->reg_lock);
+	release_firmware(fw);
+	// Updating profile to "Music" because the firmware is set to "off" during init
+	aw87xxx_update_profile(aw87xxx, AW87XXX_PROF_MUSIC);
+
+	return;
+
+exit_acf_parse_failed:
+exit_vmalloc_failed:
+	release_firmware(fw);
+	mutex_unlock(&aw87xxx->reg_lock);
+}
+
+static void aw87xxx_fw_load_work_routine(struct work_struct *work)
+{
+	struct aw87xxx *aw87xxx = container_of(work,
+			struct aw87xxx, fw_load_work.work);
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	if (prof_info->status == AW_ACF_WAIT) {
+		request_firmware_nowait(THIS_MODULE,
+//				FW_ACTION_HOTPLUG,
+				FW_ACTION_UEVENT,
+				aw87xxx->fw_name,
+				aw87xxx->dev,
+				GFP_KERNEL, aw87xxx,
+				aw87xxx_fw_load);
+	}
+}
+
+static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
+{
+#ifdef AW_CFG_UPDATE_DELAY
+	int cfg_timer_val = AW_CFG_UPDATE_DELAY_TIMER;
+#else
+	int cfg_timer_val = 0;
+#endif
+	AW_DEV_LOGI(aw87xxx->dev, "enter");
+	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", AW87XXX_FW_BIN_NAME);
+	aw87xxx_acf_init(&aw87xxx->aw_dev, &aw87xxx->acf_info, aw87xxx->dev_index);
+
+	INIT_DELAYED_WORK(&aw87xxx->fw_load_work, aw87xxx_fw_load_work_routine);
+	schedule_delayed_work(&aw87xxx->fw_load_work,
+			msecs_to_jiffies(cfg_timer_val));
+}
+
+/****************************************************************************
+ *
+ *aw87xxx attribute node
+ *
+ ****************************************************************************/
+static ssize_t aw87xxx_attr_get_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = 0;
+	unsigned int i = 0;
+	unsigned char reg_val = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_device *aw_dev = &aw87xxx->aw_dev;
+
+	mutex_lock(&aw87xxx->reg_lock);
+	for (i = 0; i < aw_dev->reg_max_addr; i++) {
+		if (!(aw_dev->reg_access[i] & AW_DEV_REG_RD_ACCESS))
+			continue;
+		ret = aw87xxx_dev_i2c_read_byte(&aw87xxx->aw_dev, i, &reg_val);
+		if (ret < 0) {
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"read reg [0x%x] failed\n", i);
+			AW_DEV_LOGE(aw87xxx->dev, "read reg [0x%x] failed", i);
+		} else {
+			len += snprintf(buf + len, PAGE_SIZE - len,
+					"reg:0x%02X=0x%02X\n", i, reg_val);
+			AW_DEV_LOGD(aw87xxx->dev, "reg:0x%02X=0x%02X",
+					i, reg_val);
+		}
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_reg(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t len)
+{
+	unsigned int databuf[2] = { 0 };
+	int ret = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	mutex_lock(&aw87xxx->reg_lock);
+	if (sscanf(buf, "0x%x 0x%x", &databuf[0], &databuf[1]) == 2) {
+		if (databuf[0] >= aw87xxx->aw_dev.reg_max_addr) {
+			AW_DEV_LOGE(aw87xxx->dev, "set reg[0x%x] error,is out of reg_addr_max[0x%x]",
+				databuf[0], aw87xxx->aw_dev.reg_max_addr);
+			mutex_unlock(&aw87xxx->reg_lock);
+			return -EINVAL;
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(&aw87xxx->aw_dev,
+					databuf[0], databuf[1]);
+		if (ret < 0)
+			AW_DEV_LOGE(aw87xxx->dev, "set [0x%x]=0x%x failed",
+				databuf[0], databuf[1]);
+		else
+			AW_DEV_LOGD(aw87xxx->dev, "set [0x%x]=0x%x succeed",
+				databuf[0], databuf[1]);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "i2c write cmd input error");
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_get_profile(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	unsigned int i = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_prof_info *prof_info = &aw87xxx->acf_info.prof_info;
+
+	if (!prof_info->status) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"profile_cfg not load\n");
+		return len;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "current profile:[%s]", aw87xxx->current_profile);
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(aw87xxx->current_profile, prof_info->prof_name_list[i],
+				AW_PROFILE_STR_MAX))
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				">%s\n", prof_info->prof_name_list[i]);
+		else
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				" %s\n", prof_info->prof_name_list[i]);
+	}
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_profile(struct device *dev,
+			struct device_attribute *attr, const char *buf,
+			size_t len)
+{
+	char profile[AW_PROFILE_STR_MAX] = {0};
+	int ret = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	if (strlen(buf) > AW_PROFILE_STR_MAX) {
+		AW_DEV_LOGE(aw87xxx->dev, "input profile_str_len is out of max[%d]",
+				AW_PROFILE_STR_MAX);
+		return -EINVAL;
+	}
+
+	if (sscanf(buf, "%s", profile) == 1) {
+		AW_DEV_LOGD(aw87xxx->dev, "set profile [%s]", profile);
+		ret = aw87xxx_update_profile(aw87xxx, profile);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "set profile[%s] failed",
+				profile);
+			return ret;
+		}
+	}
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_get_hwen(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	int hwen = aw87xxx->aw_dev.hwen_status;
+
+	if (hwen >= AW_DEV_HWEN_INVALID)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: invalid\n");
+	else if (hwen == AW_DEV_HWEN_ON)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: on\n");
+	else if (hwen == AW_DEV_HWEN_OFF)
+		len += snprintf(buf + len, PAGE_SIZE - len, "hwen_status: off\n");
+
+	return len;
+}
+
+static ssize_t aw87xxx_attr_set_hwen(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t len)
+{
+	int ret = -1;
+	unsigned int state;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	ret = kstrtouint(buf, 0, &state);
+	if (ret) {
+		AW_DEV_LOGE(aw87xxx->dev, "fail to channelge str to int");
+		return ret;
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	if (state == AW_DEV_HWEN_OFF)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false); /*OFF*/
+	else if (state == AW_DEV_HWEN_ON)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true); /*ON*/
+	else
+		AW_DEV_LOGE(aw87xxx->dev, "input [%d] error, hwen_on=[%d],hwen_off=[%d]",
+			state, AW_DEV_HWEN_ON, AW_DEV_HWEN_OFF);
+	mutex_unlock(&aw87xxx->reg_lock);
+	return len;
+}
+
+int aw87xxx_awrw_write(struct aw87xxx *aw87xxx,
+			const char *buf, size_t count)
+{
+	int i = 0, ret = -1;
+	char *data_buf = NULL;
+	int buf_len = 0;
+	int temp_data = 0;
+	int data_str_size = 0;
+	char *reg_data;
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	/* one addr or one data string Composition of Contains two bytes of symbol(0X)*/
+	/* and two byte of hexadecimal data*/
+	data_str_size = 2 + 2 * AWRW_DATA_BYTES;
+
+	/* The buf includes the first address of the register to be written and all data */
+	buf_len = AWRW_ADDR_BYTES + packet->reg_num * AWRW_DATA_BYTES;
+	AW_DEV_LOGI(aw87xxx->dev, "buf_len = %d,reg_num = %d", buf_len, packet->reg_num);
+	data_buf = vmalloc(buf_len);
+	if (data_buf == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "alloc memory failed");
+		return -ENOMEM;
+	}
+	memset(data_buf, 0, buf_len);
+
+	data_buf[0] = packet->reg_addr;
+	reg_data = data_buf + 1;
+
+	AW_DEV_LOGD(aw87xxx->dev, "reg_addr: 0x%02x", data_buf[0]);
+
+	/*ag:0x00 0x01 0x01 0x01 0x01 0x00\x0a*/
+	for (i = 0; i < packet->reg_num; i++) {
+		ret = sscanf(buf + AWRW_HDR_LEN + 1 + i * (data_str_size + 1),
+			"0x%x", &temp_data);
+		if (ret != 1) {
+			AW_DEV_LOGE(aw87xxx->dev, "sscanf failed,ret=%d", ret);
+			vfree(data_buf);
+			data_buf = NULL;
+			return ret;
+		}
+		reg_data[i] = temp_data;
+		AW_DEV_LOGD(aw87xxx->dev, "[%d] : 0x%02x", i, reg_data[i]);
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	ret = i2c_master_send(aw87xxx->aw_dev.i2c, data_buf, buf_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "write failed");
+		vfree(data_buf);
+		data_buf = NULL;
+		return -EFAULT;
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	vfree(data_buf);
+	data_buf = NULL;
+
+	AW_DEV_LOGD(aw87xxx->dev, "down");
+	return 0;
+}
+
+static int aw87xxx_awrw_data_check(struct aw87xxx *aw87xxx,
+			int *data, size_t count)
+{
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int req_data_len = 0;
+	int act_data_len = 0;
+	int data_str_size = 0;
+
+	if ((data[AWRW_HDR_ADDR_BYTES] != AWRW_ADDR_BYTES) ||
+		(data[AWRW_HDR_DATA_BYTES] != AWRW_DATA_BYTES)) {
+		AW_DEV_LOGE(aw87xxx->dev, "addr_bytes [%d] or data_bytes [%d] unsupport",
+			data[AWRW_HDR_ADDR_BYTES], data[AWRW_HDR_DATA_BYTES]);
+		return -EINVAL;
+	}
+
+	/* one data string Composition of Contains two bytes of symbol(0x)*/
+	/* and two byte of hexadecimal data*/
+	data_str_size = 2 + 2 * AWRW_DATA_BYTES;
+	act_data_len = count - AWRW_HDR_LEN - 1;
+
+	/* There is a comma(,) or space between each piece of data */
+	if (data[AWRW_HDR_WR_FLAG] == AWRW_FLAG_WRITE) {
+		/*ag:0x00 0x01 0x01 0x01 0x01 0x00\x0a*/
+		req_data_len = (data_str_size + 1) * packet->reg_num;
+		if (req_data_len > act_data_len) {
+			AW_DEV_LOGE(aw87xxx->dev, "data_len checkfailed,requeset data_len [%d],actaul data_len [%d]",
+				req_data_len, act_data_len);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/* flag addr_bytes data_bytes reg_num reg_addr*/
+static int aw87xxx_awrw_parse_buf(struct aw87xxx *aw87xxx,
+			const char *buf, size_t count, int *wr_status)
+{
+	int data[AWRW_HDR_MAX] = {0};
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int ret = -1;
+
+	if (sscanf(buf, "0x%02x 0x%02x 0x%02x 0x%02x 0x%02x",
+		&data[AWRW_HDR_WR_FLAG], &data[AWRW_HDR_ADDR_BYTES],
+		&data[AWRW_HDR_DATA_BYTES], &data[AWRW_HDR_REG_NUM],
+		&data[AWRW_HDR_REG_ADDR]) == 5) {
+
+		packet->reg_addr = data[AWRW_HDR_REG_ADDR];
+		packet->reg_num = data[AWRW_HDR_REG_NUM];
+		*wr_status = data[AWRW_HDR_WR_FLAG];
+		ret = aw87xxx_awrw_data_check(aw87xxx, data, count);
+		if (ret < 0)
+			return ret;
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static ssize_t aw87xxx_attr_awrw_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int wr_status = 0;
+	int ret = -1;
+
+	if (count < AWRW_HDR_LEN) {
+		AW_DEV_LOGE(aw87xxx->dev, "data count too smaller, please check write format");
+		AW_DEV_LOGE(aw87xxx->dev, "string %s,count=%ld",
+			buf, (u_long)count);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "string:[%s],count=%ld", buf, (u_long)count);
+	ret = aw87xxx_awrw_parse_buf(aw87xxx, buf, count, &wr_status);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "can not parse string");
+		return ret;
+	}
+
+	if (wr_status == AWRW_FLAG_WRITE) {
+		ret = aw87xxx_awrw_write(aw87xxx, buf, count);
+		if (ret < 0)
+			return ret;
+	} else if (wr_status == AWRW_FLAG_READ) {
+		packet->status = AWRW_I2C_ST_READ;
+		AW_DEV_LOGI(aw87xxx->dev, "read_cmd:reg_addr[0x%02x], reg_num[%d]",
+			packet->reg_addr, packet->reg_num);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "please check str format, unsupport read_write_status: %d",
+			wr_status);
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t aw87xxx_attr_awrw_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_i2c_packet *packet = &aw87xxx->i2c_packet;
+	int data_len = 0;
+	size_t len = 0;
+	int ret = -1, i = 0;
+	char *reg_data = NULL;
+
+	if (packet->status != AWRW_I2C_ST_READ) {
+		AW_DEV_LOGE(aw87xxx->dev, "please write read cmd first");
+		return -EINVAL;
+	}
+
+	data_len = AWRW_DATA_BYTES * packet->reg_num;
+	reg_data = (char *)vmalloc(data_len);
+	if (reg_data == NULL) {
+		AW_DEV_LOGE(aw87xxx->dev, "memory alloc failed");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	mutex_lock(&aw87xxx->reg_lock);
+	ret = aw87xxx_dev_i2c_read_msg(&aw87xxx->aw_dev, packet->reg_addr,
+				(char *)reg_data, data_len);
+	if (ret < 0) {
+		ret = -EFAULT;
+		mutex_unlock(&aw87xxx->reg_lock);
+		goto exit;
+	}
+	mutex_unlock(&aw87xxx->reg_lock);
+
+	AW_DEV_LOGI(aw87xxx->dev, "reg_addr 0x%02x, reg_num %d",
+		packet->reg_addr, packet->reg_num);
+
+	for (i = 0; i < data_len; i++) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"0x%02x,", reg_data[i]);
+		AW_DEV_LOGI(aw87xxx->dev, "0x%02x", reg_data[i]);
+	}
+
+	ret = len;
+
+exit:
+	if (reg_data) {
+		vfree(reg_data);
+		reg_data = NULL;
+	}
+	packet->status = AWRW_I2C_ST_NONE;
+	return ret;
+}
+
+static ssize_t aw87xxx_drv_ver_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+		"driver_ver: %s \n", AW87XXX_DRIVER_VERSION);
+
+	return len;
+}
+
+static DEVICE_ATTR(reg, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_reg, aw87xxx_attr_set_reg);
+static DEVICE_ATTR(profile, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_profile, aw87xxx_attr_set_profile);
+static DEVICE_ATTR(hwen, S_IWUSR | S_IRUGO,
+		aw87xxx_attr_get_hwen, aw87xxx_attr_set_hwen);
+static DEVICE_ATTR(awrw, S_IWUSR | S_IRUGO,
+	aw87xxx_attr_awrw_show, aw87xxx_attr_awrw_store);
+static DEVICE_ATTR(drv_ver, S_IRUGO, aw87xxx_drv_ver_show, NULL);
+
+static struct attribute *aw87xxx_attributes[] = {
+	&dev_attr_reg.attr,
+	&dev_attr_profile.attr,
+	&dev_attr_hwen.attr,
+	&dev_attr_awrw.attr,
+	&dev_attr_drv_ver.attr,
+	NULL
+};
+
+static struct attribute_group aw87xxx_attribute_group = {
+	.attrs = aw87xxx_attributes
+};
+
+/****************************************************************************
+ *
+ *aw87xxx device probe
+ *
+ ****************************************************************************/
+static const struct acpi_gpio_params reset_gpio = { 0, 0, false };
+static const struct acpi_gpio_mapping reset_acpi_gpios[] = {
+  { "reset-gpios", &reset_gpio, 1 },
+  { }
+};
+
+static struct aw87xxx *aw87xxx_malloc_init(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = NULL;
+
+	aw87xxx = devm_kzalloc(&client->dev, sizeof(struct aw87xxx),
+			GFP_KERNEL);
+	if (aw87xxx == NULL) {
+		AW_DEV_LOGE(&client->dev, "failed to devm_kzalloc aw87xxx");
+		return NULL;
+	}
+	memset(aw87xxx, 0, sizeof(struct aw87xxx));
+
+	aw87xxx->dev = &client->dev;
+	aw87xxx->aw_dev.dev = &client->dev;
+	aw87xxx->aw_dev.i2c_bus = client->adapter->nr;
+	aw87xxx->aw_dev.i2c_addr = client->addr;
+	aw87xxx->aw_dev.i2c = client;
+	aw87xxx->aw_dev.hwen_status = false;
+	aw87xxx->aw_dev.reg_access = NULL;
+	aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_INVALID;
+	aw87xxx->off_bin_status = AW87XXX_NO_OFF_BIN;
+	aw87xxx->codec = NULL;
+	aw87xxx->current_profile = aw87xxx->prof_off_name;
+
+	mutex_init(&aw87xxx->reg_lock);
+
+	AW_DEV_LOGI(&client->dev, "Driver struct alloc and mutex init done, devinfo: i2c_bus=%u, i2c_addr=%x", client->adapter->nr, client->addr);
+	return aw87xxx;
+}
+
+static int aw87xxx_i2c_probe(struct i2c_client *client)
+{
+	struct device_node *dev_node = client->dev.of_node;
+	const struct smi_node *node;
+	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
+	struct aw87xxx *aw87xxx = NULL;
+	struct gpio_desc *gpiod = NULL;
+	struct i2c_board_info board_info = {};
+	char i2c_name[32];
+	int ret = -1;
+	int acpi_dev_count = 0;
+
+	/* aw87xxx Get APCI I2C device count */
+	if(g_aw87xxx_dev_cnt == 0){
+		acpi_dev_count = i2c_acpi_client_count(adev);
+		AW_DEV_LOGI(&client->dev, "I2C_ACPI_CLIENT_COUNT returned [%d]", acpi_dev_count);
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		AW_DEV_LOGE(&client->dev, "check_functionality failed");
+		ret = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	/* aw87xxx i2c_dev struct init */
+	aw87xxx = aw87xxx_malloc_init(client);
+	if (aw87xxx == NULL)
+		goto exit_malloc_init_failed;
+
+	i2c_set_clientdata(client, aw87xxx);
+
+	aw87xxx_device_parse_port_id_dt(&aw87xxx->aw_dev);
+	aw87xxx_device_parse_topo_id_dt(&aw87xxx->aw_dev);
+
+	/* aw87xxx Get ACPI GPIO */
+
+	if (g_aw87xxx_dev_cnt == 0){
+		ret = devm_acpi_dev_add_driver_gpios(aw87xxx->dev, reset_acpi_gpios);
+		if(ret){
+			AW_DEV_LOGE(aw87xxx->dev, "Unable to add GPIO mapping table");
+			goto exit_device_init_failed;
+		}
+
+		gpiod = devm_gpiod_get(aw87xxx->dev, "reset", GPIOD_OUT_LOW);
+		if (gpiod == NULL){
+			AW_DEV_LOGE(aw87xxx->dev, "Gpiod returned NULL failing gracefully.");
+			goto exit_device_init_failed;
+		}
+
+		if (IS_ERR(gpiod)){
+			AW_DEV_LOGE(aw87xxx->dev, "Get gpiod failed.");
+			goto exit_device_init_failed;
+		}
+
+		aw87xxx->aw_dev.rst_gpio = desc_to_gpio(gpiod);
+		aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_OFF;
+		AW_DEV_LOGI(aw87xxx->dev, "reset gpio[%x] parse succeed", aw87xxx->aw_dev.rst_gpio);
+
+		if (gpio_is_valid(aw87xxx->aw_dev.rst_gpio)) {
+			ret = devm_gpio_request_one(aw87xxx->dev, aw87xxx->aw_dev.rst_gpio, GPIOF_OUT_INIT_LOW, "aw87xxx_reset");
+			if ((ret < 0) && (ret != -EBUSY)) {
+					AW_DEV_LOGE(aw87xxx->dev, "reset request failed, returned [%d]", ret);
+					goto exit_device_init_failed;
+			}
+		}else{
+			/*Disabling RESET GPIO*/
+			AW_DEV_LOGI(aw87xxx->dev, "no reset gpio provided, hardware reset unavailable");
+			aw87xxx->aw_dev.rst_gpio = AW_NO_RESET_GPIO;
+			aw87xxx->aw_dev.hwen_status = AW_DEV_HWEN_INVALID;
+		}
+
+	}
+
+	/*hw power on PA*/
+	if(g_aw87xxx_dev_cnt == 0) {
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+	}
+
+	/* aw87xxx devices private attributes init */
+	ret = aw87xxx_dev_init(&aw87xxx->aw_dev);
+	if (ret < 0)
+		goto exit_device_init_failed;
+
+	/*product register reset */
+	aw87xxx_dev_soft_reset(&aw87xxx->aw_dev);
+
+	/*hw power off */
+	if(g_aw87xxx_dev_cnt == 0) {
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, false);
+	}
+
+	/* create debug attrbute nodes */
+	ret = sysfs_create_group(&aw87xxx->dev->kobj, &aw87xxx_attribute_group);
+	if (ret < 0)
+		AW_DEV_LOGE(aw87xxx->dev, "failed to create sysfs nodes, will not allowed to use");
+
+	/* cfg_load init */
+	aw87xxx_fw_load_init(aw87xxx);
+
+	/*monitor init*/
+	aw87xxx_monitor_init(aw87xxx->dev, &aw87xxx->monitor, dev_node);
+
+	/*add device to total list */
+	mutex_lock(&g_aw87xxx_mutex_lock);
+	g_aw87xxx_dev_cnt++;
+	list_add(&aw87xxx->list, &g_aw87xxx_list);
+	aw87xxx->dev_index = g_aw87xxx_dev_cnt;
+
+	mutex_unlock(&g_aw87xxx_mutex_lock);
+	AW_DEV_LOGI(aw87xxx->dev, "succeed, dev_index=[%d], g_aw87xxx_dev_cnt= [%d]",
+			aw87xxx->dev_index, g_aw87xxx_dev_cnt);
+
+	AW_DEV_LOGI(aw87xxx->dev, "acpi_c=[%d] dev_c=[%d]", acpi_dev_count, g_aw87xxx_dev_cnt);
+
+	/* Attempt to add other I2C AMPs */
+	if ((acpi_dev_count > 1) && (g_aw87xxx_dev_cnt == 1)){
+		/* power on the chip */
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+
+		node = device_get_match_data(aw87xxx->dev);
+		memset(&board_info, 0, sizeof(board_info));
+		strscpy(board_info.type, client->name, I2C_NAME_SIZE);
+		snprintf(i2c_name, sizeof(i2c_name), "%s.%d", client->name, 1);
+		board_info.dev_name = i2c_name;
+
+		aw87xxx_i2c_probe(i2c_acpi_new_device_by_fwnode(acpi_fwnode_handle(adev), 1, &board_info));
+	}
+
+	return 0;
+
+exit_device_init_failed:
+	AW_DEV_LOGE(aw87xxx->dev, "pa init failed");
+
+	devm_kfree(&client->dev, aw87xxx);
+	aw87xxx = NULL;
+exit_malloc_init_failed:
+exit_check_functionality_failed:
+	return ret;
+}
+
+static void aw87xxx_i2c_remove(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = i2c_get_clientdata(client);
+
+	aw87xxx_monitor_exit(&aw87xxx->monitor);
+
+	/*rm attr node*/
+	sysfs_remove_group(&aw87xxx->dev->kobj, &aw87xxx_attribute_group);
+
+	aw87xxx_fw_cfg_free(aw87xxx);
+
+	mutex_lock(&g_aw87xxx_mutex_lock);
+	g_aw87xxx_dev_cnt--;
+	list_del(&aw87xxx->list);
+	mutex_unlock(&g_aw87xxx_mutex_lock);
+
+	devm_kfree(&client->dev, aw87xxx);
+	aw87xxx = NULL;
+
+//	return 0;
+}
+
+static void aw87xxx_i2c_shutdown(struct i2c_client *client)
+{
+	struct aw87xxx *aw87xxx = i2c_get_clientdata(client);
+
+	AW_DEV_LOGI(&client->dev, "enter");
+
+	/*soft and hw power off*/
+	aw87xxx_update_profile(aw87xxx, aw87xxx->prof_off_name);
+}
+
+static int aw87xxx_runtime_suspend(struct device *dev)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	AW_DEV_LOGI(aw87xxx->dev, "Suspending...");
+
+	// soft and hw power off
+	aw87xxx_update_profile(aw87xxx, aw87xxx->prof_off_name);
+
+	return 0;
+}
+
+static int aw87xxx_runtime_resume(struct device *dev)
+{
+	struct list_head *pos = NULL;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+
+	// Power on PA
+	if (aw87xxx->dev_index == 1)
+		aw87xxx_dev_hw_pwr_ctrl(&aw87xxx->aw_dev, true);
+
+	// Set profile to Music
+	list_for_each_prev(pos, &g_aw87xxx_list) {
+		aw87xxx = list_entry(pos, struct aw87xxx, list);
+		AW_DEV_LOGI(aw87xxx->dev, "Resuming...");
+
+		mutex_lock(&aw87xxx->reg_lock);
+		aw87xxx_power_on(aw87xxx, AW87XXX_PROF_MUSIC);
+		mutex_unlock(&aw87xxx->reg_lock);
+	}
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(aw87xxx_pm_ops, aw87xxx_runtime_suspend, aw87xxx_runtime_resume);
+
+static const struct acpi_device_id aw87xxx_acpi_match[] = {
+        { "AWDZ8830", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, aw87xxx_acpi_match);
+
+// This is not necessary if the acpi match probes correctly. This is needed for userspace `new_device() functionality
+static const struct i2c_device_id aw87xxx_i2c_id[] = {
+	{AW87XXX_I2C_NAME, 0},
+	{},
+};
+
+static struct i2c_driver aw87xxx_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = AW87XXX_I2C_NAME,
+		.acpi_match_table = aw87xxx_acpi_match,
+		.pm = &aw87xxx_pm_ops,
+		},
+	.probe = aw87xxx_i2c_probe,
+	.remove = aw87xxx_i2c_remove,
+	.shutdown = aw87xxx_i2c_shutdown,
+	.id_table = aw87xxx_i2c_id,
+};
+
+module_i2c_driver(aw87xxx_i2c_driver)
+
+MODULE_AUTHOR("<zhaozhongbo@awinic.com>");
+MODULE_DESCRIPTION("awinic aw87xxx pa driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.h b/sound/soc/codecs/aw87xxx/aw87xxx.h
new file mode 100644
index 000000000000..9638819cdc7e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.h
@@ -0,0 +1,130 @@
+#ifndef __AW87XXX_H__
+#define __AW87XXX_H__
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+
+#include "aw87xxx_device.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_acf_bin.h"
+
+#define AW_CFG_UPDATE_DELAY
+#define AW_CFG_UPDATE_DELAY_TIMER	(3000)
+
+#define AW87XXX_NO_OFF_BIN		(0)
+#define AW87XXX_OFF_BIN_OK		(1)
+
+#define AW87XXX_PRIVATE_KCONTROL_NUM	(3)
+#define AW87XXX_PUBLIC_KCONTROL_NUM	(1)
+
+#define AW_I2C_RETRIES			(5)
+#define AW_I2C_RETRY_DELAY		(2)
+#define AW_I2C_READ_MSG_NUM		(2)
+
+#define AW87XXX_FW_NAME_MAX		(64)
+#define AW_NAME_BUF_MAX			(64)
+#define AW_LOAD_FW_RETRIES		(3)
+
+#define AW_DEV_REG_RD_ACCESS		(1 << 0)
+#define AW_DEV_REG_WR_ACCESS		(1 << 1)
+
+#define AWRW_ADDR_BYTES			(1)
+#define AWRW_DATA_BYTES			(1)
+#define AWRW_HDR_LEN			(24)
+
+/***********************************************************
+ *
+ * aw87xxx codec control compatible with kernel 4.19
+ *
+ ***********************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 16, 1)
+#define AW_KERNEL_VER_OVER_6_16_1
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 1)
+#define AW_KERNEL_VER_OVER_4_19_1
+#endif
+
+#ifdef AW_KERNEL_VER_OVER_4_19_1
+typedef struct snd_soc_component aw_snd_soc_codec_t;
+#else
+typedef struct snd_soc_codec aw_snd_soc_codec_t;
+#endif
+
+struct aw_componet_codec_ops {
+	int (*add_codec_controls)(aw_snd_soc_codec_t *codec,
+		const struct snd_kcontrol_new *controls, unsigned int num_controls);
+	void (*unregister_codec)(struct device *dev);
+};
+
+
+/********************************************
+ *
+ * aw87xxx devices attributes
+ *
+ *******************************************/
+enum {
+	AWRW_FLAG_WRITE = 0,
+	AWRW_FLAG_READ,
+};
+
+enum {
+	AWRW_I2C_ST_NONE = 0,
+	AWRW_I2C_ST_READ,
+	AWRW_I2C_ST_WRITE,
+};
+
+enum {
+	AWRW_HDR_WR_FLAG = 0,
+	AWRW_HDR_ADDR_BYTES,
+	AWRW_HDR_DATA_BYTES,
+	AWRW_HDR_REG_NUM,
+	AWRW_HDR_REG_ADDR,
+	AWRW_HDR_MAX,
+};
+
+struct aw_i2c_packet {
+	char status;
+	unsigned int reg_num;
+	unsigned int reg_addr;
+	char *reg_data;
+};
+
+
+/********************************************
+ *
+ * aw87xxx device struct
+ *
+ *******************************************/
+struct aw87xxx {
+	char fw_name[AW87XXX_FW_NAME_MAX];
+	int32_t dev_index;
+	char *current_profile;
+	char prof_off_name[AW_PROFILE_STR_MAX];
+	uint32_t off_bin_status;
+	struct device *dev;
+
+	struct mutex reg_lock;
+	struct aw_device aw_dev;
+	struct aw_i2c_packet i2c_packet;
+
+	struct delayed_work fw_load_work;
+	struct acf_bin_info acf_info;
+
+	aw_snd_soc_codec_t *codec;
+
+	struct list_head list;
+
+	struct aw_monitor monitor;
+};
+
+int aw87xxx_update_profile(struct aw87xxx *aw87xxx, char *profile);
+int aw87xxx_update_profile_esd(struct aw87xxx *aw87xxx, char *profile);
+
+char *aw87xxx_show_current_profile(int dev_index);
+int aw87xxx_set_profile(int dev_index, char *profile);
+int aw87xxx_set_profile_by_id(int dev_index, int profile_id);
+int aw87xxx_add_codec_controls(void *codec);
+int aw87xxx_awrw_write(struct aw87xxx *aw87xxx, const char *buf, size_t count);
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
new file mode 100644
index 000000000000..00c7aedb7c11
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.c
@@ -0,0 +1,1558 @@
+/*
+ * aw87xxx_acf_bin.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include "aw87xxx.h"
+#include "aw87xxx_acf_bin.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_bin_parse.h"
+
+/*************************************************************************
+ *
+ *Table corresponding to customized profile ids to profile names
+ *
+ *************************************************************************/
+enum aw_customers_profile_id {
+	AW_CTOS_PROFILE_OFF = 0,
+	AW_CTOS_PROFILE_MUSIC,
+	AW_CTOS_PROFILE_VOICE,
+	AW_CTOS_PROFILE_VOIP,
+	AW_CTOS_PROFILE_RINGTONE,
+	AW_CTOS_PROFILE_RINGTONE_HS,
+	AW_CTOS_PROFILE_LOWPOWER,
+	AW_CTOS_PROFILE_BYPASS,
+	AW_CTOS_PROFILE_MMI,
+	AW_CTOS_PROFILE_FM,
+	AW_CTOS_PROFILE_NOTIFICATION,
+	AW_CTOS_PROFILE_RECEIVER,
+	AW_CTOS_PROFILE_MAX,
+};
+
+static char *g_ctos_profile_name[AW_PROFILE_MAX] = {
+	[AW_CTOS_PROFILE_OFF] = "Off",
+	[AW_CTOS_PROFILE_MUSIC] = "Music",
+	[AW_CTOS_PROFILE_VOICE] = "Voice",
+	[AW_CTOS_PROFILE_VOIP] = "Voip",
+	[AW_CTOS_PROFILE_RINGTONE] = "Ringtone",
+	[AW_CTOS_PROFILE_RINGTONE_HS] = "Ringtone_hs",
+	[AW_CTOS_PROFILE_LOWPOWER] = "Lowpower",
+	[AW_CTOS_PROFILE_BYPASS] = "Bypass",
+	[AW_CTOS_PROFILE_MMI] = "Mmi",
+	[AW_CTOS_PROFILE_FM] = "Fm",
+	[AW_CTOS_PROFILE_NOTIFICATION] = "Notification",
+	[AW_CTOS_PROFILE_RECEIVER] = "Receiver",
+};
+
+
+char *aw87xxx_ctos_get_prof_name(int profile_id)
+{
+	if (profile_id < 0 || profile_id >= AW_CTOS_PROFILE_MAX)
+		return NULL;
+	else
+		return g_ctos_profile_name[profile_id];
+}
+
+
+static char *g_profile_name[] = {"Music", "Voice", "Voip",
+		"Ringtone", "Ringtone_hs", "Lowpower", "Bypass", "Mmi",
+		"Fm", "Notification", "Receiver", "Off"};
+
+static char *g_power_off_name[] = {"Off", "OFF", "off", "oFF", "power_down"};
+
+static char *aw_get_prof_name(int profile)
+{
+	if (profile < 0 || profile >= AW_PROFILE_MAX)
+		return "NULL";
+	else
+		return g_profile_name[profile];
+}
+
+/*************************************************************************
+ *
+ *acf check
+ *
+ *************************************************************************/
+static int aw_crc8_check(const unsigned char *data, unsigned int data_size)
+
+{
+	unsigned char crc_value = 0x00;
+	unsigned char *pdata;
+	int i;
+	unsigned char pdatabuf = 0;
+
+	pdata = (unsigned char *)data;
+
+	while (data_size--) {
+		pdatabuf = *pdata++;
+		for (i = 0; i < 8; i++) {
+			if ((crc_value ^ (pdatabuf)) & 0x01) {
+				crc_value ^= 0x18;
+				crc_value >>= 1;
+				crc_value |= 0x80;
+			} else {
+				crc_value >>= 1;
+			}
+			pdatabuf >>= 1;
+		}
+	}
+
+	return (int)crc_value;
+}
+
+static int aw_check_file_id(struct device *dev,
+		char *fw_data, int32_t file_id)
+{
+	int32_t *acf_file_id = NULL;
+
+	acf_file_id = (int32_t *)fw_data;
+	if (*acf_file_id != file_id) {
+		AW_DEV_LOGE(dev, "file id [%x] check failed", *acf_file_id);
+		return -ENFILE;
+	}
+
+	return 0;
+}
+
+static int aw_check_header_size(struct device *dev,
+			char *fw_data, size_t fw_size)
+{
+	if (fw_size < sizeof(struct aw_acf_hdr)) {
+		AW_DEV_LOGE(dev, "acf size check failed,size less-than aw_acf_hdr");
+		return -ENOEXEC;
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ * V0.0.0.1 version acf check
+ **************************************************************************/
+static int aw_check_ddt_size_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)fw_data;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	/* check ddt_size in acf_header is aqual to ddt_num multiply by dde_size */
+	if (acf_hdr->ddt_size != acf_hdr->dde_num * sizeof(struct aw_acf_dde)) {
+		AW_DEV_LOGE(dev, "acf ddt size check failed");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_size_v_0_0_0_1(struct device *dev,
+		char *fw_data, size_t fw_size)
+{
+	int i = 0;
+	size_t data_size = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_size % 2) {
+			AW_DEV_LOGE(dev, "acf dde[%d].data_size[%d],dev_name[%s],data_type[%d], data_size check failed",
+				i, acf_dde[i].data_size, acf_dde[i].dev_name,
+				acf_dde[i].data_type);
+			return -EINVAL;
+		}
+		data_size += acf_dde[i].data_size;
+	}
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	if (fw_size != data_size + sizeof(struct aw_acf_hdr) + acf_hdr->ddt_size) {
+		AW_DEV_LOGE(dev, "acf size check failed");
+		AW_DEV_LOGE(dev, "fw_size=%ld,hdr_size and ddt size and data size =%ld",
+			(u_long)fw_size, (u_long)(data_size + sizeof(struct aw_acf_hdr) +
+			acf_hdr->ddt_size));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_crc_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	size_t crc_val = 0;
+	char *data = NULL;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		data = fw_data + acf_dde[i].data_offset;
+		crc_val = aw_crc8_check(data, acf_dde[i].data_size);
+		if (crc_val != acf_dde[i].data_crc) {
+			AW_DEV_LOGE(dev, "acf dde_crc check failed");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_check_profile_id_v_0_0_0_1(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_type == AW_MONITOR)
+			continue;
+		if (acf_dde[i].dev_profile > AW_PROFILE_MAX) {
+			AW_DEV_LOGE(dev, "parse profile_id[%d] failed", acf_dde[i].dev_profile);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+static int aw_check_data_v_0_0_0_1(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+
+	/* check file type id is awinic acf file */
+	ret = aw_check_file_id(dev, fw_data, AW_ACF_FILE_ID);
+	if (ret < 0)
+		return ret;
+
+	/* check ddt_size in header is equal to all ddt aize */
+	ret = aw_check_ddt_size_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	ret = aw_check_data_size_v_0_0_0_1(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	/* check crc in is equal to dde data crc */
+	ret = aw_check_data_crc_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* check profile id is in profile_id_max */
+	ret = aw_check_profile_id_v_0_0_0_1(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(dev, "acf fimware check succeed");
+
+	return 0;
+}
+
+/***************************************************************************
+ * V1.0.0.0 version acf chack
+ **************************************************************************/
+static int aw_check_ddt_size_v_1_0_0_0(struct device *dev, char *fw_data)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	/* check ddt_size in acf_header is aqual to ddt_num multiply by dde_size */
+	if (acf_hdr->ddt_size != acf_hdr->dde_num * sizeof(struct aw_acf_dde_v_1_0_0_0)) {
+		AW_DEV_LOGE(dev, "acf ddt size check failed");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_size_v_1_0_0_0(struct device *dev,
+		char *fw_data, size_t fw_size)
+{
+	int i = 0;
+	size_t data_size = 0;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (acf_dde[i].data_size % 2) {
+			AW_DEV_LOGE(dev, "acf dde[%d].data_size[%d],dev_name[%s],data_type[%d], data_size check failed",
+				i, acf_dde[i].data_size, acf_dde[i].dev_name,
+				acf_dde[i].data_type);
+			return -EINVAL;
+		}
+		data_size += acf_dde[i].data_size;
+	}
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	if (fw_size != data_size + sizeof(struct aw_acf_hdr) + acf_hdr->ddt_size) {
+		AW_DEV_LOGE(dev, "acf size check failed");
+		AW_DEV_LOGE(dev, "fw_size=%ld,hdr_size and ddt size and data size =%ld",
+			(u_long)fw_size, (u_long)(data_size + sizeof(struct aw_acf_hdr) +
+			acf_hdr->ddt_size));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_check_data_crc_v_1_0_0_0(struct device *dev, char *fw_data)
+{
+	int i = 0;
+	size_t crc_val = 0;
+	char *data = NULL;
+	struct aw_acf_hdr *acf_hdr = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde = NULL;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	acf_dde = (struct aw_acf_dde_v_1_0_0_0 *)(fw_data + acf_hdr->ddt_offset);
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		data = fw_data + acf_dde[i].data_offset;
+		crc_val = aw_crc8_check(data, acf_dde[i].data_size);
+		if (crc_val != acf_dde[i].data_crc) {
+			AW_DEV_LOGE(dev, "acf dde_crc check failed");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_check_data_v_1_0_0_0(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+
+	/* check file type id is awinic acf file */
+	ret = aw_check_file_id(dev, fw_data, AW_ACF_FILE_ID);
+	if (ret < 0)
+		return ret;
+
+	/* check ddt_size in header is equal to all ddt aize */
+	ret = aw_check_ddt_size_v_1_0_0_0(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	/* Verify that the file size is equal to the header size plus */
+	/* the table size and data size */
+	ret = aw_check_data_size_v_1_0_0_0(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	/* check crc in is equal to dde data crc */
+	ret = aw_check_data_crc_v_1_0_0_0(dev, fw_data);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(dev, "acf fimware check succeed");
+
+	return 0;
+}
+
+/***************************************************************************
+ * acf chack API
+ **************************************************************************/
+static int aw_check_acf_firmware(struct device *dev,
+			char *fw_data, size_t size)
+{
+	int ret = -1;
+	struct aw_acf_hdr *acf_hdr = NULL;
+
+	if (fw_data == NULL) {
+		AW_DEV_LOGE(dev, "fw_data is NULL,fw_data check failed");
+		return -ENODATA;
+	}
+
+	/* check file size is less-than header size */
+	ret = aw_check_header_size(dev, fw_data, size);
+	if (ret < 0)
+		return ret;
+
+	acf_hdr = (struct aw_acf_hdr *)fw_data;
+	AW_DEV_LOGI(dev, "project name: [%s]", acf_hdr->project);
+	AW_DEV_LOGI(dev, "custom name: [%s]", acf_hdr->custom);
+	AW_DEV_LOGI(dev, "version name: [%s]", acf_hdr->version);
+	AW_DEV_LOGI(dev, "author_id: [%d]", acf_hdr->author_id);
+
+	switch (acf_hdr->hdr_version) {
+	case AW_ACF_HDR_VER_0_0_0_1:
+		return aw_check_data_v_0_0_0_1(dev, fw_data, size);
+	case AW_ACF_HDR_VER_1_0_0_0:
+		return aw_check_data_v_1_0_0_0(dev, fw_data, size);
+	default:
+		AW_DEV_LOGE(dev, "unsupported hdr_version [0x%x]",
+			acf_hdr->hdr_version);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+
+
+/*************************************************************************
+ *
+ *acf parse
+ *
+ *************************************************************************/
+static int aw_parse_raw_reg(struct device *dev, uint8_t *data,
+		uint32_t data_len, struct aw_prof_desc *prof_desc)
+{
+	AW_DEV_LOGD(dev, "data_size:%d enter", data_len);
+
+	prof_desc->data_container.data = data;
+	prof_desc->data_container.len = data_len;
+
+	prof_desc->prof_st = AW_PROFILE_OK;
+
+	return 0;
+}
+
+static int aw_parse_reg_with_hdr(struct device *dev, uint8_t *data,
+			 uint32_t data_len, struct aw_prof_desc *prof_desc)
+{
+	struct aw_bin *aw_bin = NULL;
+	int ret = -1;
+
+	AW_DEV_LOGD(dev, "data_size:%d enter", data_len);
+
+	aw_bin = kzalloc(data_len + sizeof(struct aw_bin), GFP_KERNEL);
+	if (aw_bin == NULL) {
+		AW_DEV_LOGE(dev, "devm_kzalloc aw_bin failed");
+		return -ENOMEM;
+	}
+
+	aw_bin->info.len = data_len;
+	memcpy(aw_bin->info.data, data, data_len);
+
+	ret = aw87xxx_parsing_bin_file(aw_bin);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "parse bin failed");
+		goto parse_bin_failed;
+	}
+
+	if ((aw_bin->all_bin_parse_num != 1) ||
+		(aw_bin->header_info[0].bin_data_type != DATA_TYPE_REGISTER)) {
+		AW_DEV_LOGE(dev, "bin num or type error");
+		goto parse_bin_failed;
+	}
+
+	prof_desc->data_container.data =
+				data + aw_bin->header_info[0].valid_data_addr;
+	prof_desc->data_container.len = aw_bin->header_info[0].valid_data_len;
+	prof_desc->prof_st = AW_PROFILE_OK;
+
+	kfree(aw_bin);
+	aw_bin = NULL;
+
+	return 0;
+
+parse_bin_failed:
+	kfree(aw_bin);
+	aw_bin = NULL;
+	return ret;
+}
+
+static int aw_parse_monitor_config(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+
+	if (monitor_data == NULL || data_len == 0) {
+		AW_DEV_LOGE(dev, "no data to parse");
+		return -EBFONT;
+	}
+
+	ret = aw87xxx_monitor_bin_parse(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "monitor_config parse failed");
+		return ret;
+	}
+
+	AW_DEV_LOGI(dev, "monitor_bin parse succeed");
+
+	return 0;
+}
+
+static int aw_check_prof_str_is_off(char *profile_name)
+{
+	int i = 0;
+
+	for (i = 0; i < AW_POWER_OFF_NAME_SUPPORT_COUNT; i++) {
+		if (strnstr(profile_name, g_power_off_name[i],
+				strlen(profile_name) + 1))
+			return 0;
+	}
+
+	return -EINVAL;
+}
+
+/***************************************************************************
+ * V0.0.0.1 version acf paese
+ **************************************************************************/
+static int aw_check_product_name_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde *prof_hdr)
+{
+	int i = 0;
+
+	for (i = 0; i < acf_info->product_cnt; i++) {
+		if (0 == strcmp(acf_info->product_tab[i], prof_hdr->dev_name)) {
+			AW_DEV_LOGD(dev, "bin_dev_name:%s",
+				prof_hdr->dev_name);
+			return 0;
+		}
+	}
+
+	return -ENXIO;
+}
+
+static int aw_check_data_type_is_monitor_v_0_0_0_1(struct device *dev,
+				struct aw_acf_dde *prof_hdr)
+{
+	if (prof_hdr->data_type == AW_MONITOR) {
+		AW_DEV_LOGD(dev, "bin data is monitor");
+		return 0;
+	}
+
+	return -ENXIO;
+}
+
+static int aw_parse_data_by_sec_type_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde *prof_hdr,
+				struct aw_prof_desc *profile_prof_desc)
+{
+	int ret = -1;
+	char *cfg_data = acf_info->fw_data + prof_hdr->data_offset;
+
+	switch (prof_hdr->data_type) {
+	case AW_BIN_TYPE_REG:
+		snprintf(profile_prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		profile_prof_desc->prof_name = aw_get_prof_name(prof_hdr->dev_profile);
+		AW_DEV_LOGD(dev, "parse reg type data enter,profile=%s",
+			aw_get_prof_name(prof_hdr->dev_profile));
+		ret =  aw_parse_raw_reg(dev, cfg_data, prof_hdr->data_size,
+					profile_prof_desc);
+		break;
+	case AW_BIN_TYPE_HDR_REG:
+		snprintf(profile_prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		profile_prof_desc->prof_name = aw_get_prof_name(prof_hdr->dev_profile);
+		AW_DEV_LOGD(dev, "parse hdr_reg type data enter,profile=%s",
+			aw_get_prof_name(prof_hdr->dev_profile));
+		ret = aw_parse_reg_with_hdr(dev, cfg_data,
+					prof_hdr->data_size,
+					profile_prof_desc);
+		break;
+	}
+
+	return ret;
+}
+
+static int aw_parse_dev_type_v_0_0_0_1(struct device *dev,
+		struct acf_bin_info *acf_info, struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = -1;
+	int sec_num = 0;
+	char *cfg_data = NULL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_acf_dde *acf_dde =
+		(struct aw_acf_dde *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+			(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+			(acf_dde[i].type == AW_DDE_DEV_TYPE_ID)) {
+
+			ret = aw_check_product_name_v_0_0_0_1(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_data_type_is_monitor_v_0_0_0_1(dev, &acf_dde[i]);
+			if (ret == 0) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				ret = aw_parse_monitor_config(dev, cfg_data, acf_dde[i].data_size);
+				if (ret < 0)
+					return ret;
+				continue;
+			}
+
+			prof_desc = &all_prof_info->prof_desc[acf_dde[i].dev_profile];
+			ret = aw_parse_data_by_sec_type_v_0_0_0_1(dev, acf_info, &acf_dde[i],
+				prof_desc);
+			if (ret < 0) {
+				AW_DEV_LOGE(dev, "parse dev type data failed");
+				return ret;
+			}
+			sec_num++;
+		}
+	}
+
+	if (sec_num == 0) {
+		AW_DEV_LOGD(dev, "get dev type num is %d, please use default",
+			sec_num);
+		return AW_DEV_TYPE_NONE;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_default_type_v_0_0_0_1(struct device *dev,
+	struct acf_bin_info *acf_info, struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = -1;
+	int sec_num = 0;
+	char *cfg_data = NULL;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_acf_dde *acf_dde =
+		(struct aw_acf_dde *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_info->dev_index == acf_dde[i].dev_index) &&
+			(acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID)) {
+
+			ret = aw_check_product_name_v_0_0_0_1(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_data_type_is_monitor_v_0_0_0_1(dev, &acf_dde[i]);
+			if (ret == 0) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				ret = aw_parse_monitor_config(dev, cfg_data, acf_dde[i].data_size);
+				if (ret < 0)
+					return ret;
+				continue;
+			}
+
+			prof_desc = &all_prof_info->prof_desc[acf_dde[i].dev_profile];
+			ret = aw_parse_data_by_sec_type_v_0_0_0_1(dev, acf_info, &acf_dde[i],
+				prof_desc);
+			if (ret < 0) {
+				AW_DEV_LOGE(dev, "parse default type data failed");
+				return ret;
+			}
+			sec_num++;
+		}
+	}
+
+	if (sec_num == 0) {
+		AW_DEV_LOGE(dev, "get dev default type failed, get num[%d]",
+			sec_num);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_get_prof_count_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int prof_count = 0;
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+
+	for (i = 0; i < AW_PROFILE_MAX; i++) {
+		if (prof_desc[i].prof_st == AW_PROFILE_OK) {
+			prof_count++;
+		} else if (i == AW_PROFILE_OFF) {
+			prof_count++;
+			AW_DEV_LOGI(dev, "not found profile [Off], set default");
+		}
+	}
+
+	AW_DEV_LOGI(dev, "get profile count=[%d]", prof_count);
+	return prof_count;
+}
+
+static int aw_set_prof_off_info_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info,
+				int index)
+{
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (index >= prof_info->count) {
+		AW_DEV_LOGE(dev, "index[%d] is out of table,profile count[%d]",
+			index, prof_info->count);
+		return -EINVAL;
+	}
+
+	if (prof_desc[AW_PROFILE_OFF].prof_st == AW_PROFILE_OK) {
+		prof_info->prof_desc[index] = prof_desc[AW_PROFILE_OFF];
+		AW_DEV_LOGI(dev, "product=[%s]----profile=[%s]",
+			prof_info->prof_desc[index].dev_name,
+			aw_get_prof_name(AW_PROFILE_OFF));
+	} else {
+		memset(&prof_info->prof_desc[index].data_container, 0,
+			sizeof(struct aw_data_container));
+		prof_info->prof_desc[index].prof_st = AW_PROFILE_WAIT;
+		prof_info->prof_desc[index].prof_name = aw_get_prof_name(AW_PROFILE_OFF);
+		AW_DEV_LOGI(dev, "set default power_off with no data to profile");
+	}
+
+	return 0;
+}
+
+
+static int aw_get_vaild_prof_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_all_prof_info *all_prof_info)
+{
+	int i = 0;
+	int ret = 0;
+	int index = 0;
+	struct aw_prof_desc *prof_desc = all_prof_info->prof_desc;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->count = 0;
+	ret = aw_get_prof_count_v_0_0_0_1(dev, acf_info, all_prof_info);
+	if (ret < 0)
+		return ret;
+	prof_info->count = ret;
+	prof_info->prof_desc = devm_kzalloc(dev,
+			prof_info->count * sizeof(struct aw_prof_desc),
+			GFP_KERNEL);
+	if (prof_info->prof_desc == NULL) {
+		AW_DEV_LOGE(dev, "prof_desc kzalloc failed");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < AW_PROFILE_MAX; i++) {
+		if (i != AW_PROFILE_OFF && prof_desc[i].prof_st == AW_PROFILE_OK) {
+			if (index >= prof_info->count) {
+				AW_DEV_LOGE(dev, "get profile index[%d] overflow count[%d]",
+						index, prof_info->count);
+				return -ENOMEM;
+			}
+			prof_info->prof_desc[index] = prof_desc[i];
+			AW_DEV_LOGI(dev, "product=[%s]----profile=[%s]",
+				prof_info->prof_desc[index].dev_name,
+				aw_get_prof_name(i));
+			index++;
+		}
+	}
+
+	ret = aw_set_prof_off_info_v_0_0_0_1(dev, acf_info, all_prof_info, index);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGD(dev, "get vaild profile succeed");
+	return 0;
+}
+
+static int aw_set_prof_name_list_v_0_0_0_1(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int count = acf_info->prof_info.count;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->prof_name_list = (char (*)[AW_PROFILE_STR_MAX])devm_kzalloc(dev,
+		count * (AW_PROFILE_STR_MAX), GFP_KERNEL);
+	if (prof_info->prof_name_list == NULL) {
+		AW_DEV_LOGE(dev, "prof_name_list devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < count; ++i) {
+		snprintf(prof_info->prof_name_list[i], AW_PROFILE_STR_MAX, "%s",
+			prof_info->prof_desc[i].prof_name);
+		AW_DEV_LOGI(dev, "index=[%d], profile_name=[%s]",
+				i, prof_info->prof_name_list[i]);
+	}
+
+	return 0;
+}
+
+static int aw_parse_acf_v_0_0_0_1(struct device *dev,
+		struct acf_bin_info *acf_info)
+
+{
+	int ret = 0;
+	struct aw_all_prof_info all_prof_info;
+
+	AW_DEV_LOGD(dev, "enter");
+	acf_info->prof_info.status = AW_ACF_WAIT;
+
+	memset(&all_prof_info, 0, sizeof(struct aw_all_prof_info));
+
+	ret = aw_parse_dev_type_v_0_0_0_1(dev, acf_info, &all_prof_info);
+	if (ret < 0) {
+		return ret;
+	} else if (ret == AW_DEV_TYPE_NONE) {
+		AW_DEV_LOGD(dev, "get dev type num is 0, parse default dev type");
+		ret = aw_parse_default_type_v_0_0_0_1(dev, acf_info, &all_prof_info);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = aw_get_vaild_prof_v_0_0_0_1(dev, acf_info, &all_prof_info);
+	if (ret < 0) {
+		aw87xxx_acf_profile_free(dev, acf_info);
+		AW_DEV_LOGE(dev,  "hdr_cersion[0x%x] parse failed",
+					acf_info->acf_hdr.hdr_version);
+		return ret;
+	}
+
+	ret = aw_set_prof_name_list_v_0_0_0_1(dev, acf_info);
+	if (ret < 0) {
+		aw87xxx_acf_profile_free(dev, acf_info);
+		AW_DEV_LOGE(dev,  "creat prof_id_and_name_list failed");
+		return ret;
+	}
+
+	acf_info->prof_info.status = AW_ACF_UPDATE;
+	AW_DEV_LOGI(dev, "acf parse success");
+	return 0;
+}
+
+/***************************************************************************
+ * V1.0.0.0 version acf paese
+ **************************************************************************/
+static int aw_check_product_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int i = 0;
+
+	for (i = 0; i < acf_info->product_cnt; i++) {
+		if (0 == strcmp(acf_info->product_tab[i], prof_hdr->dev_name)) {
+			AW_DEV_LOGI(dev, "bin_dev_name:%s", prof_hdr->dev_name);
+			return 0;
+		}
+	}
+
+	return -ENXIO;
+}
+
+static int aw_get_dde_type_info_v_1_0_0_0(struct device *dev,
+					struct acf_bin_info *acf_info)
+{
+	int i;
+	int dev_num = 0;
+	int default_num = 0;
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+
+	prof_info->prof_type = AW_DEV_NONE_TYPE_ID;
+	for (i = 0; i < acf_hdr->dde_num; i++) {
+		if (acf_dde[i].type == AW_DDE_DEV_TYPE_ID)
+			dev_num++;
+		if (acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID)
+			default_num++;
+	}
+
+	if (!(dev_num || default_num)) {
+		AW_DEV_LOGE(dev, "can't find scene");
+		return -EINVAL;
+	}
+
+	if (dev_num != 0)
+		prof_info->prof_type = AW_DDE_DEV_TYPE_ID;
+	else if (default_num != 0)
+		prof_info->prof_type = AW_DDE_DEV_DEFAULT_TYPE_ID;
+
+	return 0;
+}
+
+
+static int aw_parse_get_dev_type_prof_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	int i = 0;
+	int ret = 0;
+	int found_off_prof_flag = 0;
+	int count = acf_info->prof_info.count;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		((acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr)) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_prof_str_is_off(acf_dde[i].dev_profile_str);
+			if (ret == 0) {
+				found_off_prof_flag = AW_PROFILE_OK;
+			}
+			count++;
+		}
+	}
+
+	if (count == 0) {
+		AW_DEV_LOGE(dev, "can't find profile");
+		return -EINVAL;
+	}
+
+	if (!found_off_prof_flag) {
+		count++;
+		AW_DEV_LOGD(dev, "set no config power off profile in count");
+	}
+
+	acf_info->prof_info.count = count;
+	AW_DEV_LOGI(dev, "profile dev_type profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_get_default_type_prof_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	int i = 0;
+	int ret = 0;
+	int found_off_prof_flag = 0;
+	int count = acf_info->prof_info.count;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			ret = aw_check_prof_str_is_off(acf_dde[i].dev_profile_str);
+			if (ret == 0) {
+				found_off_prof_flag = AW_PROFILE_OK;
+			}
+			count++;
+		}
+	}
+
+	if (count == 0) {
+		AW_DEV_LOGE(dev, "can't find profile");
+		return -EINVAL;
+	}
+
+	if (!found_off_prof_flag) {
+		count++;
+		AW_DEV_LOGD(dev, "set no config power off profile in count");
+	}
+
+	acf_info->prof_info.count = count;
+	AW_DEV_LOGI(dev, "profile default_type profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_get_profile_count_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+
+	ret = aw_get_dde_type_info_v_1_0_0_0(dev, acf_info);
+	if (ret < 0)
+		return ret;
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_get_dev_type_prof_count_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse dev_type profile count failed");
+			return ret;
+		}
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_get_default_type_prof_count_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse default_type profile count failed");
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(dev, "unsupport prof_type[0x%x]",
+			acf_info->prof_info.prof_type);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(dev, "profile count is %d", acf_info->prof_info.count);
+	return 0;
+}
+
+static int aw_parse_dev_type_prof_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i, ret, list_index = 0;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			if (list_index > prof_info->count) {
+				AW_DEV_LOGE(dev, "%s:Alrealdy set list_index [%d], redundant profile [%s]exist\n",
+					__func__, list_index,
+					acf_dde[i].dev_profile_str);
+				return -EINVAL;
+			}
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			snprintf(prof_info->prof_name_list[list_index], AW_PROFILE_STR_MAX, "%s",
+				acf_dde[i].dev_profile_str);
+			AW_DEV_LOGI(dev, "profile_name=[%s]",
+					prof_info->prof_name_list[list_index]);
+			list_index++;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_parse_default_type_prof_name_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	struct aw_acf_hdr *acf_hdr = (struct aw_acf_hdr *)acf_info->fw_data;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_hdr->ddt_offset);
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i, ret, list_index = 0;
+
+	for (i = 0; i < acf_hdr->dde_num; ++i) {
+		if (((acf_dde[i].data_type == AW_BIN_TYPE_REG) ||
+		(acf_dde[i].data_type == AW_BIN_TYPE_HDR_REG)) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			if (list_index > prof_info->count) {
+				AW_DEV_LOGE(dev, "%s:Alrealdy set list_index [%d], redundant profile [%s]exist\n",
+					__func__, list_index,
+					acf_dde[i].dev_profile_str);
+				return -EINVAL;
+			}
+
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			snprintf(prof_info->prof_name_list[list_index], AW_PROFILE_STR_MAX, "%s",
+				acf_dde[i].dev_profile_str);
+			AW_DEV_LOGI(dev, "profile_name=[%s]",
+					prof_info->prof_name_list[list_index]);
+			list_index++;
+		}
+	}
+
+	return 0;
+}
+
+static int aw_parse_prof_name_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+	int count = acf_info->prof_info.count;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->prof_name_list = (char (*)[AW_PROFILE_STR_MAX])devm_kzalloc(dev,
+		count * (AW_PROFILE_STR_MAX), GFP_KERNEL);
+	if (prof_info->prof_name_list == NULL) {
+		AW_DEV_LOGE(dev, "prof_name_list devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_dev_type_prof_name_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse dev_type profile count failed");
+			return ret;
+		}
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_default_type_prof_name_v_1_0_0_0(dev, acf_info);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "parse default_type profile count failed");
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(dev, "unsupport prof_type[0x%x]",
+			acf_info->prof_info.prof_type);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(dev, "profile name parse succeed");
+	return 0;
+}
+
+
+static int aw_search_prof_index_from_list_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_prof_desc **prof_desc,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int i = 0;
+	int count = acf_info->prof_info.count;
+	char (*prof_name_list)[AW_PROFILE_STR_MAX] = acf_info->prof_info.prof_name_list;
+
+	for (i = 0; i < count; i++) {
+		if (!strncmp(prof_name_list[i], prof_hdr->dev_profile_str, AW_PROFILE_STR_MAX)) {
+			*prof_desc = &(acf_info->prof_info.prof_desc[i]);
+			return 0;
+		}
+	}
+
+	if (i == count)
+		AW_DEV_LOGE(dev, "not find prof_id and prof_name in list");
+
+	return -EINVAL;
+}
+
+static int aw_parse_data_by_sec_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info,
+				struct aw_acf_dde_v_1_0_0_0 *prof_hdr)
+{
+	int ret = -1;
+	char *cfg_data = acf_info->fw_data + prof_hdr->data_offset;
+	struct aw_prof_desc *prof_desc = NULL;
+
+	ret = aw_search_prof_index_from_list_v_1_0_0_0(dev, acf_info, &prof_desc, prof_hdr);
+	if (ret < 0)
+		return ret;
+
+	switch (prof_hdr->data_type) {
+	case AW_BIN_TYPE_REG:
+		snprintf(prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		AW_DEV_LOGI(dev, "parse reg type data enter,product=[%s],prof_id=[%d],prof_name=[%s]",
+			prof_hdr->dev_name, prof_hdr->dev_profile,
+			prof_hdr->dev_profile_str);
+		prof_desc->prof_name = prof_hdr->dev_profile_str;
+		ret =  aw_parse_raw_reg(dev, cfg_data, prof_hdr->data_size,
+					prof_desc);
+		break;
+	case AW_BIN_TYPE_HDR_REG:
+		snprintf(prof_desc->dev_name, sizeof(prof_hdr->dev_name),
+			"%s", prof_hdr->dev_name);
+		AW_DEV_LOGI(dev, "parse hdr_reg type data enter,product=[%s],prof_id=[%d],prof_name=[%s]",
+			prof_hdr->dev_name, prof_hdr->dev_profile,
+			prof_hdr->dev_profile_str);
+		prof_desc->prof_name = prof_hdr->dev_profile_str;
+		ret = aw_parse_reg_with_hdr(dev, cfg_data,
+				prof_hdr->data_size, prof_desc);
+		break;
+	}
+
+	return ret;
+}
+
+static int aw_parse_dev_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret;
+	int parse_prof_count = 0;
+	char *cfg_data = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_dde[i].type == AW_DDE_DEV_TYPE_ID) &&
+		(acf_info->aw_dev->i2c_bus == acf_dde[i].dev_bus) &&
+		(acf_info->aw_dev->i2c_addr == acf_dde[i].dev_addr) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			if (acf_dde[i].data_type == AW_MONITOR) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				AW_DEV_LOGD(dev, "parse monitor type data enter");
+				ret = aw_parse_monitor_config(dev, cfg_data,
+					acf_dde[i].data_size);
+			} else {
+				ret = aw_parse_data_by_sec_type_v_1_0_0_0(dev, acf_info,
+					&acf_dde[i]);
+				if (ret < 0)
+					AW_DEV_LOGE(dev, "parse dev type data failed");
+				else
+					parse_prof_count++;
+			}
+		}
+	}
+
+	if (parse_prof_count == 0) {
+		AW_DEV_LOGE(dev, "get dev type num is %d, parse failed", parse_prof_count);
+		return -EINVAL;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_default_type_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret;
+	int parse_prof_count = 0;
+	char *cfg_data = NULL;
+	struct aw_acf_dde_v_1_0_0_0 *acf_dde =
+		(struct aw_acf_dde_v_1_0_0_0 *)(acf_info->fw_data + acf_info->acf_hdr.ddt_offset);
+
+	AW_DEV_LOGD(dev, "enter");
+
+	for (i = 0; i < acf_info->acf_hdr.dde_num; i++) {
+		if ((acf_dde[i].type == AW_DDE_DEV_DEFAULT_TYPE_ID) &&
+		(acf_info->dev_index == acf_dde[i].dev_index) &&
+		(acf_info->aw_dev->chipid == acf_dde[i].chip_id)) {
+			ret = aw_check_product_name_v_1_0_0_0(dev, acf_info, &acf_dde[i]);
+			if (ret < 0)
+				continue;
+
+			if (acf_dde[i].data_type == AW_MONITOR) {
+				cfg_data = acf_info->fw_data + acf_dde[i].data_offset;
+				AW_DEV_LOGD(dev, "parse monitor type data enter");
+				ret = aw_parse_monitor_config(dev, cfg_data,
+					acf_dde[i].data_size);
+			} else {
+				ret = aw_parse_data_by_sec_type_v_1_0_0_0(dev, acf_info,
+					&acf_dde[i]);
+				if (ret < 0)
+					AW_DEV_LOGE(dev, "parse default type data failed");
+				else
+					parse_prof_count++;
+			}
+		}
+	}
+
+	if (parse_prof_count == 0) {
+		AW_DEV_LOGE(dev, "get default type num is %d,parse failed", parse_prof_count);
+		return -EINVAL;
+	}
+
+	return AW_DEV_TYPE_OK;
+}
+
+static int aw_parse_by_hdr_v_1_0_0_0(struct device *dev,
+				struct acf_bin_info *acf_info)
+{
+	int ret;
+
+	if (acf_info->prof_info.prof_type == AW_DDE_DEV_TYPE_ID) {
+		ret = aw_parse_dev_type_v_1_0_0_0(dev, acf_info);
+		if (ret < 0)
+			return ret;
+	} else if (acf_info->prof_info.prof_type == AW_DDE_DEV_DEFAULT_TYPE_ID) {
+		ret = aw_parse_default_type_v_1_0_0_0(dev, acf_info);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int aw_set_prof_off_info_v_1_0_0_0(struct device *dev,
+						struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int i = 0;
+	int ret = 0;
+
+	for (i = 0; i < prof_info->count; ++i) {
+		if (!(prof_info->prof_desc[i].prof_st)) {
+			snprintf(prof_info->prof_name_list[i], AW_PROFILE_STR_MAX, "%s",
+					g_power_off_name[0]);
+			prof_info->prof_desc[i].prof_name = prof_info->prof_name_list[i];
+			prof_info->prof_desc[i].prof_st = AW_PROFILE_WAIT;
+			memset(&prof_info->prof_desc[i].data_container, 0,
+					sizeof(struct aw_data_container));
+			return 0;
+		}
+
+		ret = aw_check_prof_str_is_off(prof_info->prof_name_list[i]);
+		if (ret == 0) {
+			AW_DEV_LOGD(dev, "found profile off,data_len=[%d]",
+				prof_info->prof_desc[i].data_container.len);
+			return 0;
+		}
+	}
+
+	AW_DEV_LOGE(dev, "index[%d] is out of table,profile count[%d]",
+		i, prof_info->count);
+	return -EINVAL;
+}
+
+static int aw_parse_acf_v_1_0_0_0(struct device *dev,
+		struct acf_bin_info *acf_info)
+
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+	int ret;
+
+	ret = aw_parse_get_profile_count_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get profile count failed");
+		return ret;
+	}
+
+	ret = aw_parse_prof_name_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get profile count failed");
+		return ret;
+	}
+
+	acf_info->prof_info.prof_desc = devm_kzalloc(dev,
+		prof_info->count * sizeof(struct aw_prof_desc), GFP_KERNEL);
+	if (acf_info->prof_info.prof_desc == NULL) {
+		AW_DEV_LOGE(dev, "prof_desc devm_kzalloc failed");
+		return -ENOMEM;
+	}
+
+	ret = aw_parse_by_hdr_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "parse data failed");
+		return ret;
+	}
+
+	ret = aw_set_prof_off_info_v_1_0_0_0(dev, acf_info);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "set profile off info failed");
+		return ret;
+	}
+
+	prof_info->status = AW_ACF_UPDATE;
+	AW_DEV_LOGI(dev, "acf paese succeed");
+	return 0;
+}
+
+
+/*************************************************************************
+ *
+ *acf parse API
+ *
+ *************************************************************************/
+void aw87xxx_acf_profile_free(struct device *dev, struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	prof_info->count = 0;
+	prof_info->status = AW_ACF_WAIT;
+	memset(&acf_info->acf_hdr, 0, sizeof(struct aw_acf_hdr));
+
+	if (prof_info->prof_desc) {
+		devm_kfree(dev, prof_info->prof_desc);
+		prof_info->prof_desc = NULL;
+	}
+
+	if (prof_info->prof_name_list) {
+		devm_kfree(dev, prof_info->prof_name_list);
+		prof_info->prof_name_list = NULL;
+	}
+
+	if (acf_info->fw_data) {
+		vfree(acf_info->fw_data);
+		acf_info->fw_data = NULL;
+	}
+}
+
+int aw87xxx_acf_parse(struct device *dev, struct acf_bin_info *acf_info)
+{
+	int ret = 0;
+
+	AW_DEV_LOGD(dev, "enter");
+	acf_info->prof_info.status = AW_ACF_WAIT;
+	ret = aw_check_acf_firmware(dev, acf_info->fw_data,
+					acf_info->fw_size);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "load firmware check failed");
+		return -EINVAL;
+	}
+
+	memcpy(&acf_info->acf_hdr, acf_info->fw_data,
+		sizeof(struct aw_acf_hdr));
+
+	switch (acf_info->acf_hdr.hdr_version) {
+	case AW_ACF_HDR_VER_0_0_0_1:
+		return aw_parse_acf_v_0_0_0_1(dev, acf_info);
+	case AW_ACF_HDR_VER_1_0_0_0:
+		return aw_parse_acf_v_1_0_0_0(dev, acf_info);
+	default:
+		AW_DEV_LOGE(dev, "unsupported hdr_version [0x%x]",
+			acf_info->acf_hdr.hdr_version);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+struct aw_prof_desc *aw87xxx_acf_get_prof_desc_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name)
+{
+	int i = 0;
+	struct aw_prof_desc *prof_desc = NULL;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(profile_name, prof_info->prof_desc[i].prof_name,
+				AW_PROFILE_STR_MAX)) {
+			prof_desc = &prof_info->prof_desc[i];
+			break;
+		}
+	}
+
+	if (i == prof_info->count) {
+		AW_DEV_LOGE(dev, "profile not found");
+		return NULL;
+	}
+
+	AW_DEV_LOGI(dev, "get prof desc down");
+	return prof_desc;
+}
+
+int aw87xxx_acf_get_prof_index_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name)
+{
+	int i = 0;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		if (!strncmp(profile_name, prof_info->prof_name_list[i],
+				AW_PROFILE_STR_MAX)) {
+			return i;
+		}
+	}
+
+	AW_DEV_LOGE(dev, "profile_index not found");
+	return -EINVAL;
+}
+
+char *aw87xxx_acf_get_prof_name_form_index(struct device *dev,
+			struct acf_bin_info *acf_info, int index)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	if (index >= prof_info->count  || index < 0) {
+		AW_DEV_LOGE(dev, "profile_index out of table");
+		return NULL;
+	}
+
+	return prof_info->prof_desc[index].prof_name;
+}
+
+
+int aw87xxx_acf_get_profile_count(struct device *dev,
+			struct acf_bin_info *acf_info)
+{
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return -EINVAL;
+	}
+
+	if (prof_info->count > 0) {
+		return prof_info->count;
+	}
+
+	return -EINVAL;
+}
+
+char *aw87xxx_acf_get_prof_off_name(struct device *dev,
+			struct acf_bin_info *acf_info)
+{
+	int i = 0;
+	int ret = 0;
+	struct aw_prof_info *prof_info = &acf_info->prof_info;
+
+	if (!acf_info->prof_info.status) {
+		AW_DEV_LOGE(dev, "profile_cfg not load");
+		return NULL;
+	}
+
+	for (i = 0; i < prof_info->count; i++) {
+		ret  = aw_check_prof_str_is_off(prof_info->prof_name_list[i]);
+		if (ret == 0)
+			return prof_info->prof_name_list[i];
+	}
+
+	return NULL;
+}
+
+void aw87xxx_acf_init(struct aw_device *aw_dev, struct acf_bin_info *acf_info, int index)
+{
+
+	acf_info->load_count = 0;
+	acf_info->prof_info.status = AW_ACF_WAIT;
+	acf_info->dev_index = index;
+	acf_info->aw_dev = aw_dev;
+	acf_info->product_cnt = aw_dev->product_cnt;
+	acf_info->product_tab = aw_dev->product_tab;
+	acf_info->prof_info.prof_desc = NULL;
+	acf_info->fw_data = NULL;
+	acf_info->fw_size = 0;
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
new file mode 100644
index 000000000000..ebe0c77f5674
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_acf_bin.h
@@ -0,0 +1,191 @@
+#ifndef __AW87XXX_ACF_BIN_H__
+#define __AW87XXX_ACF_BIN_H__
+
+#include "aw87xxx_device.h"
+
+#define AW_PROJECT_NAME_MAX		(24)
+#define AW_CUSTOMER_NAME_MAX		(16)
+#define AW_CFG_VERSION_MAX		(4)
+#define AW_TBL_VERSION_MAX		(4)
+#define AW_DDE_DEVICE_TYPE		(0)
+#define AW_DDE_SKT_TYPE			(1)
+#define AW_DDE_DEFAULT_TYPE		(2)
+
+#define AW_REG_ADDR_BYTE		(1)
+#define AW_REG_DATA_BYTE		(1)
+
+#define AW_ACF_FILE_ID			(0xa15f908)
+#define AW_PROFILE_STR_MAX 		(32)
+#define AW_POWER_OFF_NAME_SUPPORT_COUNT	(5)
+
+enum aw_cfg_hdr_version {
+	AW_ACF_HDR_VER_0_0_0_1 = 0x00000001,
+	AW_ACF_HDR_VER_1_0_0_0 = 0x01000000,
+};
+
+enum aw_acf_dde_type_id {
+	AW_DEV_NONE_TYPE_ID = 0xFFFFFFFF,
+	AW_DDE_DEV_TYPE_ID = 0x00000000,
+	AW_DDE_SKT_TYPE_ID = 0x00000001,
+	AW_DDE_DEV_DEFAULT_TYPE_ID = 0x00000002,
+	AW_DDE_TYPE_MAX,
+};
+
+enum aw_raw_data_type_id {
+	AW_BIN_TYPE_REG = 0x00000000,
+	AW_BIN_TYPE_DSP,
+	AW_BIN_TYPE_DSP_CFG,
+	AW_BIN_TYPE_DSP_FW,
+	AW_BIN_TYPE_HDR_REG,
+	AW_BIN_TYPE_HDR_DSP_CFG,
+	AW_BIN_TYPE_HDR_DSP_FW,
+	AW_BIN_TYPE_MUTLBIN,
+	AW_SKT_UI_PROJECT,
+	AW_DSP_CFG,
+	AW_MONITOR,
+	AW_BIN_TYPE_MAX,
+};
+
+enum {
+	AW_DEV_TYPE_OK = 0,
+	AW_DEV_TYPE_NONE = 1,
+};
+
+enum aw_profile_status {
+	AW_PROFILE_WAIT = 0,
+	AW_PROFILE_OK,
+};
+
+enum aw_acf_load_status {
+	AW_ACF_WAIT = 0,
+	AW_ACF_UPDATE,
+};
+
+enum aw_bin_dev_profile_id {
+	AW_PROFILE_MUSIC = 0x0000,
+	AW_PROFILE_VOICE,
+	AW_PROFILE_VOIP,
+	AW_PROFILE_RINGTONE,
+	AW_PROFILE_RINGTONE_HS,
+	AW_PROFILE_LOWPOWER,
+	AW_PROFILE_BYPASS,
+	AW_PROFILE_MMI,
+	AW_PROFILE_FM,
+	AW_PROFILE_NOTIFICATION,
+	AW_PROFILE_RECEIVER,
+	AW_PROFILE_OFF,
+	AW_PROFILE_MAX,
+};
+
+struct aw_acf_hdr {
+	int32_t a_id;				/* acf file ID 0xa15f908 */
+	char project[AW_PROJECT_NAME_MAX];	/* project name */
+	char custom[AW_CUSTOMER_NAME_MAX];	/* custom name :huawei xiaomi vivo oppo */
+	uint8_t version[AW_CFG_VERSION_MAX];	/* author update version */
+	int32_t author_id;			/* author id */
+	int32_t ddt_size;			/* sub section table entry size */
+	int32_t dde_num;			/* sub section table entry num */
+	int32_t ddt_offset;			/* sub section table offset in file */
+	int32_t hdr_version;			/* sub section table version */
+	int32_t reserve[3];			/* Reserved Bits */
+};
+
+struct aw_acf_dde {
+	int32_t type;				/* dde type id */
+	char dev_name[AW_CUSTOMER_NAME_MAX];	/* customer dev name */
+	int16_t dev_index;			/* dev id */
+	int16_t dev_bus;			/* dev bus id */
+	int16_t dev_addr;			/* dev addr id */
+	int16_t dev_profile;			/* dev profile id */
+	int32_t data_type;			/* data type id */
+	int32_t data_size;			/* dde data size in block */
+	int32_t data_offset;			/* dde data offset in block */
+	int32_t data_crc;			/* dde data crc checkout */
+	int32_t reserve[5];			/* Reserved Bits */
+};
+
+struct aw_acf_dde_v_1_0_0_0 {
+	uint32_t type;				/* DDE type id */
+	char dev_name[AW_CUSTOMER_NAME_MAX];	/* customer dev name */
+	uint16_t dev_index;			/* dev id */
+	uint16_t dev_bus;			/* dev bus id */
+	uint16_t dev_addr;			/* dev addr id */
+	uint16_t dev_profile;			/* dev profile id*/
+	uint32_t data_type;			/* data type id */
+	uint32_t data_size;			/* dde data size in block */
+	uint32_t data_offset;			/* dde data offset in block */
+	uint32_t data_crc;			/* dde data crc checkout */
+	char dev_profile_str[AW_PROFILE_STR_MAX];	/* dde custom profile name */
+	uint32_t chip_id;			/* dde custom product chip id */
+	uint32_t reserve[4];
+};
+
+struct aw_data_with_header {
+	uint32_t check_sum;
+	uint32_t header_ver;
+	uint32_t bin_data_type;
+	uint32_t bin_data_ver;
+	uint32_t bin_data_size;
+	uint32_t ui_ver;
+	char product[8];
+	uint32_t addr_byte_len;
+	uint32_t data_byte_len;
+	uint32_t device_addr;
+	uint32_t reserve[4];
+};
+
+struct aw_data_container {
+	uint32_t len;
+	uint8_t *data;
+};
+
+struct aw_prof_desc {
+	uint32_t prof_st;
+	char *prof_name;
+	char dev_name[AW_CUSTOMER_NAME_MAX];
+	struct aw_data_container data_container;
+};
+
+struct aw_all_prof_info {
+	struct aw_prof_desc prof_desc[AW_PROFILE_MAX];
+};
+
+struct aw_prof_info {
+	int count;
+	int status;
+	int prof_type;
+	char (*prof_name_list)[AW_PROFILE_STR_MAX];
+	struct aw_prof_desc *prof_desc;
+};
+
+struct acf_bin_info {
+	int load_count;
+	int fw_size;
+	int16_t dev_index;
+	char *fw_data;
+	int product_cnt;
+	const char **product_tab;
+	struct aw_device *aw_dev;
+
+	struct aw_acf_hdr acf_hdr;
+	struct aw_prof_info prof_info;
+};
+
+char *aw87xxx_ctos_get_prof_name(int profile_id);
+void aw87xxx_acf_profile_free(struct device *dev,
+		struct acf_bin_info *acf_info);
+int aw87xxx_acf_parse(struct device *dev, struct acf_bin_info *acf_info);
+struct aw_prof_desc *aw87xxx_acf_get_prof_desc_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name);
+int aw87xxx_acf_get_prof_index_form_name(struct device *dev,
+			struct acf_bin_info *acf_info, char *profile_name);
+char *aw87xxx_acf_get_prof_name_form_index(struct device *dev,
+			struct acf_bin_info *acf_info, int index);
+int aw87xxx_acf_get_profile_count(struct device *dev,
+			struct acf_bin_info *acf_info);
+char *aw87xxx_acf_get_prof_off_name(struct device *dev,
+			struct acf_bin_info *acf_info);
+void aw87xxx_acf_init(struct aw_device *aw_dev, struct acf_bin_info *acf_info, int index);
+
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
new file mode 100644
index 000000000000..7eab9efde147
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.c
@@ -0,0 +1,515 @@
+/*
+* aw87xxx_bin_parse.c
+*
+* Copyright (c) 2020 AWINIC Technology CO., LTD
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2 of the License, or (at your
+* option) any later version.
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/debugfs.h>
+#include <linux/miscdevice.h>
+#include <asm/uaccess.h>
+#include <linux/regmap.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/hrtimer.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+#include <linux/string.h>
+#include "aw87xxx_bin_parse.h"
+
+#define AWINIC_CODE_VERSION "V0.0.7-V1.0.4"	/* "code version"-"excel version" */
+
+#define DEBUG_LOG_LEVEL
+#ifdef DEBUG_LOG_LEVEL
+#define DBG(fmt, arg...)   do {\
+printk("AWINIC_BIN %s,line= %d,"fmt, __func__, __LINE__, ##arg);\
+} while (0)
+#define DBG_ERR(fmt, arg...)   do {\
+printk("AWINIC_BIN_ERR %s,line= %d,"fmt, __func__, __LINE__, ##arg);\
+} while (0)
+#else
+#define DBG(fmt, arg...) do {} while (0)
+#define DBG_ERR(fmt, arg...) do {} while (0)
+#endif
+
+#define printing_data_code
+
+typedef unsigned short int aw_uint16;
+typedef unsigned long int aw_uint32;
+
+#define BigLittleSwap16(A)	((((aw_uint16)(A) & 0xff00) >> 8) | \
+				 (((aw_uint16)(A) & 0x00ff) << 8))
+
+#define BigLittleSwap32(A)	((((aw_uint32)(A) & 0xff000000) >> 24) | \
+				(((aw_uint32)(A) & 0x00ff0000) >> 8) | \
+				(((aw_uint32)(A) & 0x0000ff00) << 8) | \
+				(((aw_uint32)(A) & 0x000000ff) << 24))
+
+
+static int aw_parse_bin_header_1_0_0(struct aw_bin *bin);
+
+/**
+*
+* Interface function
+*
+* return value:
+*       value = 0 :success;
+*       value = -1 :check bin header version
+*       value = -2 :check bin data type
+*       value = -3 :check sum or check bin data len error
+*       value = -4 :check data version
+*       value = -5 :check register num
+*       value = -6 :check dsp reg num
+*       value = -7 :check soc app num
+*       value = -8 :bin is NULL point
+*
+**/
+
+/********************************************************
+*
+* check sum data
+*
+********************************************************/
+static int aw_check_sum(struct aw_bin *bin, int bin_num)
+{
+	unsigned int i = 0;
+	unsigned int sum_data = 0;
+	unsigned int check_sum = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr -
+			      bin->header_info[bin_num].header_len)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	check_sum = GET_32_DATA(*(p_check_sum + 3),
+				*(p_check_sum + 2),
+				*(p_check_sum + 1), *(p_check_sum));
+
+	for (i = 4;
+	     i <
+	     bin->header_info[bin_num].bin_data_len +
+	     bin->header_info[bin_num].header_len; i++) {
+		sum_data += *(p_check_sum + i);
+	}
+	DBG("aw_bin_parse bin_num=%d, check_sum = 0x%x, sum_data = 0x%x\n",
+		bin_num, check_sum, sum_data);
+	if (sum_data != check_sum) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse check sum or check bin data len error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, check_sum = 0x%x, sum_data = 0x%x\n", bin_num, check_sum, sum_data);
+		return -3;
+	}
+	p_check_sum = NULL;
+
+	return 0;
+}
+
+static int aw_check_data_version(struct aw_bin *bin, int bin_num)
+{
+	int i = 0;
+	DBG("enter\n");
+
+	for (i = DATA_VERSION_V1; i < DATA_VERSION_MAX; i++) {
+		if (bin->header_info[bin_num].bin_data_ver == i) {
+			return 0;
+		}
+	}
+	DBG_ERR("aw_bin_parse Unrecognized this bin data version\n");
+	return -4;
+}
+
+static int aw_check_register_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_register_num = 0;
+	unsigned int parse_register_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	parse_register_num = GET_32_DATA(*(p_check_sum + 3),
+					 *(p_check_sum + 2),
+					 *(p_check_sum + 1), *(p_check_sum));
+	check_register_num = (bin->header_info[bin_num].bin_data_len - 4) /
+	    (bin->header_info[bin_num].reg_byte_len +
+	     bin->header_info[bin_num].data_byte_len);
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_register_num = 0x%x, check_register_num = 0x%x\n",
+	     bin_num, parse_register_num, check_register_num);
+	if (parse_register_num != check_register_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse register num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_register_num = 0x%x, check_register_num = 0x%x\n", bin_num, parse_register_num, check_register_num);
+		return -5;
+	}
+	bin->header_info[bin_num].reg_num = parse_register_num;
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 4;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 4;
+	return 0;
+}
+
+static int aw_check_dsp_reg_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_dsp_reg_num = 0;
+	unsigned int parse_dsp_reg_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	parse_dsp_reg_num = GET_32_DATA(*(p_check_sum + 7),
+					*(p_check_sum + 6),
+					*(p_check_sum + 5), *(p_check_sum + 4));
+	bin->header_info[bin_num].reg_data_byte_len =
+	    GET_32_DATA(*(p_check_sum + 11), *(p_check_sum + 10),
+			*(p_check_sum + 9), *(p_check_sum + 8));
+	check_dsp_reg_num =
+	    (bin->header_info[bin_num].bin_data_len -
+	     12) / bin->header_info[bin_num].reg_data_byte_len;
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\n",
+	     bin_num, parse_dsp_reg_num, check_dsp_reg_num);
+	if (parse_dsp_reg_num != check_dsp_reg_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse dsp reg num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\n", bin_num, parse_dsp_reg_num, check_dsp_reg_num);
+		return -6;
+	}
+	bin->header_info[bin_num].download_addr =
+	    GET_32_DATA(*(p_check_sum + 3), *(p_check_sum + 2),
+			*(p_check_sum + 1), *(p_check_sum));
+	bin->header_info[bin_num].reg_num = parse_dsp_reg_num;
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 12;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 12;
+	return 0;
+}
+
+static int aw_check_soc_app_num_v1(struct aw_bin *bin, int bin_num)
+{
+	unsigned int check_soc_app_num = 0;
+	unsigned int parse_soc_app_num = 0;
+	unsigned char *p_check_sum = NULL;
+
+	DBG("enter\n");
+
+	p_check_sum =
+	    &(bin->info.data[(bin->header_info[bin_num].valid_data_addr)]);
+	DBG("aw_bin_parse p_check_sum = %p\n", p_check_sum);
+	bin->header_info[bin_num].app_version = GET_32_DATA(*(p_check_sum + 3),
+							    *(p_check_sum + 2),
+							    *(p_check_sum + 1),
+							    *(p_check_sum));
+	parse_soc_app_num = GET_32_DATA(*(p_check_sum + 11),
+					*(p_check_sum + 10),
+					*(p_check_sum + 9), *(p_check_sum + 8));
+	check_soc_app_num = bin->header_info[bin_num].bin_data_len - 12;
+	DBG
+	    ("aw_bin_parse bin_num=%d, parse_soc_app_num = 0x%x, check_soc_app_num = 0x%x\n",
+	     bin_num, parse_soc_app_num, check_soc_app_num);
+	if (parse_soc_app_num != check_soc_app_num) {
+		p_check_sum = NULL;
+		DBG_ERR("aw_bin_parse soc app num is error\n");
+		DBG_ERR("aw_bin_parse bin_num=%d, parse_soc_app_num = 0x%x, check_soc_app_num = 0x%x\n", bin_num, parse_soc_app_num, check_soc_app_num);
+		return -7;
+	}
+	bin->header_info[bin_num].reg_num = parse_soc_app_num;
+	bin->header_info[bin_num].download_addr =
+	    GET_32_DATA(*(p_check_sum + 7), *(p_check_sum + 6),
+			*(p_check_sum + 5), *(p_check_sum + 4));
+	bin->header_info[bin_num].valid_data_len =
+	    bin->header_info[bin_num].bin_data_len - 12;
+	p_check_sum = NULL;
+	bin->header_info[bin_num].valid_data_addr =
+	    bin->header_info[bin_num].valid_data_addr + 12;
+	return 0;
+}
+
+/************************
+***
+***bin header 1_0_0
+***
+************************/
+static void aw_get_single_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int i;
+	DBG("enter %s\n", __func__);
+	bin->header_info[bin->all_bin_parse_num].header_len = 60;
+	bin->header_info[bin->all_bin_parse_num].check_sum =
+	    GET_32_DATA(*(bin->p_addr + 3), *(bin->p_addr + 2),
+			*(bin->p_addr + 1), *(bin->p_addr));
+	bin->header_info[bin->all_bin_parse_num].header_ver =
+	    GET_32_DATA(*(bin->p_addr + 7), *(bin->p_addr + 6),
+			*(bin->p_addr + 5), *(bin->p_addr + 4));
+	bin->header_info[bin->all_bin_parse_num].bin_data_type =
+	    GET_32_DATA(*(bin->p_addr + 11), *(bin->p_addr + 10),
+			*(bin->p_addr + 9), *(bin->p_addr + 8));
+	bin->header_info[bin->all_bin_parse_num].bin_data_ver =
+	    GET_32_DATA(*(bin->p_addr + 15), *(bin->p_addr + 14),
+			*(bin->p_addr + 13), *(bin->p_addr + 12));
+	bin->header_info[bin->all_bin_parse_num].bin_data_len =
+	    GET_32_DATA(*(bin->p_addr + 19), *(bin->p_addr + 18),
+			*(bin->p_addr + 17), *(bin->p_addr + 16));
+	bin->header_info[bin->all_bin_parse_num].ui_ver =
+	    GET_32_DATA(*(bin->p_addr + 23), *(bin->p_addr + 22),
+			*(bin->p_addr + 21), *(bin->p_addr + 20));
+	bin->header_info[bin->all_bin_parse_num].reg_byte_len =
+	    GET_32_DATA(*(bin->p_addr + 35), *(bin->p_addr + 34),
+			*(bin->p_addr + 33), *(bin->p_addr + 32));
+	bin->header_info[bin->all_bin_parse_num].data_byte_len =
+	    GET_32_DATA(*(bin->p_addr + 39), *(bin->p_addr + 38),
+			*(bin->p_addr + 37), *(bin->p_addr + 36));
+	bin->header_info[bin->all_bin_parse_num].device_addr =
+	    GET_32_DATA(*(bin->p_addr + 43), *(bin->p_addr + 42),
+			*(bin->p_addr + 41), *(bin->p_addr + 40));
+	for (i = 0; i < 8; i++) {
+		bin->header_info[bin->all_bin_parse_num].chip_type[i] =
+		    *(bin->p_addr + 24 + i);
+	}
+	bin->header_info[bin->all_bin_parse_num].reg_num = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].reg_data_byte_len = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].download_addr = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].app_version = 0x00000000;
+	bin->header_info[bin->all_bin_parse_num].valid_data_len = 0x00000000;
+	bin->all_bin_parse_num += 1;
+}
+
+static int aw_parse_each_of_multi_bins_1_0_0(unsigned int bin_num, int bin_serial_num,
+				      struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int bin_start_addr = 0;
+	unsigned int valid_data_len = 0;
+	DBG("aw_bin_parse enter multi bin branch -- %s\n", __func__);
+	if (!bin_serial_num) {
+		bin_start_addr = GET_32_DATA(*(bin->p_addr + 67),
+					     *(bin->p_addr + 66),
+					     *(bin->p_addr + 65),
+					     *(bin->p_addr + 64));
+		bin->p_addr += (60 + bin_start_addr);
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr =
+		    bin->header_info[bin->all_bin_parse_num -
+				     1].valid_data_addr + 4 + 8 * bin_num + 60;
+	} else {
+		valid_data_len =
+		    bin->header_info[bin->all_bin_parse_num - 1].bin_data_len;
+		bin->p_addr += (60 + valid_data_len);
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr =
+		    bin->header_info[bin->all_bin_parse_num -
+				     1].valid_data_addr +
+		    bin->header_info[bin->all_bin_parse_num - 1].bin_data_len +
+		    60;
+	}
+
+	ret = aw_parse_bin_header_1_0_0(bin);
+	return ret;
+}
+
+/* Get the number of bins in multi bins, and set a for loop, loop processing each bin data */
+static int aw_get_multi_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int i = 0;
+	int ret = 0;
+	unsigned int bin_num = 0;
+	DBG("aw_bin_parse enter multi bin branch -- %s\n", __func__);
+	bin_num = GET_32_DATA(*(bin->p_addr + 63),
+			      *(bin->p_addr + 62),
+			      *(bin->p_addr + 61), *(bin->p_addr + 60));
+	if (bin->multi_bin_parse_num == 1) {
+		bin->header_info[bin->all_bin_parse_num].valid_data_addr = 60;
+	}
+	aw_get_single_bin_header_1_0_0(bin);
+
+	for (i = 0; i < bin_num; i++) {
+		DBG("aw_bin_parse enter multi bin for is %d\n", i);
+		ret = aw_parse_each_of_multi_bins_1_0_0(bin_num, i, bin);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/********************************************************
+*
+* If the bin framework header version is 1.0.0,
+  determine the data type of bin, and then perform different processing
+  according to the data type
+  If it is a single bin data type, write the data directly into the structure array
+  If it is a multi-bin data type, first obtain the number of bins,
+  and then recursively call the bin frame header processing function
+  according to the bin number to process the frame header information of each bin separately
+*
+********************************************************/
+static int aw_parse_bin_header_1_0_0(struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int bin_data_type;
+	DBG("enter %s\n", __func__);
+	bin_data_type = GET_32_DATA(*(bin->p_addr + 11),
+				    *(bin->p_addr + 10),
+				    *(bin->p_addr + 9), *(bin->p_addr + 8));
+	DBG("aw_bin_parse bin_data_type 0x%x\n", bin_data_type);
+	switch (bin_data_type) {
+	case DATA_TYPE_REGISTER:
+	case DATA_TYPE_DSP_REG:
+	case DATA_TYPE_SOC_APP:
+		/* Divided into two processing methods,
+		   one is single bin processing,
+		   and the other is single bin processing in multi bin */
+		DBG("aw_bin_parse enter single bin branch\n");
+		bin->single_bin_parse_num += 1;
+		DBG("%s bin->single_bin_parse_num is %d\n", __func__,
+			bin->single_bin_parse_num);
+		if (!bin->multi_bin_parse_num) {
+			bin->header_info[bin->
+					 all_bin_parse_num].valid_data_addr =
+			    60;
+		}
+		aw_get_single_bin_header_1_0_0(bin);
+		break;
+	case DATA_TYPE_MULTI_BINS:
+		/* Get the number of times to enter multi bins */
+		DBG("aw_bin_parse enter multi bin branch\n");
+		bin->multi_bin_parse_num += 1;
+		DBG("%s bin->multi_bin_parse_num is %d\n", __func__,
+			bin->multi_bin_parse_num);
+		ret = aw_get_multi_bin_header_1_0_0(bin);
+		if (ret < 0) {
+			return ret;
+		}
+		break;
+	default:
+		DBG_ERR("aw_bin_parse Unrecognized this bin data type\n");
+		return -2;
+	}
+	return 0;
+}
+
+/* get the bin's header version */
+static int aw_check_bin_header_version(struct aw_bin *bin)
+{
+	int ret = 0;
+	unsigned int header_version = 0;
+
+	header_version = GET_32_DATA(*(bin->p_addr + 7),
+				     *(bin->p_addr + 6),
+				     *(bin->p_addr + 5), *(bin->p_addr + 4));
+
+	DBG("aw_bin_parse header_version 0x%x\n", header_version);
+
+	/* Write data to the corresponding structure array
+	   according to different formats of the bin frame header version */
+	switch (header_version) {
+	case HEADER_VERSION_1_0_0:
+		ret = aw_parse_bin_header_1_0_0(bin);
+		return ret;
+	default:
+		DBG_ERR("aw_bin_parse Unrecognized this bin header version \n");
+		return -1;
+	}
+}
+
+int aw87xxx_parsing_bin_file(struct aw_bin *bin)
+{
+	int i = 0;
+	int ret = 0;
+
+	DBG("aw_bin_parse code version:%s\n", AWINIC_CODE_VERSION);
+	if (!bin) {
+		DBG_ERR("aw_bin_parse bin is NULL\n");
+		return -8;
+	}
+	bin->p_addr = bin->info.data;
+	bin->all_bin_parse_num = 0;
+	bin->multi_bin_parse_num = 0;
+	bin->single_bin_parse_num = 0;
+
+	/* filling bins header info */
+	ret = aw_check_bin_header_version(bin);
+	if (ret < 0) {
+		DBG_ERR("aw_bin_parse check bin header version error\n");
+		return ret;
+	}
+	bin->p_addr = NULL;
+
+	/* check bin header info */
+	for (i = 0; i < bin->all_bin_parse_num; i++) {
+		/* check sum */
+		ret = aw_check_sum(bin, i);
+		if (ret < 0) {
+			DBG_ERR("aw_bin_parse check sum data error\n");
+			return ret;
+		}
+		/* check bin data version */
+		ret = aw_check_data_version(bin, i);
+		if (ret < 0) {
+			DBG_ERR("aw_bin_parse check data version error\n");
+			return ret;
+		}
+		/* check valid data */
+		if (bin->header_info[i].bin_data_ver == DATA_VERSION_V1) {
+			/* check register num */
+			if (bin->header_info[i].bin_data_type ==
+			    DATA_TYPE_REGISTER) {
+				ret = aw_check_register_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check register num error\n");
+					return ret;
+				}
+				/* check dsp reg num */
+			} else if (bin->header_info[i].bin_data_type ==
+				   DATA_TYPE_DSP_REG) {
+				ret = aw_check_dsp_reg_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check dsp reg num error\n");
+					return ret;
+				}
+				/* check soc app num */
+			} else if (bin->header_info[i].bin_data_type ==
+				   DATA_TYPE_SOC_APP) {
+				ret = aw_check_soc_app_num_v1(bin, i);
+				if (ret < 0) {
+					DBG_ERR
+					    ("aw_bin_parse check soc app num error\n");
+					return ret;
+				}
+			} else {
+				bin->header_info[i].valid_data_len =
+				    bin->header_info[i].bin_data_len;
+			}
+		}
+	}
+	DBG("aw_bin_parse parsing success\n");
+
+	return 0;
+}
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
new file mode 100644
index 000000000000..a99c2409e613
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_bin_parse.h
@@ -0,0 +1,73 @@
+#ifndef __AW87XXX_BIN_PARSE_H__
+#define __AW87XXX_BIN_PARSE_H__
+
+#define NULL    ((void *)0)
+#define GET_32_DATA(w, x, y, z) ((unsigned int)(((w) << 24) | ((x) << 16) | ((y) << 8) | (z)))
+#define BIN_NUM_MAX   100
+#define HEADER_LEN    60
+/*********************************************************
+ *
+ * header information
+ *
+ ********************************************************/
+enum bin_header_version_enum {
+	HEADER_VERSION_1_0_0 = 0x01000000,
+};
+
+enum data_type_enum {
+	DATA_TYPE_REGISTER = 0x00000000,
+	DATA_TYPE_DSP_REG = 0x00000010,
+	DATA_TYPE_DSP_CFG = 0x00000011,
+	DATA_TYPE_SOC_REG = 0x00000020,
+	DATA_TYPE_SOC_APP = 0x00000021,
+	DATA_TYPE_MULTI_BINS = 0x00002000,
+	DATA_TYPE_MONITOR_ANALOG = 0x00020000,
+};
+
+enum data_version_enum {
+	DATA_VERSION_V1 = 0X00000001,	/*default little edian */
+	DATA_VERSION_MAX,
+};
+
+struct bin_header_info {
+	unsigned int header_len; /* Frame header length */
+	unsigned int check_sum; /* Frame header information-Checksum */
+	unsigned int header_ver; /* Frame header information-Frame header version */
+	unsigned int bin_data_type; /* Frame header information-Data type */
+	unsigned int bin_data_ver; /* Frame header information-Data version */
+	unsigned int bin_data_len; /* Frame header information-Data length */
+	unsigned int ui_ver; /* Frame header information-ui version */
+	unsigned char chip_type[8]; /* Frame header information-chip type */
+	unsigned int reg_byte_len; /* Frame header information-reg byte len */
+	unsigned int data_byte_len; /* Frame header information-data byte len */
+	unsigned int device_addr; /* Frame header information-device addr */
+	unsigned int valid_data_len; /* Length of valid data obtained after parsing */
+	unsigned int valid_data_addr; /* The offset address of the valid data obtained after parsing relative to info */
+
+	unsigned int reg_num; /* The number of registers obtained after parsing */
+	unsigned int reg_data_byte_len; /* The byte length of the register obtained after parsing */
+	unsigned int download_addr; /* The starting address or download address obtained after parsing */
+	unsigned int app_version; /* The software version number obtained after parsing */
+};
+
+/************************************************************
+*
+* function define
+*
+************************************************************/
+struct bin_container {
+	unsigned int len; /* The size of the bin file obtained from the firmware */
+	unsigned char data[]; /* Store the bin file obtained from the firmware */
+};
+
+struct aw_bin {
+	unsigned char *p_addr; /* Offset pointer (backward offset pointer to obtain frame header information and important information) */
+	unsigned int all_bin_parse_num; /* The number of all bin files */
+	unsigned int multi_bin_parse_num; /* The number of single bin files */
+	unsigned int single_bin_parse_num; /* The number of multiple bin files */
+	struct bin_header_info header_info[BIN_NUM_MAX]; /* Frame header information and other important data obtained after parsing */
+	struct bin_container info; /* Obtained bin file data that needs to be parsed */
+};
+
+extern int aw87xxx_parsing_bin_file(struct aw_bin *bin);
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_device.c b/sound/soc/codecs/aw87xxx/aw87xxx_device.c
new file mode 100644
index 000000000000..a4c9ad7d96dc
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_device.c
@@ -0,0 +1,977 @@
+/*
+ * aw87xxx_device.c  aw87xxx pa module
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include "aw87xxx.h"
+#include "aw87xxx_device.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_pid_9b_reg.h"
+#include "aw87xxx_pid_18_reg.h"
+#include "aw87xxx_pid_39_reg.h"
+#include "aw87xxx_pid_59_3x9_reg.h"
+#include "aw87xxx_pid_59_5x9_reg.h"
+#include "aw87xxx_pid_5a_reg.h"
+#include "aw87xxx_pid_76_reg.h"
+#include "aw87xxx_pid_60_reg.h"
+
+/*************************************************************************
+ * aw87xxx variable
+ ************************************************************************/
+const char *g_aw_pid_9b_product[] = {
+	"aw87319",
+};
+const char *g_aw_pid_18_product[] = {
+	"aw87418",
+};
+
+const char *g_aw_pid_39_product[] = {
+	"aw87329",
+	"aw87339",
+	"aw87349",
+};
+
+const char *g_aw_pid_59_3x9_product[] = {
+	"aw87359",
+	"aw87389",
+};
+
+const char *g_aw_pid_59_5x9_product[] = {
+	"aw87509",
+	"aw87519",
+	"aw87529",
+	"aw87539",
+};
+
+const char *g_aw_pid_5a_product[] = {
+	"aw87549",
+	"aw87559",
+	"aw87569",
+	"aw87579",
+	"aw81509",
+};
+
+const char *g_aw_pid_76_product[] = {
+	"aw87390",
+	"aw87320",
+	"aw87401",
+	"aw87360",
+};
+
+const char *g_aw_pid_60_product[] = {
+	"aw87560",
+	"aw87561",
+	"aw87562",
+	"aw87501",
+	"aw87550",
+};
+
+static int aw87xxx_dev_get_chipid(struct aw_device *aw_dev);
+
+/***************************************************************************
+ *
+ * reading and writing of I2C bus
+ *
+ ***************************************************************************/
+int aw87xxx_dev_i2c_write_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_write_byte_data(aw_dev->i2c, reg_addr, reg_data);
+		if (ret < 0)
+			AW_DEV_LOGE(aw_dev->dev, "i2c_write cnt=%d error=%d i2c_bus=%u i2c_addr=%X chipid=%X",
+				cnt, ret, aw_dev->i2c_bus, aw_dev->i2c_addr, aw_dev->chipid);
+		else
+			break;
+
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+int aw87xxx_dev_i2c_read_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t *reg_data)
+{
+	int ret = -1;
+	unsigned char cnt = 0;
+
+	while (cnt < AW_I2C_RETRIES) {
+		ret = i2c_smbus_read_byte_data(aw_dev->i2c, reg_addr);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "i2c_read cnt=%d error=%d i2c_bus=%u i2c_addr=%X chipid=%X",
+				cnt, ret, aw_dev->i2c_bus, aw_dev->i2c_addr, aw_dev->chipid);
+		} else {
+			*reg_data = ret;
+			break;
+		}
+		cnt++;
+		msleep(AW_I2C_RETRY_DELAY);
+	}
+
+	return ret;
+}
+
+int aw87xxx_dev_i2c_read_msg(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t *data_buf, uint32_t data_len)
+{
+	int ret = -1;
+
+	struct i2c_msg msg[] = {
+	[0] = {
+		.addr = aw_dev->i2c_addr,
+		.flags = 0,
+		.len = sizeof(uint8_t),
+		.buf = &reg_addr,
+		},
+	[1] = {
+		.addr = aw_dev->i2c_addr,
+		.flags = I2C_M_RD,
+		.len = data_len,
+		.buf = data_buf,
+		},
+	};
+
+	ret = i2c_transfer(aw_dev->i2c->adapter, msg, ARRAY_SIZE(msg));
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "transfer failed");
+		return ret;
+	} else if (ret != AW_I2C_READ_MSG_NUM) {
+		AW_DEV_LOGE(aw_dev->dev, "transfer failed(size error)");
+		return -ENXIO;
+	}
+
+	return 0;
+}
+
+int aw87xxx_dev_i2c_write_bits(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t mask, uint8_t reg_data)
+{
+	int ret = -1;
+	unsigned char reg_val = 0;
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, reg_addr, &reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "i2c read error, ret=%d", ret);
+		return ret;
+	}
+	reg_val &= mask;
+	reg_val |= (reg_data & (~mask));
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, reg_addr, reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "i2c write error, ret=%d", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * aw87xxx device update profile data to registers
+ *
+ ************************************************************************/
+static int aw87xxx_dev_reg_update(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "dev is pwr_off,can not update reg");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < profile_data->len; i = i + 2) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			profile_data->data[i], profile_data->data[i + 1]);
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, profile_data->data[i],
+				profile_data->data[i + 1]);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static void aw87xxx_dev_reg_mute_bits_set(struct aw_device *aw_dev,
+				uint8_t *reg_val, bool enable)
+{
+	if (enable) {
+		*reg_val &= aw_dev->mute_desc.mask;
+		*reg_val |= aw_dev->mute_desc.enable;
+	} else {
+		*reg_val &= aw_dev->mute_desc.mask;
+		*reg_val |= aw_dev->mute_desc.disable;
+	}
+}
+
+static int aw87xxx_dev_reg_update_mute(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+	uint8_t reg_val = 0;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hwen is off,can not update reg");
+		return -EINVAL;
+	}
+
+	if (aw_dev->mute_desc.mask == AW_DEV_REG_INVALID_MASK) {
+		AW_DEV_LOGE(aw_dev->dev, "mute ctrl mask invalid");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < profile_data->len; i = i + 2) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			profile_data->data[i], profile_data->data[i + 1]);
+
+		reg_val = profile_data->data[i + 1];
+		if (profile_data->data[i] == aw_dev->mute_desc.addr) {
+			aw87xxx_dev_reg_mute_bits_set(aw_dev, &reg_val, true);
+			AW_DEV_LOGD(aw_dev->dev, "change mute_mask, val = 0x%02x",
+				reg_val);
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, profile_data->data[i], reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * aw87xxx device hadware and soft contols
+ *
+ ************************************************************************/
+static bool aw87xxx_dev_gpio_is_valid(struct aw_device *aw_dev)
+{
+	if (gpio_is_valid(aw_dev->rst_gpio))
+		return true;
+	else
+		return false;
+}
+
+void aw87xxx_dev_hw_pwr_ctrl(struct aw_device *aw_dev, bool enable)
+{
+	if (aw_dev->hwen_status == AW_DEV_HWEN_INVALID) {
+		AW_DEV_LOGD(aw_dev->dev, "product not have reset-pin,hardware pwd control invalid");
+		return;
+	}
+	if (enable) {
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_LOW_LEVEL);
+			mdelay(2);
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_HIGHT_LEVEL);
+			mdelay(2);
+			aw_dev->hwen_status = AW_DEV_HWEN_ON;
+			AW_DEV_LOGI(aw_dev->dev, "hw power on");
+		} else {
+			AW_DEV_LOGI(aw_dev->dev, "hw already power on");
+		}
+	} else {
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			gpio_set_value_cansleep(aw_dev->rst_gpio, AW_GPIO_LOW_LEVEL);
+			mdelay(2);
+			aw_dev->hwen_status = AW_DEV_HWEN_OFF;
+			AW_DEV_LOGI(aw_dev->dev, "hw power off");
+		} else {
+			AW_DEV_LOGI(aw_dev->dev, "hw already power off");
+		}
+	}
+}
+
+static int aw87xxx_dev_mute_ctrl(struct aw_device *aw_dev, bool enable)
+{
+	int ret = 0;
+
+	if (enable) {
+		ret = aw87xxx_dev_i2c_write_bits(aw_dev, aw_dev->mute_desc.addr,
+				aw_dev->mute_desc.mask, aw_dev->mute_desc.enable);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw_dev->dev, "set mute down");
+	} else {
+		ret = aw87xxx_dev_i2c_write_bits(aw_dev, aw_dev->mute_desc.addr,
+				aw_dev->mute_desc.mask, aw_dev->mute_desc.disable);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw_dev->dev, "close mute down");
+	}
+
+	return 0;
+}
+
+void aw87xxx_dev_soft_reset(struct aw_device *aw_dev)
+{
+	int i = 0;
+	int ret = -1;
+	struct aw_soft_rst_desc *soft_rst = &aw_dev->soft_rst_desc;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hw is off,can not softrst");
+		return;
+	}
+
+	if (aw_dev->soft_rst_enable == AW_DEV_SOFT_RST_DISENABLE) {
+		AW_DEV_LOGD(aw_dev->dev, "softrst is disenable");
+		return;
+	}
+
+	if (soft_rst->access == NULL || soft_rst->len == 0) {
+		AW_DEV_LOGE(aw_dev->dev, "softrst_info not init");
+		return;
+	}
+
+	if (soft_rst->len % 2) {
+		AW_DEV_LOGE(aw_dev->dev, "softrst data_len[%d] is odd number,data not available",
+			aw_dev->soft_rst_desc.len);
+		return;
+	}
+
+	for (i = 0; i < soft_rst->len; i += 2) {
+		AW_DEV_LOGD(aw_dev->dev, "softrst_reg=0x%02x, val = 0x%02x",
+			soft_rst->access[i], soft_rst->access[i + 1]);
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, soft_rst->access[i],
+				soft_rst->access[i + 1]);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "write failed,ret = %d,cnt=%d",
+				ret, i);
+			return;
+		}
+	}
+	AW_DEV_LOGD(aw_dev->dev, "down");
+}
+
+
+int aw87xxx_dev_default_pwr_off(struct aw_device *aw_dev,
+		struct aw_data_container *profile_data)
+{
+	int ret = 0;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "hwen is already off");
+		return 0;
+	}
+
+	if (aw_dev->soft_off_enable && profile_data) {
+		ret = aw87xxx_dev_reg_update(aw_dev, profile_data);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "update profile[Off] fw config failed");
+			goto reg_off_update_failed;
+		}
+	}
+
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, false);
+	AW_DEV_LOGD(aw_dev->dev, "down");
+	return 0;
+
+reg_off_update_failed:
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, false);
+	return ret;
+}
+
+
+/************************************************************************
+ *
+ * aw87xxx device power on process function
+ *
+ ************************************************************************/
+
+int aw87xxx_dev_default_pwr_on(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	ret = aw87xxx_dev_reg_update(aw_dev, profile_data);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/****************************************************************************
+ *
+ * aw87xxx chip esd status check
+ *
+ ****************************************************************************/
+int aw87xxx_dev_esd_reg_status_check(struct aw_device *aw_dev)
+{
+	int ret;
+	unsigned char reg_val = 0;
+	struct aw_esd_check_desc *esd_desc = &aw_dev->esd_desc;
+
+	AW_DEV_LOGD(aw_dev->dev, "enter");
+
+	if (!esd_desc->first_update_reg_addr) {
+		AW_DEV_LOGE(aw_dev->dev, "esd check info if not init,please check");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, esd_desc->first_update_reg_addr,
+			&reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read reg 0x%02x failed",
+			esd_desc->first_update_reg_addr);
+		return ret;
+	}
+
+	AW_DEV_LOGD(aw_dev->dev, "0x%02x:default val=0x%02x real val=0x%02x",
+		esd_desc->first_update_reg_addr,
+		esd_desc->first_update_reg_val, reg_val);
+
+	if (reg_val == esd_desc->first_update_reg_val) {
+		AW_DEV_LOGE(aw_dev->dev, "reg status check failed");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int aw87xxx_dev_check_reg_is_rec_mode(struct aw_device *aw_dev)
+{
+	int ret;
+	unsigned char reg_val = 0;
+	struct aw_rec_mode_desc *rec_desc = &aw_dev->rec_desc;
+
+	if (!rec_desc->addr) {
+		AW_DEV_LOGE(aw_dev->dev, "rec check info if not init,please check");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_i2c_read_byte(aw_dev, rec_desc->addr, &reg_val);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read reg 0x%02x failed",
+			rec_desc->addr);
+		return ret;
+	}
+
+	if (rec_desc->enable) {
+		if (reg_val & ~(rec_desc->mask)) {
+			AW_DEV_LOGI(aw_dev->dev, "reg status is receiver mode");
+			aw_dev->is_rec_mode = AW_IS_REC_MODE;
+		} else {
+			aw_dev->is_rec_mode = AW_NOT_REC_MODE;
+		}
+	} else {
+		if (!(reg_val & ~(rec_desc->mask))) {
+			AW_DEV_LOGI(aw_dev->dev, "reg status is receiver mode");
+			aw_dev->is_rec_mode = AW_IS_REC_MODE;
+		} else {
+			aw_dev->is_rec_mode = AW_NOT_REC_MODE;
+		}
+	}
+	return 0;
+}
+
+
+/****************************************************************************
+ *
+ * aw87xxx product attributes init info
+ *
+ ****************************************************************************/
+
+/********************** aw87xxx_pid_9A attributes ***************************/
+
+static int aw_dev_pid_9b_reg_update(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data)
+{
+	int i = 0;
+	int ret = -1;
+	uint8_t reg_val = 0;
+
+	if (profile_data == NULL)
+		return -EINVAL;
+
+	if (aw_dev->hwen_status == AW_DEV_HWEN_OFF) {
+		AW_DEV_LOGE(aw_dev->dev, "dev is pwr_off,can not update reg");
+		return -EINVAL;
+	}
+
+	if (profile_data->len != AW_PID_9B_BIN_REG_CFG_COUNT) {
+		AW_DEV_LOGE(aw_dev->dev, "reg_config count of bin is error,can not update reg");
+		return -EINVAL;
+	}
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, AW87XXX_PID_9B_ENCRYPTION_REG,
+		AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET);
+	if (ret < 0)
+		return ret;
+
+	for (i = 1; i < AW_PID_9B_BIN_REG_CFG_COUNT; i++) {
+		AW_DEV_LOGI(aw_dev->dev, "reg=0x%02x, val = 0x%02x",
+			i, profile_data->data[i]);
+		reg_val = profile_data->data[i];
+		if (i == AW87XXX_PID_9B_SYSCTRL_REG) {
+			aw87xxx_dev_reg_mute_bits_set(aw_dev, &reg_val, true);
+			AW_DEV_LOGD(aw_dev->dev, "change mute_mask, val = 0x%02x",
+				reg_val);
+		}
+
+		ret = aw87xxx_dev_i2c_write_byte(aw_dev, i, reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int aw_dev_pid_9b_pwr_on(struct aw_device *aw_dev, struct aw_data_container *data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	/* open the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, true);
+	if (ret < 0)
+		return ret;
+
+	/* Update scene parameters in mute mode */
+	ret = aw_dev_pid_9b_reg_update(aw_dev, data);
+	if (ret < 0)
+		return ret;
+
+	/* close the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, false);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void aw_dev_pid_9b_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_9B_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_9b_reg_access;
+
+	aw_dev->mute_desc.addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->mute_desc.mask = AW87XXX_PID_9B_REG_EN_SW_MASK;
+	aw_dev->mute_desc.enable = AW87XXX_PID_9B_REG_EN_SW_DISABLE_VALUE;
+	aw_dev->mute_desc.disable = AW87XXX_PID_9B_REG_EN_SW_ENABLE_VALUE;
+	aw_dev->ops.pwr_on_func = aw_dev_pid_9b_pwr_on;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_9b_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_9b_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_DISENABLE;
+
+	aw_dev->product_tab = g_aw_pid_9b_product;
+	aw_dev->product_cnt = AW87XXX_PID_9B_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_9B_SPK_MODE_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_9B_SPK_MODE_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_9B_SPK_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_9B_SYSCTRL_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_9B_SYSCTRL_DEFAULT;
+}
+
+static int aw_dev_pid_9a_init(struct aw_device *aw_dev)
+{
+	int ret = 0;
+
+	ret = aw87xxx_dev_i2c_write_byte(aw_dev, AW87XXX_PID_9B_ENCRYPTION_REG,
+		AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "write 0x64=0x2C error");
+		return -EINVAL;
+	}
+
+	ret = aw87xxx_dev_get_chipid(aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read chipid is failed,ret=%d", ret);
+		return ret;
+	}
+
+	if (aw_dev->chipid == AW_DEV_CHIPID_9B) {
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_9B class");
+		aw_dev_pid_9b_init(aw_dev);
+	} else {
+		AW_DEV_LOGE(aw_dev->dev, "product is not pid_9B classnot support");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/********************** aw87xxx_pid_9b attributes end ***********************/
+
+/********************** aw87xxx_pid_18 attributes ***************************/
+static int aw_dev_pid_18_pwr_on(struct aw_device *aw_dev, struct aw_data_container *data)
+{
+	int ret = 0;
+
+	/*hw power on*/
+	aw87xxx_dev_hw_pwr_ctrl(aw_dev, true);
+
+	/* open the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, true);
+	if (ret < 0)
+		return ret;
+
+	/* Update scene parameters in mute mode */
+	ret = aw87xxx_dev_reg_update_mute(aw_dev, data);
+	if (ret < 0)
+		return ret;
+
+	/* close the mute */
+	ret = aw87xxx_dev_mute_ctrl(aw_dev, false);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void aw_dev_chipid_18_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_18_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_18_reg_access;
+
+	aw_dev->mute_desc.addr = AW87XXX_PID_18_SYSCTRL_REG;
+	aw_dev->mute_desc.mask = AW87XXX_PID_18_REG_EN_SW_MASK;
+	aw_dev->mute_desc.enable = AW87XXX_PID_18_REG_EN_SW_DISABLE_VALUE;
+	aw_dev->mute_desc.disable = AW87XXX_PID_18_REG_EN_SW_ENABLE_VALUE;
+	aw_dev->ops.pwr_on_func = aw_dev_pid_18_pwr_on;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_18_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_18_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_18_product;
+	aw_dev->product_cnt = AW87XXX_PID_18_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_18_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_18_REG_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_18_REG_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_18_REG_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_18_CLASSD_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_18_CLASSD_DEFAULT;
+}
+/********************** aw87xxx_pid_18 attributes end ***********************/
+
+/********************** aw87xxx_pid_39 attributes ***************************/
+static void aw_dev_chipid_39_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_39_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_39_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_39_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_39_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_39_product;
+	aw_dev->product_cnt = AW87XXX_PID_39_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_39_REG_MODECTRL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_39_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_39_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_39_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_39_REG_MODECTRL;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_39_MODECTRL_DEFAULT;
+}
+/********************* aw87xxx_pid_39 attributes end *************************/
+
+
+/********************* aw87xxx_pid_59_5x9 attributes *************************/
+static void aw_dev_chipid_59_5x9_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_59_5X9_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_59_5x9_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_59_5x9_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_59_5x9_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_59_5x9_product;
+	aw_dev->product_cnt = AW87XXX_PID_59_5X9_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_59_5X9_REG_SYSCTRL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_59_5X9_REC_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_59_5X9_REC_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_59_5X9_REC_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_59_5X9_REG_ENCR;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_59_5X9_ENCRY_DEFAULT;
+}
+/******************* aw87xxx_pid_59_5x9 attributes end ***********************/
+
+/********************* aw87xxx_pid_59_3x9 attributes *************************/
+static void aw_dev_chipid_59_3x9_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_59_3X9_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_59_3x9_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_59_3x9_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_59_3x9_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_59_3x9_product;
+	aw_dev->product_cnt = AW87XXX_PID_59_3X9_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_59_3X9_REG_MDCRTL;
+	aw_dev->rec_desc.disable = AW87XXX_PID_59_3X9_SPK_MODE_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_59_3X9_SPK_MODE_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_59_3X9_SPK_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_59_3X9_REG_ENCR;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_59_3X9_ENCR_DEFAULT;
+}
+/******************* aw87xxx_pid_59_3x9 attributes end ***********************/
+
+/********************** aw87xxx_pid_5a attributes ****************************/
+static void aw_dev_chipid_5a_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_5A_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_5a_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_5a_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_5a_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* Whether to allow register operation to power off */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_5a_product;
+	aw_dev->product_cnt = AW87XXX_PID_5A_PRODUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_5A_REG_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_5A_REG_RCV_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_5A_REG_RCV_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_5A_REG_RCV_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_5A_REG_DFT3R_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_5A_DFT3R_DEFAULT;
+}
+/********************** aw87xxx_pid_5a attributes end ************************/
+
+/********************** aw87xxx_pid_76 attributes ****************************/
+static void aw_dev_chipid_76_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_76_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_76_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_76_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_76_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* software power off control info */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_76_product;
+	aw_dev->product_cnt = AW87XXX_PID_76_PROFUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_76_MDCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_76_EN_SPK_ENABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_76_EN_SPK_DISABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_76_EN_SPK_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_76_DFT_ADP1_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_76_DFT_ADP1_CHECK;
+}
+/********************** aw87xxx_pid_76 attributes end ************************/
+
+/********************** aw87xxx_pid_60 attributes ****************************/
+static void aw_dev_chipid_60_init(struct aw_device *aw_dev)
+{
+	/* Product register permission info */
+	aw_dev->reg_max_addr = AW87XXX_PID_60_REG_MAX;
+	aw_dev->reg_access = aw87xxx_pid_60_reg_access;
+
+	/* software reset control info */
+	aw_dev->soft_rst_desc.len = sizeof(aw87xxx_pid_60_softrst_access);
+	aw_dev->soft_rst_desc.access = aw87xxx_pid_60_softrst_access;
+	aw_dev->soft_rst_enable = AW_DEV_SOFT_RST_ENABLE;
+
+	/* software power off control info */
+	aw_dev->soft_off_enable = AW_DEV_SOFT_OFF_ENABLE;
+
+	aw_dev->product_tab = g_aw_pid_60_product;
+	aw_dev->product_cnt = AW87XXX_PID_60_PROFUCT_MAX;
+
+	aw_dev->rec_desc.addr = AW87XXX_PID_60_SYSCTRL_REG;
+	aw_dev->rec_desc.disable = AW87XXX_PID_60_RCV_MODE_DISABLE;
+	aw_dev->rec_desc.enable = AW87XXX_PID_60_RCV_MODE_ENABLE;
+	aw_dev->rec_desc.mask = AW87XXX_PID_60_RCV_MODE_MASK;
+
+	/* esd reg info */
+	aw_dev->esd_desc.first_update_reg_addr = AW87XXX_PID_60_NG3_REG;
+	aw_dev->esd_desc.first_update_reg_val = AW87XXX_PID_60_ESD_REG_VAL;
+}
+/********************** aw87xxx_pid_60 attributes end ************************/
+
+static int aw_dev_chip_init(struct aw_device *aw_dev)
+{
+	int ret  = 0;
+
+	/*get info by chipid*/
+	switch (aw_dev->chipid) {
+	case AW_DEV_CHIPID_9A:
+		ret = aw_dev_pid_9a_init(aw_dev);
+		if (ret < 0)
+			AW_DEV_LOGE(aw_dev->dev, "product is pid_9B init failed");
+		break;
+	case AW_DEV_CHIPID_9B:
+		aw_dev_pid_9b_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_9B class");
+		break;
+	case AW_DEV_CHIPID_18:
+		aw_dev_chipid_18_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_18 class");
+		break;
+	case AW_DEV_CHIPID_39:
+		aw_dev_chipid_39_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_39 class");
+		break;
+	case AW_DEV_CHIPID_59:
+		if (aw87xxx_dev_gpio_is_valid(aw_dev)) {
+			aw_dev_chipid_59_5x9_init(aw_dev);
+			AW_DEV_LOGI(aw_dev->dev, "product is pid_59_5x9 class");
+		} else {
+			aw_dev_chipid_59_3x9_init(aw_dev);
+			AW_DEV_LOGI(aw_dev->dev, "product is pid_59_3x9 class");
+		}
+		break;
+	case AW_DEV_CHIPID_5A:
+		aw_dev_chipid_5a_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_5A class");
+		break;
+	case AW_DEV_CHIPID_76:
+		aw_dev_chipid_76_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_76 class");
+		break;
+	case AW_DEV_CHIPID_60:
+		aw_dev_chipid_60_init(aw_dev);
+		AW_DEV_LOGI(aw_dev->dev, "product is pid_60 class");
+		break;
+	default:
+		AW_DEV_LOGE(aw_dev->dev, "unsupported device revision [0x%x]",
+			aw_dev->chipid);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw87xxx_dev_get_chipid(struct aw_device *aw_dev)
+{
+	int ret = -1;
+	unsigned int cnt = 0;
+	unsigned char reg_val = 0;
+
+	for (cnt = 0; cnt < AW_READ_CHIPID_RETRIES; cnt++) {
+		ret = aw87xxx_dev_i2c_read_byte(aw_dev, AW_DEV_REG_CHIPID, &reg_val);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw_dev->dev, "[%d] read chip is failed, ret=%d",
+				cnt, ret);
+			continue;
+		}
+		break;
+	}
+
+
+	if (cnt == AW_READ_CHIPID_RETRIES) {
+		AW_DEV_LOGE(aw_dev->dev, "read chip is failed,cnt=%d", cnt);
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGI(aw_dev->dev, "read chipid[0x%x] succeed", reg_val);
+	aw_dev->chipid = reg_val;
+
+	return 0;
+}
+
+int aw87xxx_dev_init(struct aw_device *aw_dev)
+{
+	int ret = -1;
+
+	ret = aw87xxx_dev_get_chipid(aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw_dev->dev, "read chipid is failed,ret=%d", ret);
+		return ret;
+	}
+
+	ret = aw_dev_chip_init(aw_dev);
+
+	return ret;
+}
+
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_device.h b/sound/soc/codecs/aw87xxx/aw87xxx_device.h
new file mode 100644
index 000000000000..7c85f80a958e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_device.h
@@ -0,0 +1,149 @@
+#ifndef __AW87XXX_DEVICE_H__
+#define __AW87XXX_DEVICE_H__
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <sound/control.h>
+#include <sound/soc.h>
+#include "aw87xxx_acf_bin.h"
+
+#define AW87XXX_PID_9B_PRODUCT_MAX	(1)
+#define AW87XXX_PID_18_PRODUCT_MAX	(1)
+#define AW87XXX_PID_39_PRODUCT_MAX	(3)
+#define AW87XXX_PID_59_3X9_PRODUCT_MAX	(2)
+#define AW87XXX_PID_59_5X9_PRODUCT_MAX	(4)
+#define AW87XXX_PID_5A_PRODUCT_MAX	(5)
+#define AW87XXX_PID_76_PROFUCT_MAX	(4)
+#define AW87XXX_PID_60_PROFUCT_MAX	(5)
+#define AW_PRODUCT_NAME_LEN		(8)
+
+#define AW_GPIO_HIGHT_LEVEL		(1)
+#define AW_GPIO_LOW_LEVEL		(0)
+
+#define AW_I2C_RETRIES			(5)
+#define AW_I2C_RETRY_DELAY		(2)
+#define AW_I2C_READ_MSG_NUM		(2)
+
+#define AW_READ_CHIPID_RETRIES		(5)
+#define AW_READ_CHIPID_RETRY_DELAY	(2)
+#define AW_DEV_REG_CHIPID		(0x00)
+
+#define AW_DEV_REG_INVALID_MASK		(0xff)
+
+#define AW_NO_RESET_GPIO		(-1)
+
+#define AW_PID_9B_BIN_REG_CFG_COUNT	(10)
+
+/********************************************
+ *
+ * aw87xxx devices attributes
+ *
+ *******************************************/
+struct aw_device;
+
+struct aw_device_ops {
+	int (*pwr_on_func)(struct aw_device *aw_dev, struct aw_data_container *data);
+	int (*pwr_off_func)(struct aw_device *aw_dev, struct aw_data_container *data);
+};
+
+enum aw_dev_chipid {
+	AW_DEV_CHIPID_18 = 0x18,
+	AW_DEV_CHIPID_39 = 0x39,
+	AW_DEV_CHIPID_59 = 0x59,
+	AW_DEV_CHIPID_69 = 0x69,
+	AW_DEV_CHIPID_5A = 0x5A,
+	AW_DEV_CHIPID_9A = 0x9A,
+	AW_DEV_CHIPID_9B = 0x9B,
+	AW_DEV_CHIPID_76 = 0x76,
+	AW_DEV_CHIPID_60 = 0x60,
+};
+
+enum aw_dev_hw_status {
+	AW_DEV_HWEN_OFF = 0,
+	AW_DEV_HWEN_ON,
+	AW_DEV_HWEN_INVALID,
+	AW_DEV_HWEN_STATUS_MAX,
+};
+
+enum aw_dev_soft_off_enable {
+	AW_DEV_SOFT_OFF_DISENABLE = 0,
+	AW_DEV_SOFT_OFF_ENABLE = 1,
+};
+
+enum aw_dev_soft_rst_enable {
+	AW_DEV_SOFT_RST_DISENABLE = 0,
+	AW_DEV_SOFT_RST_ENABLE = 1,
+};
+
+enum aw_reg_receiver_mode {
+	AW_NOT_REC_MODE = 0,
+	AW_IS_REC_MODE = 1,
+};
+
+struct aw_mute_desc {
+	uint8_t addr;
+	uint8_t enable;
+	uint8_t disable;
+	uint16_t mask;
+};
+
+struct aw_soft_rst_desc {
+	int len;
+	unsigned char *access;
+};
+
+struct aw_esd_check_desc {
+	uint8_t first_update_reg_addr;
+	uint8_t first_update_reg_val;
+};
+
+struct aw_rec_mode_desc {
+	uint8_t addr;
+	uint8_t enable;
+	uint8_t disable;
+	uint8_t mask;
+};
+
+struct aw_device {
+	uint8_t i2c_addr;
+	uint8_t chipid;
+	uint8_t soft_rst_enable;
+	uint8_t soft_off_enable;
+	uint8_t is_rec_mode;
+	int hwen_status;
+	int i2c_bus;
+	int rst_gpio;
+	int reg_max_addr;
+	int product_cnt;
+	const char **product_tab;
+	const unsigned char *reg_access;
+
+	struct device *dev;
+	struct i2c_client *i2c;
+	struct aw_mute_desc mute_desc;
+	struct aw_soft_rst_desc soft_rst_desc;
+	struct aw_esd_check_desc esd_desc;
+	struct aw_rec_mode_desc rec_desc;
+
+	struct aw_device_ops ops;
+};
+
+
+int aw87xxx_dev_i2c_write_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t reg_data);
+int aw87xxx_dev_i2c_read_byte(struct aw_device *aw_dev,
+			uint8_t reg_addr, uint8_t *reg_data);
+int aw87xxx_dev_i2c_read_msg(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t *data_buf, uint32_t data_len);
+int aw87xxx_dev_i2c_write_bits(struct aw_device *aw_dev,
+	uint8_t reg_addr, uint8_t mask, uint8_t reg_data);
+void aw87xxx_dev_soft_reset(struct aw_device *aw_dev);
+void aw87xxx_dev_hw_pwr_ctrl(struct aw_device *aw_dev, bool enable);
+int aw87xxx_dev_default_pwr_on(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data);
+int aw87xxx_dev_default_pwr_off(struct aw_device *aw_dev,
+			struct aw_data_container *profile_data);
+int aw87xxx_dev_esd_reg_status_check(struct aw_device *aw_dev);
+int aw87xxx_dev_check_reg_is_rec_mode(struct aw_device *aw_dev);
+int aw87xxx_dev_init(struct aw_device *aw_dev);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
new file mode 100644
index 000000000000..93b02e30122d
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.c
@@ -0,0 +1,355 @@
+/*
+ * aw87xxx_dsp.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/hrtimer.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include "aw87xxx_log.h"
+#include "aw87xxx_dsp.h"
+
+static DEFINE_MUTEX(g_dsp_lock);
+static unsigned int g_spin_value = 0;
+
+static int g_rx_topo_id = AW_RX_DEFAULT_TOPO_ID;
+static int g_rx_port_id = AW_RX_DEFAULT_PORT_ID;
+
+#ifdef AW_MTK_OPEN_DSP_PLATFORM
+extern int mtk_spk_send_ipi_buf_to_dsp(void *data_buffer,
+				uint32_t data_size);
+extern int mtk_spk_recv_ipi_buf_from_dsp(int8_t *buffer,
+				int16_t size, uint32_t *buf_len);
+/*
+static int mtk_spk_send_ipi_buf_to_dsp(void *data_buffer,
+				uint32_t data_size)
+{
+	AW_LOGI("enter");
+	return 0;
+}
+
+static int mtk_spk_recv_ipi_buf_from_dsp(int8_t *buffer,
+				int16_t size, uint32_t *buf_len)
+{
+	AW_LOGI("enter");
+	return 0;
+}
+*/
+#elif defined AW_QCOM_OPEN_DSP_PLATFORM
+extern int afe_get_topology(int port_id);
+extern int aw_send_afe_cal_apr(uint32_t param_id,
+	void *buf, int cmd_size, bool write);
+/*
+static int afe_get_topology(int port_id)
+{
+	return -EPERM;
+}
+
+static int aw_send_afe_cal_apr(uint32_t param_id,
+	void *buf, int cmd_size, bool write)
+{
+	AW_LOGI("enter, no define AWINIC_ADSP_ENABLE", __func__);
+	return 0;
+}
+*/
+#endif
+
+#ifdef AW_QCOM_OPEN_DSP_PLATFORM
+extern void aw_set_port_id(int rx_port_id);
+#else
+static void aw_set_port_id(int rx_port_id)
+{
+	return;
+}
+#endif
+
+uint8_t aw87xxx_dsp_isEnable(void)
+{
+#if (defined AW_QCOM_OPEN_DSP_PLATFORM) || (defined AW_MTK_OPEN_DSP_PLATFORM)
+	return true;
+#else
+	return false;
+#endif
+}
+
+/*****************mtk dsp communication function start**********************/
+#ifdef AW_MTK_OPEN_DSP_PLATFORM
+static int aw_mtk_write_data_to_dsp(int32_t param_id,
+			void *data, int size)
+{
+	int32_t *dsp_data = NULL;
+	mtk_dsp_hdr_t *hdr = NULL;
+	int ret;
+
+	dsp_data = kzalloc(sizeof(mtk_dsp_hdr_t) + size, GFP_KERNEL);
+	if (!dsp_data) {
+		AW_LOGE("kzalloc dsp_msg error");
+		return -ENOMEM;
+	}
+
+	hdr = (mtk_dsp_hdr_t *)dsp_data;
+	hdr->type = DSP_MSG_TYPE_DATA;
+	hdr->opcode_id = param_id;
+	hdr->version = AW_DSP_MSG_HDR_VER;
+
+	memcpy(((char *)dsp_data) + sizeof(mtk_dsp_hdr_t),
+		data, size);
+
+	ret = mtk_spk_send_ipi_buf_to_dsp(dsp_data,
+				sizeof(mtk_dsp_hdr_t) + size);
+	if (ret < 0) {
+		AW_LOGE("write data failed");
+		kfree(dsp_data);
+		dsp_data = NULL;
+		return ret;
+	}
+
+	kfree(dsp_data);
+	dsp_data = NULL;
+	return 0;
+}
+
+static int aw_mtk_read_data_from_dsp(int32_t param_id, void *data,
+					int data_size)
+{
+	int ret;
+	mtk_dsp_hdr_t hdr;
+
+	mutex_lock(&g_dsp_lock);
+	hdr.type = DSP_MSG_TYPE_CMD;
+	hdr.opcode_id = param_id;
+	hdr.version = AW_DSP_MSG_HDR_VER;
+
+	ret = mtk_spk_send_ipi_buf_to_dsp(&hdr, sizeof(mtk_dsp_hdr_t));
+	if (ret < 0)
+		goto failed;
+
+	ret = mtk_spk_recv_ipi_buf_from_dsp(data, data_size, &data_size);
+	if (ret < 0)
+		goto failed;
+
+	mutex_unlock(&g_dsp_lock);
+	return 0;
+
+failed:
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+#endif
+/********************mtk dsp communication function end***********************/
+
+/******************qcom dsp communication function start**********************/
+#ifdef AW_QCOM_OPEN_DSP_PLATFORM
+static void aw_check_dsp_ready(void)
+{
+	int ret;
+
+	ret = afe_get_topology(g_rx_port_id);
+	AW_LOGD("topo_id 0x%x", ret);
+
+	if (ret != g_rx_topo_id)
+		AW_LOGE("topo id 0x%x", ret);
+
+}
+
+static int aw_qcom_write_data_to_dsp(int32_t param_id,
+				void *data, int data_size)
+{
+	int ret = 0;
+
+	AW_LOGI("enter");
+	mutex_lock(&g_dsp_lock);
+	aw_check_dsp_ready();
+	ret = aw_send_afe_cal_apr(param_id, data,
+		data_size, true);
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+static int aw_qcom_read_data_from_dsp(int32_t param_id,
+				void *data, int data_size)
+{
+	int ret = 0;
+
+	AW_LOGI("enter");
+	mutex_lock(&g_dsp_lock);
+	aw_check_dsp_ready();
+	ret = aw_send_afe_cal_apr(param_id, data,
+			data_size, false);
+	mutex_unlock(&g_dsp_lock);
+	return ret;
+}
+
+#endif
+/*****************qcom dsp communication function end*********************/
+
+/*****************read/write msg communication function*********************/
+static int aw_write_data_to_dsp(int32_t param_id, void *data, int data_size)
+{
+#if defined AW_QCOM_OPEN_DSP_PLATFORM
+	return aw_qcom_write_data_to_dsp(param_id, data, data_size);
+#elif defined AW_MTK_OPEN_DSP_PLATFORM
+	return aw_mtk_write_data_to_dsp(param_id, data, data_size);
+#else
+	return -EINVAL;
+#endif
+}
+
+static int aw_read_data_from_dsp(int32_t param_id, void *data, int data_size)
+{
+#if defined AW_QCOM_OPEN_DSP_PLATFORM
+	return aw_qcom_read_data_from_dsp(param_id, data, data_size);
+#elif defined AW_MTK_OPEN_DSP_PLATFORM
+	return aw_mtk_read_data_from_dsp(param_id, data, data_size);
+#else
+	return -EINVAL;
+#endif
+}
+
+/***************read/write msg communication function end*******************/
+
+int aw87xxx_dsp_get_rx_module_enable(int *enable)
+{
+	if (!enable) {
+		AW_LOGE("enable is NULL");
+		return -EINVAL;
+	}
+
+	return aw_read_data_from_dsp(AWDSP_RX_SET_ENABLE,
+			(void *)enable, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_rx_module_enable(int enable)
+{
+	switch (enable) {
+	case AW_RX_MODULE_DISENABLE:
+		AW_LOGD("set enable=%d", enable);
+		break;
+	case AW_RX_MODULE_ENABLE:
+		AW_LOGD("set enable=%d", enable);
+		break;
+	default:
+		AW_LOGE("unsupport enable=%d", enable);
+		return -EINVAL;
+	}
+
+	return aw_write_data_to_dsp(AWDSP_RX_SET_ENABLE,
+			&enable, sizeof(uint32_t));
+}
+
+
+int aw87xxx_dsp_get_vmax(uint32_t *vmax, int dev_index)
+{
+	int32_t param_id = 0;
+
+	switch (dev_index % AW_DSP_CHANNEL_MAX) {
+	case AW_DSP_CHANNEL_0:
+		param_id = AWDSP_RX_VMAX_0;
+		break;
+	case AW_DSP_CHANNEL_1:
+		param_id = AWDSP_RX_VMAX_1;
+		break;
+	default:
+		AW_LOGE("algo only support double PA channel:%d unsupport",
+			dev_index);
+		return -EINVAL;
+	}
+
+	return aw_read_data_from_dsp(param_id,
+			(void *)vmax, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_vmax(uint32_t vmax, int dev_index)
+{
+	int32_t param_id = 0;
+
+	switch (dev_index % AW_DSP_CHANNEL_MAX) {
+	case AW_DSP_CHANNEL_0:
+		param_id = AWDSP_RX_VMAX_0;
+		break;
+	case AW_DSP_CHANNEL_1:
+		param_id = AWDSP_RX_VMAX_1;
+		break;
+	default:
+		AW_LOGE("algo only support double PA channel:%d unsupport",
+			dev_index);
+		return -EINVAL;
+	}
+
+	return aw_write_data_to_dsp(param_id, &vmax, sizeof(uint32_t));
+}
+
+int aw87xxx_dsp_set_spin(uint32_t ctrl_value)
+{
+	int ret = 0;
+
+	if (ctrl_value >= AW_SPIN_MAX) {
+		AW_LOGE("spin [%d] unsupported ", ctrl_value);
+		return -EINVAL;
+	}
+	ret = aw_write_data_to_dsp(AW_MSG_ID_SPIN, &ctrl_value,
+		sizeof(uint32_t));
+	if (ret) {
+		AW_LOGE("spin [%d] set failed ", ctrl_value);
+		return ret;
+	}
+
+	g_spin_value = ctrl_value;
+	return 0;
+}
+
+int aw87xxx_dsp_get_spin(void)
+{
+	return g_spin_value;
+}
+
+int aw87xxx_spin_set_record_val(void)
+{
+	AW_LOGD("record write spin enter");
+
+	return aw87xxx_dsp_set_spin(g_spin_value);
+}
+EXPORT_SYMBOL(aw87xxx_spin_set_record_val);
+
+void aw87xxx_device_parse_topo_id_dt(struct aw_device *aw_dev)
+{
+	int ret;
+
+	ret = of_property_read_u32(aw_dev->dev->of_node, "aw-rx-topo-id", &g_rx_topo_id);
+	if (ret < 0) {
+		g_rx_topo_id = AW_RX_DEFAULT_TOPO_ID;
+		AW_DEV_LOGI(aw_dev->dev, "read aw-rx-topo-id failed,use default");
+	}
+
+	AW_DEV_LOGI(aw_dev->dev, "rx-topo-id: 0x%x",  g_rx_topo_id);
+}
+
+void aw87xxx_device_parse_port_id_dt(struct aw_device *aw_dev)
+{
+	int ret;
+
+	ret = of_property_read_u32(aw_dev->dev->of_node, "aw-rx-port-id", &g_rx_port_id);
+	if (ret < 0) {
+		g_rx_port_id = AW_RX_DEFAULT_PORT_ID;
+		AW_DEV_LOGI(aw_dev->dev, "read aw-rx-port-id failed,use default");
+	}
+
+	aw_set_port_id(g_rx_port_id);
+	AW_DEV_LOGI(aw_dev->dev, "rx-port-id: 0x%x", g_rx_port_id);
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
new file mode 100644
index 000000000000..7acc4dc0dfd9
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_dsp.h
@@ -0,0 +1,65 @@
+#ifndef __AW87XXX_DSP_H__
+#define __AW87XXX_DSP_H__
+
+#include "aw87xxx_device.h"
+
+/*#define AW_MTK_OPEN_DSP_PLATFORM*/
+/*#define AW_QCOM_OPEN_DSP_PLATFORM*/
+
+/*Note: The pord_ID is configured according to different platforms*/
+#define AW_DSP_SLEEP_TIME	(10)
+
+#define AW_DSP_MSG_HDR_VER (1)
+
+#define AW_RX_DEFAULT_TOPO_ID		(0x1000FF01)
+#define AW_RX_DEFAULT_PORT_ID		(0x4000)
+
+#define AWDSP_RX_SET_ENABLE		(0x10013D11)
+#define AWDSP_RX_PARAMS			(0x10013D12)
+#define AWDSP_RX_VMAX_0			(0X10013D17)
+#define AWDSP_RX_VMAX_1			(0X10013D18)
+#define AW_MSG_ID_SPIN 			(0x10013D2E)
+
+enum {
+	AW_SPIN_0 = 0,
+	AW_SPIN_90,
+	AW_SPIN_180,
+	AW_SPIN_270,
+	AW_SPIN_MAX,
+};
+
+typedef struct mtk_dsp_msg_header {
+	int32_t type;
+	int32_t opcode_id;
+	int32_t version;
+	int32_t reserver[3];
+} mtk_dsp_hdr_t;
+
+enum aw_rx_module_enable {
+	AW_RX_MODULE_DISENABLE = 0,
+	AW_RX_MODULE_ENABLE,
+};
+
+enum aw_dsp_msg_type {
+	DSP_MSG_TYPE_DATA = 0,
+	DSP_MSG_TYPE_CMD = 1,
+};
+
+enum aw_dsp_channel {
+	AW_DSP_CHANNEL_0 = 0,
+	AW_DSP_CHANNEL_1,
+	AW_DSP_CHANNEL_MAX,
+};
+
+uint8_t aw87xxx_dsp_isEnable(void);
+int aw87xxx_dsp_get_rx_module_enable(int *enable);
+int aw87xxx_dsp_set_rx_module_enable(int enable);
+int aw87xxx_dsp_get_vmax(uint32_t *vmax, int channel);
+int aw87xxx_dsp_set_vmax(uint32_t vmax, int channel);
+int aw87xxx_dsp_set_spin(uint32_t ctrl_value);
+int aw87xxx_dsp_get_spin(void);
+int aw87xxx_spin_set_record_val(void);
+void aw87xxx_device_parse_port_id_dt(struct aw_device *aw_dev);
+void aw87xxx_device_parse_topo_id_dt(struct aw_device *aw_dev);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_log.h b/sound/soc/codecs/aw87xxx/aw87xxx_log.h
new file mode 100644
index 000000000000..b3bde38a23c6
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_log.h
@@ -0,0 +1,33 @@
+#ifndef __AW87XXX_LOG_H__
+#define __AW87XXX_LOG_H__
+
+#include <linux/kernel.h>
+
+
+/********************************************
+ *
+ * print information control
+ *
+ *******************************************/
+#define AW_LOGI(fmt, ...)\
+	pr_info("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+#define AW_LOGD(fmt, ...)\
+	pr_debug("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+#define AW_LOGE(fmt, ...)\
+	pr_err("[Awinic] %s:" fmt "\n", __func__, ##__VA_ARGS__)
+
+
+#define AW_DEV_LOGI(dev, fmt, ...)\
+	pr_info("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+#define AW_DEV_LOGD(dev, fmt, ...)\
+	pr_debug("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+#define AW_DEV_LOGE(dev, fmt, ...)\
+	pr_err("[Awinic] [%s]%s: " fmt "\n", dev_name(dev), __func__, ##__VA_ARGS__)
+
+
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
new file mode 100644
index 000000000000..f580506b2786
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.c
@@ -0,0 +1,1208 @@
+/*
+ * aw87xxx_monitor.c
+ *
+ * Copyright (c) 2021 AWINIC Technology CO., LTD
+ *
+ * Author: Barry <zhaozhongbo@awinic.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/power_supply.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/gameport.h>
+#include <linux/moduleparam.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include "aw87xxx.h"
+#include "aw87xxx_log.h"
+#include "aw87xxx_monitor.h"
+#include "aw87xxx_dsp.h"
+#include "aw87xxx_bin_parse.h"
+#include "aw87xxx_device.h"
+
+#define AW_MONITOT_BIN_PARSE_VERSION	"V0.1.0"
+
+#define AW_GET_32_DATA(w, x, y, z) \
+	((uint32_t)((((uint8_t)w) << 24) | (((uint8_t)x) << 16) | \
+	(((uint8_t)y) << 8) | ((uint8_t)z)))
+
+/****************************************************************************
+ *
+ * aw87xxx monitor bin check
+ *
+ ****************************************************************************/
+static int aw_monitor_check_header_v_1_0_0(struct device *dev,
+				char *data, uint32_t data_len)
+{
+	int i = 0;
+	struct aw_bin_header *header = (struct aw_bin_header *)data;
+
+	if (header->bin_data_type != DATA_TYPE_MONITOR_ANALOG) {
+		AW_DEV_LOGE(dev, "monitor data_type check error!");
+		return -EINVAL;
+	}
+
+	if (header->bin_data_size != AW_MONITOR_HDR_DATA_SIZE) {
+		AW_DEV_LOGE(dev, "monitor data_size error!");
+		return -EINVAL;
+	}
+
+	if (header->data_byte_len != AW_MONITOR_HDR_DATA_BYTE_LEN) {
+		AW_DEV_LOGE(dev, "monitor data_byte_len error!");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < AW_MONITOR_DATA_VER_MAX; i++) {
+		if (header->bin_data_ver == i) {
+			AW_LOGD("monitor bin_data_ver[0x%x]", i);
+			break;
+		}
+	}
+	if (i == AW_MONITOR_DATA_VER_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int aw_monitor_check_data_v1_size(struct device *dev,
+				char *data, int32_t data_len)
+{
+	int32_t bin_header_len  = sizeof(struct aw_bin_header);
+	int32_t monitor_header_len = sizeof(struct aw_monitor_header);
+	int32_t monitor_data_len = sizeof(struct vmax_step_config);
+	int32_t len = 0;
+	struct aw_monitor_header *monitor_header = NULL;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (data_len < bin_header_len + monitor_header_len) {
+		AW_DEV_LOGE(dev, "bin len is less than aw_bin_header and monitoor_header,check failed");
+		return -EINVAL;
+	}
+
+	monitor_header = (struct aw_monitor_header *)(data + bin_header_len);
+	len = data_len - bin_header_len - monitor_header_len;
+	if (len < monitor_header->step_count * monitor_data_len) {
+		AW_DEV_LOGE(dev, "bin data len is not enough,check failed");
+		return -EINVAL;
+	}
+
+	AW_DEV_LOGD(dev, "succeed");
+
+	return 0;
+}
+
+static int aw_monitor_check_data_size(struct device *dev,
+			char *data, int32_t data_len)
+{
+	int ret = -1;
+	struct aw_bin_header *header = (struct aw_bin_header *)data;
+
+	switch (header->bin_data_ver) {
+	case AW_MONITOR_DATA_VER:
+		ret = aw_monitor_check_data_v1_size(dev, data, data_len);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		AW_DEV_LOGE(dev, "bin data_ver[0x%x] non support",
+			header->bin_data_ver);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int aw_monitor_check_bin_header(struct device *dev,
+				char *data, int32_t data_len)
+{
+	int ret = -1;
+	struct aw_bin_header *header = NULL;
+
+	if (data_len < sizeof(struct aw_bin_header)) {
+		AW_DEV_LOGE(dev, "bin len is less than aw_bin_header,check failed");
+		return -EINVAL;
+	}
+	header = (struct aw_bin_header *)data;
+
+	switch (header->header_ver) {
+	case HEADER_VERSION_1_0_0:
+		ret = aw_monitor_check_header_v_1_0_0(dev, data, data_len);
+		if (ret < 0) {
+			AW_DEV_LOGE(dev, "monitor bin haeder info check error!");
+			return ret;
+		}
+		break;
+	default:
+		AW_DEV_LOGE(dev, "bin version[0x%x] non support",
+			header->header_ver);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int aw_monitor_bin_check_sum(struct device *dev,
+			char *data, int32_t data_len)
+{
+	int i, data_sum = 0;
+	uint32_t *check_sum = (uint32_t *)data;
+
+	for (i = 4; i < data_len; i++)
+		data_sum += data[i];
+
+	if (*check_sum != data_sum) {
+		AW_DEV_LOGE(dev, "check_sum[%d] is not equal to data_sum[%d]",
+				*check_sum, data_sum);
+		return -ENOMEM;
+	}
+
+	AW_DEV_LOGD(dev, "succeed");
+
+	return 0;
+}
+
+static int aw_monitor_bin_check(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+
+	if (monitor_data == NULL || data_len == 0) {
+		AW_DEV_LOGE(dev, "none data to parse");
+		return -EINVAL;
+	}
+
+	ret = aw_monitor_bin_check_sum(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin data check sum failed");
+		return ret;
+	}
+
+	ret = aw_monitor_check_bin_header(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin data len check failed");
+		return ret;
+	}
+
+	ret = aw_monitor_check_data_size(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "bin header info check failed");
+		return ret;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************
+ *
+ * aw87xxx monitor header bin parse
+ *
+ *****************************************************************************/
+static void aw_monitor_write_to_table_v1(struct device *dev,
+			struct vmax_step_config *vmax_step,
+			char *vmax_data, uint32_t step_count)
+{
+	int i = 0;
+	int index = 0;
+	int vmax_step_size = (int)sizeof(struct vmax_step_config);
+
+	for (i = 0; i < step_count; i++) {
+		index = vmax_step_size * i;
+		vmax_step[i].vbat_min =
+			AW_GET_32_DATA(vmax_data[index + 3],
+					vmax_data[index + 2],
+					vmax_data[index + 1],
+					vmax_data[index + 0]);
+		vmax_step[i].vbat_max =
+			AW_GET_32_DATA(vmax_data[index + 7],
+					vmax_data[index + 6],
+					vmax_data[index + 5],
+					vmax_data[index + 4]);
+		vmax_step[i].vmax_vol =
+			AW_GET_32_DATA(vmax_data[index + 11],
+					vmax_data[index + 10],
+					vmax_data[index + 9],
+					vmax_data[index + 8]);
+	}
+
+	for (i = 0; i < step_count; i++)
+		AW_DEV_LOGI(dev, "vbat_min:%d, vbat_max%d, vmax_vol:0x%x",
+			vmax_step[i].vbat_min,
+			vmax_step[i].vbat_max,
+			vmax_step[i].vmax_vol);
+}
+
+static int aw_monitor_parse_vol_data_v1(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	uint32_t step_count = 0;
+	char *vmax_data = NULL;
+	struct vmax_step_config *vmax_step = NULL;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	step_count = monitor->monitor_hdr.step_count;
+	if (step_count) {
+		vmax_step = devm_kzalloc(dev, sizeof(struct vmax_step_config) * step_count,
+					GFP_KERNEL);
+		if (vmax_step == NULL) {
+			AW_DEV_LOGE(dev, "vmax_cfg vmalloc failed");
+			return -ENOMEM;
+		}
+		memset(vmax_step, 0,
+			sizeof(struct vmax_step_config) * step_count);
+	}
+
+	vmax_data = monitor_data + sizeof(struct aw_bin_header) +
+		sizeof(struct aw_monitor_header);
+	aw_monitor_write_to_table_v1(dev, vmax_step, vmax_data, step_count);
+	monitor->vmax_cfg = vmax_step;
+
+	AW_DEV_LOGI(dev, "vmax_data parse succeed");
+
+	return 0;
+}
+
+static int aw_monitor_parse_data_v1(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	int ret = -1;
+	int header_len = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	header_len = sizeof(struct aw_bin_header);
+	memcpy(monitor_hdr, monitor_data + header_len,
+		sizeof(struct aw_monitor_header));
+
+	AW_DEV_LOGI(dev, "monitor_switch:%d, monitor_time:%d (ms), monitor_count:%d, step_count:%d",
+		monitor_hdr->monitor_switch, monitor_hdr->monitor_time,
+		monitor_hdr->monitor_count, monitor_hdr->step_count);
+
+	ret = aw_monitor_parse_vol_data_v1(dev, monitor, monitor_data);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "vmax_data parse failed");
+		return ret;
+	}
+
+	monitor->bin_status = AW_MONITOR_CFG_OK;
+
+	return 0;
+}
+
+
+static int aw_monitor_parse_v_1_0_0(struct device *dev,
+			struct aw_monitor *monitor, char *monitor_data)
+{
+	int ret = -1;
+	struct aw_bin_header *header = (struct aw_bin_header *)monitor_data;
+
+	switch (header->bin_data_ver) {
+	case AW_MONITOR_DATA_VER:
+		ret = aw_monitor_parse_data_v1(dev, monitor, monitor_data);
+		if (ret < 0)
+			return ret;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void aw87xxx_monitor_cfg_free(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	monitor->bin_status = AW_MONITOR_CFG_WAIT;
+	memset(&monitor->monitor_hdr, 0,
+		sizeof(struct aw_monitor_header));
+	if (monitor->vmax_cfg) {
+		devm_kfree(aw87xxx->dev, monitor->vmax_cfg);
+		monitor->vmax_cfg = NULL;
+	}
+}
+
+int aw87xxx_monitor_bin_parse(struct device *dev,
+				char *monitor_data, uint32_t data_len)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = NULL;
+	struct aw_bin_header *bin_header = NULL;
+
+	if (aw87xxx == NULL) {
+		AW_DEV_LOGE(dev, "get struct aw87xxx failed");
+		return -EINVAL;
+	}
+
+	monitor = &aw87xxx->monitor;
+	monitor->bin_status = AW_MONITOR_CFG_WAIT;
+
+	AW_DEV_LOGI(dev, "monitor bin parse version: %s",
+			AW_MONITOT_BIN_PARSE_VERSION);
+
+	ret = aw_monitor_bin_check(dev, monitor_data, data_len);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "monitor bin check failed");
+		return ret;
+	}
+
+	bin_header = (struct aw_bin_header *)monitor_data;
+	switch (bin_header->bin_data_ver) {
+	case DATA_VERSION_V1:
+		ret = aw_monitor_parse_v_1_0_0(dev, monitor,
+				monitor_data);
+		if (ret < 0) {
+			aw87xxx_monitor_cfg_free(monitor);
+			return ret;
+		}
+		break;
+	default:
+		AW_DEV_LOGE(dev, "Unrecognized this bin data version[0x%x]",
+			bin_header->bin_data_ver);
+	}
+
+	return 0;
+}
+
+/***************************************************************************
+ *
+ * aw87xxx monitor get adjustment vmax of power
+ *
+ ***************************************************************************/
+static int aw_monitor_get_battery_capacity(struct device *dev,
+				struct aw_monitor *monitor, int *vbat_capacity)
+{
+	char name[] = "battery";
+	int ret = -1;
+	union power_supply_propval prop = { 0 };
+	struct power_supply *psy = NULL;
+
+	psy = power_supply_get_by_name(name);
+	if (psy == NULL) {
+		AW_DEV_LOGE(dev, "no struct power supply name:%s", name);
+		return -EINVAL;
+	}
+
+	ret = power_supply_get_property(psy, POWER_SUPPLY_PROP_CAPACITY, &prop);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "get vbat capacity failed");
+		return -EINVAL;
+	}
+	*vbat_capacity = prop.intval;
+	AW_DEV_LOGI(dev, "The percentage is %d",
+		*vbat_capacity);
+
+	return 0;
+}
+
+static int aw_search_vmax_from_table(struct device *dev,
+				struct aw_monitor *monitor,
+				const int vbat_vol, int *vmax_vol)
+{
+	int i = 0;
+	int vmax_set = 0;
+	uint32_t vmax_flag = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+	struct vmax_step_config *vmax_cfg = monitor->vmax_cfg;
+
+	if (monitor->bin_status == AW_MONITOR_CFG_WAIT) {
+		AW_DEV_LOGE(dev, "vmax_cfg not loaded or parse failed");
+		return -ENODATA;
+	}
+
+	for (i = 0; i < monitor_hdr->step_count; i++) {
+		if (vbat_vol == AW_VBAT_MAX) {
+			vmax_set = AW_VMAX_MAX;
+			vmax_flag = 1;
+			AW_DEV_LOGD(dev, "vbat=%d, setting vmax=0x%x",
+				vbat_vol, vmax_set);
+			break;
+		}
+
+		if (vbat_vol >= vmax_cfg[i].vbat_min &&
+			vbat_vol < vmax_cfg[i].vbat_max) {
+			vmax_set = vmax_cfg[i].vmax_vol;
+			vmax_flag = 1;
+			AW_DEV_LOGD(dev, "read setting vmax=0x%x, step[%d]: vbat_min=%d,vbat_max=%d",
+				vmax_set, i,
+				vmax_cfg[i].vbat_min,
+				vmax_cfg[i].vbat_max);
+			break;
+		}
+	}
+
+	if (!vmax_flag) {
+		AW_DEV_LOGE(dev, "vmax_cfg not found");
+		return -ENODATA;
+	}
+
+	*vmax_vol = vmax_set;
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ *monitor_esd_func
+ *
+ ***************************************************************************/
+static int aw_chip_status_recover(struct aw87xxx *aw87xxx)
+{
+	int ret = -1;
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	char *profile = aw87xxx->current_profile;
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+
+	ret = aw87xxx_update_profile_esd(aw87xxx, profile);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "load profile[%s] failed ",
+			profile);
+		return ret;
+	}
+
+	AW_DEV_LOGI(aw87xxx->dev, "current prof[%s], dev_index[%d] ",
+			profile, aw87xxx->dev_index);
+
+	monitor->pre_vmax = AW_VMAX_INIT_VAL;
+	monitor->first_entry = AW_FIRST_ENTRY;
+	monitor->timer_cnt = 0;
+	monitor->vbat_sum = 0;
+
+	return 0;
+}
+
+static int aw_monitor_chip_esd_check_work(struct aw87xxx *aw87xxx)
+{
+	int ret = 0;
+	int i = 0;
+
+	for (i = 0; i < REG_STATUS_CHECK_MAX; i++) {
+		AW_DEV_LOGD(aw87xxx->dev, "reg_status_check[%d]", i);
+
+		ret = aw87xxx_dev_esd_reg_status_check(&aw87xxx->aw_dev);
+		if (ret < 0) {
+			aw_chip_status_recover(aw87xxx);
+		} else {
+			AW_DEV_LOGD(aw87xxx->dev, "chip status check succeed");
+			break;
+		}
+		msleep(AW_ESD_CHECK_DELAY);
+	}
+
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "chip status recover failed,chip off");
+		aw87xxx_update_profile_esd(aw87xxx, aw87xxx->prof_off_name);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ * aw87xxx monitor work with dsp
+ *
+ ***************************************************************************/
+static int aw_monitor_update_vmax_to_dsp(struct device *dev,
+				struct aw_monitor *monitor, int vmax_set)
+{
+	int ret = -1;
+	uint32_t enable = 0;
+
+	if (monitor->pre_vmax != vmax_set) {
+		ret = aw87xxx_dsp_get_rx_module_enable(&enable);
+		if (!enable || ret < 0) {
+			AW_DEV_LOGE(dev, "get rx failed or rx disable, ret=%d, enable=%d",
+				ret, enable);
+			return -EPERM;
+		}
+
+		ret = aw87xxx_dsp_set_vmax(vmax_set, monitor->dev_index);
+		if (ret) {
+			AW_DEV_LOGE(dev, "set dsp msg fail, ret=%d", ret);
+			return ret;
+		}
+
+		AW_DEV_LOGI(dev, "set dsp vmax=0x%x sucess", vmax_set);
+		monitor->pre_vmax = vmax_set;
+	} else {
+		AW_DEV_LOGI(dev, "vmax=0x%x no change", vmax_set);
+	}
+
+	return 0;
+}
+
+static void aw_monitor_with_dsp_vmax_work(struct device *dev,
+					struct aw_monitor *monitor)
+{
+	int ret = -1;
+	int vmax_set = 0;
+	int vbat_capacity = 0;
+	int ave_capacity = 0;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGD(dev, "enter with dsp monitor");
+
+	ret = aw_monitor_get_battery_capacity(dev, monitor, &vbat_capacity);
+	if (ret < 0)
+		return;
+
+	if (monitor->timer_cnt < monitor_hdr->monitor_count) {
+		monitor->timer_cnt++;
+		monitor->vbat_sum += vbat_capacity;
+			AW_DEV_LOGI(dev, "timer_cnt = %d",
+			monitor->timer_cnt);
+	}
+	if ((monitor->timer_cnt >= monitor_hdr->monitor_count) ||
+	    (monitor->first_entry == AW_FIRST_ENTRY)) {
+		if (monitor->first_entry == AW_FIRST_ENTRY)
+			monitor->first_entry = AW_NOT_FIRST_ENTRY;
+		ave_capacity = monitor->vbat_sum / monitor->timer_cnt;
+
+		if (monitor->custom_capacity)
+			ave_capacity = monitor->custom_capacity;
+
+		AW_DEV_LOGI(dev, "get average capacity = %d", ave_capacity);
+
+		ret = aw_search_vmax_from_table(dev, monitor,
+				ave_capacity, &vmax_set);
+		if (ret < 0)
+			AW_DEV_LOGE(dev, "not find vmax_vol");
+		else
+			aw_monitor_update_vmax_to_dsp(dev, monitor, vmax_set);
+
+		monitor->timer_cnt = 0;
+		monitor->vbat_sum = 0;
+	}
+}
+
+static void aw_monitor_work_func(struct work_struct *work)
+{
+	int ret = 0;
+	struct aw87xxx *aw87xxx = container_of(work,
+				struct aw87xxx, monitor.with_dsp_work.work);
+	struct device *dev = aw87xxx->dev;
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGD(dev, "enter");
+
+	if (monitor->esd_enable) {
+		ret = aw_monitor_chip_esd_check_work(aw87xxx);
+		if (ret < 0)
+			return;
+	}
+
+	if (monitor_hdr->monitor_switch && !(aw87xxx->aw_dev.is_rec_mode) &&
+		monitor->open_dsp_en && monitor->bin_status == AW_ACF_UPDATE) {
+		AW_DEV_LOGD(dev, "start low power protection");
+		aw_monitor_with_dsp_vmax_work(dev, monitor);
+	}
+
+	if (monitor->esd_enable || (monitor_hdr->monitor_switch &&
+		!(aw87xxx->aw_dev.is_rec_mode) && monitor->open_dsp_en &&
+		monitor->bin_status == AW_ACF_UPDATE)) {
+		schedule_delayed_work(&monitor->with_dsp_work,
+			msecs_to_jiffies(monitor_hdr->monitor_time));
+	}
+}
+
+void aw87xxx_monitor_stop(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	AW_DEV_LOGD(aw87xxx->dev, "enter");
+	cancel_delayed_work_sync(&monitor->with_dsp_work);
+}
+
+void aw87xxx_monitor_start(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	int ret = 0;
+
+	ret = aw87xxx_dev_check_reg_is_rec_mode(&aw87xxx->aw_dev);
+	if (ret < 0) {
+		AW_DEV_LOGE(aw87xxx->dev, "get reg current mode failed");
+		return;
+	}
+
+	if (monitor->esd_enable || (monitor->monitor_hdr.monitor_switch &&
+			!(aw87xxx->aw_dev.is_rec_mode) && monitor->open_dsp_en
+			&& monitor->bin_status == AW_ACF_UPDATE)) {
+
+		AW_DEV_LOGD(aw87xxx->dev, "enter");
+		monitor->pre_vmax = AW_VMAX_INIT_VAL;
+		monitor->first_entry = AW_FIRST_ENTRY;
+		monitor->timer_cnt = 0;
+		monitor->vbat_sum = 0;
+
+		schedule_delayed_work(&monitor->with_dsp_work,
+				msecs_to_jiffies(monitor->monitor_hdr.monitor_time));
+	}
+}
+/***************************************************************************
+ *
+ * aw87xxx no dsp monitor func
+ *
+ ***************************************************************************/
+int aw87xxx_monitor_no_dsp_get_vmax(struct aw_monitor *monitor, int32_t *vmax)
+{
+	int vbat_capacity = 0;
+	int ret = -1;
+	int vmax_vol = 0;
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	struct device *dev = aw87xxx->dev;
+
+	ret = aw_monitor_get_battery_capacity(dev, monitor, &vbat_capacity);
+	if (ret < 0)
+		return ret;
+
+	if (monitor->custom_capacity)
+		vbat_capacity = monitor->custom_capacity;
+	AW_DEV_LOGI(dev, "get_battery_capacity is[%d]", vbat_capacity);
+
+	ret = aw_search_vmax_from_table(dev, monitor,
+				vbat_capacity, &vmax_vol);
+	if (ret < 0) {
+		AW_DEV_LOGE(dev, "not find vmax_vol");
+		return ret;
+	}
+
+	*vmax = vmax_vol;
+	return 0;
+}
+
+
+/***************************************************************************
+ *
+ * aw87xxx monitor sysfs nodes
+ *
+ ***************************************************************************/
+static ssize_t aw_attr_get_esd_enable(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->esd_enable) {
+		AW_DEV_LOGI(aw87xxx->dev, "esd-enable=true");
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"esd-enable=true\n");
+	} else {
+		AW_DEV_LOGI(aw87xxx->dev, "esd-enable=false");
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"esd-enable=false\n");
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_esd_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	char esd_enable[AW_ESD_ENABLE_STRLEN] = {0};
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (strlen(buf) > AW_ESD_ENABLE_STRLEN) {
+		AW_DEV_LOGE(aw87xxx->dev, "input esd_enable_str_len is out of max[%d]",
+				AW_ESD_ENABLE_STRLEN);
+		return -EINVAL;
+	}
+
+	if (sscanf(buf, "%s", esd_enable) == 1) {
+		AW_DEV_LOGD(aw87xxx->dev, "input esd-enable=[%s]", esd_enable);
+		if (!strcmp(esd_enable, "true"))
+			monitor->esd_enable = AW_ESD_ENABLE;
+		else
+			monitor->esd_enable = AW_ESD_DISABLE;
+		AW_DEV_LOGI(dev, "set esd-enable=[%s]",
+				monitor->esd_enable ? "true" : "false");
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "input esd-enable error");
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_get_vbat(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = -1;
+	int vbat_capacity = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->custom_capacity == 0) {
+		ret = aw_monitor_get_battery_capacity(dev, monitor,
+					&vbat_capacity);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "get battery_capacity failed");
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"vbat capacity=%d\n", vbat_capacity);
+	} else {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"vbat capacity=%d\n",
+				monitor->custom_capacity);
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_vbat(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	int ret = -1;
+	int capacity = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &capacity);
+	if (ret < 0)
+		return ret;
+	AW_DEV_LOGI(aw87xxx->dev, "set capacity = %d", capacity);
+	if (capacity >= AW_VBAT_CAPACITY_MIN &&
+			capacity <= AW_VBAT_CAPACITY_MAX){
+		monitor->custom_capacity = capacity;
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "vbat_set=invalid,please input value [%d-%d]",
+			AW_VBAT_CAPACITY_MIN, AW_VBAT_CAPACITY_MAX);
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_get_vmax(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	int ret = -1;
+	int vbat_capacity = 0;
+	int vmax_get = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_get_vmax(&vmax_get, aw87xxx->dev_index);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev,
+				"get dsp vmax fail, ret=%d", ret);
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"get_vmax=%d\n", vmax_get);
+	} else {
+		ret = aw_monitor_get_battery_capacity(dev, monitor,
+						&vbat_capacity);
+		if (ret < 0)
+			return ret;
+		AW_DEV_LOGI(aw87xxx->dev, "get_battery_capacity is [%d]",
+			vbat_capacity);
+
+		if (monitor->custom_capacity) {
+			vbat_capacity = monitor->custom_capacity;
+			AW_DEV_LOGI(aw87xxx->dev, "get custom_capacity is [%d]",
+				vbat_capacity);
+		}
+
+		ret = aw_search_vmax_from_table(aw87xxx->dev, monitor,
+					vbat_capacity, &vmax_get);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "not find vmax_vol");
+			len += snprintf(buf + len, PAGE_SIZE - len,
+				"not_find_vmax_vol\n");
+			return len;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"0x%x\n", vmax_get);
+		AW_DEV_LOGI(aw87xxx->dev, "0x%x", vmax_get);
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_vmax(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t vmax_set = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &vmax_set);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(aw87xxx->dev, "vmax_set=0x%x", vmax_set);
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_set_vmax(vmax_set, aw87xxx->dev_index);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "send dsp_msg error, ret = %d",
+				ret);
+			return ret;
+		}
+		msleep(2);
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "no_dsp system,vmax_set invalid");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_switch(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw87xxx monitor switch: %u\n",
+			monitor_hdr->monitor_switch);
+	return len;
+}
+
+
+int aw87xxx_dev_monitor_switch_set(struct aw_monitor *monitor, uint32_t enable)
+{
+	struct aw87xxx *aw87xxx =
+			container_of(monitor, struct aw87xxx, monitor);
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	AW_DEV_LOGI(aw87xxx->dev, "monitor switch set =%d", enable);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (monitor_hdr->monitor_switch == enable)
+		return 0;
+
+	if (enable > 0) {
+		monitor_hdr->monitor_switch = 1;
+		if (monitor->open_dsp_en) {
+			monitor->pre_vmax = AW_VMAX_INIT_VAL;
+			monitor->first_entry = AW_FIRST_ENTRY;
+			monitor->timer_cnt = 0;
+			monitor->vbat_sum = 0;
+		}
+	} else {
+		monitor_hdr->monitor_switch = 0;
+	}
+
+	return 0;
+}
+
+static ssize_t aw_attr_set_monitor_switch(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	uint32_t enable = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+
+	ret = kstrtouint(buf, 0, &enable);
+	if (ret < 0)
+		return ret;
+
+	ret = aw87xxx_dev_monitor_switch_set(monitor, enable);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_time(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw_monitor_timer = %u(ms)\n",
+			monitor_hdr->monitor_time);
+	return len;
+}
+
+static ssize_t aw_attr_set_monitor_time(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int timer_val = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	ret = kstrtouint(buf, 0, &timer_val);
+	if (ret < 0)
+		return ret;
+
+	AW_DEV_LOGI(aw87xxx->dev, "input monitor timer=%d(ms)", timer_val);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (timer_val != monitor_hdr->monitor_time)
+		monitor_hdr->monitor_time = timer_val;
+	else
+		AW_DEV_LOGI(aw87xxx->dev, "no_change monitor_time");
+
+	return count;
+}
+
+static ssize_t aw_attr_get_monitor_count(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw_monitor_count = %u\n",
+			monitor_hdr->monitor_count);
+	return len;
+}
+
+static ssize_t aw_attr_set_monitor_count(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int monitor_count = 0;
+	int ret = -1;
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	struct aw_monitor_header *monitor_hdr = &monitor->monitor_hdr;
+
+	ret = kstrtouint(buf, 0, &monitor_count);
+	if (ret < 0)
+		return ret;
+	AW_DEV_LOGI(aw87xxx->dev, "input monitor count=%d", monitor_count);
+
+	if (!monitor->bin_status) {
+		AW_DEV_LOGE(aw87xxx->dev, "bin parse faile or not loaded,set invalid");
+		return -EINVAL;
+	}
+
+	if (monitor_count != monitor_hdr->monitor_count)
+		monitor_hdr->monitor_count = monitor_count;
+	else
+		AW_DEV_LOGI(aw87xxx->dev, "no_change monitor_count");
+
+	return count;
+}
+
+
+static ssize_t aw_attr_get_rx(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	ssize_t len = 0;
+	int ret = -1;
+	uint32_t enable = 0;
+
+	if (monitor->open_dsp_en) {
+		ret = aw87xxx_dsp_get_rx_module_enable(&enable);
+		if (ret) {
+			AW_DEV_LOGE(aw87xxx->dev, "dsp_msg error, ret=%d", ret);
+			return ret;
+		}
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"aw87xxx rx: %u\n", enable);
+	} else {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+				"command is invalid\n");
+	}
+
+	return len;
+}
+
+static ssize_t aw_attr_set_rx(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct aw87xxx *aw87xxx = dev_get_drvdata(dev);
+	struct aw_monitor *monitor = &aw87xxx->monitor;
+	int ret = -1;
+	uint32_t enable;
+
+	ret = kstrtouint(buf, 0, &enable);
+	if (ret < 0)
+		return ret;
+
+	if (monitor->open_dsp_en) {
+		AW_DEV_LOGI(aw87xxx->dev, "set rx enable=%d", enable);
+
+		ret = aw87xxx_dsp_set_rx_module_enable(enable);
+		if (ret < 0) {
+			AW_DEV_LOGE(aw87xxx->dev, "dsp_msg error, ret=%d",
+				ret);
+			return ret;
+		}
+	} else {
+		AW_DEV_LOGE(aw87xxx->dev, "command is invalid");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(esd_enable, S_IWUSR | S_IRUGO,
+	aw_attr_get_esd_enable, aw_attr_set_esd_enable);
+static DEVICE_ATTR(vbat, S_IWUSR | S_IRUGO,
+	aw_attr_get_vbat, aw_attr_set_vbat);
+static DEVICE_ATTR(vmax, S_IWUSR | S_IRUGO,
+	aw_attr_get_vmax, aw_attr_set_vmax);
+
+static DEVICE_ATTR(monitor_switch, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_switch, aw_attr_set_monitor_switch);
+static DEVICE_ATTR(monitor_time, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_time, aw_attr_set_monitor_time);
+static DEVICE_ATTR(monitor_count, S_IWUSR | S_IRUGO,
+	aw_attr_get_monitor_count, aw_attr_set_monitor_count);
+static DEVICE_ATTR(rx, S_IWUSR | S_IRUGO,
+	aw_attr_get_rx, aw_attr_set_rx);
+
+static struct attribute *aw_monitor_vol_adjust[] = {
+	&dev_attr_esd_enable.attr,
+	&dev_attr_vbat.attr,
+	&dev_attr_vmax.attr,
+	NULL
+};
+
+static struct attribute_group aw_monitor_vol_adjust_group = {
+	.attrs = aw_monitor_vol_adjust,
+};
+
+static struct attribute *aw_monitor_control[] = {
+	&dev_attr_monitor_switch.attr,
+	&dev_attr_monitor_time.attr,
+	&dev_attr_monitor_count.attr,
+	&dev_attr_rx.attr,
+	NULL
+};
+
+static struct attribute_group aw_monitor_control_group = {
+	.attrs = aw_monitor_control,
+};
+
+/***************************************************************************
+ *
+ * aw87xxx monitor init
+ *
+ ***************************************************************************/
+static void aw_monitor_dtsi_parse(struct device *dev,
+				struct aw_monitor *monitor,
+				struct device_node *dev_node)
+{
+	int ret = -1;
+	const char *esd_enable;
+
+	ret = of_property_read_string(dev_node, "esd-enable", &esd_enable);
+	if (ret < 0) {
+		AW_DEV_LOGI(dev, "esd_enable parse failed, user default[disable]");
+		monitor->esd_enable = AW_ESD_DISABLE;
+	} else {
+		if (!strcmp(esd_enable, "true"))
+			monitor->esd_enable = AW_ESD_ENABLE;
+		else
+			monitor->esd_enable = AW_ESD_DISABLE;
+
+		AW_DEV_LOGI(dev, "parse esd-enable=[%s]",
+				monitor->esd_enable ? "true" : "false");
+	}
+}
+
+void aw87xxx_monitor_init(struct device *dev, struct aw_monitor *monitor,
+				struct device_node *dev_node)
+{
+	int ret = -1;
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+
+	monitor->dev_index = aw87xxx->dev_index;
+	monitor->monitor_hdr.monitor_time = AW_DEFAULT_MONITOR_TIME;
+
+	aw_monitor_dtsi_parse(dev, monitor, dev_node);
+
+	/* get platform open dsp type */
+	monitor->open_dsp_en = aw87xxx_dsp_isEnable();
+
+	ret = sysfs_create_group(&dev->kobj, &aw_monitor_vol_adjust_group);
+	if (ret < 0)
+		AW_DEV_LOGE(dev, "failed to create monitor vol_adjust sysfs nodes");
+
+	INIT_DELAYED_WORK(&monitor->with_dsp_work, aw_monitor_work_func);
+
+	if (monitor->open_dsp_en) {
+		ret = sysfs_create_group(&dev->kobj, &aw_monitor_control_group);
+		if (ret < 0)
+			AW_DEV_LOGE(dev, "failed to create monitor dsp control sysfs nodes");
+	}
+
+	if (!ret)
+		AW_DEV_LOGI(dev, "monitor init succeed");
+}
+
+void aw87xxx_monitor_exit(struct aw_monitor *monitor)
+{
+	struct aw87xxx *aw87xxx =
+		container_of(monitor, struct aw87xxx, monitor);
+	/*rm attr node*/
+	sysfs_remove_group(&aw87xxx->dev->kobj,
+			&aw_monitor_vol_adjust_group);
+
+	aw87xxx_monitor_stop(monitor);
+
+	if (monitor->open_dsp_en) {
+		sysfs_remove_group(&aw87xxx->dev->kobj,
+				&aw_monitor_control_group);
+	}
+}
+
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
new file mode 100644
index 000000000000..daf9f2bfa09f
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_monitor.h
@@ -0,0 +1,96 @@
+#ifndef __AW87XXX_MONITOR_H__
+#define __AW87XXX_MONITOR_H__
+
+#define AW_WAIT_DSP_OPEN_TIME			(3000)
+#define AW_VBAT_CAPACITY_MIN			(0)
+#define AW_VBAT_CAPACITY_MAX			(100)
+#define AW_VMAX_INIT_VAL			(0xFFFFFFFF)
+#define AW_VBAT_MAX				(100)
+#define AW_VMAX_MAX				(0)
+#define AW_DEFAULT_MONITOR_TIME			(3000)
+#define AW_WAIT_TIME				(3000)
+#define REG_STATUS_CHECK_MAX			(10)
+#define AW_ESD_CHECK_DELAY			(1)
+
+#define AW_ESD_ENABLE				(true)
+#define AW_ESD_DISABLE				(false)
+#define AW_ESD_ENABLE_STRLEN			(16)
+
+enum aw_monitor_init {
+	AW_MONITOR_CFG_WAIT = 0,
+	AW_MONITOR_CFG_OK = 1,
+};
+
+enum aw_monitor_hdr_info {
+	AW_MONITOR_HDR_DATA_SIZE = 0x00000004,
+	AW_MONITOR_HDR_DATA_BYTE_LEN = 0x00000004,
+};
+
+enum aw_monitor_data_ver {
+	AW_MONITOR_DATA_VER = 0x00000001,
+	AW_MONITOR_DATA_VER_MAX,
+};
+
+enum aw_monitor_first_enter {
+	AW_FIRST_ENTRY = 0,
+	AW_NOT_FIRST_ENTRY = 1,
+};
+
+struct aw_bin_header {
+	uint32_t check_sum;
+	uint32_t header_ver;
+	uint32_t bin_data_type;
+	uint32_t bin_data_ver;
+	uint32_t bin_data_size;
+	uint32_t ui_ver;
+	char product[8];
+	uint32_t addr_byte_len;
+	uint32_t data_byte_len;
+	uint32_t device_addr;
+	uint32_t reserve[4];
+};
+
+struct aw_monitor_header {
+	uint32_t monitor_switch;
+	uint32_t monitor_time;
+	uint32_t monitor_count;
+	uint32_t step_count;
+	uint32_t reserve[4];
+};
+
+struct vmax_step_config {
+	uint32_t vbat_min;
+	uint32_t vbat_max;
+	int vmax_vol;
+};
+
+struct aw_monitor {
+	bool open_dsp_en;
+	bool esd_enable;
+	int32_t dev_index;
+	uint8_t first_entry;
+	uint8_t timer_cnt;
+	uint32_t vbat_sum;
+	int32_t custom_capacity;
+	uint32_t pre_vmax;
+
+	int bin_status;
+	struct aw_monitor_header monitor_hdr;
+	struct vmax_step_config *vmax_cfg;
+
+	struct delayed_work with_dsp_work;
+};
+
+void aw87xxx_monitor_cfg_free(struct aw_monitor *monitor);
+int aw87xxx_monitor_bin_parse(struct device *dev,
+			char *monitor_data, uint32_t data_len);
+void aw87xxx_monitor_stop(struct aw_monitor *monitor);
+void aw87xxx_monitor_start(struct aw_monitor *monitor);
+int aw87xxx_monitor_no_dsp_get_vmax(struct aw_monitor *monitor,
+					int32_t *vmax);
+void aw87xxx_monitor_init(struct device *dev, struct aw_monitor *monitor,
+				struct device_node *dev_node);
+void aw87xxx_monitor_exit(struct aw_monitor *monitor);
+int aw87xxx_dev_monitor_switch_set(struct aw_monitor *monitor, uint32_t enable);
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
new file mode 100644
index 000000000000..74d6548db91e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_18_reg.h
@@ -0,0 +1,2315 @@
+#ifndef __AW87XXX_PID_18_REG_H__
+#define __AW87XXX_PID_18_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_18_CHIPID_REG		(0x00)
+#define AW87XXX_PID_18_SYSST_REG		(0x01)
+#define AW87XXX_PID_18_SYSINT_REG		(0x02)
+#define AW87XXX_PID_18_SYSCTRL_REG		(0x03)
+#define AW87XXX_PID_18_CPOC_REG			(0x04)
+#define AW87XXX_PID_18_CLASSD_REG		(0x05)
+#define AW87XXX_PID_18_MADPVTH_REG		(0x06)
+#define AW87XXX_PID_18_A3PARAM_REG		(0x07)
+#define AW87XXX_PID_18_A3A2PO_REG		(0x08)
+#define AW87XXX_PID_18_A2PARAM_REG		(0x09)
+#define AW87XXX_PID_18_A1PARAM_REG		(0x0A)
+#define AW87XXX_PID_18_POPCLK_REG		(0x0B)
+#define AW87XXX_PID_18_GTDRCPSS_REG		(0x0C)
+#define AW87XXX_PID_18_MULTI_REG		(0x0D)
+#define AW87XXX_PID_18_DFT1_REG			(0x61)
+#define AW87XXX_PID_18_DFT2_REG			(0x62)
+#define AW87XXX_PID_18_DFT3_REG			(0x63)
+#define AW87XXX_PID_18_DFT4_REG			(0x64)
+#define AW87XXX_PID_18_DFT5_REG			(0x65)
+#define AW87XXX_PID_18_DFT6_REG			(0x66)
+
+#define AW87XXX_PID_18_CLASSD_DEFAULT		(0x10)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_18_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_18_REG_MAX			(0x67)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_18_reg_access[AW87XXX_PID_18_REG_MAX] = {
+	[AW87XXX_PID_18_CHIPID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_18_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_CPOC_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_CLASSD_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_MADPVTH_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A3PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A3A2PO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A2PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_A1PARAM_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_POPCLK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_GTDRCPSS_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_MULTI_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT4_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT5_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_18_DFT6_REG]	= (REG_RD_ACCESS),
+};
+
+/* detail information of registers begin */
+/* CHIPID (0x00) detail */
+/* IDCODE bit 7:0 (CHIPID 0x00) */
+#define AW87XXX_PID_18_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_18_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_18_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_18_IDCODE_BITS_LEN)-1) << AW87XXX_PID_18_IDCODE_START_BIT))
+
+#define AW87XXX_PID_18_IDCODE_DEFAULT_VALUE	(0x18)
+#define AW87XXX_PID_18_IDCODE_DEFAULT	\
+	(AW87XXX_PID_18_IDCODE_DEFAULT_VALUE << AW87XXX_PID_18_IDCODE_START_BIT)
+
+/* default value of CHIPID (0x00) */
+/* #define AW87XXX_PID_18_CHIPID_DEFAULT		(0x18) */
+
+/* SYSST (0x01) detail */
+/* UVLOS bit 7 (SYSST 0x01) */
+#define AW87XXX_PID_18_UVLOS_START_BIT	(7)
+#define AW87XXX_PID_18_UVLOS_BITS_LEN	(1)
+#define AW87XXX_PID_18_UVLOS_MASK		\
+	(~(((1<<AW87XXX_PID_18_UVLOS_BITS_LEN)-1) << AW87XXX_PID_18_UVLOS_START_BIT))
+
+#define AW87XXX_PID_18_UVLOS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_UVLOS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_UVLOS_NORMAL_OPERATION << AW87XXX_PID_18_UVLOS_START_BIT)
+
+#define AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_18_UVLOS_VBAT_UNDER_VOLTAGE << AW87XXX_PID_18_UVLOS_START_BIT)
+
+#define AW87XXX_PID_18_UVLOS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_UVLOS_DEFAULT	\
+	(AW87XXX_PID_18_UVLOS_DEFAULT_VALUE << AW87XXX_PID_18_UVLOS_START_BIT)
+
+/* OTNS bit 6 (SYSST 0x01) */
+#define AW87XXX_PID_18_OTNS_START_BIT	(6)
+#define AW87XXX_PID_18_OTNS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OTNS_MASK		\
+	(~(((1<<AW87XXX_PID_18_OTNS_BITS_LEN)-1) << AW87XXX_PID_18_OTNS_START_BIT))
+
+#define AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(0)
+#define AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OTNS_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_18_OTNS_START_BIT)
+
+#define AW87XXX_PID_18_OTNS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_18_OTNS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OTNS_NORMAL_OPERATION << AW87XXX_PID_18_OTNS_START_BIT)
+
+#define AW87XXX_PID_18_OTNS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OTNS_DEFAULT		\
+	(AW87XXX_PID_18_OTNS_DEFAULT_VALUE << AW87XXX_PID_18_OTNS_START_BIT)
+
+/* OC_FLAGS bit 5 (SYSST 0x01) */
+#define AW87XXX_PID_18_OC_FLAGS_START_BIT	(5)
+#define AW87XXX_PID_18_OC_FLAGS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OC_FLAGS_MASK	\
+	(~(((1<<AW87XXX_PID_18_OC_FLAGS_BITS_LEN)-1) << AW87XXX_PID_18_OC_FLAGS_START_BIT))
+
+#define AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGS_NORMAL_OPERATION << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGS_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OC_FLAGS_DEFAULT	\
+	(AW87XXX_PID_18_OC_FLAGS_DEFAULT_VALUE << AW87XXX_PID_18_OC_FLAGS_START_BIT)
+
+/* VOUTDECTS bit 4 (SYSST 0x01) */
+#define AW87XXX_PID_18_VOUTDECTS_START_BIT	(4)
+#define AW87XXX_PID_18_VOUTDECTS_BITS_LEN	(1)
+#define AW87XXX_PID_18_VOUTDECTS_MASK	\
+	(~(((1<<AW87XXX_PID_18_VOUTDECTS_BITS_LEN)-1) << AW87XXX_PID_18_VOUTDECTS_START_BIT))
+
+#define AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD	(0)
+#define AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTS_PVDDBELOWVDD << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD	(1)
+#define AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTS_PVDDABOVEVDD << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VOUTDECTS_DEFAULT	\
+	(AW87XXX_PID_18_VOUTDECTS_DEFAULT_VALUE << AW87XXX_PID_18_VOUTDECTS_START_BIT)
+
+/* STARTOKS bit 3 (SYSST 0x01) */
+#define AW87XXX_PID_18_STARTOKS_START_BIT	(3)
+#define AW87XXX_PID_18_STARTOKS_BITS_LEN	(1)
+#define AW87XXX_PID_18_STARTOKS_MASK	\
+	(~(((1<<AW87XXX_PID_18_STARTOKS_BITS_LEN)-1) << AW87XXX_PID_18_STARTOKS_START_BIT))
+
+#define AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED	(0)
+#define AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED_VALUE	\
+	(AW87XXX_PID_18_STARTOKS_CP_START_FAIL_DECTECTED << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_STARTOKS_NORMAL_OPERATION << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_STARTOKS_DEFAULT	\
+	(AW87XXX_PID_18_STARTOKS_DEFAULT_VALUE << AW87XXX_PID_18_STARTOKS_START_BIT)
+
+/* VBGOKN1S bit 2 (SYSST 0x01) */
+#define AW87XXX_PID_18_VBGOKN1S_START_BIT	(2)
+#define AW87XXX_PID_18_VBGOKN1S_BITS_LEN	(1)
+#define AW87XXX_PID_18_VBGOKN1S_MASK	\
+	(~(((1<<AW87XXX_PID_18_VBGOKN1S_BITS_LEN)-1) << AW87XXX_PID_18_VBGOKN1S_START_BIT))
+
+#define AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS	(0)
+#define AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1S_NORMAL_WORKS << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS	(1)
+#define AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1S_ABNORMAL_WORKS << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1S_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VBGOKN1S_DEFAULT	\
+	(AW87XXX_PID_18_VBGOKN1S_DEFAULT_VALUE << AW87XXX_PID_18_VBGOKN1S_START_BIT)
+
+/* OVPS bit 1 (SYSST 0x01) */
+#define AW87XXX_PID_18_OVPS_START_BIT	(1)
+#define AW87XXX_PID_18_OVPS_BITS_LEN	(1)
+#define AW87XXX_PID_18_OVPS_MASK		\
+	(~(((1<<AW87XXX_PID_18_OVPS_BITS_LEN)-1) << AW87XXX_PID_18_OVPS_START_BIT))
+
+#define AW87XXX_PID_18_OVPS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OVPS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OVPS_NORMAL_OPERATION << AW87XXX_PID_18_OVPS_START_BIT)
+
+#define AW87XXX_PID_18_OVPS_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_18_OVPS_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OVPS_CP_OVP_DETECTED << AW87XXX_PID_18_OVPS_START_BIT)
+
+#define AW87XXX_PID_18_OVPS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OVPS_DEFAULT		\
+	(AW87XXX_PID_18_OVPS_DEFAULT_VALUE << AW87XXX_PID_18_OVPS_START_BIT)
+
+/* CP_2PS bit 0 (SYSST 0x01) */
+#define AW87XXX_PID_18_CP_2PS_START_BIT	(0)
+#define AW87XXX_PID_18_CP_2PS_BITS_LEN	(1)
+#define AW87XXX_PID_18_CP_2PS_MASK		\
+	(~(((1<<AW87XXX_PID_18_CP_2PS_BITS_LEN)-1) << AW87XXX_PID_18_CP_2PS_START_BIT))
+
+#define AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL	(0)
+#define AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PS_WEAK_SIGNAL << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL	(1)
+#define AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PS_STRONG_SIGNAL << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_CP_2PS_DEFAULT	\
+	(AW87XXX_PID_18_CP_2PS_DEFAULT_VALUE << AW87XXX_PID_18_CP_2PS_START_BIT)
+
+/* default value of SYSST (0x01) */
+/* #define AW87XXX_PID_18_SYSST_DEFAULT		(0x00) */
+
+/* SYSINT (0x02) detail */
+/* UVLOI bit 7 (SYSINT 0x02) */
+#define AW87XXX_PID_18_UVLOI_START_BIT	(7)
+#define AW87XXX_PID_18_UVLOI_BITS_LEN	(1)
+#define AW87XXX_PID_18_UVLOI_MASK		\
+	(~(((1<<AW87XXX_PID_18_UVLOI_BITS_LEN)-1) << AW87XXX_PID_18_UVLOI_START_BIT))
+
+#define AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_UVLOI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_UVLOI_START_BIT)
+
+#define AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED	(1)
+#define AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED_VALUE	\
+	(AW87XXX_PID_18_UVLOI_UNDER_VOLTAGE_LOCK_OUT_DETECTED << AW87XXX_PID_18_UVLOI_START_BIT)
+
+#define AW87XXX_PID_18_UVLOI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_UVLOI_DEFAULT	\
+	(AW87XXX_PID_18_UVLOI_DEFAULT_VALUE << AW87XXX_PID_18_UVLOI_START_BIT)
+
+/* OTNI bit 6 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OTNI_START_BIT	(6)
+#define AW87XXX_PID_18_OTNI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OTNI_MASK		\
+	(~(((1<<AW87XXX_PID_18_OTNI_BITS_LEN)-1) << AW87XXX_PID_18_OTNI_START_BIT))
+
+#define AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_OTNI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_OTNI_START_BIT)
+
+#define AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OTNI_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_18_OTNI_START_BIT)
+
+#define AW87XXX_PID_18_OTNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OTNI_DEFAULT		\
+	(AW87XXX_PID_18_OTNI_DEFAULT_VALUE << AW87XXX_PID_18_OTNI_START_BIT)
+
+/* OC_FLAGI bit 5 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OC_FLAGI_START_BIT	(5)
+#define AW87XXX_PID_18_OC_FLAGI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OC_FLAGI_MASK	\
+	(~(((1<<AW87XXX_PID_18_OC_FLAGI_BITS_LEN)-1) << AW87XXX_PID_18_OC_FLAGI_START_BIT))
+
+#define AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OC_FLAGI_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_18_OC_FLAGI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OC_FLAGI_DEFAULT	\
+	(AW87XXX_PID_18_OC_FLAGI_DEFAULT_VALUE << AW87XXX_PID_18_OC_FLAGI_START_BIT)
+
+/* VOUTDECTI bit 4 (SYSINT 0x02) */
+#define AW87XXX_PID_18_VOUTDECTI_START_BIT	(4)
+#define AW87XXX_PID_18_VOUTDECTI_BITS_LEN	(1)
+#define AW87XXX_PID_18_VOUTDECTI_MASK	\
+	(~(((1<<AW87XXX_PID_18_VOUTDECTI_BITS_LEN)-1) << AW87XXX_PID_18_VOUTDECTI_START_BIT))
+
+#define AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD	(0)
+#define AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTI_PVDDBELOWVDD << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD	(1)
+#define AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD_VALUE	\
+	(AW87XXX_PID_18_VOUTDECTI_PVDDABOVEVDD << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+#define AW87XXX_PID_18_VOUTDECTI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VOUTDECTI_DEFAULT	\
+	(AW87XXX_PID_18_VOUTDECTI_DEFAULT_VALUE << AW87XXX_PID_18_VOUTDECTI_START_BIT)
+
+/* STARTOKI bit 3 (SYSINT 0x02) */
+#define AW87XXX_PID_18_STARTOKI_START_BIT	(3)
+#define AW87XXX_PID_18_STARTOKI_BITS_LEN	(1)
+#define AW87XXX_PID_18_STARTOKI_MASK	\
+	(~(((1<<AW87XXX_PID_18_STARTOKI_BITS_LEN)-1) << AW87XXX_PID_18_STARTOKI_START_BIT))
+
+#define AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE	(0)
+#define AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_18_STARTOKI_SIGNAL_STATUS_DO_NOT_CHANGE << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED	(1)
+#define AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED_VALUE	\
+	(AW87XXX_PID_18_STARTOKI_CHARGEPUMB_START_UP_OK_DECTECTED << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_18_STARTOKI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_STARTOKI_DEFAULT	\
+	(AW87XXX_PID_18_STARTOKI_DEFAULT_VALUE << AW87XXX_PID_18_STARTOKI_START_BIT)
+
+/* VBGOKN1I bit 2 (SYSINT 0x02) */
+#define AW87XXX_PID_18_VBGOKN1I_START_BIT	(2)
+#define AW87XXX_PID_18_VBGOKN1I_BITS_LEN	(1)
+#define AW87XXX_PID_18_VBGOKN1I_MASK	\
+	(~(((1<<AW87XXX_PID_18_VBGOKN1I_BITS_LEN)-1) << AW87XXX_PID_18_VBGOKN1I_START_BIT))
+
+#define AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS	(0)
+#define AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1I_NORMAL_WORKS << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS	(1)
+#define AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS_VALUE	\
+	(AW87XXX_PID_18_VBGOKN1I_ABNORMAL_WORKS << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+#define AW87XXX_PID_18_VBGOKN1I_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_VBGOKN1I_DEFAULT	\
+	(AW87XXX_PID_18_VBGOKN1I_DEFAULT_VALUE << AW87XXX_PID_18_VBGOKN1I_START_BIT)
+
+/* OVPI bit 1 (SYSINT 0x02) */
+#define AW87XXX_PID_18_OVPI_START_BIT	(1)
+#define AW87XXX_PID_18_OVPI_BITS_LEN	(1)
+#define AW87XXX_PID_18_OVPI_MASK		\
+	(~(((1<<AW87XXX_PID_18_OVPI_BITS_LEN)-1) << AW87XXX_PID_18_OVPI_START_BIT))
+
+#define AW87XXX_PID_18_OVPI_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_18_OVPI_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_18_OVPI_NORMAL_OPERATION << AW87XXX_PID_18_OVPI_START_BIT)
+
+#define AW87XXX_PID_18_OVPI_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_18_OVPI_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_18_OVPI_CP_OVP_DETECTED << AW87XXX_PID_18_OVPI_START_BIT)
+
+#define AW87XXX_PID_18_OVPI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_OVPI_DEFAULT		\
+	(AW87XXX_PID_18_OVPI_DEFAULT_VALUE << AW87XXX_PID_18_OVPI_START_BIT)
+
+/* CP_2PI bit 0 (SYSINT 0x02) */
+#define AW87XXX_PID_18_CP_2PI_START_BIT	(0)
+#define AW87XXX_PID_18_CP_2PI_BITS_LEN	(1)
+#define AW87XXX_PID_18_CP_2PI_MASK		\
+	(~(((1<<AW87XXX_PID_18_CP_2PI_BITS_LEN)-1) << AW87XXX_PID_18_CP_2PI_START_BIT))
+
+#define AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL	(0)
+#define AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PI_WEAK_SIGNAL << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL	(1)
+#define AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL_VALUE	\
+	(AW87XXX_PID_18_CP_2PI_STRONG_SIGNAL << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+#define AW87XXX_PID_18_CP_2PI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_CP_2PI_DEFAULT	\
+	(AW87XXX_PID_18_CP_2PI_DEFAULT_VALUE << AW87XXX_PID_18_CP_2PI_START_BIT)
+
+/* default value of SYSINT (0x02) */
+/* #define AW87XXX_PID_18_SYSINT_DEFAULT		(0x00) */
+
+/* SYSCTRL (0x03) detail */
+/* EN_SS bit 7 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_EN_SS_START_BIT	(7)
+#define AW87XXX_PID_18_EN_SS_BITS_LEN	(1)
+#define AW87XXX_PID_18_EN_SS_MASK		\
+	(~(((1<<AW87XXX_PID_18_EN_SS_BITS_LEN)-1) << AW87XXX_PID_18_EN_SS_START_BIT))
+
+#define AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ	(0)
+#define AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ_VALUE	\
+	(AW87XXX_PID_18_EN_SS_DISABLE_REG_FSS11001P6MHZ << AW87XXX_PID_18_EN_SS_START_BIT)
+
+#define AW87XXX_PID_18_EN_SS_ENABLE		(1)
+#define AW87XXX_PID_18_EN_SS_ENABLE_VALUE	\
+	(AW87XXX_PID_18_EN_SS_ENABLE << AW87XXX_PID_18_EN_SS_START_BIT)
+
+#define AW87XXX_PID_18_EN_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_EN_SS_DEFAULT	\
+	(AW87XXX_PID_18_EN_SS_DEFAULT_VALUE << AW87XXX_PID_18_EN_SS_START_BIT)
+
+/* REG_EN_SW bit 6 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_SW_START_BIT	(6)
+#define AW87XXX_PID_18_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_SW_DISABLE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_SW_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_SW_ENABLE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_SW_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_SW_START_BIT)
+
+/* REG_EN_PA bit 5 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_PA_START_BIT	(5)
+#define AW87XXX_PID_18_REG_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_PA_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_PA_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_PA_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_PA_DISABLE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_PA_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_PA_ENABLE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_PA_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_PA_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_PA_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_PA_START_BIT)
+
+/* REG_EN_ADAP bit 4 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_ADAP_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EN_ADAP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_ADAP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_ADAP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_ADAP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_ADAP_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_ADAP_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ADAP_DISABLE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ADAP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_ADAP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ADAP_ENABLE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ADAP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_ADAP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_ADAP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_ADAP_START_BIT)
+
+/* REG_EN_MPD bit 3 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_MPD_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_MPD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_MPD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_MPD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_MPD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_MPD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_MPD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MPD_DISABLE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MPD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_MPD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MPD_ENABLE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MPD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_MPD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_MPD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_MPD_START_BIT)
+
+/* REG_EN_CP bit 2 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_EN_CP_START_BIT	(2)
+#define AW87XXX_PID_18_REG_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE	(0)
+#define AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CP_DISABLE_PVDDVBAT_DIRECT_TROUGH_MODE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CP_ENABLE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CP_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_CP_START_BIT)
+
+/* REG_REC_MODE bit 1 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_REC_MODE_START_BIT	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_18_REG_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_18_REG_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_18_REG_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_REC_MODE_DISABLE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_18_REG_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_18_REG_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_REC_MODE_ENABLE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_18_REG_REC_MODE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_REC_MODE_DEFAULT	\
+	(AW87XXX_PID_18_REG_REC_MODE_DEFAULT_VALUE << AW87XXX_PID_18_REG_REC_MODE_START_BIT)
+
+/* REG_FORCE_2X bit 0 (SYSCTRL 0x03) */
+#define AW87XXX_PID_18_REG_FORCE_2X_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FORCE_2X_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FORCE_2X_BITS_LEN)-1) << AW87XXX_PID_18_REG_FORCE_2X_START_BIT))
+
+#define AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM	(0)
+#define AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM_VALUE	\
+	(AW87XXX_PID_18_REG_FORCE_2X_DISABLE_CPS_WORKING_STATUS_DEPENDS_ON_THE_SYSTEM << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+#define AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE_VALUE	\
+	(AW87XXX_PID_18_REG_FORCE_2X_ENABLE_FORCE_THE_CP_WORKS_IN_X2_MODE << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+#define AW87XXX_PID_18_REG_FORCE_2X_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_FORCE_2X_DEFAULT	\
+	(AW87XXX_PID_18_REG_FORCE_2X_DEFAULT_VALUE << AW87XXX_PID_18_REG_FORCE_2X_START_BIT)
+
+/* default value of SYSCTRL (0x03) */
+/* #define AW87XXX_PID_18_SYSCTRL_DEFAULT		(0xE5) */
+
+/* CPOC (0x04) detail */
+/* REG_CP_OVP bit 5:2 (CPOC 0x04) */
+#define AW87XXX_PID_18_REG_CP_OVP_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_CP_OVP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_OVP_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_OVP_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_OVP_8P5V	(8)
+#define AW87XXX_PID_18_REG_CP_OVP_8P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_8P25V	(7)
+#define AW87XXX_PID_18_REG_CP_OVP_8P25V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8P25V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_8V	(6)
+#define AW87XXX_PID_18_REG_CP_OVP_8V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_8V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P75V	(5)
+#define AW87XXX_PID_18_REG_CP_OVP_7P75V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P75V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P5V	(4)
+#define AW87XXX_PID_18_REG_CP_OVP_7P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7P25V	(3)
+#define AW87XXX_PID_18_REG_CP_OVP_7P25V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7P25V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_7V	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_7V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_7V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_6P75V	(1)
+#define AW87XXX_PID_18_REG_CP_OVP_6P75V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_6P75V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_6P5V	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_6P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_6P5V << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_DEFAULT_VALUE	(0x6)
+#define AW87XXX_PID_18_REG_CP_OVP_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_OVP_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_OVP_START_BIT)
+
+/* REG_OC_DELAY bit 1:0 (CPOC 0x04) */
+#define AW87XXX_PID_18_REG_OC_DELAY_START_BIT	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_OC_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_OC_DELAY_BITS_LEN)-1) << AW87XXX_PID_18_REG_OC_DELAY_START_BIT))
+
+#define AW87XXX_PID_18_REG_OC_DELAY_60NS	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_60NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_60NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_80NS	(1)
+#define AW87XXX_PID_18_REG_OC_DELAY_80NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_80NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_90NS	(2)
+#define AW87XXX_PID_18_REG_OC_DELAY_90NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_90NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_110NS	(3)
+#define AW87XXX_PID_18_REG_OC_DELAY_110NS_VALUE	\
+	(AW87XXX_PID_18_REG_OC_DELAY_110NS << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+#define AW87XXX_PID_18_REG_OC_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_OC_DELAY_DEFAULT	\
+	(AW87XXX_PID_18_REG_OC_DELAY_DEFAULT_VALUE << AW87XXX_PID_18_REG_OC_DELAY_START_BIT)
+
+/* default value of CPOC (0x04) */
+/* #define AW87XXX_PID_18_CPOC_DEFAULT		(0x18) */
+
+/* CLASSD (0x05) detail */
+/* REG_BK1 bit 7 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK1_START_BIT	(7)
+#define AW87XXX_PID_18_REG_BK1_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK1_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK1_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK1_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK1_22MV		(0)
+#define AW87XXX_PID_18_REG_BK1_22MV_VALUE	\
+	(AW87XXX_PID_18_REG_BK1_22MV << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+#define AW87XXX_PID_18_REG_BK1_15MV		(1)
+#define AW87XXX_PID_18_REG_BK1_15MV_VALUE	\
+	(AW87XXX_PID_18_REG_BK1_15MV << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+#define AW87XXX_PID_18_REG_BK1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK1_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK1_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK1_START_BIT)
+
+/* REG_BK2 bit 6 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK2_START_BIT	(6)
+#define AW87XXX_PID_18_REG_BK2_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK2_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK2_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK2_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK2_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK2_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK2_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK2_START_BIT)
+
+/* REG_BK3 bit 5 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_BK3_START_BIT	(5)
+#define AW87XXX_PID_18_REG_BK3_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_BK3_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_BK3_BITS_LEN)-1) << AW87XXX_PID_18_REG_BK3_START_BIT))
+
+#define AW87XXX_PID_18_REG_BK3_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_BK3_DEFAULT	\
+	(AW87XXX_PID_18_REG_BK3_DEFAULT_VALUE << AW87XXX_PID_18_REG_BK3_START_BIT)
+
+/* REG_D_GAIN bit 4:0 (CLASSD 0x05) */
+#define AW87XXX_PID_18_REG_D_GAIN_START_BIT	(0)
+#define AW87XXX_PID_18_REG_D_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_18_REG_D_GAIN_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_D_GAIN_BITS_LEN)-1) << AW87XXX_PID_18_REG_D_GAIN_START_BIT))
+
+#define AW87XXX_PID_18_REG_D_GAIN_0DB	(0)
+#define AW87XXX_PID_18_REG_D_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_0DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_1P5DB	(1)
+#define AW87XXX_PID_18_REG_D_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_1P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_3DB	(2)
+#define AW87XXX_PID_18_REG_D_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_3DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_4P5DB	(3)
+#define AW87XXX_PID_18_REG_D_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_4P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_6DB	(4)
+#define AW87XXX_PID_18_REG_D_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_6DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_7P5DB	(5)
+#define AW87XXX_PID_18_REG_D_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_7P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_9DB	(6)
+#define AW87XXX_PID_18_REG_D_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_9DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_10P5DB	(7)
+#define AW87XXX_PID_18_REG_D_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_10P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_12DB	(8)
+#define AW87XXX_PID_18_REG_D_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_12DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_13P5DB	(9)
+#define AW87XXX_PID_18_REG_D_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_13P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_15DB	(10)
+#define AW87XXX_PID_18_REG_D_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_15DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_16P5DB	(11)
+#define AW87XXX_PID_18_REG_D_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_16P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_18DB	(12)
+#define AW87XXX_PID_18_REG_D_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_18DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_19P5DB	(13)
+#define AW87XXX_PID_18_REG_D_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_19P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_21DB	(14)
+#define AW87XXX_PID_18_REG_D_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_21DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_22P5DB	(15)
+#define AW87XXX_PID_18_REG_D_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_22P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_24DB	(16)
+#define AW87XXX_PID_18_REG_D_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_24DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_25P5DB	(17)
+#define AW87XXX_PID_18_REG_D_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_25P5DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_27DB	(18)
+#define AW87XXX_PID_18_REG_D_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_18_REG_D_GAIN_27DB << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+#define AW87XXX_PID_18_REG_D_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_18_REG_D_GAIN_DEFAULT	\
+	(AW87XXX_PID_18_REG_D_GAIN_DEFAULT_VALUE << AW87XXX_PID_18_REG_D_GAIN_START_BIT)
+
+/* default value of CLASSD (0x05) */
+/* #define AW87XXX_PID_18_CLASSD_DEFAULT		(0x10) */
+
+/* MADPVTH (0x06) detail */
+/* REG_ADAP_VTH bit 3:2 (MADPVTH 0x06) */
+#define AW87XXX_PID_18_REG_ADAP_VTH_START_BIT	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_ADAP_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W	(0)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P1W0P05W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W	(1)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P2W0P15W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W	(2)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P3W0P25W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W	(3)
+#define AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W_VALUE	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_0P4W0P35W << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_ADAP_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_ADAP_VTH_START_BIT)
+
+/* REG_MPD_VTH bit 1:0 (MADPVTH 0x06) */
+#define AW87XXX_PID_18_REG_MPD_VTH_START_BIT	(0)
+#define AW87XXX_PID_18_REG_MPD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_MPD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_MPD_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_MPD_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW	(0)
+#define AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_8P1MW3P6MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW	(1)
+#define AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_11MW5P6MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW	(2)
+#define AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_14P4MW8P1MW << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W	(3)
+#define AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W_VALUE	\
+	(AW87XXX_PID_18_REG_MPD_VTH_18P2MW11W << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_MPD_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_MPD_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_MPD_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_MPD_VTH_START_BIT)
+
+/* default value of MADPVTH (0x06) */
+/* #define AW87XXX_PID_18_MADPVTH_DEFAULT		(0x05) */
+
+/* A3PARAM (0x07) detail */
+/* REG_AGC3_RT bit 7:5 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_RT_START_BIT	(5)
+#define AW87XXX_PID_18_REG_AGC3_RT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC3_RT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_RT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_RT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_RT_69P12MS	(0)
+#define AW87XXX_PID_18_REG_AGC3_RT_69P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_69P12MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_138P24MS	(1)
+#define AW87XXX_PID_18_REG_AGC3_RT_138P24MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_138P24MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_276P48MS	(2)
+#define AW87XXX_PID_18_REG_AGC3_RT_276P48MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_276P48MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_552P96MS	(3)
+#define AW87XXX_PID_18_REG_AGC3_RT_552P96MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_552P96MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_1107MS	(4)
+#define AW87XXX_PID_18_REG_AGC3_RT_1107MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_1107MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_2160MS	(5)
+#define AW87XXX_PID_18_REG_AGC3_RT_2160MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_2160MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_4320MS	(6)
+#define AW87XXX_PID_18_REG_AGC3_RT_4320MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_RT_4320MS << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_RT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC3_RT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_RT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_RT_START_BIT)
+
+/* REG_AGC3_AT bit 4:2 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_AT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_AGC3_AT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC3_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_5P76MS_0P32MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_11P52MS_0P64MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_23P04MS_1P28MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_92P16MS_5P12MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP	(4)
+#define AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_368P64MS_20P48MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP	(5)
+#define AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_738MS_41MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP	(6)
+#define AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_1476MS_82MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP	(7)
+#define AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_AT_2952MS_164MSSTEP << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_AT_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_18_REG_AGC3_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_AT_START_BIT)
+
+/* REG_AGC3_1ST_AT bit 1:0 (A3PARAM 0x07) */
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_1ST_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS	(0)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_5P12MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS	(1)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_10P24MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS	(2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_20P48MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS	(3)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_41MS << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_1ST_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_1ST_AT_START_BIT)
+
+/* default value of A3PARAM (0x07) */
+/* #define AW87XXX_PID_18_A3PARAM_DEFAULT		(0x52) */
+
+/* A3A2PO (0x08) detail */
+/* REG_AGC3_PO bit 7:4 (A3A2PO 0x08) */
+#define AW87XXX_PID_18_REG_AGC3_PO_START_BIT	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC3_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC3_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM	(0)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P2W8_OHM_0P27W6_OHM_0P05W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM	(1)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P3W8_OHM_0P4W6_OHM_0P075W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM	(2)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM	(3)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P5W8_OHM_0P67W6_OHM_0P125W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM	(4)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM	(5)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P7W8_OHM_0P93W6_OHM_0P175W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM	(6)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM	(7)
+#define AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_0P9W8_OHM_1P2W6_OHM_0P225W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM	(8)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM	(9)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P1W8_OHM_1P46W6_OHM_0P275W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM	(10)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P2W8_OHM_1P6W6_OHM_0P30W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM	(11)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P3W8_OHM_1P73W6_OHM_0P325W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM	(12)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM	(13)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P5W8_OHM_2W6_OHM_0P375W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM	(14)
+#define AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF	(15)
+#define AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF_VALUE	\
+	(AW87XXX_PID_18_REG_AGC3_PO_AGC3_OFF << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC3_PO_DEFAULT_VALUE	(0xA)
+#define AW87XXX_PID_18_REG_AGC3_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC3_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC3_PO_START_BIT)
+
+/* REG_AGC2_PO bit 3:0 (A3A2PO 0x08) */
+#define AW87XXX_PID_18_REG_AGC2_PO_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC2_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC2_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM	(0)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P4W8_OHM_0P53W6_OHM_0P1W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM	(1)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P6W8_OHM_0P8W6_OHM_0P15W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM	(2)
+#define AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_0P8W8_OHM_1P06W6_OHM_0P2W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM	(3)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P0W8_OHM_1P33W6_OHM_0P25W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM	(4)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P2W8_OHM_1P6W6_OHM_0P3W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM	(5)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P4W8_OHM_1P86W6_OHM_0P35W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM	(6)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P6W8_OHM_2P13W6_OHM_0P4W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM	(7)
+#define AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_1P8W8_OHM_2P4W6_OHM_0P45W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM	(8)
+#define AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_2P0W8_OHM_2P66W6_OHM_0P5W32_OHM << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF	(9)
+#define AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_PO_AGC2_OFF << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_PO_DEFAULT_VALUE	(0x6)
+#define AW87XXX_PID_18_REG_AGC2_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_PO_START_BIT)
+
+/* default value of A3A2PO (0x08) */
+/* #define AW87XXX_PID_18_A3A2PO_DEFAULT		(0xA6) */
+
+/* A2PARAM (0x09) detail */
+/* REG_TEDGE bit 5 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_TEDGE_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TEDGE_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TEDGE_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TEDGE_BITS_LEN)-1) << AW87XXX_PID_18_REG_TEDGE_START_BIT))
+
+#define AW87XXX_PID_18_REG_TEDGE_4NS	(0)
+#define AW87XXX_PID_18_REG_TEDGE_4NS_VALUE	\
+	(AW87XXX_PID_18_REG_TEDGE_4NS << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+#define AW87XXX_PID_18_REG_TEDGE_12NS	(1)
+#define AW87XXX_PID_18_REG_TEDGE_12NS_VALUE	\
+	(AW87XXX_PID_18_REG_TEDGE_12NS << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+#define AW87XXX_PID_18_REG_TEDGE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TEDGE_DEFAULT	\
+	(AW87XXX_PID_18_REG_TEDGE_DEFAULT_VALUE << AW87XXX_PID_18_REG_TEDGE_START_BIT)
+
+/* REG_AGC2_AT bit 4:2 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_AGC2_AT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_AGC2_AT_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_AGC2_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_1P44MS_0P08MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_2P88MS_0P16MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_5P76MS_0P32MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_23P04MS_1P28MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP	(4)
+#define AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_92P16MS_5P12MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP	(5)
+#define AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_368P64MS_20P48MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP	(6)
+#define AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_737P28MS_41MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP	(7)
+#define AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_AT_1474P56MS_82MSSTEP << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_AT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_18_REG_AGC2_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_AT_START_BIT)
+
+/* REG_AGC2_1ST_AT bit 1:0 (A2PARAM 0x09) */
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC2_1ST_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_0P08MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS	(1)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_0P32MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS	(2)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_1P28MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS	(3)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS_VALUE	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_5P12MS << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC2_1ST_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC2_1ST_AT_START_BIT)
+
+/* default value of A2PARAM (0x09) */
+/* #define AW87XXX_PID_18_A2PARAM_DEFAULT		(0x08) */
+
+/* A1PARAM (0x0A) detail */
+/* REG_AGC1_PO bit 6:3 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_AGC1_PO_START_BIT	(3)
+#define AW87XXX_PID_18_REG_AGC1_PO_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_AGC1_PO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_PO_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_PO_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5V	(0)
+#define AW87XXX_PID_18_REG_AGC1_PO_5V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P2V	(1)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P4V	(2)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P6V	(3)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_5P8V	(4)
+#define AW87XXX_PID_18_REG_AGC1_PO_5P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_5P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P0V	(5)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P0V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P0V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P2V	(6)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P4V	(7)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P6V	(8)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_6P8V	(9)
+#define AW87XXX_PID_18_REG_AGC1_PO_6P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_6P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7V	(10)
+#define AW87XXX_PID_18_REG_AGC1_PO_7V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P2V	(11)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P2V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P2V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P4V	(12)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P4V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P4V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P6V	(13)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P6V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P6V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_7P8V	(14)
+#define AW87XXX_PID_18_REG_AGC1_PO_7P8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_7P8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_8V	(15)
+#define AW87XXX_PID_18_REG_AGC1_PO_8V_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_PO_8V << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_PO_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_18_REG_AGC1_PO_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_PO_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_PO_START_BIT)
+
+/* REG_AGC1_AT bit 2:1 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_AGC1_AT_START_BIT	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_AGC1_AT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_AT_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_AT_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP	(0)
+#define AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_0P48MS_0P02MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_0P96MS_0P04MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP	(2)
+#define AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_1P92MS_0P08MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP	(3)
+#define AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_AT_3P84MS_0P16MSSTEP << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_AT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_AGC1_AT_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_AT_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_AT_START_BIT)
+
+/* REG_PD_AGC1 bit 0 (A1PARAM 0x0A) */
+#define AW87XXX_PID_18_REG_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC_VALUE	\
+	(AW87XXX_PID_18_REG_PD_AGC1_ENABLE_FASTEST_LEVEL_AGC << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC	(1)
+#define AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC_VALUE	\
+	(AW87XXX_PID_18_REG_PD_AGC1_DISABLE_FASTEST_LEVEL_AGC << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_AGC1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_AGC1_START_BIT)
+
+/* default value of A1PARAM (0x0A) */
+/* #define AW87XXX_PID_18_A1PARAM_DEFAULT		(0x4A) */
+
+/* POPCLK (0x0B) detail */
+/* REG_DCLK_L bit 7 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_DCLK_L_START_BIT	(7)
+#define AW87XXX_PID_18_REG_DCLK_L_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_DCLK_L_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_DCLK_L_BITS_LEN)-1) << AW87XXX_PID_18_REG_DCLK_L_START_BIT))
+
+#define AW87XXX_PID_18_REG_DCLK_L_30NS	(0)
+#define AW87XXX_PID_18_REG_DCLK_L_30NS_VALUE	\
+	(AW87XXX_PID_18_REG_DCLK_L_30NS << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+#define AW87XXX_PID_18_REG_DCLK_L_45NS	(1)
+#define AW87XXX_PID_18_REG_DCLK_L_45NS_VALUE	\
+	(AW87XXX_PID_18_REG_DCLK_L_45NS << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+#define AW87XXX_PID_18_REG_DCLK_L_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_DCLK_L_DEFAULT	\
+	(AW87XXX_PID_18_REG_DCLK_L_DEFAULT_VALUE << AW87XXX_PID_18_REG_DCLK_L_START_BIT)
+
+/* REG_CLK_MAPD bit 6:5 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_MAPD_START_BIT	(5)
+#define AW87XXX_PID_18_REG_CLK_MAPD_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_MAPD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_MAPD_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_40MS	(0)
+#define AW87XXX_PID_18_REG_CLK_MAPD_40MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_40MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_80MS	(1)
+#define AW87XXX_PID_18_REG_CLK_MAPD_80MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_80MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_160MS	(2)
+#define AW87XXX_PID_18_REG_CLK_MAPD_160MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_160MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_320MS	(3)
+#define AW87XXX_PID_18_REG_CLK_MAPD_320MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_320MS << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_MAPD_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_MAPD_START_BIT)
+
+/* REG_CLK_POP bit 4:3 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_POP_START_BIT	(3)
+#define AW87XXX_PID_18_REG_CLK_POP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_POP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_POP_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_POP_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_POP_40MS	(0)
+#define AW87XXX_PID_18_REG_CLK_POP_40MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_40MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_10MS	(1)
+#define AW87XXX_PID_18_REG_CLK_POP_10MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_10MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_5MS	(2)
+#define AW87XXX_PID_18_REG_CLK_POP_5MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_5MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_2P5MS	(3)
+#define AW87XXX_PID_18_REG_CLK_POP_2P5MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_POP_2P5MS << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_POP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CLK_POP_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_POP_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_POP_START_BIT)
+
+/* REG_CLK_OC bit 2:1 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_CLK_OC_START_BIT	(1)
+#define AW87XXX_PID_18_REG_CLK_OC_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CLK_OC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CLK_OC_BITS_LEN)-1) << AW87XXX_PID_18_REG_CLK_OC_START_BIT))
+
+#define AW87XXX_PID_18_REG_CLK_OC_160MS	(0)
+#define AW87XXX_PID_18_REG_CLK_OC_160MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_160MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_640MS	(1)
+#define AW87XXX_PID_18_REG_CLK_OC_640MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_640MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_1280MS	(2)
+#define AW87XXX_PID_18_REG_CLK_OC_1280MS_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_1280MS << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT	(3)
+#define AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT_VALUE	\
+	(AW87XXX_PID_18_REG_CLK_OC_SHUTDOWN_OUTPUT << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_CLK_OC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CLK_OC_DEFAULT	\
+	(AW87XXX_PID_18_REG_CLK_OC_DEFAULT_VALUE << AW87XXX_PID_18_REG_CLK_OC_START_BIT)
+
+/* REG_AGC1_VTH bit 0 (POPCLK 0x0B) */
+#define AW87XXX_PID_18_REG_AGC1_VTH_START_BIT	(0)
+#define AW87XXX_PID_18_REG_AGC1_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_AGC1_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN	(0)
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_SELECT_ONLY_FROM_RAMP_GEN << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_AGC1_VTH_ADAPTIVELY_SELECT_FROM_RAMP_GEN_AND_THGEN << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_AGC1_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_AGC1_VTH_START_BIT)
+
+/* default value of POPCLK (0x0B) */
+/* #define AW87XXX_PID_18_POPCLK_DEFAULT		(0x21) */
+
+/* GTDRCPSS (0x0C) detail */
+/* REG_TDEAD bit 5 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_TDEAD_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TDEAD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TDEAD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TDEAD_BITS_LEN)-1) << AW87XXX_PID_18_REG_TDEAD_START_BIT))
+
+#define AW87XXX_PID_18_REG_TDEAD_17NS	(0)
+#define AW87XXX_PID_18_REG_TDEAD_17NS_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_17NS << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_25NS	(1)
+#define AW87XXX_PID_18_REG_TDEAD_25NS_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_25NS << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TDEAD_DEFAULT	\
+	(AW87XXX_PID_18_REG_TDEAD_DEFAULT_VALUE << AW87XXX_PID_18_REG_TDEAD_START_BIT)
+
+/* REG_CZ_35MV bit 4 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_CZ_35MV_START_BIT	(4)
+#define AW87XXX_PID_18_REG_CZ_35MV_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_CZ_35MV_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CZ_35MV_BITS_LEN)-1) << AW87XXX_PID_18_REG_CZ_35MV_START_BIT))
+
+#define AW87XXX_PID_18_REG_CZ_35MV_25MV	(0)
+#define AW87XXX_PID_18_REG_CZ_35MV_25MV_VALUE	\
+	(AW87XXX_PID_18_REG_CZ_35MV_25MV << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+#define AW87XXX_PID_18_REG_CZ_35MV_35MV	(1)
+#define AW87XXX_PID_18_REG_CZ_35MV_35MV_VALUE	\
+	(AW87XXX_PID_18_REG_CZ_35MV_35MV << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+#define AW87XXX_PID_18_REG_CZ_35MV_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CZ_35MV_DEFAULT	\
+	(AW87XXX_PID_18_REG_CZ_35MV_DEFAULT_VALUE << AW87XXX_PID_18_REG_CZ_35MV_START_BIT)
+
+/* BIT_CTRL bit 3 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_BIT_CTRL_START_BIT	(3)
+#define AW87XXX_PID_18_BIT_CTRL_BITS_LEN	(1)
+#define AW87XXX_PID_18_BIT_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_18_BIT_CTRL_BITS_LEN)-1) << AW87XXX_PID_18_BIT_CTRL_START_BIT))
+
+#define AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM	(0)
+#define AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_18_BIT_CTRL_32_STEP_SPREAD_SPECTRUM << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+#define AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM	(1)
+#define AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_18_BIT_CTRL_14_STEP_SPREAD_SPECTRUM << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+#define AW87XXX_PID_18_BIT_CTRL_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_BIT_CTRL_DEFAULT	\
+	(AW87XXX_PID_18_BIT_CTRL_DEFAULT_VALUE << AW87XXX_PID_18_BIT_CTRL_START_BIT)
+
+/* SS_EXCH bit 2 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_SS_EXCH_START_BIT	(2)
+#define AW87XXX_PID_18_SS_EXCH_BITS_LEN	(1)
+#define AW87XXX_PID_18_SS_EXCH_MASK		\
+	(~(((1<<AW87XXX_PID_18_SS_EXCH_BITS_LEN)-1) << AW87XXX_PID_18_SS_EXCH_START_BIT))
+
+#define AW87XXX_PID_18_SS_EXCH_12_RANGE	(0)
+#define AW87XXX_PID_18_SS_EXCH_12_RANGE_VALUE	\
+	(AW87XXX_PID_18_SS_EXCH_12_RANGE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+#define AW87XXX_PID_18_SS_EXCH_6_RANGE	(1)
+#define AW87XXX_PID_18_SS_EXCH_6_RANGE_VALUE	\
+	(AW87XXX_PID_18_SS_EXCH_6_RANGE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+#define AW87XXX_PID_18_SS_EXCH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_SS_EXCH_DEFAULT	\
+	(AW87XXX_PID_18_SS_EXCH_DEFAULT_VALUE << AW87XXX_PID_18_SS_EXCH_START_BIT)
+
+/* REG_ISTART bit 1 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_ISTART_START_BIT	(1)
+#define AW87XXX_PID_18_REG_ISTART_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_ISTART_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_ISTART_BITS_LEN)-1) << AW87XXX_PID_18_REG_ISTART_START_BIT))
+
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA	(0)
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA_VALUE	\
+	(AW87XXX_PID_18_REG_ISTART_IBIAS_WI_46P8NA << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA	(1)
+#define AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA_VALUE	\
+	(AW87XXX_PID_18_REG_ISTART_IBIAS_WI_62P5NA << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+#define AW87XXX_PID_18_REG_ISTART_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_ISTART_DEFAULT	\
+	(AW87XXX_PID_18_REG_ISTART_DEFAULT_VALUE << AW87XXX_PID_18_REG_ISTART_START_BIT)
+
+/* REG_PD_OVPICTRL bit 0 (GTDRCPSS 0x0C) */
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_OVPICTRL_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_DISABLE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE	(1)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_ENABLE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_OVPICTRL_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_OVPICTRL_START_BIT)
+
+/* default value of GTDRCPSS (0x0C) */
+/* #define AW87XXX_PID_18_GTDRCPSS_DEFAULT		(0x08) */
+
+/* MULTI (0x0D) detail */
+/* REG_CP_FREQ bit 7:6 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_CP_FREQ_START_BIT	(6)
+#define AW87XXX_PID_18_REG_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_FREQ_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ	(0)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P8MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ	(1)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P6MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ	(2)
+#define AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_1P4MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ	(3)
+#define AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_CP_FREQ_2P1MHZ << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_FREQ_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_FREQ_START_BIT)
+
+/* REG_EN_OT150 bit 5 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_OT150_START_BIT	(5)
+#define AW87XXX_PID_18_REG_EN_OT150_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_OT150_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_OT150_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_OT150_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_OT150_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OT150_DISABLE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OT150_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OT150_ENABLE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OT150_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_OT150_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_OT150_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_OT150_START_BIT)
+
+/* REG_EN_TEST bit 4 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_TEST_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EN_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_TEST_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_TEST_DISABLE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_TEST_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_TEST_ENABLE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_TEST_START_BIT)
+
+/* REG_EN_CLASSD bit 3 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_CLASSD_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_CLASSD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_CLASSD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_CLASSD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_DISABLE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_ENABLE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_CLASSD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_CLASSD_START_BIT)
+
+/* REG_EN_DEFAULT bit 2 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT	(2)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_DEFAULT_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS	(0)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS_VALUE	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_SELF_DEFINE_THE_SETTINGS << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK	(1)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_USE_THE_DEFAULT_SETTING_IN_THE_SYSCTRL_BLOCK << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_DEFAULT_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_DEFAULT_START_BIT)
+
+/* REG_EN_ESD bit 1 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_ESD_START_BIT	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_ESD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_ESD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_ESD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_ESD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ESD_DISABLE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ESD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_ESD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_ESD_ENABLE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_ESD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_ESD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_ESD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_ESD_START_BIT)
+
+/* REG_EN_MT bit 0 (MULTI 0x0D) */
+#define AW87XXX_PID_18_REG_EN_MT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_EN_MT_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_MT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_MT_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_MT_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_MT_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_MT_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MT_DISABLE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MT_ENBLAE	(1)
+#define AW87XXX_PID_18_REG_EN_MT_ENBLAE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_MT_ENBLAE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_MT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_MT_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_MT_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_MT_START_BIT)
+
+/* default value of MULTI (0x0D) */
+/* #define AW87XXX_PID_18_MULTI_DEFAULT		(0x68) */
+
+/* DFT1 (0x61) detail */
+/* REG_SET_R2 bit 7 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_SET_R2_START_BIT	(7)
+#define AW87XXX_PID_18_REG_SET_R2_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_SET_R2_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_SET_R2_BITS_LEN)-1) << AW87XXX_PID_18_REG_SET_R2_START_BIT))
+
+#define AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH	(0)
+#define AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH_VALUE	\
+	(AW87XXX_PID_18_REG_SET_R2_NOT_LIMIT_THE_HIGH_LEVEL_VTH << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH	(1)
+#define AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH_VALUE	\
+	(AW87XXX_PID_18_REG_SET_R2_LIMIT_THE_HIGH_LEVEL_VTH << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_R2_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_SET_R2_DEFAULT	\
+	(AW87XXX_PID_18_REG_SET_R2_DEFAULT_VALUE << AW87XXX_PID_18_REG_SET_R2_START_BIT)
+
+/* REG_CP_ISOFT bit 6:5 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_CP_ISOFT_START_BIT	(5)
+#define AW87XXX_PID_18_REG_CP_ISOFT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_ISOFT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_ISOFT_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P2A	(0)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P2A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P2A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P3A	(1)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P3A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P3A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P4A	(2)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P4A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P4A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P5A	(3)
+#define AW87XXX_PID_18_REG_CP_ISOFT_0P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_0P5A << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_ISOFT_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_ISOFT_START_BIT)
+
+/* REG_CP_IPEAK bit 4:2 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_CP_IPEAK_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_IPEAK_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_CP_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_IPEAK_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_2A	(0)
+#define AW87XXX_PID_18_REG_CP_IPEAK_2A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_2A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_2P5A	(1)
+#define AW87XXX_PID_18_REG_CP_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_2P5A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_3A	(2)
+#define AW87XXX_PID_18_REG_CP_IPEAK_3A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_3A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_3P5A	(3)
+#define AW87XXX_PID_18_REG_CP_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_3P5A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_4A	(4)
+#define AW87XXX_PID_18_REG_CP_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_4A << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_IPEAK_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_IPEAK_START_BIT)
+
+/* REG_SET_OCDT bit 1:0 (DFT1 0x61) */
+#define AW87XXX_PID_18_REG_SET_OCDT_START_BIT	(0)
+#define AW87XXX_PID_18_REG_SET_OCDT_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_SET_OCDT_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_SET_OCDT_BITS_LEN)-1) << AW87XXX_PID_18_REG_SET_OCDT_START_BIT))
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P1A	(0)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P1A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P1A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P5A	(1)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P5A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P5A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_4P9A	(2)
+#define AW87XXX_PID_18_REG_SET_OCDT_4P9A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_4P9A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_5P3A	(3)
+#define AW87XXX_PID_18_REG_SET_OCDT_5P3A_VALUE	\
+	(AW87XXX_PID_18_REG_SET_OCDT_5P3A << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+#define AW87XXX_PID_18_REG_SET_OCDT_DEFAULT_VALUE	(0X2)
+#define AW87XXX_PID_18_REG_SET_OCDT_DEFAULT	\
+	(AW87XXX_PID_18_REG_SET_OCDT_DEFAULT_VALUE << AW87XXX_PID_18_REG_SET_OCDT_START_BIT)
+
+/* default value of DFT1 (0x61) */
+/* #define AW87XXX_PID_18_DFT1_DEFAULT		(0xA6) */
+
+/* DFT2 (0x62) detail */
+/* REG_CP_TEST bit 7 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_CP_TEST_START_BIT	(7)
+#define AW87XXX_PID_18_REG_CP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_CP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_TEST_DISABLE	(0)
+#define AW87XXX_PID_18_REG_CP_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_CP_TEST_DISABLE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_TEST_ENABLE	(1)
+#define AW87XXX_PID_18_REG_CP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_CP_TEST_ENABLE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CP_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_TEST_START_BIT)
+
+/* REG_VFAGC bit 6:4 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_VFAGC_START_BIT	(4)
+#define AW87XXX_PID_18_REG_VFAGC_BITS_LEN	(3)
+#define AW87XXX_PID_18_REG_VFAGC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_VFAGC_BITS_LEN)-1) << AW87XXX_PID_18_REG_VFAGC_START_BIT))
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD	(0)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P775VDDVREF_FAGC_VHYS0P7VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD	(1)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P8VDDVREF_FAGC_VHYS0P725VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD	(2)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P825VDDVREF_FAGC_VHYS0P75VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD	(3)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P85VDDVREF_FAGC_VHYS0P775VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD	(4)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P875VDDVREF_FAGC_VHYS0P8VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD	(5)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P9VDDVREF_FAGC_VHYS0P825VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD	(6)
+#define AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_VREF_FAGC0P925VDDVREF_FAGC_VHYS0P85VDD << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_001	(7)
+#define AW87XXX_PID_18_REG_VFAGC_001_VALUE	\
+	(AW87XXX_PID_18_REG_VFAGC_001 << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_VFAGC_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_VFAGC_DEFAULT	\
+	(AW87XXX_PID_18_REG_VFAGC_DEFAULT_VALUE << AW87XXX_PID_18_REG_VFAGC_START_BIT)
+
+/* REG_CP_OVP_TEST bit 3:2 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_CP_OVP_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_8P7V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V	(1)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P0V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V	(2)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P20V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V	(3)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V_VALUE	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_9P5V << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_CP_OVP_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_CP_OVP_TEST_START_BIT)
+
+/* REG_PAVG bit 1:0 (DFT2 0x62) */
+#define AW87XXX_PID_18_REG_PAVG_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PAVG_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_PAVG_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PAVG_BITS_LEN)-1) << AW87XXX_PID_18_REG_PAVG_START_BIT))
+
+#define AW87XXX_PID_18_REG_PAVG_PO0P94	(0)
+#define AW87XXX_PID_18_REG_PAVG_PO0P94_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO0P94 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_PO1		(1)
+#define AW87XXX_PID_18_REG_PAVG_PO1_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO1 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_PO1P06	(2)
+#define AW87XXX_PID_18_REG_PAVG_PO1P06_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_PO1P06 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_TURN_TO_10	(3)
+#define AW87XXX_PID_18_REG_PAVG_TURN_TO_10_VALUE	\
+	(AW87XXX_PID_18_REG_PAVG_TURN_TO_10 << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+#define AW87XXX_PID_18_REG_PAVG_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_PAVG_DEFAULT	\
+	(AW87XXX_PID_18_REG_PAVG_DEFAULT_VALUE << AW87XXX_PID_18_REG_PAVG_START_BIT)
+
+/* default value of DFT2 (0x62) */
+/* #define AW87XXX_PID_18_DFT2_DEFAULT		(0x11) */
+
+/* DFT3 (0x63) detail */
+/* REG_TDEAD_CP bit 7 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_TDEAD_CP_START_BIT	(7)
+#define AW87XXX_PID_18_REG_TDEAD_CP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TDEAD_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TDEAD_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG	(0)
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_SETTIG << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME	(1)
+#define AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME_VALUE	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_ENLARGE_THE_DEAD_TIME << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_TDEAD_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_TDEAD_CP_START_BIT)
+
+/* REG_EN_EXPVDD bit 6 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT	(6)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_EXPVDD_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_DISABLE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_ENABLE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_EXPVDD_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_EXPVDD_START_BIT)
+
+/* REG_TM_MADP bit 5 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_TM_MADP_START_BIT	(5)
+#define AW87XXX_PID_18_REG_TM_MADP_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_TM_MADP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TM_MADP_BITS_LEN)-1) << AW87XXX_PID_18_REG_TM_MADP_START_BIT))
+
+#define AW87XXX_PID_18_REG_TM_MADP_DISABLE	(0)
+#define AW87XXX_PID_18_REG_TM_MADP_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_TM_MADP_DISABLE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TM_MADP_ENABLE	(1)
+#define AW87XXX_PID_18_REG_TM_MADP_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_TM_MADP_ENABLE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+#define AW87XXX_PID_18_REG_TM_MADP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TM_MADP_DEFAULT	\
+	(AW87XXX_PID_18_REG_TM_MADP_DEFAULT_VALUE << AW87XXX_PID_18_REG_TM_MADP_START_BIT)
+
+/* REG_PD_UVLO bit 4 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_PD_UVLO_START_BIT	(4)
+#define AW87XXX_PID_18_REG_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_PD_UVLO_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_18_REG_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_UVLO_ENABLE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_18_REG_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_UVLO_DISABLE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_UVLO_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_UVLO_START_BIT)
+
+/* REG_UVLO_VTH bit 3:2 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_UVLO_VTH_START_BIT	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V	(0)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P6V2P5V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V	(1)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P7V2P6V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V	(2)
+#define AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_2P5V2P4V << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00	(3)
+#define AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00_VALUE	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_TURN_TO_00 << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_18_REG_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_18_REG_UVLO_VTH_START_BIT)
+
+/* REG_PD_CRS0 bit 1:0 (DFT3 0x63) */
+#define AW87XXX_PID_18_REG_PD_CRS0_START_BIT	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_PD_CRS0_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_PD_CRS0_BITS_LEN)-1) << AW87XXX_PID_18_REG_PD_CRS0_START_BIT))
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_ENABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE	(1)
+#define AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_BOTH_AGC2_AND_AGC3_CROSS_ZERO_ENABLE_AGC1_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE	(2)
+#define AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ONLY_AGC3_CROSS_ZERO_ENABLE_AGC1_AND_AGC2_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE	(3)
+#define AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_PD_CRS0_ALL_OF_AGC1_AGC2_AND_AGC3_CROSS_ZERO_DISABLE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+#define AW87XXX_PID_18_REG_PD_CRS0_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_PD_CRS0_DEFAULT	\
+	(AW87XXX_PID_18_REG_PD_CRS0_DEFAULT_VALUE << AW87XXX_PID_18_REG_PD_CRS0_START_BIT)
+
+/* default value of DFT3 (0x63) */
+/* #define AW87XXX_PID_18_DFT3_DEFAULT		(0x00) */
+
+/* DFT4 (0x64) detail */
+/* REG_DEGLITCH_CP bit 7:6 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT	(6)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_DEGLITCH_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_3NS	(0)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_3NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_3NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_5NS	(1)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_5NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_5NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_1NS	(2)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_1NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_1NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_0NS	(3)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_0NS_VALUE	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_0NS << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_DEGLITCH_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_DEGLITCH_CP_START_BIT)
+
+/* REG_EDGE_CP bit 5:4 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_EDGE_CP_START_BIT	(4)
+#define AW87XXX_PID_18_REG_EDGE_CP_BITS_LEN	(2)
+#define AW87XXX_PID_18_REG_EDGE_CP_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EDGE_CP_BITS_LEN)-1) << AW87XXX_PID_18_REG_EDGE_CP_START_BIT))
+
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS	(0)
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_14P8NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS	(1)
+#define AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_MODERATE_13P5NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS	(2)
+#define AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_SLOWEST_19P3NS << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00	(3)
+#define AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00_VALUE	\
+	(AW87XXX_PID_18_REG_EDGE_CP_FASTEST_4P6NS00 << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_EDGE_CP_DEFAULT	\
+	(AW87XXX_PID_18_REG_EDGE_CP_DEFAULT_VALUE << AW87XXX_PID_18_REG_EDGE_CP_START_BIT)
+
+/* REG_TESTSEL bit 3:0 (DFT4 0x64) */
+#define AW87XXX_PID_18_REG_TESTSEL_START_BIT	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_TESTSEL_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_TESTSEL_BITS_LEN)-1) << AW87XXX_PID_18_REG_TESTSEL_START_BIT))
+
+#define AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VBG_FROM_BIAS << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP	(1)
+#define AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VCOM1_FROM_PREAMP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP	(2)
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VREF_AGC_FROM_RAMP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN	(3)
+#define AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_VREF_ADP_FROM_THGEN << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OC	(4)
+#define AW87XXX_PID_18_REG_TESTSEL_OC_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OC << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OT160	(5)
+#define AW87XXX_PID_18_REG_TESTSEL_OT160_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OT160 << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_UVLO	(6)
+#define AW87XXX_PID_18_REG_TESTSEL_UVLO_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_UVLO << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER	(7)
+#define AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT_P_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER	(8)
+#define AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT_N_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER	(9)
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT1_P_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER	(10)
+#define AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_GT1_N_TEST_FROM_GATEDRIVER << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP	(11)
+#define AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OVP0_TEST_FROM_OVP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP	(12)
+#define AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_OVP1_TEST_FROM_OVP << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN	(13)
+#define AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN_VALUE	\
+	(AW87XXX_PID_18_REG_TESTSEL_PORN_TEST_FROM_PORN << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+#define AW87XXX_PID_18_REG_TESTSEL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_TESTSEL_DEFAULT	\
+	(AW87XXX_PID_18_REG_TESTSEL_DEFAULT_VALUE << AW87XXX_PID_18_REG_TESTSEL_START_BIT)
+
+/* default value of DFT4 (0x64) */
+/* #define AW87XXX_PID_18_DFT4_DEFAULT		(0x00) */
+
+/* DFT5 (0x65) detail */
+/* FCLK_CS bit 5 (DFT5 0x65) */
+#define AW87XXX_PID_18_FCLK_CS_START_BIT	(5)
+#define AW87XXX_PID_18_FCLK_CS_BITS_LEN	(1)
+#define AW87XXX_PID_18_FCLK_CS_MASK		\
+	(~(((1<<AW87XXX_PID_18_FCLK_CS_BITS_LEN)-1) << AW87XXX_PID_18_FCLK_CS_START_BIT))
+
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART	(0)
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART_VALUE	\
+	(AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNALCLK_PA_FROM_THE_ANALOG_PART << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING	(1)
+#define AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING_VALUE	\
+	(AW87XXX_PID_18_FCLK_CS_CHOOSE_THE_CLOCK_SIGNAL_GENERATED_BY_DIGITAL_PART_THEN_WRITE_0XA5_TO_THE_0X66_REGISTORGENERATE_A_PULSE_AFTER_EACH_WRITING << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+#define AW87XXX_PID_18_FCLK_CS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_FCLK_CS_DEFAULT	\
+	(AW87XXX_PID_18_FCLK_CS_DEFAULT_VALUE << AW87XXX_PID_18_FCLK_CS_START_BIT)
+
+/* REG_OT_TEST bit 4 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_OT_TEST_START_BIT	(4)
+#define AW87XXX_PID_18_REG_OT_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_OT_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_OT_TEST_BITS_LEN)-1) << AW87XXX_PID_18_REG_OT_TEST_START_BIT))
+
+#define AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK	(0)
+#define AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_OT_TEST_DISABLE_NOT_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK	(1)
+#define AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK_VALUE	\
+	(AW87XXX_PID_18_REG_OT_TEST_ENABLE_TO_TRANSFER_THE_OTN_TO_THE_TEST_BLOCK << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_18_REG_OT_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_OT_TEST_DEFAULT	\
+	(AW87XXX_PID_18_REG_OT_TEST_DEFAULT_VALUE << AW87XXX_PID_18_REG_OT_TEST_START_BIT)
+
+/* REG_EN_OC bit 3 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_EN_OC_START_BIT	(3)
+#define AW87XXX_PID_18_REG_EN_OC_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_EN_OC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_EN_OC_BITS_LEN)-1) << AW87XXX_PID_18_REG_EN_OC_START_BIT))
+
+#define AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0	(0)
+#define AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OC_TURN_OFF_THE_OC_BLOCK_FORCE_0C0 << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION	(1)
+#define AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION_VALUE	\
+	(AW87XXX_PID_18_REG_EN_OC_TURN_ON_THE_OC_BLOCK_FUNCTION << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+#define AW87XXX_PID_18_REG_EN_OC_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_18_REG_EN_OC_DEFAULT	\
+	(AW87XXX_PID_18_REG_EN_OC_DEFAULT_VALUE << AW87XXX_PID_18_REG_EN_OC_START_BIT)
+
+/* EN_RD bit 2 (DFT5 0x65) */
+#define AW87XXX_PID_18_EN_RD_START_BIT	(2)
+#define AW87XXX_PID_18_EN_RD_BITS_LEN	(1)
+#define AW87XXX_PID_18_EN_RD_MASK		\
+	(~(((1<<AW87XXX_PID_18_EN_RD_BITS_LEN)-1) << AW87XXX_PID_18_EN_RD_START_BIT))
+
+#define AW87XXX_PID_18_EN_RD_DISABLE	(0)
+#define AW87XXX_PID_18_EN_RD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_EN_RD_DISABLE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+#define AW87XXX_PID_18_EN_RD_ENABLE		(1)
+#define AW87XXX_PID_18_EN_RD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_EN_RD_ENABLE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+#define AW87XXX_PID_18_EN_RD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_EN_RD_DEFAULT	\
+	(AW87XXX_PID_18_EN_RD_DEFAULT_VALUE << AW87XXX_PID_18_EN_RD_START_BIT)
+
+/* REG_FAST_VFAGC bit 1 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FAST_VFAGC_BITS_LEN)-1) << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT))
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE	(0)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_DISABLE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE	(1)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_ENABLE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT	\
+	(AW87XXX_PID_18_REG_FAST_VFAGC_DEFAULT_VALUE << AW87XXX_PID_18_REG_FAST_VFAGC_START_BIT)
+
+/* REG_FAST_HVDD bit 0 (DFT5 0x65) */
+#define AW87XXX_PID_18_REG_FAST_HVDD_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_BITS_LEN	(1)
+#define AW87XXX_PID_18_REG_FAST_HVDD_MASK	\
+	(~(((1<<AW87XXX_PID_18_REG_FAST_HVDD_BITS_LEN)-1) << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT))
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_DISABLE	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_DISABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_DISABLE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_ENABLE	(1)
+#define AW87XXX_PID_18_REG_FAST_HVDD_ENABLE_VALUE	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_ENABLE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+#define AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT	\
+	(AW87XXX_PID_18_REG_FAST_HVDD_DEFAULT_VALUE << AW87XXX_PID_18_REG_FAST_HVDD_START_BIT)
+
+/* default value of DFT5 (0x65) */
+/* #define AW87XXX_PID_18_DFT5_DEFAULT		(0x08) */
+
+/* DFT6 (0x66) detail */
+/* Q_SHDN bit 7:4 (DFT6 0x66) */
+#define AW87XXX_PID_18_Q_SHDN_START_BIT	(4)
+#define AW87XXX_PID_18_Q_SHDN_BITS_LEN	(4)
+#define AW87XXX_PID_18_Q_SHDN_MASK		\
+	(~(((1<<AW87XXX_PID_18_Q_SHDN_BITS_LEN)-1) << AW87XXX_PID_18_Q_SHDN_START_BIT))
+
+#define AW87XXX_PID_18_Q_SHDN_MODE1		(0)
+#define AW87XXX_PID_18_Q_SHDN_MODE1_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE1 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE2		(1)
+#define AW87XXX_PID_18_Q_SHDN_MODE2_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE2 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE3		(2)
+#define AW87XXX_PID_18_Q_SHDN_MODE3_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE3 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE4		(3)
+#define AW87XXX_PID_18_Q_SHDN_MODE4_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE4 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE5		(4)
+#define AW87XXX_PID_18_Q_SHDN_MODE5_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE5 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE6		(5)
+#define AW87XXX_PID_18_Q_SHDN_MODE6_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE6 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE7		(6)
+#define AW87XXX_PID_18_Q_SHDN_MODE7_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE7 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE8		(7)
+#define AW87XXX_PID_18_Q_SHDN_MODE8_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE8 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE9		(8)
+#define AW87XXX_PID_18_Q_SHDN_MODE9_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE9 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_MODE10	(9)
+#define AW87XXX_PID_18_Q_SHDN_MODE10_VALUE	\
+	(AW87XXX_PID_18_Q_SHDN_MODE10 << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+#define AW87XXX_PID_18_Q_SHDN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_18_Q_SHDN_DEFAULT	\
+	(AW87XXX_PID_18_Q_SHDN_DEFAULT_VALUE << AW87XXX_PID_18_Q_SHDN_START_BIT)
+
+/* REG_FSS bit 3:0 (DFT6 0x66) */
+#define AW87XXX_PID_18_REG_FSS_START_BIT	(0)
+#define AW87XXX_PID_18_REG_FSS_BITS_LEN	(4)
+#define AW87XXX_PID_18_REG_FSS_MASK		\
+	(~(((1<<AW87XXX_PID_18_REG_FSS_BITS_LEN)-1) << AW87XXX_PID_18_REG_FSS_START_BIT))
+
+#define AW87XXX_PID_18_REG_FSS_1P408MHZ	(0)
+#define AW87XXX_PID_18_REG_FSS_1P408MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P408MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P432MHZ	(1)
+#define AW87XXX_PID_18_REG_FSS_1P432MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P432MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P456MHZ	(3)
+#define AW87XXX_PID_18_REG_FSS_1P456MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P456MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P48MHZ	(2)
+#define AW87XXX_PID_18_REG_FSS_1P48MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P48MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P504MHZ	(6)
+#define AW87XXX_PID_18_REG_FSS_1P504MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P504MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P528MHZ	(7)
+#define AW87XXX_PID_18_REG_FSS_1P528MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P528MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P552MHZ	(5)
+#define AW87XXX_PID_18_REG_FSS_1P552MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P552MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P576MHZ	(4)
+#define AW87XXX_PID_18_REG_FSS_1P576MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P576MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P6MHZ	(12)
+#define AW87XXX_PID_18_REG_FSS_1P6MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P6MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P627MHZ	(13)
+#define AW87XXX_PID_18_REG_FSS_1P627MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P627MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P655MHZ	(15)
+#define AW87XXX_PID_18_REG_FSS_1P655MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P655MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P682MHZ	(14)
+#define AW87XXX_PID_18_REG_FSS_1P682MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P682MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P71MHZ	(10)
+#define AW87XXX_PID_18_REG_FSS_1P71MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P71MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P737MHZ	(11)
+#define AW87XXX_PID_18_REG_FSS_1P737MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P737MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P765MHZ	(9)
+#define AW87XXX_PID_18_REG_FSS_1P765MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P765MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_1P792MHZ	(8)
+#define AW87XXX_PID_18_REG_FSS_1P792MHZ_VALUE	\
+	(AW87XXX_PID_18_REG_FSS_1P792MHZ << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+#define AW87XXX_PID_18_REG_FSS_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_18_REG_FSS_DEFAULT	\
+	(AW87XXX_PID_18_REG_FSS_DEFAULT_VALUE << AW87XXX_PID_18_REG_FSS_START_BIT)
+
+/* default value of DFT6 (0x66) */
+/* #define AW87XXX_PID_18_DFT6_DEFAULT		(0x0C) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_18_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
new file mode 100644
index 000000000000..0dfd9751c39e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_39_reg.h
@@ -0,0 +1,67 @@
+#ifndef __AW87XXX_PID_39_REG_H__
+#define __AW87XXX_PID_39_REG_H__
+
+#define AW87XXX_PID_39_REG_CHIPID		(0x00)
+#define AW87XXX_PID_39_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_39_REG_MODECTRL		(0x02)
+#define AW87XXX_PID_39_REG_CPOVP		(0x03)
+#define AW87XXX_PID_39_REG_CPP			(0x04)
+#define AW87XXX_PID_39_REG_GAIN			(0x05)
+#define AW87XXX_PID_39_REG_AGC3_PO		(0x06)
+#define AW87XXX_PID_39_REG_AGC3			(0x07)
+#define AW87XXX_PID_39_REG_AGC2_PO		(0x08)
+#define AW87XXX_PID_39_REG_AGC2			(0x09)
+#define AW87XXX_PID_39_REG_AGC1			(0x0A)
+#define AW87XXX_PID_39_REG_DFT1			(0x62)
+#define AW87XXX_PID_39_REG_DFT2			(0x63)
+#define AW87XXX_PID_39_REG_ENCRY		(0x64)
+
+#define AW87XXX_PID_39_MODECTRL_DEFAULT		(0xa0)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_39_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_39_REG_MAX			(0x65)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_39_reg_access[AW87XXX_PID_39_REG_MAX] = {
+	[AW87XXX_PID_39_REG_CHIPID]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_MODECTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_CPOVP]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_CPP]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_GAIN]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC3_PO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC3]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC2_PO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC2]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_AGC1]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_39_REG_DFT1]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_DFT2]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_39_REG_ENCRY]	= (REG_RD_ACCESS),
+};
+
+/* RCV_MODE bit 3 (MODECTRL 0x02) */
+#define AW87XXX_PID_39_REC_MODE_START_BIT	(3)
+#define AW87XXX_PID_39_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_39_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_39_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_39_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_39_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_39_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_39_REC_MODE_DISABLE << AW87XXX_PID_39_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_39_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_39_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_39_REC_MODE_ENABLE << AW87XXX_PID_39_REC_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
new file mode 100644
index 000000000000..67f73477b892
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_3x9_reg.h
@@ -0,0 +1,93 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_59_3X9_REG
+ * @version: V1.33
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_59_3X9_REG_H__
+#define __AW87XXX_PID_59_3X9_REG_H__
+
+#define AW87XXX_PID_59_3X9_REG_CHIPID		(0x00)
+#define AW87XXX_PID_59_3X9_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_59_3X9_REG_MDCRTL		(0x02)
+#define AW87XXX_PID_59_3X9_REG_CPOVP		(0x03)
+#define AW87XXX_PID_59_3X9_REG_CPP		(0x04)
+#define AW87XXX_PID_59_3X9_REG_PAG		(0x05)
+#define AW87XXX_PID_59_3X9_REG_AGC3PO		(0x06)
+#define AW87XXX_PID_59_3X9_REG_AGC3PA		(0x07)
+#define AW87XXX_PID_59_3X9_REG_AGC2PO		(0x08)
+#define AW87XXX_PID_59_3X9_REG_AGC2PA		(0x09)
+#define AW87XXX_PID_59_3X9_REG_AGC1PA		(0x0A)
+#define AW87XXX_PID_59_3X9_REG_SYSST		(0x59)
+#define AW87XXX_PID_59_3X9_REG_SYSINT		(0x60)
+#define AW87XXX_PID_59_3X9_REG_DFT_SYSCTRL	(0x61)
+#define AW87XXX_PID_59_3X9_REG_DFT_MDCTRL	(0x62)
+#define AW87XXX_PID_59_3X9_REG_DFT_CPOVP2	(0x63)
+#define AW87XXX_PID_59_3X9_REG_DFT_AGCPA	(0x64)
+#define AW87XXX_PID_59_3X9_REG_DFT_POFR		(0x65)
+#define AW87XXX_PID_59_3X9_REG_DFT_OC		(0x66)
+#define AW87XXX_PID_59_3X9_REG_DFT_OTA		(0x67)
+#define AW87XXX_PID_59_3X9_REG_DFT_REF		(0x68)
+#define AW87XXX_PID_59_3X9_REG_DFT_LDO		(0x69)
+#define AW87XXX_PID_59_3X9_REG_ENCR		(0x70)
+
+#define AW87XXX_PID_59_3X9_ENCR_DEFAULT		(0x00)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_59_3x9_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_59_3X9_REG_MAX			(0x71)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_59_3x9_reg_access[AW87XXX_PID_59_3X9_REG_MAX] = {
+	[AW87XXX_PID_59_3X9_REG_CHIPID]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_MDCRTL]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_CPOVP]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_CPP]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_PAG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC3PO]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC3PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC2PO]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC2PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_AGC1PA]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSST]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_SYSINT]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_MDCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_CPOVP2]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_AGCPA]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_POFR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_OC]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_OTA]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_REF]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_DFT_LDO]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_3X9_REG_ENCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* SPK_MODE bit 2 (MDCRTL 0x02) */
+#define AW87XXX_PID_59_3X9_SPK_MODE_START_BIT	(2)
+#define AW87XXX_PID_59_3X9_SPK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_59_3X9_SPK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_59_3X9_SPK_MODE_BITS_LEN)-1) << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT))
+
+#define AW87XXX_PID_59_3X9_SPK_MODE_DISABLE	(0)
+#define AW87XXX_PID_59_3X9_SPK_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_59_3X9_SPK_MODE_DISABLE << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT)
+
+#define AW87XXX_PID_59_3X9_SPK_MODE_ENABLE	(1)
+#define AW87XXX_PID_59_3X9_SPK_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_59_3X9_SPK_MODE_ENABLE << AW87XXX_PID_59_3X9_SPK_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
new file mode 100644
index 000000000000..6a0cae4c49ac
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_59_5x9_reg.h
@@ -0,0 +1,94 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_59_5X9_REG
+ * @version: V1.33
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_59_5X9_REG_H__
+#define __AW87XXX_PID_59_5X9_REG_H__
+
+
+#define AW87XXX_PID_59_5X9_REG_CHIPID		(0x00)
+#define AW87XXX_PID_59_5X9_REG_SYSCTRL		(0x01)
+#define AW87XXX_PID_59_5X9_REG_BATSAFE		(0x02)
+#define AW87XXX_PID_59_5X9_REG_BSTOVR		(0x03)
+#define AW87XXX_PID_59_5X9_REG_BSTVPR		(0x04)
+#define AW87XXX_PID_59_5X9_REG_PAGR		(0x05)
+#define AW87XXX_PID_59_5X9_REG_PAGC3OPR		(0x06)
+#define AW87XXX_PID_59_5X9_REG_PAGC3PR		(0x07)
+#define AW87XXX_PID_59_5X9_REG_PAGC2OPR		(0x08)
+#define AW87XXX_PID_59_5X9_REG_PAGC2PR		(0x09)
+#define AW87XXX_PID_59_5X9_REG_PAGC1PR		(0x0A)
+#define AW87XXX_PID_59_5X9_REG_SYSST		(0x58)
+#define AW87XXX_PID_59_5X9_REG_SYSINT		(0x59)
+#define AW87XXX_PID_59_5X9_REG_CPCR		(0x60)
+#define AW87XXX_PID_59_5X9_REG_DFT1R		(0x61)
+#define AW87XXX_PID_59_5X9_REG_DFT2R		(0x62)
+#define AW87XXX_PID_59_5X9_REG_DFT3R		(0x63)
+#define AW87XXX_PID_59_5X9_REG_DFT4R		(0x64)
+#define AW87XXX_PID_59_5X9_REG_DFT5R		(0x65)
+#define AW87XXX_PID_59_5X9_REG_DFT6R		(0x66)
+#define AW87XXX_PID_59_5X9_REG_DFT7R		(0x67)
+#define AW87XXX_PID_59_5X9_REG_DFT8R		(0x68)
+#define AW87XXX_PID_59_5X9_REG_ENCR		(0x69)
+
+#define AW87XXX_PID_59_5X9_ENCRY_DEFAULT	(0x00)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_59_5x9_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_59_5X9_REG_MAX			(0x70)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_59_5x9_reg_access[AW87XXX_PID_59_5X9_REG_MAX] = {
+	[AW87XXX_PID_59_5X9_REG_CHIPID]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSCTRL]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BATSAFE]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BSTOVR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_BSTVPR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC3OPR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC3PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC2OPR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC2PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_PAGC1PR]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSST]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_SYSINT]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_CPCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT1R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT2R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT3R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT4R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT5R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT6R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT7R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_DFT8R]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_59_5X9_REG_ENCR]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* RCV_MODE bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_59_5X9_REC_MODE_START_BIT	(3)
+#define AW87XXX_PID_59_5X9_REC_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_59_5X9_REC_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_59_5X9_REC_MODE_BITS_LEN)-1) << AW87XXX_PID_59_5X9_REC_MODE_START_BIT))
+
+#define AW87XXX_PID_59_5X9_REC_MODE_DISABLE	(0)
+#define AW87XXX_PID_59_5X9_REC_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_59_5X9_REC_MODE_DISABLE << AW87XXX_PID_59_5X9_REC_MODE_START_BIT)
+
+#define AW87XXX_PID_59_5X9_REC_MODE_ENABLE	(1)
+#define AW87XXX_PID_59_5X9_REC_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_59_5X9_REC_MODE_ENABLE << AW87XXX_PID_59_5X9_REC_MODE_START_BIT)
+
+#endif
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
new file mode 100644
index 000000000000..020bf5496d01
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_5a_reg.h
@@ -0,0 +1,4124 @@
+/*
+ * @Descripttion: Header file of AW87XXX_PID_5A_REG
+ * @version: V1.4
+ * @Author: zhaozhongbo
+ * @Date: 2021-03-10
+ * @LastEditors: Please set LastEditors
+ * @LastEditTime: 2021-03-10
+ */
+#ifndef __AW87XXX_PID_5A_REG_H__
+#define __AW87XXX_PID_5A_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_5A_REG_ID_REG		(0x00)
+#define AW87XXX_PID_5A_REG_SYSCTRL_REG	(0x01)
+#define AW87XXX_PID_5A_REG_BATSAFE_REG	(0x02)
+#define AW87XXX_PID_5A_REG_BSTOVR_REG	(0x03)
+#define AW87XXX_PID_5A_REG_BSTCPR1_REG	(0x04)
+#define AW87XXX_PID_5A_REG_BSTCPR2_REG	(0x05)
+#define AW87XXX_PID_5A_REG_PAGR_REG		(0x06)
+#define AW87XXX_PID_5A_REG_PAGC3OPR_REG	(0x07)
+#define AW87XXX_PID_5A_REG_PAGC3PR_REG	(0x08)
+#define AW87XXX_PID_5A_REG_PAGC2OPR_REG	(0x09)
+#define AW87XXX_PID_5A_REG_PAGC2PR_REG	(0x0A)
+#define AW87XXX_PID_5A_REG_PAGC1PR_REG	(0x0B)
+#define AW87XXX_PID_5A_REG_ADP_MODE_REG	(0x0C)
+#define AW87XXX_PID_5A_REG_ADPBST_TIME1_REG	(0x0D)
+#define AW87XXX_PID_5A_REG_ADPBST_TIME2_REG	(0x0E)
+#define AW87XXX_PID_5A_REG_ADPBST_VTH_REG	(0x0F)
+#define AW87XXX_PID_5A_REG_BOOST_PAR_REG	(0x10)
+#define AW87XXX_PID_5A_REG_BOOST_VOUT_DET_REG	(0x57)
+#define AW87XXX_PID_5A_REG_SYSST_REG	(0x58)
+#define AW87XXX_PID_5A_REG_SYSINT_REG	(0x59)
+#define AW87XXX_PID_5A_REG_DFT1R_REG	(0x60)
+#define AW87XXX_PID_5A_REG_DFT2R_REG	(0x61)
+#define AW87XXX_PID_5A_REG_DFT3R_REG	(0x62)
+#define AW87XXX_PID_5A_REG_DFT4R_REG	(0x63)
+#define AW87XXX_PID_5A_REG_DFT5R_REG	(0x64)
+#define AW87XXX_PID_5A_REG_DFT6R_REG	(0x65)
+#define AW87XXX_PID_5A_REG_DFT7R_REG	(0x66)
+#define AW87XXX_PID_5A_REG_DFT8R_REG	(0x67)
+#define AW87XXX_PID_5A_REG_DFT9R_REG	(0x68)
+#define AW87XXX_PID_5A_REG_DFTAR_REG	(0x69)
+#define AW87XXX_PID_5A_REG_DFTBR_REG	(0x70)
+#define AW87XXX_PID_5A_REG_DFTCR_REG	(0x71)
+#define AW87XXX_PID_5A_REG_DFTDR_REG	(0x72)
+#define AW87XXX_PID_5A_REG_DFTER_REG	(0x73)
+#define AW87XXX_PID_5A_REG_DFTFR_REG	(0x74)
+#define AW87XXX_PID_5A_REG_test1_REG	(0x75)
+#define AW87XXX_PID_5A_REG_test2_REG	(0x76)
+#define AW87XXX_PID_5A_REG_ENCR_REG	(0x77)
+
+#define AW87XXX_PID_5A_DFT3R_DEFAULT	(0x02)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_5a_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_5A_REG_MAX		(0x78)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_5a_reg_access[AW87XXX_PID_5A_REG_MAX] = {
+	[AW87XXX_PID_5A_REG_ID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BATSAFE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTOVR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTCPR1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BSTCPR2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC3OPR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC3PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC2OPR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC2PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_PAGC1PR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADP_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_TIME1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_TIME2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ADPBST_VTH_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BOOST_PAR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_BOOST_VOUT_DET_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT1R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT2R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT3R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT4R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT5R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT6R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT7R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT8R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFT9R_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTAR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTBR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTER_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_DFTFR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_test1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_test2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_5A_REG_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_5A_REG_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_5A_REG_IDCODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_IDCODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_IDCODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_IDCODE_DEFAULT_VALUE	(0x5A)
+#define AW87XXX_PID_5A_REG_IDCODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_IDCODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_5A_REG_ID_DEFAULT		(0x5A) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_SW bit 6 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_SW_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SW_DISABLE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SW_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SW_ENABLE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SW_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_SW_START_BIT)
+
+/* EN_CP bit 5 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_CP_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_CP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_CP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_CP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_CP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CP_DISABLE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CP_ENABLE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_CP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_CP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_CP_START_BIT)
+
+/* EN_BOOST bit 4 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_DISABLE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_ENABLE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_START_BIT)
+
+/* EN_PA bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_PA_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_PA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_PA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_PA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_PA_DISABLE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_PA_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_PA_ENABLE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_PA_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_PA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_PA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_PA_START_BIT)
+
+/* RCV_MODE bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_RCV_MODE_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_RCV_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_RCV_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RCV_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_RCV_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_DISABLE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_RCV_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_ENABLE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RCV_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RCV_MODE_START_BIT)
+
+/* EN_OVERLOAD bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_OVERLOAD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL	(0)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_DISABL << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_ENABLE << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_OVERLOAD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_OVERLOAD_START_BIT)
+
+/* EN_HVBAT bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HVBAT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_DISABLE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_ENABLE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HVBAT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HVBAT_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_5A_REG_SYSCTRL_DEFAULT		(0x38) */
+
+/* BATSAFE (0x02) detail */
+/* BAT_SFGD_DEGLITCH bit 6:5 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_1MS << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_500US << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_200US << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DISABLE << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_DEGLITCH_START_BIT)
+
+/* BAT_SFGD_VTH bit 4:3 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P3V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P4V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P5V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_3P6V << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_VTH_START_BIT)
+
+/* EN_BAT_SFGD bit 2 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BAT_SFGD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_DISABLE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_ENABLE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BAT_SFGD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BAT_SFGD_START_BIT)
+
+/* BAT_SFGD_LEVEL bit 1:0 (BATSAFE 0x02) */
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V	(0)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V	(1)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_5P5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V	(2)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V	(3)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_6P5V << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT_VALUE	(0x01)
+#define AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BAT_SFGD_LEVEL_START_BIT)
+
+/* default value of BATSAFE (0x02) */
+/* #define AW87XXX_PID_5A_REG_BATSAFE_DEFAULT		(0x09) */
+
+/* BSTOVR (0x03) detail */
+/* BST_VOUT bit 4:0 (BSTOVR 0x03) */
+#define AW87XXX_PID_5A_REG_BST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_BST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_VOUT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P5V	(0)
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_6P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P75V	(1)
+#define AW87XXX_PID_5A_REG_BST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_6P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P0V	(2)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P25V	(3)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P5V	(4)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P75V	(5)
+#define AW87XXX_PID_5A_REG_BST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_7P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P0V	(6)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P25V	(7)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P5V	(8)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P75V	(9)
+#define AW87XXX_PID_5A_REG_BST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_8P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P0V	(10)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P25V	(11)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P5V	(12)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P75V	(13)
+#define AW87XXX_PID_5A_REG_BST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_9P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P0V	(14)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P25V	(15)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P5V	(16)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P75V	(17)
+#define AW87XXX_PID_5A_REG_BST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_10P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P0V	(18)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P25V	(19)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P5V	(20)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P75V	(21)
+#define AW87XXX_PID_5A_REG_BST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_11P75V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P0V	(22)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P0V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P25V	(23)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P25V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P5V	(24)
+#define AW87XXX_PID_5A_REG_BST_VOUT_12P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_12P5V << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_VOUT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_VOUT_START_BIT)
+
+/* default value of BSTOVR (0x03) */
+/* #define AW87XXX_PID_5A_REG_BSTOVR_DEFAULT		(0x0C) */
+
+/* BSTCPR1 (0x04) detail */
+/* BURST_HYS_SELA bit 7 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_HYS_SELA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_3P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_5MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SELA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_HYS_SELA_START_BIT)
+
+/* BST_IPEAK_SS bit 6:5 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_0P8A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_1A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_1P5A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_2A << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_SS_START_BIT)
+
+/* BST_IPEAK_ADJ bit 4 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_IPEAK0P5A << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_ADJ_START_BIT)
+
+/* BST_IPEAK_LOWBAT_EN bit 3 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DISABLE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_ENABLE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+/* BST_IPEAK_LOWBAT bit 2 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P5A << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_2P75A << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_LOWBAT_START_BIT)
+
+/* BURST_HYS_SEL bit 1 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_HYS_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_3P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_5MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_8P3MV << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_HYS_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_HYS_SEL_START_BIT)
+
+/* BURST_MODE bit 0 (BSTCPR1 0x04) */
+#define AW87XXX_PID_5A_REG_BURST_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BURST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE	(0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_PVDD_DECIDE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE	(1)
+#define AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_BUEST_PEAK_DECIDE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_MODE_START_BIT)
+
+/* default value of BSTCPR1 (0x04) */
+/* #define AW87XXX_PID_5A_REG_BSTCPR1_DEFAULT		(0x00) */
+
+/* BSTCPR2 (0x05) detail */
+/* BURST_PEAK bit 5:4 (BSTCPR2 0x05) */
+#define AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BURST_PEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV	(0)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_660MV_HYS_800MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV	(1)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_730MV_HYS_890MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV	(2)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_780MV_HYS_930MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV	(3)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_CLAMP_810MV_HYS_970MV << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BURST_PEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BURST_PEAK_START_BIT)
+
+/* BST_IPEAK bit 3:0 (BSTCPR2 0x05) */
+#define AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_IPEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P5A	(0)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_1P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P75A	(1)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_1P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_1P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2A	(2)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P25A	(3)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P25A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P25A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P5A	(4)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P75A	(5)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_2P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_2P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3A	(6)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P25	(7)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P25_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P25 << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P5A	(8)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P75A	(9)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_3P75A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_3P75A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4A	(10)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P25A	(11)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P25A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4P25A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P5A	(12)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_4P5A_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_4P5A << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT_VALUE	(0x8)
+#define AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_IPEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_IPEAK_START_BIT)
+
+/* default value of BSTCPR2 (0x05) */
+/* #define AW87XXX_PID_5A_REG_BSTCPR2_DEFAULT		(0x08) */
+
+/* PAGR (0x06) detail */
+/* PA_GAIN bit 4:0 (PAGR 0x06) */
+#define AW87XXX_PID_5A_REG_PA_GAIN_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PA_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_PA_GAIN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GAIN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_0DB	(0)
+#define AW87XXX_PID_5A_REG_PA_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_0DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_1P5DB	(1)
+#define AW87XXX_PID_5A_REG_PA_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_1P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_3DB	(2)
+#define AW87XXX_PID_5A_REG_PA_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_3DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_4P5DB	(3)
+#define AW87XXX_PID_5A_REG_PA_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_4P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_6DB	(4)
+#define AW87XXX_PID_5A_REG_PA_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_6DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_7P5DB	(5)
+#define AW87XXX_PID_5A_REG_PA_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_7P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_9DB	(6)
+#define AW87XXX_PID_5A_REG_PA_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_9DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_10P5DB	(7)
+#define AW87XXX_PID_5A_REG_PA_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_10P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_12DB	(8)
+#define AW87XXX_PID_5A_REG_PA_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_12DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_13P5DB	(9)
+#define AW87XXX_PID_5A_REG_PA_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_13P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_15DB	(10)
+#define AW87XXX_PID_5A_REG_PA_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_15DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_16P5DB	(11)
+#define AW87XXX_PID_5A_REG_PA_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_16P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_18DB	(12)
+#define AW87XXX_PID_5A_REG_PA_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_18DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_19P5DB	(13)
+#define AW87XXX_PID_5A_REG_PA_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_19P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_21DB	(14)
+#define AW87XXX_PID_5A_REG_PA_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_21DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_22P5DB	(15)
+#define AW87XXX_PID_5A_REG_PA_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_22P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_24DB	(16)
+#define AW87XXX_PID_5A_REG_PA_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_24DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_25P5DB	(17)
+#define AW87XXX_PID_5A_REG_PA_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_25P5DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_27DB	(18)
+#define AW87XXX_PID_5A_REG_PA_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_27DB << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GAIN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GAIN_START_BIT)
+
+/* default value of PAGR (0x06) */
+/* #define AW87XXX_PID_5A_REG_PAGR_DEFAULT		(0x10) */
+
+/* PAGC3OPR (0x07) detail */
+/* PAVG_ADJ bit 7:5 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PAVG_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO	(0)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_0P94PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO	(1)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_0P97PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO	(2)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P0PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO	(3)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P03PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO	(4)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P06PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO	(5)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO_VALUE	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_1P09PO << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PAVG_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PAVG_ADJ_START_BIT)
+
+/* PD_AGC3 bit 4 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_PD_AGC3_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_PD_AGC3_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC3_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_AGC3_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC3_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_ENABLE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC3_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_DISABLE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_AGC3_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_AGC3_START_BIT)
+
+/* AGC3_OUTPUT_POWER bit 3:0 (PAGC3OPR 0x07) */
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM	(0)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P5W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM	(1)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P6W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM	(2)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P7W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM	(3)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P8W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM	(4)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_0P9W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM	(5)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P0W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM	(6)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P1W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM	(7)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P2W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM	(8)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P3W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM	(9)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P4W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM	(10)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P5W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM	(11)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P6W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM	(12)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P7W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM	(13)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P8W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM	(14)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_1P9W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM	(15)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_2P0W8_OHM << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_OUTPUT_POWER_START_BIT)
+
+/* default value of PAGC3OPR (0x07) */
+/* #define AW87XXX_PID_5A_REG_PAGC3OPR_DEFAULT		(0x43) */
+
+/* PAGC3PR (0x08) detail */
+/* AGC3_REL_TIME bit 7:5 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_REL_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_5P12MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_20P48MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_81P92MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_163P84MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_327P68MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_655P36MSDB << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_REL_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_REL_TIME_START_BIT)
+
+/* AGC3_ATT_TIME bit 4:2 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_1P28MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_2P56MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_82MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_164MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_328MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_656MSDB << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_ATT_TIME_START_BIT)
+
+/* AGC3_FIRST_ATT_TIME bit 1:0 (PAGC3PR 0x08) */
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS	(0)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS	(1)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_10P24MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS	(2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_20P48MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS	(3)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_41MS << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC3_FIRST_ATT_TIME_START_BIT)
+
+/* default value of PAGC3PR (0x08) */
+/* #define AW87XXX_PID_5A_REG_PAGC3PR_DEFAULT		(0x4E) */
+
+/* PAGC2OPR (0x09) detail */
+/* AGC2_OUTPUT_POWER bit 3:0 (PAGC2OPR 0x09) */
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM	(0)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM	(1)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P2W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM	(2)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P4W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM	(3)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P6W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM	(4)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_1P8W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM	(5)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM	(6)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P2W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM	(7)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P4W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM	(8)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P6W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM	(9)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_2P8W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM	(10)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_3P0W8_OHM << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF	(11)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_AGC2_OFF << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_OUTPUT_POWER_START_BIT)
+
+/* default value of PAGC2OPR (0x09) */
+/* #define AW87XXX_PID_5A_REG_PAGC2OPR_DEFAULT		(0x03) */
+
+/* PAGC2PR (0x0A) detail */
+/* AGC2_ATT_TIME bit 4:2 (PAGC2PR 0x0A) */
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P16MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P32MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_0P64MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_2P56MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_10P24MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_40P96MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_82MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_164MSDB << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_ATT_TIME_START_BIT)
+
+/* AGC2_FIRST_ATT_TIME bit 1:0 (PAGC2PR 0x0A) */
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS	(0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P08MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS	(1)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_0P32MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS	(2)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_1P28MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS	(3)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC2_FIRST_ATT_TIME_START_BIT)
+
+/* default value of PAGC2PR (0x0A) */
+/* #define AW87XXX_PID_5A_REG_PAGC2PR_DEFAULT		(0x08) */
+
+/* PAGC1PR (0x0B) detail */
+/* AGC1_OUTPUT_LEVEL bit 6:3 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V	(0)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V	(1)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V	(2)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V	(3)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V	(4)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_5P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V	(5)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P0V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V	(6)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V	(7)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V	(8)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V	(9)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_6P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V	(10)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V	(11)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P2V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V	(12)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P4V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V	(13)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P6V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V	(14)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_7P8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V	(15)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_8V << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_OUTPUT_LEVEL_START_BIT)
+
+/* AGC1_ATT_TIME bit 2:1 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P04MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P08MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P16MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P32MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P02MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P01MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_ATT_TIME_START_BIT)
+
+/* PD_AGC1 bit 0 (PAGC1PR 0x0B) */
+#define AW87XXX_PID_5A_REG_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_ENABLE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_AGC1_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_DISABLE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_AGC1_START_BIT)
+
+/* default value of PAGC1PR (0x0B) */
+/* #define AW87XXX_PID_5A_REG_PAGC1PR_DEFAULT		(0x4A) */
+
+/* ADP_MODE (0x0C) detail */
+/* AGC1_ATT_TIMEA bit 3 (ADP_MODE 0x0C) */
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P04MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB	(1)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P08MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB	(2)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P16MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB	(3)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P32MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB	(4)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P02MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB	(5)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P01MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB	(6)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB	(7)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_0P005MSDB << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_ATT_TIMEA_START_BIT)
+
+/* ADPBOOST_MODE bit 2:0 (ADP_MODE 0x0C) */
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADPBOOST_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH	(0)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_PASS_THROUGH << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST	(1)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_FORCE_BOOST << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1	(2)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD1 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2	(3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3	(4)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD3 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4	(5)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD4 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5	(6)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD5 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2	(7)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2_VALUE	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_MD2 << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADPBOOST_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADPBOOST_MODE_START_BIT)
+
+/* default value of ADP_MODE (0x0C) */
+/* #define AW87XXX_PID_5A_REG_ADP_MODE_DEFAULT		(0x03) */
+
+/* ADPBST_TIME1 (0x0D) detail */
+/* ADP_BST_TIME_2W bit 7:4 (ADPBST_TIME1 0x0D) */
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_1P25MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS	(1)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_2P5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS	(2)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS	(3)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_10MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_15MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS	(5)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_20MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS	(6)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_30MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS	(7)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_40MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS	(8)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_65MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS	(9)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_80MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS	(10)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_100MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS	(11)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_120MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS	(12)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_140MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS	(13)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_160MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS	(14)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_320MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS	(15)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_480MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT_VALUE	(0xD)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BST_TIME_2W_START_BIT)
+
+/* ADP_BST_TIME_0P4W bit 3:0 (ADPBST_TIME1 0x0D) */
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS	(0)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_1P25MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS	(1)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_2P5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS	(2)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_5MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS	(3)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_10MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS	(4)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_15MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS	(5)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_20MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS	(6)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_30MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS	(7)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_40MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS	(8)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_65MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS	(9)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_80MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS	(10)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_100MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS	(11)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_120MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS	(12)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_140MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS	(13)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_160MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS	(14)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_320MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS	(15)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_480MS << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT_VALUE	(0xD)
+#define AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BST_TIME_0P4W_START_BIT)
+
+/* default value of ADPBST_TIME1 (0x0D) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_TIME1_DEFAULT		(0xDD) */
+
+/* ADPBST_TIME2 (0x0E) detail */
+/* BST_UP_DT bit 7:4 (ADPBST_TIME2 0x0E) */
+#define AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_UP_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS	(0)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P005MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS	(1)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P01MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS	(2)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P015MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS	(3)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P02MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS	(4)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P03MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS	(5)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P04MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS	(6)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P05MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS	(7)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P06MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS	(8)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P07MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS	(9)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P08MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS	(10)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P10MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS	(11)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P16MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS	(12)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P20MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS	(13)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P32MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS	(14)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_0P64MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS	(15)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_1P28MS << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT_VALUE	(0x7)
+#define AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_UP_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_UP_DT_START_BIT)
+
+/* BST_DOWN_TD bit 3:0 (ADPBST_TIME2 0x0E) */
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_BITS_LEN	(4)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_DOWN_TD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS	(0)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P01MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS	(1)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P02MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS	(2)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P04MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS	(3)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P08MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS	(4)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P12MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS	(5)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P16MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS	(6)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P24MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS	(7)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P32MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS	(8)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P64MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS	(9)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_0P96MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS	(10)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P28MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS	(11)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P60MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS	(12)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_1P92MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS	(13)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_2P56MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS	(14)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_5P12MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS	(15)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_10P24MS << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT_VALUE	(0xA)
+#define AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_DOWN_TD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_DOWN_TD_START_BIT)
+
+/* default value of ADPBST_TIME2 (0x0E) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_TIME2_DEFAULT		(0x7A) */
+
+/* ADPBST_VTH (0x0F) detail */
+/* ADP_LOW_STEP bit 7:6 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_LOW_STEP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000	(0)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00000 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001	(1)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00001 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010	(2)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00010 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011	(3)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_1ST_BST_OUT00011 << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_LOW_STEP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_LOW_STEP_START_BIT)
+
+/* SET_BOOST_VTH2 bit 5:3 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SET_BOOST_VTH2_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W	(1)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W	(2)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_1P8W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W	(4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P0W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W	(5)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W	(6)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W	(7)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_2P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH2_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SET_BOOST_VTH2_START_BIT)
+
+/* SET_BOOST_VTH1 bit 2:0 (ADPBST_VTH 0x0F) */
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SET_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P1W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P2W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W	(2)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P3W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W	(3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P4W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W	(4)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P5W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(5)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(6)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W	(7)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W_VALUE	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_0P6W << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SET_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SET_BOOST_VTH1_START_BIT)
+
+/* default value of ADPBST_VTH (0x0F) */
+/* #define AW87XXX_PID_5A_REG_ADPBST_VTH_DEFAULT		(0x23) */
+
+/* BOOST_PAR (0x10) detail */
+/* CLKDLY_SELECT bit 7 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CLKDLY_SELECT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY	(0)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY_VALUE	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_CLK_DLY << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY	(1)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY_VALUE	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DELAY_CLK_CHOOSE_MAXIM_DUTY << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CLKDLY_SELECT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CLKDLY_SELECT_START_BIT)
+
+/* CPOK_VBGOK bit 6 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CPOK_VBGOK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK	(0)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_CPOK << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK	(1)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_ENABLE_VBGOK << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CPOK_VBGOK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CPOK_VBGOK_START_BIT)
+
+/* EN_LOWBAT_ADJ bit 5 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DISABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_ENABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_LOWBAT_ADJ_START_BIT)
+
+/* EN_ADP_MODE1_DEGLITCH bit 4 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DISABLE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_ENABLE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+/* EN_VCLAMP_MIN_VTH bit 3 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DISABLE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_ENABLE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_VCLAMP_MIN_VTH_START_BIT)
+
+/* SS_ADP_BIAS bit 2 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_ADP_BIAS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA	(0)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_4UA << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA	(1)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_SS_ADP_BIAS_8UA << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_ADP_BIAS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_ADP_BIAS_START_BIT)
+
+/* BOOST_VTH1_0P1W_0P2W bit 1 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P1W << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_BOOST_VTH1_0P2W << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BOOST_VTH1_0P1W_0P2W_START_BIT)
+
+/* EN_LOWBAT_BOOST_VTH1 bit 0 (BOOST_PAR 0x10) */
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DISABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_ENABLE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_LOWBAT_BOOST_VTH1_START_BIT)
+
+/* default value of BOOST_PAR (0x10) */
+/* #define AW87XXX_PID_5A_REG_BOOST_PAR_DEFAULT		(0x08) */
+
+/* BOOST_VOUT_DET (0x57) detail */
+/* ADP_BOOST_VOUT bit 4:0 (BOOST_VOUT_DET 0x57) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_6P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V	(2)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V	(3)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V	(4)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V	(5)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_7P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V	(6)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V	(7)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V	(8)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V	(9)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_8P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V	(10)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V	(11)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V	(12)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V	(13)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_9P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V	(14)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V	(15)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V	(16)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V	(17)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_10P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V	(18)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V	(19)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V	(20)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V	(21)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_11P75V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V	(22)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P0V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V	(23)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P25V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V	(24)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_12P5V << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT_VALUE	(0x0C)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_VOUT_START_BIT)
+
+/* default value of BOOST_VOUT_DET (0x57) */
+/* #define AW87XXX_PID_5A_REG_BOOST_VOUT_DET_DEFAULT		(0x0C) */
+
+/* SYSST (0x58) detail */
+/* UVLO_S bit 7 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_UVLO_S_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_UVLO_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_S_VBAT_UNDER_VOLTAGE << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_S_START_BIT)
+
+/* LOW_BATT_S bit 6 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_LOW_BATT_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_LOW_VBAT_DETECTED << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_LOW_BATT_S_START_BIT)
+
+/* BST_OVP_S bit 5 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_S_START_BIT)
+
+/* BST_OVP2_S bit 4 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_S_START_BIT)
+
+/* BST_SCP_S bit 3 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SCP_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SCP_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SCP_S_START_BIT)
+
+/* PA_OC_S bit 2 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_PA_OC_S_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_S_START_BIT)
+
+/* OT160_S bit 1 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_OT160_S_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OT160_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OT160_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_S_NORMAL_OPERATION << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_OT160_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OT160_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OT160_S_START_BIT)
+
+/* ADP_BOOST_S bit 0 (SYSST 0x58) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_S_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_DIRECT_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_BOOST_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_S_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_S_START_BIT)
+
+/* default value of SYSST (0x58) */
+/* #define AW87XXX_PID_5A_REG_SYSST_DEFAULT		(0xFF) */
+
+/* SYSINT (0x59) detail */
+/* UVLO_I bit 7 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_UVLO_I_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_UVLO_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_I_VBAT_UNDER_VOLTAGE << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_I_START_BIT)
+
+/* LOW_BATT_I bit 6 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_LOW_BATT_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_LOW_VBAT_DETECTED << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_LOW_BATT_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_LOW_BATT_I_START_BIT)
+
+/* BST_OVP_I bit 5 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_I_START_BIT)
+
+/* BST_OVP2_I bit 4 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_I_START_BIT)
+
+/* BST_SCP_I bit 3 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SCP_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SCP_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SCP_I_START_BIT)
+
+/* PA_OC_I bit 2 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_PA_OC_I_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_I_START_BIT)
+
+/* OT160_I bit 1 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_OT160_I_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OT160_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OT160_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_I_NORMAL_OPERATION << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_5A_REG_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OT160_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_OT160_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OT160_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OT160_I_START_BIT)
+
+/* ADP_BOOST_I bit 0 (SYSINT 0x59) */
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_ADP_BOOST_I_BITS_LEN)-1) << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT))
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE	(0)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_DIRECT_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE	(1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_BOOST_MODE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT	\
+	(AW87XXX_PID_5A_REG_ADP_BOOST_I_DEFAULT_VALUE << AW87XXX_PID_5A_REG_ADP_BOOST_I_START_BIT)
+
+/* default value of SYSINT (0x59) */
+/* #define AW87XXX_PID_5A_REG_SYSINT_DEFAULT		(0xFF) */
+
+/* DFT1R (0x60) detail */
+/* CP_FREQ bit 7:6 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_FREQ_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_FREQ_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ	(0)
+#define AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_4P8MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ	(1)
+#define AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_6P4MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ	(2)
+#define AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_8P0MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ	(3)
+#define AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_9P6MHZ << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_FREQ_START_BIT)
+
+/* CP_LDO bit 5:4 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_LDO_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_CP_LDO_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_LDO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_LDO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_LDO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_LDO_4P75V	(0)
+#define AW87XXX_PID_5A_REG_CP_LDO_4P75V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_4P75V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5V	(1)
+#define AW87XXX_PID_5A_REG_CP_LDO_5V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5P25V	(2)
+#define AW87XXX_PID_5A_REG_CP_LDO_5P25V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5P25V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_5P5V	(3)
+#define AW87XXX_PID_5A_REG_CP_LDO_5P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_LDO_5P5V << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_LDO_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_CP_LDO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_LDO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_LDO_START_BIT)
+
+/* CP_VOS bit 3:2 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_VOS_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_VOS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_VOS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_VOS_0MV	(0)
+#define AW87XXX_PID_5A_REG_CP_VOS_0MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_0MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_50MV	(1)
+#define AW87XXX_PID_5A_REG_CP_VOS_50MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_50MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_100MV	(2)
+#define AW87XXX_PID_5A_REG_CP_VOS_100MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_100MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_150MV	(3)
+#define AW87XXX_PID_5A_REG_CP_VOS_150MV_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_VOS_150MV << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_VOS_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CP_VOS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_VOS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_VOS_START_BIT)
+
+/* CPOK_TM bit 1 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CPOK_TM_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CPOK_TM_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_0P6MS	(0)
+#define AW87XXX_PID_5A_REG_CPOK_TM_0P6MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_0P6MS << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_1MS	(1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_1MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_1MS << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CPOK_TM_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CPOK_TM_START_BIT)
+
+/* CP_DDT bit 0 (DFT1R 0x60) */
+#define AW87XXX_PID_5A_REG_CP_DDT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_CP_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CP_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CP_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CP_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CP_DDT_0NS	(0)
+#define AW87XXX_PID_5A_REG_CP_DDT_0NS_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_DDT_0NS << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_DDT_10NS	(1)
+#define AW87XXX_PID_5A_REG_CP_DDT_10NS_VALUE	\
+	(AW87XXX_PID_5A_REG_CP_DDT_10NS << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CP_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CP_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CP_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CP_DDT_START_BIT)
+
+/* default value of DFT1R (0x60) */
+/* #define AW87XXX_PID_5A_REG_DFT1R_DEFAULT		(0x66) */
+
+/* DFT2R (0x61) detail */
+/* BOOST_VCLAMP_SS bit 7:6 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV	(0)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_680MV840MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV	(1)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_780MV930MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV	(2)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1070MV1225MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV	(3)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV_VALUE	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_CLAMP_1350MV1500MV << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BOOST_VCLAMP_SS_START_BIT)
+
+/* BST_KICK_ITH bit 5:4 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_KICK_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM	(0)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P5KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM	(1)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P25KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM	(2)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P167KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM	(3)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_PVDD0P125KOHM << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_KICK_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_KICK_ITH_START_BIT)
+
+/* BST_EA_CUR bit 3 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EA_CUR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_1UA	(0)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_1UA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_1UA << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_4UA	(1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_4UA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_4UA << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EA_CUR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EA_CUR_START_BIT)
+
+/* BST_CK_MODE bit 2 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_CK_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ	(0)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_1P6MHZ << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ	(1)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_2P0MHZ << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_CK_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_CK_MODE_START_BIT)
+
+/* BST_COMPMAX bit 1:0 (DFT2R 0x61) */
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_COMPMAX_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V	(0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P2V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V	(1)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P4V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V	(2)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P6V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V	(3)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_2P8V << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_COMPMAX_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_COMPMAX_START_BIT)
+
+/* default value of DFT2R (0x61) */
+/* #define AW87XXX_PID_5A_REG_DFT2R_DEFAULT		(0x18) */
+
+/* DFT3R (0x62) detail */
+/* BST_PWM_SHORT bit 7 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_PWM_SHORT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD	(0)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDD << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH	(1)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_VBSTBELOWVDDMINUS_VTH << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_PWM_SHORT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_PWM_SHORT_START_BIT)
+
+/* BST_SLOPE bit 6:5 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SLOPE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE	(0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25	(1)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P25 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P5 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_ISLOPE1P75 << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SLOPE_START_BIT)
+
+/* BST_LOOPC bit 4 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LOOPC_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_28PF	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_28PF_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_28PF << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_50PF	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_50PF_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_50PF << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LOOPC_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LOOPC_START_BIT)
+
+/* BST_OS_WIDTH bit 3:2 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OS_WIDTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS	(0)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_40NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS	(1)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_30NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS	(2)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_50NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS	(3)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_60NS << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OS_WIDTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OS_WIDTH_START_BIT)
+
+/* BST_LOOPR bit 1:0 (DFT3R 0x62) */
+#define AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LOOPR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K	(0)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_320K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_160K	(1)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_160K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_160K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LOOPR_480K	(2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_480K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_480K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K	(3)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_320K_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_320K << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LOOPR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LOOPR_START_BIT)
+
+/* default value of DFT3R (0x62) */
+/* #define AW87XXX_PID_5A_REG_DFT3R_DEFAULT		(0x02) */
+
+/* DFT4R (0x63) detail */
+/* BST_BURST_IN_DELAY bit 7:6 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US	(0)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_8US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US	(1)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_12US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_4US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US	(3)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_2US << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_BURST_IN_DELAY_START_BIT)
+
+/* BST_BURST_OUT_DELAY bit 5:4 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US	(0)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_2US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US	(1)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_4US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US	(2)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P3US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US	(3)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_1P0US << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_BURST_OUT_DELAY_START_BIT)
+
+/* BST_EN_DELAY bit 3:2 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EN_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS	(0)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_8NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_80NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_130NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS	(3)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_200NS << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EN_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EN_DELAY_START_BIT)
+
+/* BST_GD_DELAY bit 1:0 (DFT4R 0x63) */
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_GD_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS	(0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_1P2NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS	(1)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_1P2NS_LS_2P5NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS	(2)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_1P2NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS	(3)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_HS_2P5NS_LS_2P5NS << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_GD_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_GD_DELAY_START_BIT)
+
+/* default value of DFT4R (0x63) */
+/* #define AW87XXX_PID_5A_REG_DFT4R_DEFAULT		(0x08) */
+
+/* DFT5R (0x64) detail */
+/* PA_FLT_SR bit 7 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_FLT_SR_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_ENABLE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_DISABLE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_FLT_SR_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_FLT_SR_START_BIT)
+
+/* AGC1_VTH_SEL bit 6:5 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_AGC1_VTH_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN	(0)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN	(1)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN	(2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN	(3)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN_VALUE	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_RAMP_GEN_AND_THGEN << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_AGC1_VTH_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_AGC1_VTH_SEL_START_BIT)
+
+/* BST_OVP2_EN bit 4 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_DISABLE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_ENABLE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_EN_START_BIT)
+
+/* BST_OVP2_ITH bit 3:2 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P5KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P25KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P167KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_PVDD0P125KOHM << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_ITH_START_BIT)
+
+/* BST_OVP2_VTH bit 1:0 (DFT5R 0x64) */
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP2_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_13V_9V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_13P5V_9P5V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V	(2)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_14V_10V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_14P5V_10P5V << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP2_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP2_VTH_START_BIT)
+
+/* default value of DFT5R (0x64) */
+/* #define AW87XXX_PID_5A_REG_DFT5R_DEFAULT		(0x45) */
+
+/* DFT6R (0x65) detail */
+/* POWER_SAVE_DLY_SELECT bit 7 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER	(0)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER_VALUE	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_HIGH_VOLTAGE_TRIGGER << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER	(1)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER_VALUE	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_CLK_RISING_EDGE_TRIGGER << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_POWER_SAVE_DLY_SELECT_START_BIT)
+
+/* PA_OPD bit 6 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_PA_OPD_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_PA_OPD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OPD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OPD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OPD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING	(0)
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_FLOATING << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND	(1)
+#define AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OPD_OUTPUT_TIED_TO_GND << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OPD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_OPD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OPD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OPD_START_BIT)
+
+/* CLK_OCP_SEL bit 5 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_CLK_OCP_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS	(0)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_160MS << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS	(1)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS_VALUE	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_640MS << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_CLK_OCP_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_CLK_OCP_SEL_START_BIT)
+
+/* BST_SKIP_EN bit 4 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SKIP_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_DISABLE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_ENABLE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SKIP_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SKIP_EN_START_BIT)
+
+/* BST_OVP_DEGLITCH_SEL bit 3 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH	(0)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_NO_DEGLITCH << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS	(1)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEGLITCH_300NS << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_OVP_DEGLITCH_SEL_START_BIT)
+
+/* BST_NCD_ITH bit 2:1 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_NCD_ITH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA	(0)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_150MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA	(1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_200MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA	(2)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_250MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA	(3)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_300MA << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_NCD_ITH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_NCD_ITH_START_BIT)
+
+/* BST_LMD_VTH bit 0 (DFT6R 0x65) */
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_LMD_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD	(0)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_HIGH_SIDE_VDD << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD	(1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_LOW_SIDE_VDD << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_LMD_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_LMD_VTH_START_BIT)
+
+/* default value of DFT6R (0x65) */
+/* #define AW87XXX_PID_5A_REG_DFT6R_DEFAULT		(0x53) */
+
+/* DFT7R (0x66) detail */
+
+/* PA_OC_DT bit 4:3 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OC_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_80NS	(0)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_80NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_80NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_150NS	(1)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_150NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_150NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_210NS	(2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_210NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_210NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_240NS	(3)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_240NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_240NS << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OC_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OC_DT_START_BIT)
+
+/* PA_RAMP_AGC1 bit 2:1 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_RAMP_AGC1_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD	(0)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P8VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD	(1)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P825VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD	(2)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P85VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD	(3)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_0P875VDD << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_RAMP_AGC1_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_RAMP_AGC1_START_BIT)
+
+/* PA_OCSWD bit 0 (DFT7R 0x66) */
+#define AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_OCSWD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER	(0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_GATEDRIVER << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS	(1)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_THROUGH_SWITCH_MOS << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_OCSWD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_OCSWD_START_BIT)
+
+/* default value of DFT7R (0x66) */
+/* #define AW87XXX_PID_5A_REG_DFT7R_DEFAULT		(0x70) */
+
+/* DFT8R (0x67) detail */
+/* PA_GD_DELAY bit 7:6 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GD_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_1P2NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_1P2NS_LS_2P5NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS	(2)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_1P2NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS	(3)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_HS_2P5NS_LS_2P5NS << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GD_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GD_DELAY_START_BIT)
+
+/* PA_GD_DGT bit 5 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GD_DGT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_4NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_4NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_4NS << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_5P5NS << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GD_DGT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GD_DGT_START_BIT)
+
+/* PA_PORT bit 4:3 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PA_PORT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_PA_PORT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_PORT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_PORT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_PORT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_PORT_80MS	(0)
+#define AW87XXX_PID_5A_REG_PA_PORT_80MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_80MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_40MS	(1)
+#define AW87XXX_PID_5A_REG_PA_PORT_40MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_40MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_20MS	(2)
+#define AW87XXX_PID_5A_REG_PA_PORT_20MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_20MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_10MS	(3)
+#define AW87XXX_PID_5A_REG_PA_PORT_10MS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_PORT_10MS << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_PORT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_PA_PORT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_PORT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_PORT_START_BIT)
+
+/* EN_AGC1_ADP bit 2 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_AGC1_ADP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE	(0)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY	(1)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_AGC1_ADP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_AGC1_ADP_START_BIT)
+
+/* PD_CROSSZERO bit 1:0 (DFT8R 0x67) */
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_CROSSZERO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO	(0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO	(1)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC2AGC3_CROSS_ZERO_DISABLE_AGC1_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO	(2)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_ENABLE_AGC3_CROSS_ZERO_DISABLE_AGC1AGC2_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO	(3)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_DISABLE_AGC1AGC2_AND_AGC3_CROSS_ZERO << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_CROSSZERO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_CROSSZERO_START_BIT)
+
+/* default value of DFT8R (0x67) */
+/* #define AW87XXX_PID_5A_REG_DFT8R_DEFAULT		(0x08) */
+
+/* DFT9R (0x68) detail */
+/* EN_BOOST_VCLAMP_SS bit 7 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DISABLE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_ENABLE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_VCLAMP_SS_START_BIT)
+
+/* EN_BOOST_PLDO bit 6 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_BOOST_PLDO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD	(0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_VDD << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO	(1)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_SET_PVLDO << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_BOOST_PLDO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_BOOST_PLDO_START_BIT)
+
+/* EN_CLAMP bit 5 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_CLAMP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_DISABLE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_ENABLE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_CLAMP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_CLAMP_START_BIT)
+
+/* EN_VBG_PASS bit 4 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_VBG_PASS_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_DISABLE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_ENABLE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_VBG_PASS_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_VBG_PASS_START_BIT)
+
+/* SS_SOFT_IPEAK_ADP bit 3 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DISABLE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_ENABLE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_SOFT_IPEAK_ADP_START_BIT)
+
+/* EN_ADP_IPEAK bit 2 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_ADP_IPEAK_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DISABLE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_ENABLE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_ADP_IPEAK_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_ADP_IPEAK_START_BIT)
+
+/* SEL_FINISH_ID bit 1 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SEL_FINISH_ID_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY	(0)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY_VALUE	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_MODE1_DELAY << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH	(1)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH_VALUE	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_LIMIT_SS_FINISH << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SEL_FINISH_ID_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SEL_FINISH_ID_START_BIT)
+
+/* SS_FINISH_SELECTED bit 0 (DFT9R 0x68) */
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US	(0)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_3US << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US	(1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_0US << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_FINISH_SELECTED_START_BIT)
+
+/* default value of DFT9R (0x68) */
+/* #define AW87XXX_PID_5A_REG_DFT9R_DEFAULT		(0x21) */
+
+/* DFTAR (0x69) detail */
+/* HWM_DELAY_INITIAL bit 7:6 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS	(0)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_104NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS	(1)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_63NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS	(2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_56NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS	(3)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS_VALUE	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_42NS << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_HWM_DELAY_INITIAL_START_BIT)
+
+/* BST_DFPWM bit 5:3 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_DFPWM_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_2P5US	(0)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_2P5US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_2P5US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_5US	(1)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_5US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_5US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_10US	(2)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_10US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_10US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_20US	(3)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_20US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_20US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_40US	(4)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_40US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_40US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_80US	(5)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_80US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_80US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_160US	(6)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_160US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_160US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_320US	(7)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_320US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_320US << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_DFPWM_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_DFPWM_START_BIT)
+
+/* BST_SOFT_DELAY bit 2:0 (DFTAR 0x69) */
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SOFT_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US	(0)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_40US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US	(1)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_80US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US	(2)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_160US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US	(3)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_320US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US	(4)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_1280US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US	(5)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_2560US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US	(6)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_5120US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US	(7)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_10240US << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SOFT_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SOFT_DELAY_START_BIT)
+
+/* default value of DFTAR (0x69) */
+/* #define AW87XXX_PID_5A_REG_DFTAR_DEFAULT		(0xA4) */
+
+/* DFTBR (0x70) detail */
+/* BST_CLK_DIV bit 4 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_CLK_DIV_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4	(0)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_4 << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2	(1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DIV_BY_2 << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_CLK_DIV_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_CLK_DIV_START_BIT)
+
+/* RAMP_1SPW_VC bit 3:2 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RAMP_1SPW_VC_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P37VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD	(1)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P39VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P33VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD	(3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_VC0P35VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VC_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RAMP_1SPW_VC_START_BIT)
+
+/* RAMP_1SPW_VL bit 1:0 (DFTBR 0x70) */
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_RAMP_1SPW_VL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD	(0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P16VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD	(1)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P18VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD	(2)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P20VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD	(3)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD_VALUE	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_VC0P14VDD << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_RAMP_1SPW_VL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_RAMP_1SPW_VL_START_BIT)
+
+/* default value of DFTBR (0x70) */
+/* #define AW87XXX_PID_5A_REG_DFTBR_DEFAULT		(0x1C) */
+
+/* DFTCR (0x71) detail */
+/* DT_EN bit 7 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_DT_EN_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_DT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DT_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DT_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DT_EN_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_DT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_DT_EN_DISABLE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DT_EN_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_DT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_DT_EN_ENABLE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DT_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_DT_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DT_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DT_EN_START_BIT)
+
+/* BST_TD bit 6:4 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_TD_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_BST_TD_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_TD_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_TD_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_TD_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P08MS	(0)
+#define AW87XXX_PID_5A_REG_BST_TD_0P08MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P08MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P16MS	(1)
+#define AW87XXX_PID_5A_REG_BST_TD_0P16MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P16MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P32MS	(2)
+#define AW87XXX_PID_5A_REG_BST_TD_0P32MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P32MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_0P64MS	(3)
+#define AW87XXX_PID_5A_REG_BST_TD_0P64MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_0P64MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_1P28MS	(4)
+#define AW87XXX_PID_5A_REG_BST_TD_1P28MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_1P28MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_2P56MS	(5)
+#define AW87XXX_PID_5A_REG_BST_TD_2P56MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_2P56MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_5P12MS	(6)
+#define AW87XXX_PID_5A_REG_BST_TD_5P12MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_5P12MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_10P24MS	(7)
+#define AW87XXX_PID_5A_REG_BST_TD_10P24MS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_TD_10P24MS << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_TD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_TD_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_TD_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_TD_START_BIT)
+
+/* BST_GTDR_DDT bit 3 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS	(0)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_3NS << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS	(1)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_6NS << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_GTDR_DDT_START_BIT)
+
+/* BST_EN_RSQN_DLY bit 2 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DISABLE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_ENABLE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_EN_RSQN_DLY_START_BIT)
+
+/* BST_RSQN_DLY bit 1:0 (DFTCR 0x71) */
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS	(0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_15NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS	(1)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_25NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS	(2)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_35NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS	(3)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_45NS << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_RSQN_DLY_START_BIT)
+
+/* default value of DFTCR (0x71) */
+/* #define AW87XXX_PID_5A_REG_DFTCR_DEFAULT		(0x10) */
+
+/* DFTDR (0x72) detail */
+/* DLY_EN bit 7 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_DLY_EN_START_BIT	(7)
+#define AW87XXX_PID_5A_REG_DLY_EN_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DLY_EN_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DLY_EN_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DLY_EN_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY	(0)
+#define AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY_VALUE	\
+	(AW87XXX_PID_5A_REG_DLY_EN_NO_DELAY << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK	(1)
+#define AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK_VALUE	\
+	(AW87XXX_PID_5A_REG_DLY_EN_DELAY_TWO_CLOCK << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DLY_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_DLY_EN_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DLY_EN_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DLY_EN_START_BIT)
+
+/* DOWNSIGNAL_SEL bit 6 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS	(0)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS_VALUE	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_160MS << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS	(1)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS_VALUE	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_SET_640MS << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_DOWNSIGNAL_SEL_START_BIT)
+
+/* BST_SLOPE_LIMIT bit 5:3 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_BITS_LEN	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE	(0)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE	(1)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE	(2)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE	(3)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE	(4)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P5SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE	(5)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_0P75SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE	(6)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P25SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE	(7)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_1P75SLOPE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SLOPE_LIMIT_START_BIT)
+
+/* MODEL_START_DELAY bit 2:1 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_MODEL_START_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US	(0)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_20US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US	(1)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_0US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US	(2)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_5US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US	(3)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US_VALUE	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_2P5US << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_MODEL_START_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_MODEL_START_DELAY_START_BIT)
+
+/* PEAK_LIMIT_SS_CAP bit 0 (DFTDR 0x72) */
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF	(0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF_VALUE	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_350FF << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF	(1)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF_VALUE	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_0FF << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PEAK_LIMIT_SS_CAP_START_BIT)
+
+/* default value of DFTDR (0x72) */
+/* #define AW87XXX_PID_5A_REG_DFTDR_DEFAULT		(0xA0) */
+
+/* DFTER (0x73) detail */
+/* BST_SS_TIME bit 7:6 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_BST_SS_TIME_BITS_LEN)-1) << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT))
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_35US	(0)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_35US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_35US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_56US	(1)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_56US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_56US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_76US	(2)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_76US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_76US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_107US	(3)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_107US_VALUE	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_107US << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT	\
+	(AW87XXX_PID_5A_REG_BST_SS_TIME_DEFAULT_VALUE << AW87XXX_PID_5A_REG_BST_SS_TIME_START_BIT)
+
+/* PD_UVLO bit 5 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_PD_UVLO_START_BIT	(5)
+#define AW87XXX_PID_5A_REG_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_UVLO_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_ENABLE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_5A_REG_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_DISABLE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_UVLO_START_BIT)
+
+/* UVLO_VTH bit 4:3 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT	(3)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V	(0)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P6V_VL2P5V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V	(1)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P7V_VL2P6V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V	(2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P8V_VL2P7V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V	(3)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_VH2P9V_VL2P8V << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_VTH_START_BIT)
+
+/* UVLO_DT bit 2 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_UVLO_DT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_UVLO_DT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_UVLO_DT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_3US	(0)
+#define AW87XXX_PID_5A_REG_UVLO_DT_3US_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_3US << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_10US	(1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_10US_VALUE	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_10US << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_UVLO_DT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_UVLO_DT_START_BIT)
+
+/* OC_DISABLE bit 1 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_OC_DISABLE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_ENABLE << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN	(1)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_SHUTDOWN << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_OC_DISABLE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_OC_DISABLE_START_BIT)
+
+/* PD_OT bit 0 (DFTER 0x73) */
+#define AW87XXX_PID_5A_REG_PD_OT_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_PD_OT_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_PD_OT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PD_OT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PD_OT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PD_OT_ENABLE	(0)
+#define AW87XXX_PID_5A_REG_PD_OT_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_OT_ENABLE << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN	(1)
+#define AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_5A_REG_PD_OT_SHUTDOWN << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PD_OT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PD_OT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PD_OT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PD_OT_START_BIT)
+
+/* default value of DFTER (0x73) */
+/* #define AW87XXX_PID_5A_REG_DFTER_DEFAULT		(0x54) */
+
+/* DFTFR (0x74) detail */
+/* EN_SWF bit 6 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_SWF_START_BIT	(6)
+#define AW87XXX_PID_5A_REG_EN_SWF_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_SWF_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_SWF_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_SWF_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_SWF_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_SWF_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SWF_DISABLE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SWF_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_SWF_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_SWF_ENABLE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_SWF_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_SWF_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_SWF_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_SWF_START_BIT)
+
+/* SS_CONTROL bit 5:4 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT	(4)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_SS_CONTROL_BITS_LEN)-1) << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT))
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM	(0)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SPREAD_SPECTRUM << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111	(1)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20111 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20000	(2)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20000_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20000 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+/*
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111	(3)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_SW20111_VALUE	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_SW20111 << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+*/
+#define AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT	\
+	(AW87XXX_PID_5A_REG_SS_CONTROL_DEFAULT_VALUE << AW87XXX_PID_5A_REG_SS_CONTROL_START_BIT)
+
+/* PA_GTDR_DDT bit 3:2 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_BITS_LEN	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_PA_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS	(0)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_12NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS	(1)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_13NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS	(2)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_14NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS	(3)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS_VALUE	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_15NS << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_5A_REG_PA_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_5A_REG_PA_GTDR_DDT_START_BIT)
+
+/* EN_HWM_DELAY bit 1 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HWM_DELAY_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_DISABLE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_ENABLE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HWM_DELAY_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HWM_DELAY_START_BIT)
+
+/* EN_HW_MODE bit 0 (DFTFR 0x74) */
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT	(0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_5A_REG_EN_HW_MODE_BITS_LEN)-1) << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT))
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE	(0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_DISABLE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE	(1)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_ENABLE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT	\
+	(AW87XXX_PID_5A_REG_EN_HW_MODE_DEFAULT_VALUE << AW87XXX_PID_5A_REG_EN_HW_MODE_START_BIT)
+
+/* default value of DFTFR (0x74) */
+/* #define AW87XXX_PID_5A_REG_DFTFR_DEFAULT		(0x00) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_5A_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
new file mode 100644
index 000000000000..ba47dd1ff546
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_60_reg.h
@@ -0,0 +1,5246 @@
+#ifndef __AW87XXX_PID_60_REG_H__
+#define __AW87XXX_PID_60_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_60_ID_REG			(0x00)
+#define AW87XXX_PID_60_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_60_BSTOVR_REG		(0x02)
+#define AW87XXX_PID_60_PEAKLIMIT_REG		(0x03)
+#define AW87XXX_PID_60_ADPSET_REG		(0x04)
+#define AW87XXX_PID_60_PAG_REG			(0x05)
+#define AW87XXX_PID_60_AGC1PA_REG		(0x06)
+#define AW87XXX_PID_60_AGC2PA_REG		(0x07)
+#define AW87XXX_PID_60_AGC3PA_REG		(0x08)
+#define AW87XXX_PID_60_AGC3P_REG		(0x09)
+#define AW87XXX_PID_60_LOW_BAT_REG		(0x0A)
+#define AW87XXX_PID_60_BSTOUT_REG		(0x0B)
+#define AW87XXX_PID_60_SYSST_REG		(0x59)
+#define AW87XXX_PID_60_SYSINT_REG		(0x60)
+#define AW87XXX_PID_60_BURST_CON_REG		(0x61)
+#define AW87XXX_PID_60_BST_BIAS_REG		(0x62)
+#define AW87XXX_PID_60_BST_EA_REG		(0x63)
+#define AW87XXX_PID_60_BST_DE_SOFT_REG		(0x64)
+#define AW87XXX_PID_60_BST_BURST_KICK_REG	(0x65)
+#define AW87XXX_PID_60_BST_CON1_REG		(0x66)
+#define AW87XXX_PID_60_BST_OVP_REG		(0x67)
+#define AW87XXX_PID_60_LINE_MODE_REG		(0x68)
+#define AW87XXX_PID_60_BST_ISEN_REG		(0x69)
+#define AW87XXX_PID_60_BST_PEAK_REG		(0x6A)
+#define AW87XXX_PID_60_BST_PEAK2_REG		(0x6B)
+#define AW87XXX_PID_60_OFFTIME_REG		(0x6C)
+#define AW87XXX_PID_60_ADPBST_REG		(0x6D)
+#define AW87XXX_PID_60_OTA_REG			(0x6E)
+#define AW87XXX_PID_60_RAMPGEN_REG		(0x6F)
+#define AW87XXX_PID_60_CLASSD_SYSCTRL_REG	(0x70)
+#define AW87XXX_PID_60_GTDR_REG			(0x71)
+#define AW87XXX_PID_60_OC_REG			(0x72)
+#define AW87XXX_PID_60_AGC_CON_REG		(0x73)
+#define AW87XXX_PID_60_NG_REG			(0x74)
+#define AW87XXX_PID_60_NG2_REG			(0x75)
+#define AW87XXX_PID_60_NG3_REG			(0x76)
+#define AW87XXX_PID_60_CP_REG			(0x77)
+#define AW87XXX_PID_60_TEST_GTDR_REG		(0x78)
+#define AW87XXX_PID_60_TEST_BST_REG		(0x79)
+#define AW87XXX_PID_60_TEST_MODE_REG		(0x7A)
+#define AW87XXX_PID_60_TEST_CON_REG		(0x7B)
+#define AW87XXX_PID_60_ENCR_REG			(0x7C)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_60_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_60_REG_MAX			(0x7D)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+#define AW87XXX_PID_60_ESD_REG_VAL			(0x91)
+
+const unsigned char aw87xxx_pid_60_reg_access[AW87XXX_PID_60_REG_MAX] = {
+	[AW87XXX_PID_60_ID_REG]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BSTOVR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_PEAKLIMIT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ADPSET_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_PAG_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC1PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC2PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC3PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC3P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_LOW_BAT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BSTOUT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_60_BURST_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_BIAS_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_EA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_DE_SOFT_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_BURST_KICK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_CON1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_OVP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_LINE_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_ISEN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_PEAK_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_BST_PEAK2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OFFTIME_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ADPBST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OTA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_RAMPGEN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_CLASSD_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_GTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_OC_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_AGC_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_NG3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_CP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_GTDR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_BST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_MODE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_TEST_CON_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_60_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_60_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_60_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_60_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_60_IDCODE_BITS_LEN)-1) << AW87XXX_PID_60_IDCODE_START_BIT))
+
+#define AW87XXX_PID_60_IDCODE_DEFAULT_VALUE	(0x60)
+#define AW87XXX_PID_60_IDCODE_DEFAULT	\
+	(AW87XXX_PID_60_IDCODE_DEFAULT_VALUE << AW87XXX_PID_60_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_60_ID_DEFAULT		(0x60) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_HVBAT bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_HVBAT_START_BIT	(0)
+#define AW87XXX_PID_60_EN_HVBAT_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_HVBAT_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_HVBAT_BITS_LEN)-1) << AW87XXX_PID_60_EN_HVBAT_START_BIT))
+
+#define AW87XXX_PID_60_EN_HVBAT_DISABLE	(0)
+#define AW87XXX_PID_60_EN_HVBAT_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HVBAT_DISABLE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_60_EN_HVBAT_ENABLE	(1)
+#define AW87XXX_PID_60_EN_HVBAT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HVBAT_ENABLE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+#define AW87XXX_PID_60_EN_HVBAT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_HVBAT_DEFAULT	\
+	(AW87XXX_PID_60_EN_HVBAT_DEFAULT_VALUE << AW87XXX_PID_60_EN_HVBAT_START_BIT)
+
+/* RCV_MODE bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_RCV_MODE_START_BIT	(1)
+#define AW87XXX_PID_60_RCV_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_RCV_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_RCV_MODE_BITS_LEN)-1) << AW87XXX_PID_60_RCV_MODE_START_BIT))
+
+#define AW87XXX_PID_60_RCV_MODE_DISABLE	(0)
+#define AW87XXX_PID_60_RCV_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_RCV_MODE_DISABLE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_60_RCV_MODE_ENABLE	(1)
+#define AW87XXX_PID_60_RCV_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_RCV_MODE_ENABLE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+#define AW87XXX_PID_60_RCV_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_RCV_MODE_DEFAULT	\
+	(AW87XXX_PID_60_RCV_MODE_DEFAULT_VALUE << AW87XXX_PID_60_RCV_MODE_START_BIT)
+
+/* EN_PA bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_PA_START_BIT	(2)
+#define AW87XXX_PID_60_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_PA_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_PA_BITS_LEN)-1) << AW87XXX_PID_60_EN_PA_START_BIT))
+
+#define AW87XXX_PID_60_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_60_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_PA_DISABLE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+#define AW87XXX_PID_60_EN_PA_ENABLE		(1)
+#define AW87XXX_PID_60_EN_PA_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_PA_ENABLE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+#define AW87XXX_PID_60_EN_PA_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_PA_DEFAULT	\
+	(AW87XXX_PID_60_EN_PA_DEFAULT_VALUE << AW87XXX_PID_60_EN_PA_START_BIT)
+
+/* EN_BOOST bit 3 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_BOOST_START_BIT	(3)
+#define AW87XXX_PID_60_EN_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_BOOST_BITS_LEN)-1) << AW87XXX_PID_60_EN_BOOST_START_BIT))
+
+#define AW87XXX_PID_60_EN_BOOST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BOOST_DISABLE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_EN_BOOST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BOOST_ENABLE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_EN_BOOST_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_BOOST_DEFAULT	\
+	(AW87XXX_PID_60_EN_BOOST_DEFAULT_VALUE << AW87XXX_PID_60_EN_BOOST_START_BIT)
+
+/* EN_CP bit 4 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_CP_START_BIT	(4)
+#define AW87XXX_PID_60_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_CP_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_CP_BITS_LEN)-1) << AW87XXX_PID_60_EN_CP_START_BIT))
+
+#define AW87XXX_PID_60_EN_CP_DISABLE	(0)
+#define AW87XXX_PID_60_EN_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_CP_DISABLE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+#define AW87XXX_PID_60_EN_CP_ENABLE		(1)
+#define AW87XXX_PID_60_EN_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_CP_ENABLE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+#define AW87XXX_PID_60_EN_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_EN_CP_DEFAULT	\
+	(AW87XXX_PID_60_EN_CP_DEFAULT_VALUE << AW87XXX_PID_60_EN_CP_START_BIT)
+
+/* EN_SW bit 5 (SYSCTRL 0x01) */
+#define AW87XXX_PID_60_EN_SW_START_BIT	(5)
+#define AW87XXX_PID_60_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_SW_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_SW_BITS_LEN)-1) << AW87XXX_PID_60_EN_SW_START_BIT))
+
+#define AW87XXX_PID_60_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_60_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SW_DISABLE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+#define AW87XXX_PID_60_EN_SW_ENABLE		(1)
+#define AW87XXX_PID_60_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SW_ENABLE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+#define AW87XXX_PID_60_EN_SW_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_SW_DEFAULT	\
+	(AW87XXX_PID_60_EN_SW_DEFAULT_VALUE << AW87XXX_PID_60_EN_SW_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_60_SYSCTRL_DEFAULT		(0x1C) */
+
+/* BSTOVR (0x02) detail */
+/* CP_FREQ bit 6:5 (BSTOVR 0x02) */
+#define AW87XXX_PID_60_CP_FREQ_START_BIT	(5)
+#define AW87XXX_PID_60_CP_FREQ_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_FREQ_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_FREQ_BITS_LEN)-1) << AW87XXX_PID_60_CP_FREQ_START_BIT))
+
+#define AW87XXX_PID_60_CP_FREQ_4P8MHZ	(0)
+#define AW87XXX_PID_60_CP_FREQ_4P8MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_4P8MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_6P4MHZ	(1)
+#define AW87XXX_PID_60_CP_FREQ_6P4MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_6P4MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_8P0MHZ	(2)
+#define AW87XXX_PID_60_CP_FREQ_8P0MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_8P0MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_9P6MHZ	(3)
+#define AW87XXX_PID_60_CP_FREQ_9P6MHZ_VALUE	\
+	(AW87XXX_PID_60_CP_FREQ_9P6MHZ << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+#define AW87XXX_PID_60_CP_FREQ_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CP_FREQ_DEFAULT	\
+	(AW87XXX_PID_60_CP_FREQ_DEFAULT_VALUE << AW87XXX_PID_60_CP_FREQ_START_BIT)
+
+/* BST_VOUT bit 4:0 (BSTOVR 0x02) */
+#define AW87XXX_PID_60_BST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_60_BST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_60_BST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VOUT_BITS_LEN)-1) << AW87XXX_PID_60_BST_VOUT_START_BIT))
+
+#define AW87XXX_PID_60_BST_VOUT_4P75V	(0)
+#define AW87XXX_PID_60_BST_VOUT_4P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_4P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P0V	(1)
+#define AW87XXX_PID_60_BST_VOUT_5P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P25V	(2)
+#define AW87XXX_PID_60_BST_VOUT_5P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P5V	(3)
+#define AW87XXX_PID_60_BST_VOUT_5P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_5P75V	(4)
+#define AW87XXX_PID_60_BST_VOUT_5P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_5P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P0V	(5)
+#define AW87XXX_PID_60_BST_VOUT_6P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P25V	(6)
+#define AW87XXX_PID_60_BST_VOUT_6P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P5V	(7)
+#define AW87XXX_PID_60_BST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_6P75V	(8)
+#define AW87XXX_PID_60_BST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_6P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P0V	(9)
+#define AW87XXX_PID_60_BST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P25V	(10)
+#define AW87XXX_PID_60_BST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P5V	(11)
+#define AW87XXX_PID_60_BST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_7P75V	(12)
+#define AW87XXX_PID_60_BST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_7P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P0V	(13)
+#define AW87XXX_PID_60_BST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P25V	(14)
+#define AW87XXX_PID_60_BST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P5V	(15)
+#define AW87XXX_PID_60_BST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_8P75V	(16)
+#define AW87XXX_PID_60_BST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_8P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P0V	(17)
+#define AW87XXX_PID_60_BST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P25V	(18)
+#define AW87XXX_PID_60_BST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P5V	(19)
+#define AW87XXX_PID_60_BST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_9P75V	(20)
+#define AW87XXX_PID_60_BST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_9P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P0V	(21)
+#define AW87XXX_PID_60_BST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P25V	(22)
+#define AW87XXX_PID_60_BST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P5V	(23)
+#define AW87XXX_PID_60_BST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_10P75V	(24)
+#define AW87XXX_PID_60_BST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_10P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P0V	(25)
+#define AW87XXX_PID_60_BST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P25V	(26)
+#define AW87XXX_PID_60_BST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P5V	(27)
+#define AW87XXX_PID_60_BST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P5V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_11P75V	(28)
+#define AW87XXX_PID_60_BST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_11P75V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_12P0V	(29)
+#define AW87XXX_PID_60_BST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_12P0V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_12P25V	(30)
+#define AW87XXX_PID_60_BST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_12P25V << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_DEFAULT_VALUE	(0x11)
+#define AW87XXX_PID_60_BST_VOUT_DEFAULT	\
+	(AW87XXX_PID_60_BST_VOUT_DEFAULT_VALUE << AW87XXX_PID_60_BST_VOUT_START_BIT)
+
+/* default value of BSTOVR (0x02) */
+/* #define AW87XXX_PID_60_BSTOVR_DEFAULT		(0x31) */
+
+/* PEAKLIMIT (0x03) detail */
+/* BST_OVP2_VTH bit 6:4 (PEAKLIMIT 0x03) */
+#define AW87XXX_PID_60_BST_OVP2_VTH_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_VTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OVP2_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_13P5V	(0)
+#define AW87XXX_PID_60_BST_OVP2_VTH_13P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_13P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P0	(1)
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P0_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_14P0 << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P5V	(2)
+#define AW87XXX_PID_60_BST_OVP2_VTH_14P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_14P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_15P0V	(3)
+#define AW87XXX_PID_60_BST_OVP2_VTH_15P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_15P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P0V	(4)
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_9P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P5V	(5)
+#define AW87XXX_PID_60_BST_OVP2_VTH_9P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_9P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P0V	(6)
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_10P0V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P5V	(7)
+#define AW87XXX_PID_60_BST_OVP2_VTH_10P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_10P5V << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_VTH_START_BIT)
+
+/* BST_IPEAK bit 3:0 (PEAKLIMIT 0x03) */
+#define AW87XXX_PID_60_BST_IPEAK_START_BIT	(0)
+#define AW87XXX_PID_60_BST_IPEAK_BITS_LEN	(4)
+#define AW87XXX_PID_60_BST_IPEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_1P5A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_1P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_1P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_1P75A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_1P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_1P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P0A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_2P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P0A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P25A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_2P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P5A	(4)
+#define AW87XXX_PID_60_BST_IPEAK_2P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_2P75A	(5)
+#define AW87XXX_PID_60_BST_IPEAK_2P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_2P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P0A	(6)
+#define AW87XXX_PID_60_BST_IPEAK_3P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P0A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P25A	(7)
+#define AW87XXX_PID_60_BST_IPEAK_3P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P5A	(8)
+#define AW87XXX_PID_60_BST_IPEAK_3P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P5A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_3P75A	(9)
+#define AW87XXX_PID_60_BST_IPEAK_3P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_3P75A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4A		(10)
+#define AW87XXX_PID_60_BST_IPEAK_4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4P25A	(11)
+#define AW87XXX_PID_60_BST_IPEAK_4P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4P25A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_4P50A	(12)
+#define AW87XXX_PID_60_BST_IPEAK_4P50A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_4P50A << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_DEFAULT_VALUE	(9)
+#define AW87XXX_PID_60_BST_IPEAK_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_START_BIT)
+
+/* default value of PEAKLIMIT (0x03) */
+/* #define AW87XXX_PID_60_PEAKLIMIT_DEFAULT		(0x09) */
+
+/* ADPSET (0x04) detail */
+/* EN_ADP_BST bit 6 (ADPSET 0x04) */
+#define AW87XXX_PID_60_EN_ADP_BST_START_BIT	(6)
+#define AW87XXX_PID_60_EN_ADP_BST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_BST_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_BST_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_BST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_BST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_BST_DISABLE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_BST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_BST_ENABLE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_BST_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_ADP_BST_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_BST_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_BST_START_BIT)
+
+/* ADP_BOOST_MODE bit 5:3 (ADPSET 0x04) */
+#define AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_BITS_LEN	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_MODE_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_RCV	(0)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_RCV_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_RCV << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST	(1)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_FORCE_BOOST << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD	(2)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_OSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD	(3)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_TSBTSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD	(4)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_TSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD	(5)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBOSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD	(6)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBTSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD	(7)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_MSBMSD << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_MODE_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_MODE_START_BIT)
+
+/* SET_BOOST_VTH2 bit 2:0 (ADPSET 0x04) */
+#define AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_BITS_LEN	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_MASK	\
+	(~(((1<<AW87XXX_PID_60_SET_BOOST_VTH2_BITS_LEN)-1) << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT))
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P2W	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P2W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P4W	(1)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P4W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P6W	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P6W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P6W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P8W	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_1P8W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_1P8W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P0W	(4)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P0W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P0W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P2W	(5)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P2W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P4W	(6)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P4W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P6W	(7)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_2P6W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_2P6W << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT	\
+	(AW87XXX_PID_60_SET_BOOST_VTH2_DEFAULT_VALUE << AW87XXX_PID_60_SET_BOOST_VTH2_START_BIT)
+
+/* default value of ADPSET (0x04) */
+/* #define AW87XXX_PID_60_ADPSET_DEFAULT		(0x54) */
+
+/* PAG (0x05) detail */
+/* SET_BOOST_VTH1 bit 6:5 (PAG 0x05) */
+#define AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT	(5)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_BITS_LEN	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_MASK	\
+	(~(((1<<AW87XXX_PID_60_SET_BOOST_VTH1_BITS_LEN)-1) << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT))
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P1W	(0)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P1W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P1W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P2W	(1)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P2W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P2W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P3W	(2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P3W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P3W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P4W	(3)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_0P4W_VALUE	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_0P4W << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+#define AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT	\
+	(AW87XXX_PID_60_SET_BOOST_VTH1_DEFAULT_VALUE << AW87XXX_PID_60_SET_BOOST_VTH1_START_BIT)
+
+/* PA_GAIN bit 4:0 (PAG 0x05) */
+#define AW87XXX_PID_60_PA_GAIN_START_BIT	(0)
+#define AW87XXX_PID_60_PA_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_60_PA_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_GAIN_BITS_LEN)-1) << AW87XXX_PID_60_PA_GAIN_START_BIT))
+
+#define AW87XXX_PID_60_PA_GAIN_0DB		(0)
+#define AW87XXX_PID_60_PA_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_0DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_1P5DB	(1)
+#define AW87XXX_PID_60_PA_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_1P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_3DB		(2)
+#define AW87XXX_PID_60_PA_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_3DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_4P5DB	(3)
+#define AW87XXX_PID_60_PA_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_4P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_6DB		(4)
+#define AW87XXX_PID_60_PA_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_6DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_7P5DB	(5)
+#define AW87XXX_PID_60_PA_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_7P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_9DB		(6)
+#define AW87XXX_PID_60_PA_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_9DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_10P5DB	(7)
+#define AW87XXX_PID_60_PA_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_10P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_12DB		(8)
+#define AW87XXX_PID_60_PA_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_12DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_13P5DB	(9)
+#define AW87XXX_PID_60_PA_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_13P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_15DB		(10)
+#define AW87XXX_PID_60_PA_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_15DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_16P5DB	(11)
+#define AW87XXX_PID_60_PA_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_16P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_18DB		(12)
+#define AW87XXX_PID_60_PA_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_18DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_19P5DB	(13)
+#define AW87XXX_PID_60_PA_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_19P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_21DB		(14)
+#define AW87XXX_PID_60_PA_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_21DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_22P5DB	(15)
+#define AW87XXX_PID_60_PA_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_22P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_24DB		(16)
+#define AW87XXX_PID_60_PA_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_24DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_25P5DB	(17)
+#define AW87XXX_PID_60_PA_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_25P5DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_PA_GAIN_27DB		(18)
+#define AW87XXX_PID_60_PA_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_60_PA_GAIN_27DB << AW87XXX_PID_60_PA_GAIN_START_BIT)
+/*
+Fix me here:
+reg_addr:0x05, reg_name:PAG, field_name:PA_GAIN, content:when RCV_MODE=0PA_GAIN  default 10000
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PA_GAIN_DEFAULT_VALUE	(0x10)
+#define AW87XXX_PID_60_PA_GAIN_DEFAULT	\
+	(AW87XXX_PID_60_PA_GAIN_DEFAULT_VALUE << AW87XXX_PID_60_PA_GAIN_START_BIT)
+
+/* default value of PAG (0x05) */
+/* #define AW87XXX_PID_60_PAG_DEFAULT		(0x50) */
+
+/* AGC1PA (0x06) detail */
+/* PD_AGC1 bit 7 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_PD_AGC1_START_BIT	(7)
+#define AW87XXX_PID_60_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_AGC1_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_60_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_60_PD_AGC1_ENABLE	(0)
+#define AW87XXX_PID_60_PD_AGC1_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC1_ENABLE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC1_DISABLE	(1)
+#define AW87XXX_PID_60_PD_AGC1_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC1_DISABLE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_60_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_60_PD_AGC1_START_BIT)
+
+/* AGC1_OUTPUT_LEVEL bit 6:3 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT	(3)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V	(0)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V	(1)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V	(2)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V	(3)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V	(4)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_5P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V	(5)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P0V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V	(6)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V	(7)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V	(8)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V	(9)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_6P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V	(10)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V	(11)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P2V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V	(12)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P4V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V	(13)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P6V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V	(14)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_7P8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V	(15)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V_VALUE	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_8V << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE	(0x9)
+#define AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_OUTPUT_LEVEL_START_BIT)
+
+/* AGC1_ATT_TIME bit 2:0 (AGC1PA 0x06) */
+#define AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB	(0)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P04MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB	(1)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P08MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB	(2)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P16MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB	(3)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P32MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB	(4)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P02MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB	(5)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P01MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB	(6)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+/*
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB	(7)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_0P005MSDB << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+*/
+
+#define AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_ATT_TIME_START_BIT)
+
+/* default value of AGC1PA (0x06) */
+/* #define AW87XXX_PID_60_AGC1PA_DEFAULT		(0x49) */
+
+/* AGC2PA (0x07) detail */
+/* AGC2_OUTPUT_POWER bit 6:3 (AGC2PA 0x07) */
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT	(3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM	(0)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P0W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM	(1)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P4W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM	(2)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_2P8W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM	(3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P2W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM	(4)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_3P6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM	(5)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P0W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM	(6)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P4W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM	(7)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_4P8W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM	(8)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P2W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM	(9)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_5P6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM	(10)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_6W4_OHM << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF	(11)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_AGC2_OFF << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_OUTPUT_POWER_START_BIT)
+
+/* AGC2_ATT_TIME bit 2:0 (AGC2PA 0x07) */
+#define AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB	(0)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P16MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB	(1)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P32MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB	(2)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_0P64MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB	(3)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_2P56MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB	(4)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_10P24MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB	(5)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_40P96MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB	(6)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_82MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB	(7)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_164MSDB << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_ATT_TIME_START_BIT)
+
+/* default value of AGC2PA (0x07) */
+/* #define AW87XXX_PID_60_AGC2PA_DEFAULT		(0x1A) */
+
+/* AGC3PA (0x08) detail */
+/* PD_AGC3 bit 4 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_PD_AGC3_START_BIT	(4)
+#define AW87XXX_PID_60_PD_AGC3_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_AGC3_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_AGC3_BITS_LEN)-1) << AW87XXX_PID_60_PD_AGC3_START_BIT))
+
+#define AW87XXX_PID_60_PD_AGC3_ENABLE	(0)
+#define AW87XXX_PID_60_PD_AGC3_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC3_ENABLE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC3_DISABLE	(1)
+#define AW87XXX_PID_60_PD_AGC3_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_AGC3_DISABLE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+#define AW87XXX_PID_60_PD_AGC3_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_AGC3_DEFAULT	\
+	(AW87XXX_PID_60_PD_AGC3_DEFAULT_VALUE << AW87XXX_PID_60_PD_AGC3_START_BIT)
+
+/* EN_HW_MODE bit 5 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_EN_HW_MODE_START_BIT	(5)
+#define AW87XXX_PID_60_EN_HW_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_HW_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_HW_MODE_BITS_LEN)-1) << AW87XXX_PID_60_EN_HW_MODE_START_BIT))
+
+#define AW87XXX_PID_60_EN_HW_MODE_DISABLE	(0)
+#define AW87XXX_PID_60_EN_HW_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HW_MODE_DISABLE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_60_EN_HW_MODE_ENABLE	(1)
+#define AW87XXX_PID_60_EN_HW_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_HW_MODE_ENABLE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+#define AW87XXX_PID_60_EN_HW_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_HW_MODE_DEFAULT	\
+	(AW87XXX_PID_60_EN_HW_MODE_DEFAULT_VALUE << AW87XXX_PID_60_EN_HW_MODE_START_BIT)
+
+/* AGC3_OUTPUT_POWER bit 3:0 (AGC3PA 0x08) */
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT	(0)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_BITS_LEN	(4)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_OUTPUT_POWER_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM	(0)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM	(1)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM	(2)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM	(3)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM	(4)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_1P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM	(5)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM	(6)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM	(7)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM	(8)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM	(9)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_2P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM	(10)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM	(11)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P2W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM	(12)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P4W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM	(13)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P6W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM	(14)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_3P8W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM	(15)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM_VALUE	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_4P0W4_OHM << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_OUTPUT_POWER_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_OUTPUT_POWER_START_BIT)
+
+/* default value of AGC3PA (0x08) */
+/* #define AW87XXX_PID_60_AGC3PA_DEFAULT		(0x03) */
+
+/* AGC3P (0x09) detail */
+/* AGC3_REL_TIME bit 7:5 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_REL_TIME_START_BIT	(5)
+#define AW87XXX_PID_60_AGC3_REL_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC3_REL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_REL_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB	(0)
+#define AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_5P12MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB	(1)
+#define AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_10P24MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB	(2)
+#define AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_20P48MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_40P96MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB	(4)
+#define AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_81P92MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB	(5)
+#define AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_163P84MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB	(6)
+#define AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_327P68MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB	(7)
+#define AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_655P36MSDB << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_REL_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_REL_TIME_START_BIT)
+
+/* AGC3_ATT_TIME bit 4:2 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT	(2)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB	(0)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_1P28MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB	(1)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_2P56MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB	(2)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_10P24MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB	(3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_40P96MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB	(4)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_82MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB	(5)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_164MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB	(6)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_328MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB	(7)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB_VALUE	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_656MSDB << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_ATT_TIME_START_BIT)
+
+/* AGC3_FIRST_ATT_TIME bit 1:0 (AGC3P 0x09) */
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS	(0)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS	(1)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_10P24MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS	(2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_20P48MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS	(3)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS_VALUE	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_41MS << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC3_FIRST_ATT_TIME_START_BIT)
+
+/* default value of AGC3P (0x09) */
+/* #define AW87XXX_PID_60_AGC3P_DEFAULT		(0x4E) */
+
+/* LOW_BAT (0x0A) detail */
+/* EN_BAT_SFGD bit 6 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_EN_BAT_SFGD_START_BIT	(6)
+#define AW87XXX_PID_60_EN_BAT_SFGD_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_BAT_SFGD_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_BAT_SFGD_BITS_LEN)-1) << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT))
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_DISABLE	(0)
+#define AW87XXX_PID_60_EN_BAT_SFGD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_DISABLE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_ENABLE	(1)
+#define AW87XXX_PID_60_EN_BAT_SFGD_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_ENABLE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+#define AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT	\
+	(AW87XXX_PID_60_EN_BAT_SFGD_DEFAULT_VALUE << AW87XXX_PID_60_EN_BAT_SFGD_START_BIT)
+
+/* BAT_SFGD_VTH bit 5:4 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT	(4)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P3V	(0)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P3V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P3V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P4V	(1)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P4V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P4V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P5V	(2)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P5V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P6V	(3)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_3P6V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_3P6V << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_VTH_START_BIT)
+
+/* BAT_SFGD_LEVEL bit 3:2 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_LEVEL_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5V	(0)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V	(1)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_5P5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6V	(2)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_6V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V	(3)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_6P5V << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT_VALUE	(0x01)
+#define AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_LEVEL_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_LEVEL_START_BIT)
+
+/* BAT_SFGD_DEGLITCH bit 1:0 (LOW_BAT 0x0A) */
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT	(0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BAT_SFGD_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS	(0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_1MS << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US	(1)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_500US << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US	(2)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_200US << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE	(3)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DISABLE << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_60_BAT_SFGD_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_60_BAT_SFGD_DEGLITCH_START_BIT)
+
+/* default value of LOW_BAT (0x0A) */
+/* #define AW87XXX_PID_60_LOW_BAT_DEFAULT		(0x14) */
+
+/* BSTOUT (0x0B) detail */
+/* ADP_BOOST_VOUT bit 4:0 (BSTOUT 0x0B) */
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_BITS_LEN	(5)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_VOUT_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V	(0)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_4P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V	(1)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V	(2)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V	(3)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V	(4)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_5P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V	(5)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V	(6)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V	(7)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V	(8)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_6P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V	(9)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V	(10)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V	(11)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V	(12)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_7P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V	(13)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V	(14)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V	(15)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V	(16)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_8P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V	(17)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V	(18)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V	(19)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V	(20)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_9P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V	(21)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V	(22)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V	(23)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V	(24)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_10P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V	(25)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V	(26)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V	(27)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P5V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V	(28)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_11P75V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V	(29)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_12P0V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V	(30)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_12P25V << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT_VALUE	(0x11)
+#define AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_VOUT_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_VOUT_START_BIT)
+
+/* default value of BSTOUT (0x0B) */
+/* #define AW87XXX_PID_60_BSTOUT_DEFAULT		(0x11) */
+
+/* SYSST (0x59) detail */
+/* ADP_BOOST_S bit 0 (SYSST 0x59) */
+#define AW87XXX_PID_60_ADP_BOOST_S_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_ADP_BOOST_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_S_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_S_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE	(0)
+#define AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_S_DIRECT_MODE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE	(1)
+#define AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_S_BOOST_MODE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADP_BOOST_S_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_S_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_S_START_BIT)
+
+/* OT160_S bit 1 (SYSST 0x59) */
+#define AW87XXX_PID_60_OT160_S_START_BIT	(1)
+#define AW87XXX_PID_60_OT160_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_OT160_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_OT160_S_BITS_LEN)-1) << AW87XXX_PID_60_OT160_S_START_BIT))
+
+#define AW87XXX_PID_60_OT160_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_OT160_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_OT160_S_NORMAL_OPERATION << AW87XXX_PID_60_OT160_S_START_BIT)
+
+#define AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_OT160_S_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_60_OT160_S_START_BIT)
+
+#define AW87XXX_PID_60_OT160_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OT160_S_DEFAULT	\
+	(AW87XXX_PID_60_OT160_S_DEFAULT_VALUE << AW87XXX_PID_60_OT160_S_START_BIT)
+
+/* PA_OC_S bit 2 (SYSST 0x59) */
+#define AW87XXX_PID_60_PA_OC_S_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OC_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OC_S_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_S_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_PA_OC_S_NORMAL_OPERATION << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_PA_OC_S_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OC_S_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_S_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_S_START_BIT)
+
+/* BST_SCP_S bit 3 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_SCP_S_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SCP_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_S_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_SCP_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_S_START_BIT)
+
+/* BST_OVP2_S bit 4 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_OVP2_S_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_S_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP2_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_S_START_BIT)
+
+/* BST_OVP_S bit 5 (SYSST 0x59) */
+#define AW87XXX_PID_60_BST_OVP_S_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_S_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_S_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_S_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_S_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP_S_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_S_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_S_START_BIT)
+
+/* LOW_BATT_S bit 6 (SYSST 0x59) */
+#define AW87XXX_PID_60_LOW_BATT_S_START_BIT	(6)
+#define AW87XXX_PID_60_LOW_BATT_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_LOW_BATT_S_MASK	\
+	(~(((1<<AW87XXX_PID_60_LOW_BATT_S_BITS_LEN)-1) << AW87XXX_PID_60_LOW_BATT_S_START_BIT))
+
+#define AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_S_NORMAL_OPERATION << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_S_LOW_VBAT_DETECTED << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LOW_BATT_S_DEFAULT	\
+	(AW87XXX_PID_60_LOW_BATT_S_DEFAULT_VALUE << AW87XXX_PID_60_LOW_BATT_S_START_BIT)
+
+/* UVLO_S bit 7 (SYSST 0x59) */
+#define AW87XXX_PID_60_UVLO_S_START_BIT	(7)
+#define AW87XXX_PID_60_UVLO_S_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_S_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_S_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_S_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_UVLO_S_NORMAL_OPERATION << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_60_UVLO_S_VBAT_UNDER_VOLTAGE << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_S_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_S_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_S_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_S_START_BIT)
+
+/* default value of SYSST (0x59) */
+/* #define AW87XXX_PID_60_SYSST_DEFAULT		(0xFF) */
+
+/* SYSINT (0x60) detail */
+/* ADP_BOOST_I bit 0 (SYSINT 0x60) */
+#define AW87XXX_PID_60_ADP_BOOST_I_START_BIT	(0)
+#define AW87XXX_PID_60_ADP_BOOST_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_ADP_BOOST_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADP_BOOST_I_BITS_LEN)-1) << AW87XXX_PID_60_ADP_BOOST_I_START_BIT))
+
+#define AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE	(0)
+#define AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_I_DIRECT_MODE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE	(1)
+#define AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE_VALUE	\
+	(AW87XXX_PID_60_ADP_BOOST_I_BOOST_MODE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+#define AW87XXX_PID_60_ADP_BOOST_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADP_BOOST_I_DEFAULT	\
+	(AW87XXX_PID_60_ADP_BOOST_I_DEFAULT_VALUE << AW87XXX_PID_60_ADP_BOOST_I_START_BIT)
+
+/* OT160_I bit 1 (SYSINT 0x60) */
+#define AW87XXX_PID_60_OT160_I_START_BIT	(1)
+#define AW87XXX_PID_60_OT160_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_OT160_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_OT160_I_BITS_LEN)-1) << AW87XXX_PID_60_OT160_I_START_BIT))
+
+#define AW87XXX_PID_60_OT160_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_OT160_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_OT160_I_NORMAL_OPERATION << AW87XXX_PID_60_OT160_I_START_BIT)
+
+#define AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_OT160_I_PA_OVER_TEMPRETURE_PROTECTION_DETECTED << AW87XXX_PID_60_OT160_I_START_BIT)
+
+#define AW87XXX_PID_60_OT160_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OT160_I_DEFAULT	\
+	(AW87XXX_PID_60_OT160_I_DEFAULT_VALUE << AW87XXX_PID_60_OT160_I_START_BIT)
+
+/* PA_OC_I bit 2 (SYSINT 0x60) */
+#define AW87XXX_PID_60_PA_OC_I_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OC_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OC_I_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_I_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_PA_OC_I_NORMAL_OPERATION << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_PA_OC_I_PA_OVER_CURRENT_PROTECTION_DETECTED << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OC_I_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_I_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_I_START_BIT)
+
+/* BST_SCP_I bit 3 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_SCP_I_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SCP_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_I_BOOST_SHORT_CIRCUIT_PROTECTION_DETECTED << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_SCP_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_I_START_BIT)
+
+/* BST_OVP2_I bit 4 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_OVP2_I_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED	(1)
+#define AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_I_BOOST_HEAVY_LOAD_PROTECTION_DETECTED << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP2_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_I_START_BIT)
+
+/* BST_OVP_I bit 5 (SYSINT 0x60) */
+#define AW87XXX_PID_60_BST_OVP_I_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_I_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_I_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_I_NORMAL_OPERATION << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION	(1)
+#define AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_I_BOOST_OVER_VOLTAGE_PROTECTION << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OVP_I_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_I_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_I_START_BIT)
+
+/* LOW_BATT_I bit 6 (SYSINT 0x60) */
+#define AW87XXX_PID_60_LOW_BATT_I_START_BIT	(6)
+#define AW87XXX_PID_60_LOW_BATT_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_LOW_BATT_I_MASK	\
+	(~(((1<<AW87XXX_PID_60_LOW_BATT_I_BITS_LEN)-1) << AW87XXX_PID_60_LOW_BATT_I_START_BIT))
+
+#define AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_I_NORMAL_OPERATION << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED	(1)
+#define AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED_VALUE	\
+	(AW87XXX_PID_60_LOW_BATT_I_LOW_VBAT_DETECTED << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+#define AW87XXX_PID_60_LOW_BATT_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LOW_BATT_I_DEFAULT	\
+	(AW87XXX_PID_60_LOW_BATT_I_DEFAULT_VALUE << AW87XXX_PID_60_LOW_BATT_I_START_BIT)
+
+/* UVLO_I bit 7 (SYSINT 0x60) */
+#define AW87XXX_PID_60_UVLO_I_START_BIT	(7)
+#define AW87XXX_PID_60_UVLO_I_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_I_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_I_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_I_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_60_UVLO_I_NORMAL_OPERATION << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_60_UVLO_I_VBAT_UNDER_VOLTAGE << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_I_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_I_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_I_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_I_START_BIT)
+
+/* default value of SYSINT (0x60) */
+/* #define AW87XXX_PID_60_SYSINT_DEFAULT		(0xFF) */
+
+/* BURST_CON (0x61) detail */
+/* BURST_PEAK bit 7:5 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BURST_PEAK_START_BIT	(5)
+#define AW87XXX_PID_60_BURST_PEAK_BITS_LEN	(3)
+#define AW87XXX_PID_60_BURST_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_BURST_PEAK_BITS_LEN)-1) << AW87XXX_PID_60_BURST_PEAK_START_BIT))
+
+#define AW87XXX_PID_60_BURST_PEAK_10MA	(0)
+#define AW87XXX_PID_60_BURST_PEAK_10MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_10MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_20MA	(1)
+#define AW87XXX_PID_60_BURST_PEAK_20MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_20MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_30MA	(2)
+#define AW87XXX_PID_60_BURST_PEAK_30MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_30MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_50MA	(3)
+#define AW87XXX_PID_60_BURST_PEAK_50MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_50MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_70MA	(4)
+#define AW87XXX_PID_60_BURST_PEAK_70MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_70MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_130MA	(5)
+#define AW87XXX_PID_60_BURST_PEAK_130MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_130MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_160MA	(7)
+#define AW87XXX_PID_60_BURST_PEAK_160MA_VALUE	\
+	(AW87XXX_PID_60_BURST_PEAK_160MA << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_BURST_PEAK_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BURST_PEAK_DEFAULT	\
+	(AW87XXX_PID_60_BURST_PEAK_DEFAULT_VALUE << AW87XXX_PID_60_BURST_PEAK_START_BIT)
+
+/* BST_BURST_SS bit 4:2 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BST_BURST_SS_START_BIT	(2)
+#define AW87XXX_PID_60_BST_BURST_SS_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_BURST_SS_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_SS_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_SS_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_SS_700MV	(0)
+#define AW87XXX_PID_60_BST_BURST_SS_700MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_700MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_760MV	(1)
+#define AW87XXX_PID_60_BST_BURST_SS_760MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_760MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_820MV	(2)
+#define AW87XXX_PID_60_BST_BURST_SS_820MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_820MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_880MV	(3)
+#define AW87XXX_PID_60_BST_BURST_SS_880MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_880MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_940MV	(4)
+#define AW87XXX_PID_60_BST_BURST_SS_940MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_940MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1000MV	(5)
+#define AW87XXX_PID_60_BST_BURST_SS_1000MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1000MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1060MV	(6)
+#define AW87XXX_PID_60_BST_BURST_SS_1060MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1060MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_1120MV	(7)
+#define AW87XXX_PID_60_BST_BURST_SS_1120MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SS_1120MV << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_BURST_SS_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_SS_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_SS_START_BIT)
+
+/* BST_COMPMAX bit 1:0 (BURST_CON 0x61) */
+#define AW87XXX_PID_60_BST_COMPMAX_START_BIT	(0)
+#define AW87XXX_PID_60_BST_COMPMAX_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_COMPMAX_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_COMPMAX_BITS_LEN)-1) << AW87XXX_PID_60_BST_COMPMAX_START_BIT))
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P0V	(0)
+#define AW87XXX_PID_60_BST_COMPMAX_2P0V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P0V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P2V	(1)
+#define AW87XXX_PID_60_BST_COMPMAX_2P2V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P2V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P3V	(2)
+#define AW87XXX_PID_60_BST_COMPMAX_2P3V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P3V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_2P4V	(3)
+#define AW87XXX_PID_60_BST_COMPMAX_2P4V_VALUE	\
+	(AW87XXX_PID_60_BST_COMPMAX_2P4V << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+#define AW87XXX_PID_60_BST_COMPMAX_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_60_BST_COMPMAX_DEFAULT	\
+	(AW87XXX_PID_60_BST_COMPMAX_DEFAULT_VALUE << AW87XXX_PID_60_BST_COMPMAX_START_BIT)
+
+/* default value of BURST_CON (0x61) */
+/* #define AW87XXX_PID_60_BURST_CON_DEFAULT		(0x47) */
+
+/* BST_BIAS (0x62) detail */
+/* BST_EA_CUR bit 0 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_EA_CUR_START_BIT	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_EA_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EA_CUR_BITS_LEN)-1) << AW87XXX_PID_60_BST_EA_CUR_START_BIT))
+
+#define AW87XXX_PID_60_BST_EA_CUR_1UA	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_1UA_VALUE	\
+	(AW87XXX_PID_60_BST_EA_CUR_1UA << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_60_BST_EA_CUR_2UA	(1)
+#define AW87XXX_PID_60_BST_EA_CUR_2UA_VALUE	\
+	(AW87XXX_PID_60_BST_EA_CUR_2UA << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+#define AW87XXX_PID_60_BST_EA_CUR_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_EA_CUR_DEFAULT	\
+	(AW87XXX_PID_60_BST_EA_CUR_DEFAULT_VALUE << AW87XXX_PID_60_BST_EA_CUR_START_BIT)
+
+/* BST_BURST_SSMD bit 5 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_BURST_SSMD_START_BIT	(5)
+#define AW87XXX_PID_60_BST_BURST_SSMD_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_SSMD_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_SLOW	(0)
+#define AW87XXX_PID_60_BST_BURST_SSMD_SLOW_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_SLOW << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_FAST	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_FAST_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_FAST << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_SSMD_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_SSMD_START_BIT)
+
+/* BST_NCD_ITH bit 7:6 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_NCD_ITH_START_BIT	(6)
+#define AW87XXX_PID_60_BST_NCD_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_NCD_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_NCD_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_NCD_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_NCD_ITH_170MA	(0)
+#define AW87XXX_PID_60_BST_NCD_ITH_170MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_170MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_220MA	(1)
+#define AW87XXX_PID_60_BST_NCD_ITH_220MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_220MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_280MA	(2)
+#define AW87XXX_PID_60_BST_NCD_ITH_280MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_280MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_340MA	(3)
+#define AW87XXX_PID_60_BST_NCD_ITH_340MA_VALUE	\
+	(AW87XXX_PID_60_BST_NCD_ITH_340MA << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_NCD_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_NCD_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_NCD_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_NCD_ITH_START_BIT)
+
+/* BST_VOUT_TRIM bit 4:3 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT	(3)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VOUT_TRIM_BITS_LEN)-1) << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT))
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25UA	(0)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_25UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24UA	(1)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_24UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA	(2)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_25P5UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA	(3)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA_VALUE	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_24P5UA << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT	\
+	(AW87XXX_PID_60_BST_VOUT_TRIM_DEFAULT_VALUE << AW87XXX_PID_60_BST_VOUT_TRIM_START_BIT)
+
+/* BST_BURST_IN bit 2:1 (BST_BIAS 0x62) */
+#define AW87XXX_PID_60_BST_BURST_IN_START_BIT	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_IN_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_IN_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_IN_3MV	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_3MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_3MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_5MV	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_5MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_5MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_7MV	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_7MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_7MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_9MV	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_9MV_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_9MV << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_IN_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_IN_START_BIT)
+
+/* default value of BST_BIAS (0x62) */
+/* #define AW87XXX_PID_60_BST_BIAS_DEFAULT		(0x60) */
+
+/* BST_EA (0x63) detail */
+/* BST_LOW_CLAMP_EN bit 2 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT	(2)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOW_CLAMP_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_DISABLE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_ENABLE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOW_CLAMP_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOW_CLAMP_EN_START_BIT)
+
+/* EN_VOUT_DIV bit 7 (BST_EA 0x63) */
+#define AW87XXX_PID_60_EN_VOUT_DIV_START_BIT	(7)
+#define AW87XXX_PID_60_EN_VOUT_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_VOUT_DIV_BITS_LEN)-1) << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT))
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_DISABLE	(0)
+#define AW87XXX_PID_60_EN_VOUT_DIV_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_DISABLE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_ENABLE	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_ENABLE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+#define AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT	\
+	(AW87XXX_PID_60_EN_VOUT_DIV_DEFAULT_VALUE << AW87XXX_PID_60_EN_VOUT_DIV_START_BIT)
+
+/* BST_BURST_OUT_DELAY bit 6:5 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT	(5)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_OUT_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US	(0)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_2P8US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US	(1)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_8P1US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US	(2)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P2US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US	(3)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_1P8US << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_OUT_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_OUT_DELAY_START_BIT)
+
+/* BST_BURST_IN_DELAY bit 4:3 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_IN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_7P4US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US	(1)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_14P6US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US	(2)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_3P7US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_5US	(3)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_5US_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_5US << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_IN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_IN_DELAY_START_BIT)
+
+/* BST_LOOPR bit 1:0 (BST_EA 0x63) */
+#define AW87XXX_PID_60_BST_LOOPR_START_BIT	(0)
+#define AW87XXX_PID_60_BST_LOOPR_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_LOOPR_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOOPR_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOOPR_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOOPR_100K	(0)
+#define AW87XXX_PID_60_BST_LOOPR_100K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_100K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_200K	(1)
+#define AW87XXX_PID_60_BST_LOOPR_200K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_200K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_400K	(2)
+#define AW87XXX_PID_60_BST_LOOPR_400K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_400K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_500K	(3)
+#define AW87XXX_PID_60_BST_LOOPR_500K_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPR_500K << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPR_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_LOOPR_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOOPR_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOOPR_START_BIT)
+
+/* default value of BST_EA (0x63) */
+/* #define AW87XXX_PID_60_BST_EA_DEFAULT		(0x86) */
+
+/* BST_DE_SOFT (0x64) detail */
+/* EN_ADP_PEAK bit 0 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_EN_ADP_PEAK_START_BIT	(0)
+#define AW87XXX_PID_60_EN_ADP_PEAK_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_PEAK_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_PEAK_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_DISABLE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_ENABLE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_PEAK_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_PEAK_START_BIT)
+
+/* BST_SOFT_MODE_EN bit 7 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT	(7)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SOFT_MODE_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_DISABLE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_ENABLE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_SOFT_MODE_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_SOFT_MODE_EN_START_BIT)
+
+/* BST_LOOPC bit 6:5 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_LOOPC_START_BIT	(5)
+#define AW87XXX_PID_60_BST_LOOPC_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_LOOPC_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LOOPC_BITS_LEN)-1) << AW87XXX_PID_60_BST_LOOPC_START_BIT))
+
+#define AW87XXX_PID_60_BST_LOOPC_30PF	(0)
+#define AW87XXX_PID_60_BST_LOOPC_30PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_30PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPC_40PF	(1)
+#define AW87XXX_PID_60_BST_LOOPC_40PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_40PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_LOOPC_40PF	(2)
+#define AW87XXX_PID_60_BST_LOOPC_40PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_40PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_LOOPC_50PF	(3)
+#define AW87XXX_PID_60_BST_LOOPC_50PF_VALUE	\
+	(AW87XXX_PID_60_BST_LOOPC_50PF << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+#define AW87XXX_PID_60_BST_LOOPC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_LOOPC_DEFAULT	\
+	(AW87XXX_PID_60_BST_LOOPC_DEFAULT_VALUE << AW87XXX_PID_60_BST_LOOPC_START_BIT)
+
+/* BST_SEL_DFPWM bit 4:3 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SEL_DFPWM_BITS_LEN)-1) << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT))
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US	(0)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_32US_00_2US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK	(1)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_64US_01_CLK << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US	(2)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_128US_10_4US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US	(3)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US_VALUE	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_256US_11_8US << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT	\
+	(AW87XXX_PID_60_BST_SEL_DFPWM_DEFAULT_VALUE << AW87XXX_PID_60_BST_SEL_DFPWM_START_BIT)
+
+/* BST_SOFT_DELAY bit 2:1 (BST_DE_SOFT 0x64) */
+#define AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT	(1)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SOFT_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U	(0)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_40US_001280U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U	(1)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_80US_012560U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U	(2)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_160US_105120U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U	(3)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U_VALUE	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_320US_1110240U << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_SOFT_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_SOFT_DELAY_START_BIT)
+
+/* default value of BST_DE_SOFT (0x64) */
+/* #define AW87XXX_PID_60_BST_DE_SOFT_DEFAULT		(0x09) */
+
+/* BST_BURST_KICK (0x65) detail */
+/* EN_TRANS_ERROR bit 0 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_TRANS_ERROR_BITS_LEN)-1) << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT))
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_DISABLE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE	(1)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_ENABLE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT	\
+	(AW87XXX_PID_60_EN_TRANS_ERROR_DEFAULT_VALUE << AW87XXX_PID_60_EN_TRANS_ERROR_START_BIT)
+
+/* BST_SCP_VTH bit 1 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_SCP_VTH_START_BIT	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD	(0)
+#define AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_VTH_HIGH_SIDE_VDD << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD	(1)
+#define AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_VTH_LOW_SIDE_VDD << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_VTH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SCP_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_VTH_START_BIT)
+
+/* BST_SKIP_EN bit 6 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_SKIP_EN_START_BIT	(6)
+#define AW87XXX_PID_60_BST_SKIP_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SKIP_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SKIP_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_SKIP_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_SKIP_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_SKIP_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SKIP_EN_ENABLE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SKIP_EN_DISABLE	(1)
+#define AW87XXX_PID_60_BST_SKIP_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SKIP_EN_DISABLE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_SKIP_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SKIP_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_SKIP_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_SKIP_EN_START_BIT)
+
+/* BST_ADBK_COMP_ADJ bit 7 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT	(7)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_ADBK_COMP_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA	(0)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA_VALUE	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_14UA << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA	(1)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA_VALUE	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_10UA << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_BST_ADBK_COMP_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_BST_ADBK_COMP_ADJ_START_BIT)
+
+/* BST_OVP2_ITH bit 5:4 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_OVP2_ITH_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OVP2_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_OVP2_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_32MA	(0)
+#define AW87XXX_PID_60_BST_OVP2_ITH_32MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_32MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_48MA	(1)
+#define AW87XXX_PID_60_BST_OVP2_ITH_48MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_48MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA	(2)
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_64MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA	(3)
+#define AW87XXX_PID_60_BST_OVP2_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_64MA << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_ITH_START_BIT)
+
+/* BST_KICK_ITH bit 3:2 (BST_BURST_KICK 0x65) */
+#define AW87XXX_PID_60_BST_KICK_ITH_START_BIT	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_KICK_ITH_BITS_LEN)-1) << AW87XXX_PID_60_BST_KICK_ITH_START_BIT))
+
+#define AW87XXX_PID_60_BST_KICK_ITH_32MA	(0)
+#define AW87XXX_PID_60_BST_KICK_ITH_32MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_32MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_KICK_ITH_48MA	(1)
+#define AW87XXX_PID_60_BST_KICK_ITH_48MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_48MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA	(2)
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_64MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA	(3)
+#define AW87XXX_PID_60_BST_KICK_ITH_64MA_VALUE	\
+	(AW87XXX_PID_60_BST_KICK_ITH_64MA << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_BST_KICK_ITH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_KICK_ITH_DEFAULT	\
+	(AW87XXX_PID_60_BST_KICK_ITH_DEFAULT_VALUE << AW87XXX_PID_60_BST_KICK_ITH_START_BIT)
+
+/* default value of BST_BURST_KICK (0x65) */
+/* #define AW87XXX_PID_60_BST_BURST_KICK_DEFAULT		(0x14) */
+
+/* BST_CON1 (0x66) detail */
+/* BST_GTDR_DDT bit 2 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_GTDR_DDT_START_BIT	(2)
+#define AW87XXX_PID_60_BST_GTDR_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_9NS	(0)
+#define AW87XXX_PID_60_BST_GTDR_DDT_9NS_VALUE	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_9NS << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_12NS	(1)
+#define AW87XXX_PID_60_BST_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_12NS << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_60_BST_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_60_BST_GTDR_DDT_START_BIT)
+
+/* EN_ADP_MODE1_DEGLITCH bit 3 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT	(3)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_BITS_LEN)-1) << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT))
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE	(0)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DISABLE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE	(1)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_ENABLE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT	\
+	(AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_DEFAULT_VALUE << AW87XXX_PID_60_EN_ADP_MODE1_DEGLITCH_START_BIT)
+
+/* SS_FINISH_SELECT bit 6 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT	(6)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_BITS_LEN	(1)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_MASK	\
+	(~(((1<<AW87XXX_PID_60_SS_FINISH_SELECT_BITS_LEN)-1) << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT))
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE	(0)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE_VALUE	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_NOT_USE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_USE	(1)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_USE_VALUE	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_USE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+#define AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT	\
+	(AW87XXX_PID_60_SS_FINISH_SELECT_DEFAULT_VALUE << AW87XXX_PID_60_SS_FINISH_SELECT_START_BIT)
+
+/* BST_GDRV_TEST bit 7 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_GDRV_TEST_START_BIT	(7)
+#define AW87XXX_PID_60_BST_GDRV_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_GDRV_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_GDRV_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_GDRV_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_DIABLE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_GDRV_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_ENABLE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_GDRV_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_GDRV_TEST_START_BIT)
+
+/* BST_EN_DELAY bit 5:4 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_EN_DELAY_START_BIT	(4)
+#define AW87XXX_PID_60_BST_EN_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_EN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_BST_EN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_BST_EN_DELAY_8N	(0)
+#define AW87XXX_PID_60_BST_EN_DELAY_8N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_8N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_80N	(1)
+#define AW87XXX_PID_60_BST_EN_DELAY_80N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_80N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_130N	(2)
+#define AW87XXX_PID_60_BST_EN_DELAY_130N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_130N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_200N	(3)
+#define AW87XXX_PID_60_BST_EN_DELAY_200N_VALUE	\
+	(AW87XXX_PID_60_BST_EN_DELAY_200N << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_DELAY_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_EN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_BST_EN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_BST_EN_DELAY_START_BIT)
+
+/* BST_SRC bit 1:0 (BST_CON1 0x66) */
+#define AW87XXX_PID_60_BST_SRC_START_BIT	(0)
+#define AW87XXX_PID_60_BST_SRC_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SRC_MASK		\
+	(~(((1<<AW87XXX_PID_60_BST_SRC_BITS_LEN)-1) << AW87XXX_PID_60_BST_SRC_START_BIT))
+
+#define AW87XXX_PID_60_BST_SRC_3NS		(0)
+#define AW87XXX_PID_60_BST_SRC_3NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_3NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_4NS		(1)
+#define AW87XXX_PID_60_BST_SRC_4NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_4NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_7NS		(2)
+#define AW87XXX_PID_60_BST_SRC_7NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_7NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_15NS		(3)
+#define AW87XXX_PID_60_BST_SRC_15NS_VALUE	\
+	(AW87XXX_PID_60_BST_SRC_15NS << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+#define AW87XXX_PID_60_BST_SRC_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SRC_DEFAULT	\
+	(AW87XXX_PID_60_BST_SRC_DEFAULT_VALUE << AW87XXX_PID_60_BST_SRC_START_BIT)
+
+/* default value of BST_CON1 (0x66) */
+/* #define AW87XXX_PID_60_BST_CON1_DEFAULT		(0x10) */
+
+/* BST_OVP (0x67) detail */
+/* BST_OVP_VTH bit 0 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP_VTH_START_BIT	(0)
+#define AW87XXX_PID_60_BST_OVP_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_VTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_VTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V	(0)
+#define AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_VTH_3MINUS6P875V << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_VTH_7MINUS11V << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_VTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OVP_VTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_VTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_VTH_START_BIT)
+
+/* BST_VFB_EN bit 1 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_VFB_EN_START_BIT	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_VFB_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_VFB_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_VFB_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_VFB_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_VFB_EN_DISABLE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_VFB_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_VFB_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_VFB_EN_ENABLE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_VFB_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_VFB_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_VFB_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_VFB_EN_START_BIT)
+
+/* BST_FORCE_PWM bit 2 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_FORCE_PWM_START_BIT	(2)
+#define AW87XXX_PID_60_BST_FORCE_PWM_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_FORCE_PWM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_FORCE_PWM_BITS_LEN)-1) << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT))
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_DISABLE	(0)
+#define AW87XXX_PID_60_BST_FORCE_PWM_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_DISABLE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_ENABLE	(1)
+#define AW87XXX_PID_60_BST_FORCE_PWM_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_ENABLE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT	\
+	(AW87XXX_PID_60_BST_FORCE_PWM_DEFAULT_VALUE << AW87XXX_PID_60_BST_FORCE_PWM_START_BIT)
+
+/* BST_OVP2_EN bit 5 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP2_EN_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP2_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP2_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP2_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP2_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP2_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_OVP2_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_EN_DISABLE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_OVP2_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP2_EN_ENABLE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP2_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP2_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP2_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP2_EN_START_BIT)
+
+/* BST_OVP_DEGLI_SEL bit 6 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT	(6)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_DEGLI_SEL_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH	(0)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_NO_DEGLITCH << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH	(1)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEGLITCH << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_DEGLI_SEL_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_DEGLI_SEL_START_BIT)
+
+/* BST_CLK_DIV bit 7 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BST_CLK_DIV_START_BIT	(7)
+#define AW87XXX_PID_60_BST_CLK_DIV_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_CLK_DIV_BITS_LEN)-1) << AW87XXX_PID_60_BST_CLK_DIV_START_BIT))
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4	(0)
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4_VALUE	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_4 << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2_VALUE	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DIV_BY_2 << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+#define AW87XXX_PID_60_BST_CLK_DIV_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_CLK_DIV_DEFAULT	\
+	(AW87XXX_PID_60_BST_CLK_DIV_DEFAULT_VALUE << AW87XXX_PID_60_BST_CLK_DIV_START_BIT)
+
+/* BURST_HYS_EN bit 4:3 (BST_OVP 0x67) */
+#define AW87XXX_PID_60_BURST_HYS_EN_START_BIT	(3)
+#define AW87XXX_PID_60_BURST_HYS_EN_BITS_LEN	(2)
+#define AW87XXX_PID_60_BURST_HYS_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BURST_HYS_EN_BITS_LEN)-1) << AW87XXX_PID_60_BURST_HYS_EN_START_BIT))
+
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT	(0)
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_OUT << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_IN	(1)
+#define AW87XXX_PID_60_BURST_HYS_EN_IN_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_IN << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN	(3)
+#define AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN_VALUE	\
+	(AW87XXX_PID_60_BURST_HYS_EN_OUT_AND_IN << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+#define AW87XXX_PID_60_BURST_HYS_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BURST_HYS_EN_DEFAULT	\
+	(AW87XXX_PID_60_BURST_HYS_EN_DEFAULT_VALUE << AW87XXX_PID_60_BURST_HYS_EN_START_BIT)
+
+/* default value of BST_OVP (0x67) */
+/* #define AW87XXX_PID_60_BST_OVP_DEFAULT		(0x81) */
+
+/* LINE_MODE (0x68) detail */
+/* BST_EN_RSQN_DLY bit 0 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT	(0)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_EN_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE	(0)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_DISABLE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_ENABLE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_60_BST_EN_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_60_BST_EN_RSQN_DLY_START_BIT)
+
+/* BST_FORCE_BOOST bit 1 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_FORCE_BOOST_BITS_LEN)-1) << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT))
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE	(0)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_DISABLE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_ENABLE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT	\
+	(AW87XXX_PID_60_BST_FORCE_BOOST_DEFAULT_VALUE << AW87XXX_PID_60_BST_FORCE_BOOST_START_BIT)
+
+/* BST_PWM_SHORT bit 2 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_PWM_SHORT_START_BIT	(2)
+#define AW87XXX_PID_60_BST_PWM_SHORT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_PWM_SHORT_BITS_LEN)-1) << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT))
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD	(0)
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD_VALUE	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDD << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH_VALUE	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_VBSTBELOWVDDMINUSVTH << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+#define AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT	\
+	(AW87XXX_PID_60_BST_PWM_SHORT_DEFAULT_VALUE << AW87XXX_PID_60_BST_PWM_SHORT_START_BIT)
+
+/* BST_OS_WIDTH bit 7:5 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_BST_OS_WIDTH_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OS_WIDTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OS_WIDTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OS_WIDTH_BITS_LEN)-1) << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT))
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_10NS	(0)
+#define AW87XXX_PID_60_BST_OS_WIDTH_10NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_10NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_20NS	(1)
+#define AW87XXX_PID_60_BST_OS_WIDTH_20NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_20NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_30NS	(2)
+#define AW87XXX_PID_60_BST_OS_WIDTH_30NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_30NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_40NS	(3)
+#define AW87XXX_PID_60_BST_OS_WIDTH_40NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_40NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_50NS	(4)
+#define AW87XXX_PID_60_BST_OS_WIDTH_50NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_50NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_60NS	(5)
+#define AW87XXX_PID_60_BST_OS_WIDTH_60NS_VALUE	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_60NS << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+#define AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT	\
+	(AW87XXX_PID_60_BST_OS_WIDTH_DEFAULT_VALUE << AW87XXX_PID_60_BST_OS_WIDTH_START_BIT)
+
+/* MODE1_START_DELAY bit 4:3 (LINE_MODE 0x68) */
+#define AW87XXX_PID_60_MODE1_START_DELAY_START_BIT	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_BITS_LEN	(2)
+#define AW87XXX_PID_60_MODE1_START_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_MODE1_START_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_15P6US	(0)
+#define AW87XXX_PID_60_MODE1_START_DELAY_15P6US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_15P6US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_11P4US	(1)
+#define AW87XXX_PID_60_MODE1_START_DELAY_11P4US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_11P4US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_7P3US	(2)
+#define AW87XXX_PID_60_MODE1_START_DELAY_7P3US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_7P3US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_3US	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_3US_VALUE	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_3US << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_MODE1_START_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_MODE1_START_DELAY_START_BIT)
+
+/* default value of LINE_MODE (0x68) */
+/* #define AW87XXX_PID_60_LINE_MODE_DEFAULT		(0x3F) */
+
+/* BST_ISEN (0x69) detail */
+/* BST_RSQN_DLY bit 7:5 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_RSQN_DLY_START_BIT	(5)
+#define AW87XXX_PID_60_BST_RSQN_DLY_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_RSQN_DLY_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_RSQN_DLY_BITS_LEN)-1) << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT))
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_15NS	(0)
+#define AW87XXX_PID_60_BST_RSQN_DLY_15NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_15NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_25NS	(1)
+#define AW87XXX_PID_60_BST_RSQN_DLY_25NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_25NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_35NS	(2)
+#define AW87XXX_PID_60_BST_RSQN_DLY_35NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_35NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_45NS	(3)
+#define AW87XXX_PID_60_BST_RSQN_DLY_45NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_45NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_70NS	(4)
+#define AW87XXX_PID_60_BST_RSQN_DLY_70NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_70NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_80NS	(5)
+#define AW87XXX_PID_60_BST_RSQN_DLY_80NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_80NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_90NS	(6)
+#define AW87XXX_PID_60_BST_RSQN_DLY_90NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_90NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_100NS	(7)
+#define AW87XXX_PID_60_BST_RSQN_DLY_100NS_VALUE	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_100NS << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+#define AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT	\
+	(AW87XXX_PID_60_BST_RSQN_DLY_DEFAULT_VALUE << AW87XXX_PID_60_BST_RSQN_DLY_START_BIT)
+
+/* BST_SLOPE bit 4:3 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_SLOPE_START_BIT	(3)
+#define AW87XXX_PID_60_BST_SLOPE_BITS_LEN	(2)
+#define AW87XXX_PID_60_BST_SLOPE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SLOPE_BITS_LEN)-1) << AW87XXX_PID_60_BST_SLOPE_START_BIT))
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1	(0)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25	(1)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P25 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5	(2)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P5 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75	(3)
+#define AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_ISLOPE1P75 << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SLOPE_DEFAULT	\
+	(AW87XXX_PID_60_BST_SLOPE_DEFAULT_VALUE << AW87XXX_PID_60_BST_SLOPE_START_BIT)
+
+/* BST_SLOPE_LIMIT bit 2:0 (BST_ISEN 0x69) */
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT	(0)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SLOPE_LIMIT_BITS_LEN)-1) << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT))
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE	(0)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_0P50ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE	(1)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_0P75ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE	(2)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P00ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE	(3)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P25ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE	(4)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P50ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE	(5)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_1P75ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE	(6)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_2P00ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE	(7)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE_VALUE	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_2P25ISLOPE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT	\
+	(AW87XXX_PID_60_BST_SLOPE_LIMIT_DEFAULT_VALUE << AW87XXX_PID_60_BST_SLOPE_LIMIT_START_BIT)
+
+/* default value of BST_ISEN (0x69) */
+/* #define AW87XXX_PID_60_BST_ISEN_DEFAULT		(0x42) */
+
+/* BST_PEAK (0x6A) detail */
+/* BST_IPEAK_LOWBAT bit 3 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT	(3)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_LOWBAT_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P5A << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_2P75A << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_START_BIT)
+
+/* BST_IPEAK_LOWBAT_EN bit 4 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT	(4)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DISABLE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_ENABLE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_LOWBAT_EN_START_BIT)
+
+/* BST_IPEAK_ADJ bit 5 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT	(5)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_IPEAK0P5A << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_ADJ_START_BIT)
+
+/* BACK_ADPT_R400K bit 6 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT	(6)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_BITS_LEN	(1)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_MASK	\
+	(~(((1<<AW87XXX_PID_60_BACK_ADPT_R400K_BITS_LEN)-1) << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT))
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE	(0)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_DISABLE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE	(1)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE_VALUE	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_ENABALE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT	\
+	(AW87XXX_PID_60_BACK_ADPT_R400K_DEFAULT_VALUE << AW87XXX_PID_60_BACK_ADPT_R400K_START_BIT)
+
+/* SEL_FINISH_ID bit 7 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_SEL_FINISH_ID_START_BIT	(7)
+#define AW87XXX_PID_60_SEL_FINISH_ID_BITS_LEN	(1)
+#define AW87XXX_PID_60_SEL_FINISH_ID_MASK	\
+	(~(((1<<AW87XXX_PID_60_SEL_FINISH_ID_BITS_LEN)-1) << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT))
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_MODE1START	(0)
+#define AW87XXX_PID_60_SEL_FINISH_ID_MODE1START_VALUE	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_MODE1START << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH	(1)
+#define AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH_VALUE	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_LIMITSSFINISH << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+#define AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT	\
+	(AW87XXX_PID_60_SEL_FINISH_ID_DEFAULT_VALUE << AW87XXX_PID_60_SEL_FINISH_ID_START_BIT)
+
+/* BST_IPEAK_SS bit 2:0 (BST_PEAK 0x6A) */
+#define AW87XXX_PID_60_BST_IPEAK_SS_START_BIT	(0)
+#define AW87XXX_PID_60_BST_IPEAK_SS_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_IPEAK_SS_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_SS_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_0P8A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_SS_0P8A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_0P8A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P0A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P0A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P25A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P25A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P5A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P5A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P75A	(4)
+#define AW87XXX_PID_60_BST_IPEAK_SS_1P75A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_1P75A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2A	(5)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P25A	(6)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P25A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2P25A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P50A	(7)
+#define AW87XXX_PID_60_BST_IPEAK_SS_2P50A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_2P50A << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_SS_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_SS_START_BIT)
+
+/* default value of BST_PEAK (0x6A) */
+/* #define AW87XXX_PID_60_BST_PEAK_DEFAULT		(0x01) */
+
+/* BST_PEAK2 (0x6B) detail */
+/* BST_BACK_EN bit 2 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_BACK_EN_START_BIT	(2)
+#define AW87XXX_PID_60_BST_BACK_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BACK_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BACK_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_BACK_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_BACK_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_BACK_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BACK_EN_ENABLE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BACK_EN_DIABALE	(1)
+#define AW87XXX_PID_60_BST_BACK_EN_DIABALE_VALUE	\
+	(AW87XXX_PID_60_BST_BACK_EN_DIABALE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_BACK_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BACK_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_BACK_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_BACK_EN_START_BIT)
+
+/* BST_IPEAK_ITH_EN bit 3 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT	(3)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_ITH_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAK << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_IPEAKMINUS0P5A << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_ITH_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_ITH_EN_START_BIT)
+
+/* BST_IPEAK_TRIM bit 7:4 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT	(4)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_BITS_LEN	(4)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_IPEAK_TRIM_BITS_LEN)-1) << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT))
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0A	(0)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A	(1)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A	(2)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A	(3)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_0P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A	(8)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A	(9)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A	(10)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A	(11)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS1A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A	(12)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P8A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A	(13)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P6A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A	(14)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P4A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A	(15)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A_VALUE	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_MINUS0P2A << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT	\
+	(AW87XXX_PID_60_BST_IPEAK_TRIM_DEFAULT_VALUE << AW87XXX_PID_60_BST_IPEAK_TRIM_START_BIT)
+
+/* OFFTIME_OUT_C bit 1:0 (BST_PEAK2 0x6B) */
+#define AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT	(0)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_BITS_LEN	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_MASK	\
+	(~(((1<<AW87XXX_PID_60_OFFTIME_OUT_C_BITS_LEN)-1) << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT))
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_0	(0)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_0_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_0 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_1	(1)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_1_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_1 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_2	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_2_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_2 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_3	(3)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_3_VALUE	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_3 << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+#define AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT	\
+	(AW87XXX_PID_60_OFFTIME_OUT_C_DEFAULT_VALUE << AW87XXX_PID_60_OFFTIME_OUT_C_START_BIT)
+
+/* default value of BST_PEAK2 (0x6B) */
+/* #define AW87XXX_PID_60_BST_PEAK2_DEFAULT		(0x02) */
+
+/* OFFTIME (0x6C) detail */
+/* HEAD_ROOM bit 3 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_HEAD_ROOM_START_BIT	(3)
+#define AW87XXX_PID_60_HEAD_ROOM_BITS_LEN	(1)
+#define AW87XXX_PID_60_HEAD_ROOM_MASK	\
+	(~(((1<<AW87XXX_PID_60_HEAD_ROOM_BITS_LEN)-1) << AW87XXX_PID_60_HEAD_ROOM_START_BIT))
+
+#define AW87XXX_PID_60_HEAD_ROOM_1P5V	(0)
+#define AW87XXX_PID_60_HEAD_ROOM_1P5V_VALUE	\
+	(AW87XXX_PID_60_HEAD_ROOM_1P5V << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+#define AW87XXX_PID_60_HEAD_ROOM_2P0V	(1)
+#define AW87XXX_PID_60_HEAD_ROOM_2P0V_VALUE	\
+	(AW87XXX_PID_60_HEAD_ROOM_2P0V << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+#define AW87XXX_PID_60_HEAD_ROOM_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_HEAD_ROOM_DEFAULT	\
+	(AW87XXX_PID_60_HEAD_ROOM_DEFAULT_VALUE << AW87XXX_PID_60_HEAD_ROOM_START_BIT)
+
+/* BST_OFFTIME_EN bit 7 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT	(7)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OFFTIME_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_ENABLE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_DIABALE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_OFFTIME_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_OFFTIME_EN_START_BIT)
+
+/* BST_OFFTIME bit 6:4 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OFFTIME_START_BIT	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OFFTIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OFFTIME_BITS_LEN)-1) << AW87XXX_PID_60_BST_OFFTIME_START_BIT))
+
+#define AW87XXX_PID_60_BST_OFFTIME_4	(0)
+#define AW87XXX_PID_60_BST_OFFTIME_4_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_4 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_3	(1)
+#define AW87XXX_PID_60_BST_OFFTIME_3_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_3 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_2	(2)
+#define AW87XXX_PID_60_BST_OFFTIME_2_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_2 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_1	(3)
+#define AW87XXX_PID_60_BST_OFFTIME_1_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_1 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_0	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_0_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_0 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS1	(5)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS1_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS1 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS2	(6)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS2_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS2 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS3	(7)
+#define AW87XXX_PID_60_BST_OFFTIME_MINUS3_VALUE	\
+	(AW87XXX_PID_60_BST_OFFTIME_MINUS3 << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+#define AW87XXX_PID_60_BST_OFFTIME_DEFAULT_VALUE	(4)
+#define AW87XXX_PID_60_BST_OFFTIME_DEFAULT	\
+	(AW87XXX_PID_60_BST_OFFTIME_DEFAULT_VALUE << AW87XXX_PID_60_BST_OFFTIME_START_BIT)
+
+/* BST_OUT_VTH0 bit 2:0 (OFFTIME 0x6C) */
+#define AW87XXX_PID_60_BST_OUT_VTH0_START_BIT	(0)
+#define AW87XXX_PID_60_BST_OUT_VTH0_BITS_LEN	(3)
+#define AW87XXX_PID_60_BST_OUT_VTH0_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OUT_VTH0_BITS_LEN)-1) << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT))
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P5V	(0)
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_6P5V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P75V	(1)
+#define AW87XXX_PID_60_BST_OUT_VTH0_6P75V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_6P75V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P0V	(2)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P0V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P25V	(3)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P25V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P25V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P5V	(4)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P5V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P5V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P75V	(5)
+#define AW87XXX_PID_60_BST_OUT_VTH0_7P75V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_7P75V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P0V	(6)
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P0V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_8P0V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P25V	(7)
+#define AW87XXX_PID_60_BST_OUT_VTH0_8P25V_VALUE	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_8P25V << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+#define AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT	\
+	(AW87XXX_PID_60_BST_OUT_VTH0_DEFAULT_VALUE << AW87XXX_PID_60_BST_OUT_VTH0_START_BIT)
+
+/* default value of OFFTIME (0x6C) */
+/* #define AW87XXX_PID_60_OFFTIME_DEFAULT		(0x41) */
+
+/* ADPBST (0x6D) detail */
+/* REG_CLK_CP_OTA bit 0 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_CLK_CP_OTA_BITS_LEN)-1) << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT))
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_200KHZ << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_400KHZ << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT	\
+	(AW87XXX_PID_60_REG_CLK_CP_OTA_DEFAULT_VALUE << AW87XXX_PID_60_REG_CLK_CP_OTA_START_BIT)
+
+/* OTA_MD2 bit 1 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_OTA_MD2_START_BIT	(1)
+#define AW87XXX_PID_60_OTA_MD2_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_MD2_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_MD2_BITS_LEN)-1) << AW87XXX_PID_60_OTA_MD2_START_BIT))
+
+#define AW87XXX_PID_60_OTA_MD2_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_MD2_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_MD2_DISABLE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+#define AW87XXX_PID_60_OTA_MD2_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_MD2_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_MD2_ENABLE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+#define AW87XXX_PID_60_OTA_MD2_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OTA_MD2_DEFAULT	\
+	(AW87XXX_PID_60_OTA_MD2_DEFAULT_VALUE << AW87XXX_PID_60_OTA_MD2_START_BIT)
+
+/* OTA_RCV bit 2 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_OTA_RCV_START_BIT	(2)
+#define AW87XXX_PID_60_OTA_RCV_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_RCV_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_RCV_BITS_LEN)-1) << AW87XXX_PID_60_OTA_RCV_START_BIT))
+
+#define AW87XXX_PID_60_OTA_RCV_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_RCV_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_RCV_DISABLE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+#define AW87XXX_PID_60_OTA_RCV_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_RCV_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_RCV_ENABLE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+#define AW87XXX_PID_60_OTA_RCV_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OTA_RCV_DEFAULT	\
+	(AW87XXX_PID_60_OTA_RCV_DEFAULT_VALUE << AW87XXX_PID_60_OTA_RCV_START_BIT)
+
+/* MSBM_VDD_SEL bit 3 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT	(3)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_MSBM_VDD_SEL_BITS_LEN)-1) << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT))
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V	(0)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V_VALUE	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_VDDBELOW4P5V << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V	(1)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V_VALUE	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_VDDABOVE4P5V << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+#define AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT	\
+	(AW87XXX_PID_60_MSBM_VDD_SEL_DEFAULT_VALUE << AW87XXX_PID_60_MSBM_VDD_SEL_START_BIT)
+
+/* DLY_EN bit 4 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_DLY_EN_START_BIT	(4)
+#define AW87XXX_PID_60_DLY_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_DLY_EN_MASK		\
+	(~(((1<<AW87XXX_PID_60_DLY_EN_BITS_LEN)-1) << AW87XXX_PID_60_DLY_EN_START_BIT))
+
+#define AW87XXX_PID_60_DLY_EN_DISABLE	(0)
+#define AW87XXX_PID_60_DLY_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_EN_DISABLE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_EN_ENABLE	(1)
+#define AW87XXX_PID_60_DLY_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_EN_ENABLE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_EN_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_DLY_EN_DEFAULT	\
+	(AW87XXX_PID_60_DLY_EN_DEFAULT_VALUE << AW87XXX_PID_60_DLY_EN_START_BIT)
+
+/* DLY_CLK_EN bit 5 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_DLY_CLK_EN_START_BIT	(5)
+#define AW87XXX_PID_60_DLY_CLK_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_DLY_CLK_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_DLY_CLK_EN_BITS_LEN)-1) << AW87XXX_PID_60_DLY_CLK_EN_START_BIT))
+
+#define AW87XXX_PID_60_DLY_CLK_EN_DISABLE	(0)
+#define AW87XXX_PID_60_DLY_CLK_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_CLK_EN_DISABLE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_CLK_EN_ENABLE	(1)
+#define AW87XXX_PID_60_DLY_CLK_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_DLY_CLK_EN_ENABLE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+#define AW87XXX_PID_60_DLY_CLK_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_DLY_CLK_EN_DEFAULT	\
+	(AW87XXX_PID_60_DLY_CLK_EN_DEFAULT_VALUE << AW87XXX_PID_60_DLY_CLK_EN_START_BIT)
+
+/* ADPBST_FALL_TIME bit 7:6 (ADPBST 0x6D) */
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT	(6)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_ADPBST_FALL_TIME_BITS_LEN)-1) << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT))
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_5MS	(0)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_5MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_5MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_10MS	(1)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_10MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_10MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_20MS	(2)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_20MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_20MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_40MS	(3)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_40MS_VALUE	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_40MS << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT	\
+	(AW87XXX_PID_60_ADPBST_FALL_TIME_DEFAULT_VALUE << AW87XXX_PID_60_ADPBST_FALL_TIME_START_BIT)
+
+/* default value of ADPBST (0x6D) */
+/* #define AW87XXX_PID_60_ADPBST_DEFAULT		(0x50) */
+
+/* OTA (0x6E) detail */
+/* EN_SWF bit 0 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_SWF_START_BIT	(0)
+#define AW87XXX_PID_60_EN_SWF_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_SWF_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_SWF_BITS_LEN)-1) << AW87XXX_PID_60_EN_SWF_START_BIT))
+
+#define AW87XXX_PID_60_EN_SWF_DISABLE	(0)
+#define AW87XXX_PID_60_EN_SWF_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SWF_DISABLE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_60_EN_SWF_ENABLE	(1)
+#define AW87XXX_PID_60_EN_SWF_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_SWF_ENABLE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+#define AW87XXX_PID_60_EN_SWF_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_SWF_DEFAULT	\
+	(AW87XXX_PID_60_EN_SWF_DEFAULT_VALUE << AW87XXX_PID_60_EN_SWF_START_BIT)
+
+/* BST_CK_MODE bit 1 (OTA 0x6E) */
+#define AW87XXX_PID_60_BST_CK_MODE_START_BIT	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_CK_MODE_BITS_LEN)-1) << AW87XXX_PID_60_BST_CK_MODE_START_BIT))
+
+#define AW87XXX_PID_60_BST_CK_MODE_1P6MHZ	(0)
+#define AW87XXX_PID_60_BST_CK_MODE_1P6MHZ_VALUE	\
+	(AW87XXX_PID_60_BST_CK_MODE_1P6MHZ << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_60_BST_CK_MODE_2P0MHZ	(1)
+#define AW87XXX_PID_60_BST_CK_MODE_2P0MHZ_VALUE	\
+	(AW87XXX_PID_60_BST_CK_MODE_2P0MHZ << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+#define AW87XXX_PID_60_BST_CK_MODE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BST_CK_MODE_DEFAULT	\
+	(AW87XXX_PID_60_BST_CK_MODE_DEFAULT_VALUE << AW87XXX_PID_60_BST_CK_MODE_START_BIT)
+
+/* EN_LOOP_GBW_REDUCE bit 2 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT	(2)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_BITS_LEN)-1) << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT))
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE	(0)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DISABLE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE	(1)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_ENABLE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT	\
+	(AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_DEFAULT_VALUE << AW87XXX_PID_60_EN_LOOP_GBW_REDUCE_START_BIT)
+
+/* EN_DEM_POWER bit 3 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_DEM_POWER_START_BIT	(3)
+#define AW87XXX_PID_60_EN_DEM_POWER_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_DEM_POWER_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_DEM_POWER_BITS_LEN)-1) << AW87XXX_PID_60_EN_DEM_POWER_START_BIT))
+
+#define AW87XXX_PID_60_EN_DEM_POWER_DISABLE	(0)
+#define AW87XXX_PID_60_EN_DEM_POWER_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_POWER_DISABLE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_POWER_ENABLE	(1)
+#define AW87XXX_PID_60_EN_DEM_POWER_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_POWER_ENABLE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_POWER_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_DEM_POWER_DEFAULT	\
+	(AW87XXX_PID_60_EN_DEM_POWER_DEFAULT_VALUE << AW87XXX_PID_60_EN_DEM_POWER_START_BIT)
+
+/* REG_CLK_CP_RIN bit 4 (OTA 0x6E) */
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT	(4)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_CLK_CP_RIN_BITS_LEN)-1) << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT))
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ	(0)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_200KHZ << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ	(1)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ_VALUE	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_400KHZ << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT	\
+	(AW87XXX_PID_60_REG_CLK_CP_RIN_DEFAULT_VALUE << AW87XXX_PID_60_REG_CLK_CP_RIN_START_BIT)
+
+/* EN_DEM bit 5 (OTA 0x6E) */
+#define AW87XXX_PID_60_EN_DEM_START_BIT	(5)
+#define AW87XXX_PID_60_EN_DEM_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_DEM_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_DEM_BITS_LEN)-1) << AW87XXX_PID_60_EN_DEM_START_BIT))
+
+#define AW87XXX_PID_60_EN_DEM_DISABLE	(0)
+#define AW87XXX_PID_60_EN_DEM_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_DISABLE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_ENABLE	(1)
+#define AW87XXX_PID_60_EN_DEM_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_DEM_ENABLE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+#define AW87XXX_PID_60_EN_DEM_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_DEM_DEFAULT	\
+	(AW87XXX_PID_60_EN_DEM_DEFAULT_VALUE << AW87XXX_PID_60_EN_DEM_START_BIT)
+
+/* OTA_NG bit 6 (OTA 0x6E) */
+#define AW87XXX_PID_60_OTA_NG_START_BIT	(6)
+#define AW87XXX_PID_60_OTA_NG_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_NG_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_NG_BITS_LEN)-1) << AW87XXX_PID_60_OTA_NG_START_BIT))
+
+#define AW87XXX_PID_60_OTA_NG_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_NG_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_NG_DISABLE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+#define AW87XXX_PID_60_OTA_NG_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_NG_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_NG_ENABLE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+#define AW87XXX_PID_60_OTA_NG_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OTA_NG_DEFAULT	\
+	(AW87XXX_PID_60_OTA_NG_DEFAULT_VALUE << AW87XXX_PID_60_OTA_NG_START_BIT)
+
+/* OTA_CP bit 7 (OTA 0x6E) */
+#define AW87XXX_PID_60_OTA_CP_START_BIT	(7)
+#define AW87XXX_PID_60_OTA_CP_BITS_LEN	(1)
+#define AW87XXX_PID_60_OTA_CP_MASK		\
+	(~(((1<<AW87XXX_PID_60_OTA_CP_BITS_LEN)-1) << AW87XXX_PID_60_OTA_CP_START_BIT))
+
+#define AW87XXX_PID_60_OTA_CP_DISABLE	(0)
+#define AW87XXX_PID_60_OTA_CP_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_CP_DISABLE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+#define AW87XXX_PID_60_OTA_CP_ENABLE	(1)
+#define AW87XXX_PID_60_OTA_CP_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OTA_CP_ENABLE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+#define AW87XXX_PID_60_OTA_CP_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_OTA_CP_DEFAULT	\
+	(AW87XXX_PID_60_OTA_CP_DEFAULT_VALUE << AW87XXX_PID_60_OTA_CP_START_BIT)
+
+/* default value of OTA (0x6E) */
+/* #define AW87XXX_PID_60_OTA_DEFAULT		(0xC0) */
+
+/* RAMPGEN (0x6F) detail */
+/* RAMP_1SPW_VL bit 7:6 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT	(6)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_BITS_LEN	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_MASK	\
+	(~(((1<<AW87XXX_PID_60_RAMP_1SPW_VL_BITS_LEN)-1) << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT))
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD	(0)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P16VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD	(1)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P18VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P20VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD	(3)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_0P14VDD << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT	\
+	(AW87XXX_PID_60_RAMP_1SPW_VL_DEFAULT_VALUE << AW87XXX_PID_60_RAMP_1SPW_VL_START_BIT)
+
+/* PA_RAMP_AGC1 bit 5:4 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT	(4)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_RAMP_AGC1_BITS_LEN)-1) << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT))
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD	(0)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P8VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD	(1)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P825VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD	(2)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P85VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD	(3)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD_VALUE	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_0P875VDD << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+#define AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT	\
+	(AW87XXX_PID_60_PA_RAMP_AGC1_DEFAULT_VALUE << AW87XXX_PID_60_PA_RAMP_AGC1_START_BIT)
+
+/* RAMP_1SPW_VC bit 3:2 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_BITS_LEN	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_MASK	\
+	(~(((1<<AW87XXX_PID_60_RAMP_1SPW_VC_BITS_LEN)-1) << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT))
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD	(0)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P37VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD	(1)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P39VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD	(2)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P33VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD	(3)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD_VALUE	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_0P35VDD << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+#define AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT	\
+	(AW87XXX_PID_60_RAMP_1SPW_VC_DEFAULT_VALUE << AW87XXX_PID_60_RAMP_1SPW_VC_START_BIT)
+
+/* SS_CONTROL bit 1:0 (RAMPGEN 0x6F) */
+#define AW87XXX_PID_60_SS_CONTROL_START_BIT	(0)
+#define AW87XXX_PID_60_SS_CONTROL_BITS_LEN	(2)
+#define AW87XXX_PID_60_SS_CONTROL_MASK	\
+	(~(((1<<AW87XXX_PID_60_SS_CONTROL_BITS_LEN)-1) << AW87XXX_PID_60_SS_CONTROL_START_BIT))
+
+#define AW87XXX_PID_60_SS_CONTROL_SS_MODE	(0)
+#define AW87XXX_PID_60_SS_CONTROL_SS_MODE_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SS_MODE << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111	(1)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE111 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000	(2)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE000 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011	(3)
+#define AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011_VALUE	\
+	(AW87XXX_PID_60_SS_CONTROL_SWBELOW20ABOVE011 << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+#define AW87XXX_PID_60_SS_CONTROL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_SS_CONTROL_DEFAULT	\
+	(AW87XXX_PID_60_SS_CONTROL_DEFAULT_VALUE << AW87XXX_PID_60_SS_CONTROL_START_BIT)
+
+/* default value of RAMPGEN (0x6F) */
+/* #define AW87XXX_PID_60_RAMPGEN_DEFAULT		(0x0C) */
+
+/* CLASSD_SYSCTRL (0x70) detail */
+/* SEL_VCOM1 bit 0 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_SEL_VCOM1_START_BIT	(0)
+#define AW87XXX_PID_60_SEL_VCOM1_BITS_LEN	(1)
+#define AW87XXX_PID_60_SEL_VCOM1_MASK	\
+	(~(((1<<AW87XXX_PID_60_SEL_VCOM1_BITS_LEN)-1) << AW87XXX_PID_60_SEL_VCOM1_START_BIT))
+
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V	(0)
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V_VALUE	\
+	(AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+
+/*
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V	(1)
+#define AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V_VALUE	\
+	(AW87XXX_PID_60_SEL_VCOM1_VCOM11P4V << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+*/
+/*
+Fix me here:
+reg_addr:0x70, reg_name:CLASSD_SYSCTRL, field_name:SEL_VCOM1, content:When ENOTA=0:
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_SEL_VCOM1_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_SEL_VCOM1_DEFAULT	\
+	(AW87XXX_PID_60_SEL_VCOM1_DEFAULT_VALUE << AW87XXX_PID_60_SEL_VCOM1_START_BIT)
+
+/* PA_OPD bit 1 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_OPD_START_BIT	(1)
+#define AW87XXX_PID_60_PA_OPD_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OPD_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_OPD_BITS_LEN)-1) << AW87XXX_PID_60_PA_OPD_START_BIT))
+
+#define AW87XXX_PID_60_PA_OPD_FLOATING	(0)
+#define AW87XXX_PID_60_PA_OPD_FLOATING_VALUE	\
+	(AW87XXX_PID_60_PA_OPD_FLOATING << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OPD_TIED_TO_GND	(1)
+#define AW87XXX_PID_60_PA_OPD_TIED_TO_GND_VALUE	\
+	(AW87XXX_PID_60_PA_OPD_TIED_TO_GND << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OPD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OPD_DEFAULT	\
+	(AW87XXX_PID_60_PA_OPD_DEFAULT_VALUE << AW87XXX_PID_60_PA_OPD_START_BIT)
+
+/* CLK_OCP_SEL bit 4 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_CLK_OCP_SEL_START_BIT	(4)
+#define AW87XXX_PID_60_CLK_OCP_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_CLK_OCP_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_CLK_OCP_SEL_BITS_LEN)-1) << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT))
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_160MS	(0)
+#define AW87XXX_PID_60_CLK_OCP_SEL_160MS_VALUE	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_160MS << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN	(1)
+#define AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_SHUTDOWN << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+#define AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT	\
+	(AW87XXX_PID_60_CLK_OCP_SEL_DEFAULT_VALUE << AW87XXX_PID_60_CLK_OCP_SEL_START_BIT)
+
+/* PD_OT bit 5 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PD_OT_START_BIT	(5)
+#define AW87XXX_PID_60_PD_OT_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_OT_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_OT_BITS_LEN)-1) << AW87XXX_PID_60_PD_OT_START_BIT))
+
+#define AW87XXX_PID_60_PD_OT_ENABLE		(0)
+#define AW87XXX_PID_60_PD_OT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_OT_ENABLE << AW87XXX_PID_60_PD_OT_START_BIT)
+
+#define AW87XXX_PID_60_PD_OT_SHUTDOWN	(1)
+#define AW87XXX_PID_60_PD_OT_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_PD_OT_SHUTDOWN << AW87XXX_PID_60_PD_OT_START_BIT)
+
+#define AW87XXX_PID_60_PD_OT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_OT_DEFAULT	\
+	(AW87XXX_PID_60_PD_OT_DEFAULT_VALUE << AW87XXX_PID_60_PD_OT_START_BIT)
+
+/* PA_FLT_SR bit 6 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_FLT_SR_START_BIT	(6)
+#define AW87XXX_PID_60_PA_FLT_SR_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_FLT_SR_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_FLT_SR_BITS_LEN)-1) << AW87XXX_PID_60_PA_FLT_SR_START_BIT))
+
+#define AW87XXX_PID_60_PA_FLT_SR_ADD_RC	(0)
+#define AW87XXX_PID_60_PA_FLT_SR_ADD_RC_VALUE	\
+	(AW87XXX_PID_60_PA_FLT_SR_ADD_RC << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_60_PA_FLT_SR_NO_RC	(1)
+#define AW87XXX_PID_60_PA_FLT_SR_NO_RC_VALUE	\
+	(AW87XXX_PID_60_PA_FLT_SR_NO_RC << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+#define AW87XXX_PID_60_PA_FLT_SR_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_FLT_SR_DEFAULT	\
+	(AW87XXX_PID_60_PA_FLT_SR_DEFAULT_VALUE << AW87XXX_PID_60_PA_FLT_SR_START_BIT)
+
+/* PA_PORT bit 3:2 (CLASSD_SYSCTRL 0x70) */
+#define AW87XXX_PID_60_PA_PORT_START_BIT	(2)
+#define AW87XXX_PID_60_PA_PORT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_PORT_MASK		\
+	(~(((1<<AW87XXX_PID_60_PA_PORT_BITS_LEN)-1) << AW87XXX_PID_60_PA_PORT_START_BIT))
+
+#define AW87XXX_PID_60_PA_PORT_80MS		(0)
+#define AW87XXX_PID_60_PA_PORT_80MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_80MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_40MS		(1)
+#define AW87XXX_PID_60_PA_PORT_40MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_40MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_20MS		(2)
+#define AW87XXX_PID_60_PA_PORT_20MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_20MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_10MS		(3)
+#define AW87XXX_PID_60_PA_PORT_10MS_VALUE	\
+	(AW87XXX_PID_60_PA_PORT_10MS << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+#define AW87XXX_PID_60_PA_PORT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_PORT_DEFAULT	\
+	(AW87XXX_PID_60_PA_PORT_DEFAULT_VALUE << AW87XXX_PID_60_PA_PORT_START_BIT)
+
+/* default value of CLASSD_SYSCTRL (0x70) */
+/* #define AW87XXX_PID_60_CLASSD_SYSCTRL_DEFAULT		(0x07) */
+
+/* GTDR (0x71) detail */
+/* REG_DUTY_T bit 0 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_DUTY_T_START_BIT	(0)
+#define AW87XXX_PID_60_REG_DUTY_T_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_DUTY_T_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_DUTY_T_BITS_LEN)-1) << AW87XXX_PID_60_REG_DUTY_T_START_BIT))
+
+#define AW87XXX_PID_60_REG_DUTY_T_DISABLE	(0)
+#define AW87XXX_PID_60_REG_DUTY_T_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_T_DISABLE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_T_ENALBE	(1)
+#define AW87XXX_PID_60_REG_DUTY_T_ENALBE_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_T_ENALBE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_T_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_DUTY_T_DEFAULT	\
+	(AW87XXX_PID_60_REG_DUTY_T_DEFAULT_VALUE << AW87XXX_PID_60_REG_DUTY_T_START_BIT)
+
+/* LN_DELAY bit 1 (GTDR 0x71) */
+#define AW87XXX_PID_60_LN_DELAY_START_BIT	(1)
+#define AW87XXX_PID_60_LN_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_LN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_LN_DELAY_DISABLE	(0)
+#define AW87XXX_PID_60_LN_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_DELAY_DISABLE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_LN_DELAY_ENABLE	(1)
+#define AW87XXX_PID_60_LN_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_LN_DELAY_ENABLE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_LN_DELAY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_LN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_LN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_LN_DELAY_START_BIT)
+
+/* HN_DELAY bit 2 (GTDR 0x71) */
+#define AW87XXX_PID_60_HN_DELAY_START_BIT	(2)
+#define AW87XXX_PID_60_HN_DELAY_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_DELAY_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_DELAY_BITS_LEN)-1) << AW87XXX_PID_60_HN_DELAY_START_BIT))
+
+#define AW87XXX_PID_60_HN_DELAY_DISABLE	(0)
+#define AW87XXX_PID_60_HN_DELAY_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_DELAY_DISABLE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_HN_DELAY_ENABLE	(1)
+#define AW87XXX_PID_60_HN_DELAY_ENABLE_VALUE	\
+	(AW87XXX_PID_60_HN_DELAY_ENABLE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+#define AW87XXX_PID_60_HN_DELAY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_HN_DELAY_DEFAULT	\
+	(AW87XXX_PID_60_HN_DELAY_DEFAULT_VALUE << AW87XXX_PID_60_HN_DELAY_START_BIT)
+
+/* REG_T_EDGE bit 3 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_T_EDGE_START_BIT	(3)
+#define AW87XXX_PID_60_REG_T_EDGE_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_T_EDGE_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_T_EDGE_BITS_LEN)-1) << AW87XXX_PID_60_REG_T_EDGE_START_BIT))
+
+#define AW87XXX_PID_60_REG_T_EDGE_5NS	(0)
+#define AW87XXX_PID_60_REG_T_EDGE_5NS_VALUE	\
+	(AW87XXX_PID_60_REG_T_EDGE_5NS << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+#define AW87XXX_PID_60_REG_T_EDGE_15NS	(1)
+#define AW87XXX_PID_60_REG_T_EDGE_15NS_VALUE	\
+	(AW87XXX_PID_60_REG_T_EDGE_15NS << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+#define AW87XXX_PID_60_REG_T_EDGE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_T_EDGE_DEFAULT	\
+	(AW87XXX_PID_60_REG_T_EDGE_DEFAULT_VALUE << AW87XXX_PID_60_REG_T_EDGE_START_BIT)
+
+/* REG_L_PULL bit 4 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_L_PULL_START_BIT	(4)
+#define AW87XXX_PID_60_REG_L_PULL_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_L_PULL_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_L_PULL_BITS_LEN)-1) << AW87XXX_PID_60_REG_L_PULL_START_BIT))
+
+#define AW87XXX_PID_60_REG_L_PULL_7NS	(0)
+#define AW87XXX_PID_60_REG_L_PULL_7NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PULL_7NS << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PULL_14NS	(1)
+#define AW87XXX_PID_60_REG_L_PULL_14NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PULL_14NS << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PULL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_L_PULL_DEFAULT	\
+	(AW87XXX_PID_60_REG_L_PULL_DEFAULT_VALUE << AW87XXX_PID_60_REG_L_PULL_START_BIT)
+
+/* REG_L_PUD bit 5 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_L_PUD_START_BIT	(5)
+#define AW87XXX_PID_60_REG_L_PUD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_L_PUD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_L_PUD_BITS_LEN)-1) << AW87XXX_PID_60_REG_L_PUD_START_BIT))
+
+#define AW87XXX_PID_60_REG_L_PUD_0NS	(0)
+#define AW87XXX_PID_60_REG_L_PUD_0NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PUD_0NS << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PUD_3NS	(1)
+#define AW87XXX_PID_60_REG_L_PUD_3NS_VALUE	\
+	(AW87XXX_PID_60_REG_L_PUD_3NS << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+#define AW87XXX_PID_60_REG_L_PUD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_L_PUD_DEFAULT	\
+	(AW87XXX_PID_60_REG_L_PUD_DEFAULT_VALUE << AW87XXX_PID_60_REG_L_PUD_START_BIT)
+
+/* REG_HNG_PULL bit 6 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_HNG_PULL_START_BIT	(6)
+#define AW87XXX_PID_60_REG_HNG_PULL_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_HNG_PULL_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_HNG_PULL_BITS_LEN)-1) << AW87XXX_PID_60_REG_HNG_PULL_START_BIT))
+
+#define AW87XXX_PID_60_REG_HNG_PULL_DISABLE	(0)
+#define AW87XXX_PID_60_REG_HNG_PULL_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_HNG_PULL_DISABLE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_HNG_PULL_ENABLE	(1)
+#define AW87XXX_PID_60_REG_HNG_PULL_ENABLE_VALUE	\
+	(AW87XXX_PID_60_REG_HNG_PULL_ENABLE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+#define AW87XXX_PID_60_REG_HNG_PULL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_HNG_PULL_DEFAULT	\
+	(AW87XXX_PID_60_REG_HNG_PULL_DEFAULT_VALUE << AW87XXX_PID_60_REG_HNG_PULL_START_BIT)
+
+/* REG_DUTY_VTH bit 7 (GTDR 0x71) */
+#define AW87XXX_PID_60_REG_DUTY_VTH_START_BIT	(7)
+#define AW87XXX_PID_60_REG_DUTY_VTH_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_DUTY_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_DUTY_VTH_BITS_LEN)-1) << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT))
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH0	(0)
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH0_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_POVTH0 << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH4	(1)
+#define AW87XXX_PID_60_REG_DUTY_VTH_POVTH4_VALUE	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_POVTH4 << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+#define AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT	\
+	(AW87XXX_PID_60_REG_DUTY_VTH_DEFAULT_VALUE << AW87XXX_PID_60_REG_DUTY_VTH_START_BIT)
+
+/* default value of GTDR (0x71) */
+/* #define AW87XXX_PID_60_GTDR_DEFAULT		(0x27) */
+
+/* OC (0x72) detail */
+/* REG_SHORT_GUARD bit 7 (OC 0x72) */
+#define AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT	(7)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_SHORT_GUARD_BITS_LEN)-1) << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT))
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE	(0)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_DISABLE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE	(1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE_VALUE	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_ENALBE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT	\
+	(AW87XXX_PID_60_REG_SHORT_GUARD_DEFAULT_VALUE << AW87XXX_PID_60_REG_SHORT_GUARD_START_BIT)
+
+/* PA_GTDR_DDT bit 6:5 (OC 0x72) */
+#define AW87XXX_PID_60_PA_GTDR_DDT_START_BIT	(5)
+#define AW87XXX_PID_60_PA_GTDR_DDT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_GTDR_DDT_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_GTDR_DDT_BITS_LEN)-1) << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT))
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_12NS	(0)
+#define AW87XXX_PID_60_PA_GTDR_DDT_12NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_12NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_13NS	(1)
+#define AW87XXX_PID_60_PA_GTDR_DDT_13NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_13NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_14NS	(2)
+#define AW87XXX_PID_60_PA_GTDR_DDT_14NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_14NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_15NS	(3)
+#define AW87XXX_PID_60_PA_GTDR_DDT_15NS_VALUE	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_15NS << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+#define AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT	\
+	(AW87XXX_PID_60_PA_GTDR_DDT_DEFAULT_VALUE << AW87XXX_PID_60_PA_GTDR_DDT_START_BIT)
+
+/* PA_OC_ITH bit 4:2 (OC 0x72) */
+#define AW87XXX_PID_60_PA_OC_ITH_START_BIT	(2)
+#define AW87XXX_PID_60_PA_OC_ITH_BITS_LEN	(3)
+#define AW87XXX_PID_60_PA_OC_ITH_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OC_ITH_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_ITH_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_ITH_3P4A	(0)
+#define AW87XXX_PID_60_PA_OC_ITH_3P4A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_3P4A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_3P8A	(1)
+#define AW87XXX_PID_60_PA_OC_ITH_3P8A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_3P8A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_4P2A	(2)
+#define AW87XXX_PID_60_PA_OC_ITH_4P2A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_4P2A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_4P6A	(3)
+#define AW87XXX_PID_60_PA_OC_ITH_4P6A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_4P6A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P0A	(4)
+#define AW87XXX_PID_60_PA_OC_ITH_5P0A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P0A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P4A	(5)
+#define AW87XXX_PID_60_PA_OC_ITH_5P4A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P4A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_5P7A	(6)
+#define AW87XXX_PID_60_PA_OC_ITH_5P7A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_5P7A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_6P0A	(7)
+#define AW87XXX_PID_60_PA_OC_ITH_6P0A_VALUE	\
+	(AW87XXX_PID_60_PA_OC_ITH_6P0A << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_ITH_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_PA_OC_ITH_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_ITH_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_ITH_START_BIT)
+
+/* PA_OC_DT bit 1:0 (OC 0x72) */
+#define AW87XXX_PID_60_PA_OC_DT_START_BIT	(0)
+#define AW87XXX_PID_60_PA_OC_DT_BITS_LEN	(2)
+#define AW87XXX_PID_60_PA_OC_DT_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OC_DT_BITS_LEN)-1) << AW87XXX_PID_60_PA_OC_DT_START_BIT))
+
+#define AW87XXX_PID_60_PA_OC_DT_20NS	(0)
+#define AW87XXX_PID_60_PA_OC_DT_20NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_20NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_40NS	(1)
+#define AW87XXX_PID_60_PA_OC_DT_40NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_40NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_60NS	(2)
+#define AW87XXX_PID_60_PA_OC_DT_60NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_60NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_80NS	(3)
+#define AW87XXX_PID_60_PA_OC_DT_80NS_VALUE	\
+	(AW87XXX_PID_60_PA_OC_DT_80NS << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+#define AW87XXX_PID_60_PA_OC_DT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_OC_DT_DEFAULT	\
+	(AW87XXX_PID_60_PA_OC_DT_DEFAULT_VALUE << AW87XXX_PID_60_PA_OC_DT_START_BIT)
+
+/* default value of OC (0x72) */
+/* #define AW87XXX_PID_60_OC_DEFAULT		(0x8C) */
+
+/* AGC_CON (0x73) detail */
+/* PA_OCSWD bit 6 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_PA_OCSWD_START_BIT	(6)
+#define AW87XXX_PID_60_PA_OCSWD_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_OCSWD_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_OCSWD_BITS_LEN)-1) << AW87XXX_PID_60_PA_OCSWD_START_BIT))
+
+#define AW87XXX_PID_60_PA_OCSWD_FAST	(0)
+#define AW87XXX_PID_60_PA_OCSWD_FAST_VALUE	\
+	(AW87XXX_PID_60_PA_OCSWD_FAST << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OCSWD_SLOW	(1)
+#define AW87XXX_PID_60_PA_OCSWD_SLOW_VALUE	\
+	(AW87XXX_PID_60_PA_OCSWD_SLOW << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+#define AW87XXX_PID_60_PA_OCSWD_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PA_OCSWD_DEFAULT	\
+	(AW87XXX_PID_60_PA_OCSWD_DEFAULT_VALUE << AW87XXX_PID_60_PA_OCSWD_START_BIT)
+
+/* PD_CROSSZERO bit 5:4 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_PD_CROSSZERO_START_BIT	(4)
+#define AW87XXX_PID_60_PD_CROSSZERO_BITS_LEN	(2)
+#define AW87XXX_PID_60_PD_CROSSZERO_MASK	\
+	(~(((1<<AW87XXX_PID_60_PD_CROSSZERO_BITS_LEN)-1) << AW87XXX_PID_60_PD_CROSSZERO_START_BIT))
+
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO	(0)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC2_3_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO	(1)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+/*
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO	(2)
+#define AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_ENABLE_AGC1_WHEN_PVDD_IS_RISINGAGC23_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+*/
+
+#define AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO	(3)
+#define AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO_VALUE	\
+	(AW87XXX_PID_60_PD_CROSSZERO_AGC123_CROSSZERO << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+/*
+Fix me here:
+reg_addr:0x73, reg_name:AGC_CON, field_name:PD_CROSSZERO, content:AGC cross_zero adaptively When EN_AGC1_ADP=1
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PD_CROSSZERO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_CROSSZERO_DEFAULT	\
+	(AW87XXX_PID_60_PD_CROSSZERO_DEFAULT_VALUE << AW87XXX_PID_60_PD_CROSSZERO_START_BIT)
+
+/* AGC1_VTH_SEL bit 3:2 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC1_VTH_SEL_BITS_LEN)-1) << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT))
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN	(0)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_RAMPGEN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_THGEN	(1)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_THGEN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_THGEN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN	(2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+/*
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN	(3)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN_VALUE	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_BOTH_MIN << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+*/
+
+#define AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT	\
+	(AW87XXX_PID_60_AGC1_VTH_SEL_DEFAULT_VALUE << AW87XXX_PID_60_AGC1_VTH_SEL_START_BIT)
+
+/* AGC2_FIRST_ATT_TIME bit 1:0 (AGC_CON 0x73) */
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT	(0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_BITS_LEN	(2)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_MASK	\
+	(~(((1<<AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_BITS_LEN)-1) << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT))
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS	(0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P08MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS	(1)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_0P32MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS	(2)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_1P28MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS	(3)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS_VALUE	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_5P12MS << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT	\
+	(AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_DEFAULT_VALUE << AW87XXX_PID_60_AGC2_FIRST_ATT_TIME_START_BIT)
+
+/* default value of AGC_CON (0x73) */
+/* #define AW87XXX_PID_60_AGC_CON_DEFAULT		(0x48) */
+
+/* NG (0x74) detail */
+/* NG_MODE bit 2 (NG 0x74) */
+#define AW87XXX_PID_60_NG_MODE_START_BIT	(2)
+#define AW87XXX_PID_60_NG_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_MODE_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_MODE_BITS_LEN)-1) << AW87XXX_PID_60_NG_MODE_START_BIT))
+
+#define AW87XXX_PID_60_NG_MODE_MODE1	(0)
+#define AW87XXX_PID_60_NG_MODE_MODE1_VALUE	\
+	(AW87XXX_PID_60_NG_MODE_MODE1 << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+#define AW87XXX_PID_60_NG_MODE_MODE2	(1)
+#define AW87XXX_PID_60_NG_MODE_MODE2_VALUE	\
+	(AW87XXX_PID_60_NG_MODE_MODE2 << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+#define AW87XXX_PID_60_NG_MODE_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_MODE_DEFAULT	\
+	(AW87XXX_PID_60_NG_MODE_DEFAULT_VALUE << AW87XXX_PID_60_NG_MODE_START_BIT)
+
+/* EN_NG bit 3 (NG 0x74) */
+#define AW87XXX_PID_60_EN_NG_START_BIT	(3)
+#define AW87XXX_PID_60_EN_NG_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_NG_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_NG_BITS_LEN)-1) << AW87XXX_PID_60_EN_NG_START_BIT))
+
+#define AW87XXX_PID_60_EN_NG_DISABLE	(0)
+#define AW87XXX_PID_60_EN_NG_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_NG_DISABLE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+#define AW87XXX_PID_60_EN_NG_ENABLE		(1)
+#define AW87XXX_PID_60_EN_NG_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_NG_ENABLE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+#define AW87XXX_PID_60_EN_NG_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_NG_DEFAULT	\
+	(AW87XXX_PID_60_EN_NG_DEFAULT_VALUE << AW87XXX_PID_60_EN_NG_START_BIT)
+
+/* EN_AGC1_ADP bit 7 (NG 0x74) */
+#define AW87XXX_PID_60_EN_AGC1_ADP_START_BIT	(7)
+#define AW87XXX_PID_60_EN_AGC1_ADP_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_AGC1_ADP_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_AGC1_ADP_BITS_LEN)-1) << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT))
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE	(0)
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE_VALUE	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_AS_BEFORE << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY	(1)
+#define AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY_VALUE	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_AGC_CROSSZERO_ADAPTIVELY << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+#define AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT	\
+	(AW87XXX_PID_60_EN_AGC1_ADP_DEFAULT_VALUE << AW87XXX_PID_60_EN_AGC1_ADP_START_BIT)
+
+/* PAVG_ADJ bit 6:4 (NG 0x74) */
+#define AW87XXX_PID_60_PAVG_ADJ_START_BIT	(4)
+#define AW87XXX_PID_60_PAVG_ADJ_BITS_LEN	(3)
+#define AW87XXX_PID_60_PAVG_ADJ_MASK	\
+	(~(((1<<AW87XXX_PID_60_PAVG_ADJ_BITS_LEN)-1) << AW87XXX_PID_60_PAVG_ADJ_START_BIT))
+
+#define AW87XXX_PID_60_PAVG_ADJ_0P94	(0)
+#define AW87XXX_PID_60_PAVG_ADJ_0P94_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_0P94 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_0P97	(1)
+#define AW87XXX_PID_60_PAVG_ADJ_0P97_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_0P97 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P0		(2)
+#define AW87XXX_PID_60_PAVG_ADJ_1P0_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P0 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P03	(3)
+#define AW87XXX_PID_60_PAVG_ADJ_1P03_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P03 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P06	(4)
+#define AW87XXX_PID_60_PAVG_ADJ_1P06_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P06 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_1P09	(5)
+#define AW87XXX_PID_60_PAVG_ADJ_1P09_VALUE	\
+	(AW87XXX_PID_60_PAVG_ADJ_1P09 << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+#define AW87XXX_PID_60_PAVG_ADJ_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_PAVG_ADJ_DEFAULT	\
+	(AW87XXX_PID_60_PAVG_ADJ_DEFAULT_VALUE << AW87XXX_PID_60_PAVG_ADJ_START_BIT)
+
+/* NG_GAIN bit 1:0 (NG 0x74) */
+#define AW87XXX_PID_60_NG_GAIN_START_BIT	(0)
+#define AW87XXX_PID_60_NG_GAIN_BITS_LEN	(2)
+#define AW87XXX_PID_60_NG_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_GAIN_BITS_LEN)-1) << AW87XXX_PID_60_NG_GAIN_START_BIT))
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS6DB	(0)
+#define AW87XXX_PID_60_NG_GAIN_MINUS6DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS6DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS7P5DB	(1)
+#define AW87XXX_PID_60_NG_GAIN_MINUS7P5DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS7P5DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS9DB	(2)
+#define AW87XXX_PID_60_NG_GAIN_MINUS9DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS9DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_MINUS12DB	(3)
+#define AW87XXX_PID_60_NG_GAIN_MINUS12DB_VALUE	\
+	(AW87XXX_PID_60_NG_GAIN_MINUS12DB << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+#define AW87XXX_PID_60_NG_GAIN_DEFAULT_VALUE	(0x3)
+#define AW87XXX_PID_60_NG_GAIN_DEFAULT	\
+	(AW87XXX_PID_60_NG_GAIN_DEFAULT_VALUE << AW87XXX_PID_60_NG_GAIN_START_BIT)
+
+/* default value of NG (0x74) */
+/* #define AW87XXX_PID_60_NG_DEFAULT		(0x27) */
+
+/* NG2 (0x75) detail */
+/* NG_CLK0_SEL bit 0 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_CLK0_SEL_START_BIT	(0)
+#define AW87XXX_PID_60_NG_CLK0_SEL_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_NG_CLK0_SEL_BITS_LEN)-1) << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT))
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_5US	(0)
+#define AW87XXX_PID_60_NG_CLK0_SEL_5US_VALUE	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_5US << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_10US	(1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_10US_VALUE	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_10US << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+#define AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT	\
+	(AW87XXX_PID_60_NG_CLK0_SEL_DEFAULT_VALUE << AW87XXX_PID_60_NG_CLK0_SEL_START_BIT)
+
+/* NG_DEGLITCH_CTRL bit 7 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT	(7)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_BITS_LEN	(1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_NG_DEGLITCH_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N	(0)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N_VALUE	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_8P6N << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N	(1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N_VALUE	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_14P2N << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_NG_DEGLITCH_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_NG_DEGLITCH_CTRL_START_BIT)
+
+/* NGVTH bit 6:4 (NG2 0x75) */
+#define AW87XXX_PID_60_NGVTH_START_BIT	(4)
+#define AW87XXX_PID_60_NGVTH_BITS_LEN	(3)
+#define AW87XXX_PID_60_NGVTH_MASK		\
+	(~(((1<<AW87XXX_PID_60_NGVTH_BITS_LEN)-1) << AW87XXX_PID_60_NGVTH_START_BIT))
+
+#define AW87XXX_PID_60_NGVTH_5MV		(0)
+#define AW87XXX_PID_60_NGVTH_5MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_5MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_8MV		(1)
+#define AW87XXX_PID_60_NGVTH_8MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_8MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_10MV		(2)
+#define AW87XXX_PID_60_NGVTH_10MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_10MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_12MV		(3)
+#define AW87XXX_PID_60_NGVTH_12MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_12MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_14MV		(4)
+#define AW87XXX_PID_60_NGVTH_14MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_14MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_16MV		(5)
+#define AW87XXX_PID_60_NGVTH_16MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_16MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+/*
+#define AW87XXX_PID_60_NGVTH_16MV		(6)
+#define AW87XXX_PID_60_NGVTH_16MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_16MV << AW87XXX_PID_60_NGVTH_START_BIT)
+*/
+
+#define AW87XXX_PID_60_NGVTH_25MV		(7)
+#define AW87XXX_PID_60_NGVTH_25MV_VALUE	\
+	(AW87XXX_PID_60_NGVTH_25MV << AW87XXX_PID_60_NGVTH_START_BIT)
+
+#define AW87XXX_PID_60_NGVTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_NGVTH_DEFAULT	\
+	(AW87XXX_PID_60_NGVTH_DEFAULT_VALUE << AW87XXX_PID_60_NGVTH_START_BIT)
+
+/* NG_ACK bit 3:1 (NG2 0x75) */
+#define AW87XXX_PID_60_NG_ACK_START_BIT	(1)
+#define AW87XXX_PID_60_NG_ACK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_ACK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_ACK_BITS_LEN)-1) << AW87XXX_PID_60_NG_ACK_START_BIT))
+
+#define AW87XXX_PID_60_NG_ACK_10MS		(0)
+#define AW87XXX_PID_60_NG_ACK_10MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_10MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_20MS		(1)
+#define AW87XXX_PID_60_NG_ACK_20MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_20MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_40MS		(2)
+#define AW87XXX_PID_60_NG_ACK_40MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_40MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_80MS		(3)
+#define AW87XXX_PID_60_NG_ACK_80MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_80MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_160MS		(4)
+#define AW87XXX_PID_60_NG_ACK_160MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_160MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_320MS		(5)
+#define AW87XXX_PID_60_NG_ACK_320MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_320MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_640MS		(6)
+#define AW87XXX_PID_60_NG_ACK_640MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_640MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_1280MS	(7)
+#define AW87XXX_PID_60_NG_ACK_1280MS_VALUE	\
+	(AW87XXX_PID_60_NG_ACK_1280MS << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+#define AW87XXX_PID_60_NG_ACK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_ACK_DEFAULT	\
+	(AW87XXX_PID_60_NG_ACK_DEFAULT_VALUE << AW87XXX_PID_60_NG_ACK_START_BIT)
+
+/* default value of NG2 (0x75) */
+/* #define AW87XXX_PID_60_NG2_DEFAULT		(0xA9) */
+
+/* NG3 (0x76) detail */
+/* NG_RCK bit 7:5 (NG3 0x76) */
+#define AW87XXX_PID_60_NG_RCK_START_BIT	(5)
+#define AW87XXX_PID_60_NG_RCK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_RCK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_RCK_BITS_LEN)-1) << AW87XXX_PID_60_NG_RCK_START_BIT))
+
+#define AW87XXX_PID_60_NG_RCK_90US		(0)
+#define AW87XXX_PID_60_NG_RCK_90US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_90US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_180US		(1)
+#define AW87XXX_PID_60_NG_RCK_180US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_180US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_360US		(2)
+#define AW87XXX_PID_60_NG_RCK_360US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_360US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_720US		(3)
+#define AW87XXX_PID_60_NG_RCK_720US_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_720US << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_1P44M		(4)
+#define AW87XXX_PID_60_NG_RCK_1P44M_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_1P44M << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_2P88MS	(5)
+#define AW87XXX_PID_60_NG_RCK_2P88MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_2P88MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_5P76MS	(6)
+#define AW87XXX_PID_60_NG_RCK_5P76MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_5P76MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_11P52MS	(7)
+#define AW87XXX_PID_60_NG_RCK_11P52MS_VALUE	\
+	(AW87XXX_PID_60_NG_RCK_11P52MS << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_RCK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_RCK_DEFAULT	\
+	(AW87XXX_PID_60_NG_RCK_DEFAULT_VALUE << AW87XXX_PID_60_NG_RCK_START_BIT)
+
+/* NG_WCK bit 4:2 (NG3 0x76) */
+#define AW87XXX_PID_60_NG_WCK_START_BIT	(2)
+#define AW87XXX_PID_60_NG_WCK_BITS_LEN	(3)
+#define AW87XXX_PID_60_NG_WCK_MASK		\
+	(~(((1<<AW87XXX_PID_60_NG_WCK_BITS_LEN)-1) << AW87XXX_PID_60_NG_WCK_START_BIT))
+
+#define AW87XXX_PID_60_NG_WCK_20MS		(0)
+#define AW87XXX_PID_60_NG_WCK_20MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_20MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_40MS		(1)
+#define AW87XXX_PID_60_NG_WCK_40MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_40MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_80MS		(2)
+#define AW87XXX_PID_60_NG_WCK_80MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_80MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_160MS		(3)
+#define AW87XXX_PID_60_NG_WCK_160MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_160MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_320MS		(4)
+#define AW87XXX_PID_60_NG_WCK_320MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_320MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_640MS		(5)
+#define AW87XXX_PID_60_NG_WCK_640MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_640MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_1280MS	(6)
+#define AW87XXX_PID_60_NG_WCK_1280MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_1280MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_2556MS	(7)
+#define AW87XXX_PID_60_NG_WCK_2556MS_VALUE	\
+	(AW87XXX_PID_60_NG_WCK_2556MS << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+#define AW87XXX_PID_60_NG_WCK_DEFAULT_VALUE	(0x4)
+#define AW87XXX_PID_60_NG_WCK_DEFAULT	\
+	(AW87XXX_PID_60_NG_WCK_DEFAULT_VALUE << AW87XXX_PID_60_NG_WCK_START_BIT)
+
+/* CP_VOS bit 1:0 (NG3 0x76) */
+#define AW87XXX_PID_60_CP_VOS_START_BIT	(0)
+#define AW87XXX_PID_60_CP_VOS_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_VOS_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_VOS_BITS_LEN)-1) << AW87XXX_PID_60_CP_VOS_START_BIT))
+
+#define AW87XXX_PID_60_CP_VOS_0MV		(0)
+#define AW87XXX_PID_60_CP_VOS_0MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_0MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_50MV		(1)
+#define AW87XXX_PID_60_CP_VOS_50MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_50MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_100MV		(2)
+#define AW87XXX_PID_60_CP_VOS_100MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_100MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_150MV		(3)
+#define AW87XXX_PID_60_CP_VOS_150MV_VALUE	\
+	(AW87XXX_PID_60_CP_VOS_150MV << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+#define AW87XXX_PID_60_CP_VOS_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CP_VOS_DEFAULT	\
+	(AW87XXX_PID_60_CP_VOS_DEFAULT_VALUE << AW87XXX_PID_60_CP_VOS_START_BIT)
+
+/* default value of NG3 (0x76) */
+/* #define AW87XXX_PID_60_NG3_DEFAULT		(0x91) */
+
+/* CP (0x77) detail */
+/* CP_DDT bit 0 (CP 0x77) */
+#define AW87XXX_PID_60_CP_DDT_START_BIT	(0)
+#define AW87XXX_PID_60_CP_DDT_BITS_LEN	(1)
+#define AW87XXX_PID_60_CP_DDT_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_DDT_BITS_LEN)-1) << AW87XXX_PID_60_CP_DDT_START_BIT))
+
+#define AW87XXX_PID_60_CP_DDT_0NS		(0)
+#define AW87XXX_PID_60_CP_DDT_0NS_VALUE	\
+	(AW87XXX_PID_60_CP_DDT_0NS << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_60_CP_DDT_10NS		(1)
+#define AW87XXX_PID_60_CP_DDT_10NS_VALUE	\
+	(AW87XXX_PID_60_CP_DDT_10NS << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+#define AW87XXX_PID_60_CP_DDT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_CP_DDT_DEFAULT	\
+	(AW87XXX_PID_60_CP_DDT_DEFAULT_VALUE << AW87XXX_PID_60_CP_DDT_START_BIT)
+
+/* CPOK_TM bit 1 (CP 0x77) */
+#define AW87XXX_PID_60_CPOK_TM_START_BIT	(1)
+#define AW87XXX_PID_60_CPOK_TM_BITS_LEN	(1)
+#define AW87XXX_PID_60_CPOK_TM_MASK		\
+	(~(((1<<AW87XXX_PID_60_CPOK_TM_BITS_LEN)-1) << AW87XXX_PID_60_CPOK_TM_START_BIT))
+
+#define AW87XXX_PID_60_CPOK_TM_0P6MS	(0)
+#define AW87XXX_PID_60_CPOK_TM_0P6MS_VALUE	\
+	(AW87XXX_PID_60_CPOK_TM_0P6MS << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_60_CPOK_TM_1MS		(1)
+#define AW87XXX_PID_60_CPOK_TM_1MS_VALUE	\
+	(AW87XXX_PID_60_CPOK_TM_1MS << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+#define AW87XXX_PID_60_CPOK_TM_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_CPOK_TM_DEFAULT	\
+	(AW87XXX_PID_60_CPOK_TM_DEFAULT_VALUE << AW87XXX_PID_60_CPOK_TM_START_BIT)
+
+/* UVLO_DT bit 4 (CP 0x77) */
+#define AW87XXX_PID_60_UVLO_DT_START_BIT	(4)
+#define AW87XXX_PID_60_UVLO_DT_BITS_LEN	(1)
+#define AW87XXX_PID_60_UVLO_DT_MASK		\
+	(~(((1<<AW87XXX_PID_60_UVLO_DT_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_DT_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_DT_3US		(0)
+#define AW87XXX_PID_60_UVLO_DT_3US_VALUE	\
+	(AW87XXX_PID_60_UVLO_DT_3US << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_DT_10US		(1)
+#define AW87XXX_PID_60_UVLO_DT_10US_VALUE	\
+	(AW87XXX_PID_60_UVLO_DT_10US << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_DT_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_UVLO_DT_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_DT_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_DT_START_BIT)
+
+/* PD_UVLO bit 7 (CP 0x77) */
+#define AW87XXX_PID_60_PD_UVLO_START_BIT	(7)
+#define AW87XXX_PID_60_PD_UVLO_BITS_LEN	(1)
+#define AW87XXX_PID_60_PD_UVLO_MASK		\
+	(~(((1<<AW87XXX_PID_60_PD_UVLO_BITS_LEN)-1) << AW87XXX_PID_60_PD_UVLO_START_BIT))
+
+#define AW87XXX_PID_60_PD_UVLO_ENABLE	(0)
+#define AW87XXX_PID_60_PD_UVLO_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PD_UVLO_ENABLE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_60_PD_UVLO_DISABLE	(1)
+#define AW87XXX_PID_60_PD_UVLO_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PD_UVLO_DISABLE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+#define AW87XXX_PID_60_PD_UVLO_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PD_UVLO_DEFAULT	\
+	(AW87XXX_PID_60_PD_UVLO_DEFAULT_VALUE << AW87XXX_PID_60_PD_UVLO_START_BIT)
+
+/* UVLO_VTH bit 6:5 (CP 0x77) */
+#define AW87XXX_PID_60_UVLO_VTH_START_BIT	(5)
+#define AW87XXX_PID_60_UVLO_VTH_BITS_LEN	(2)
+#define AW87XXX_PID_60_UVLO_VTH_MASK	\
+	(~(((1<<AW87XXX_PID_60_UVLO_VTH_BITS_LEN)-1) << AW87XXX_PID_60_UVLO_VTH_START_BIT))
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V	(0)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P6V_VL2P5V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V	(1)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P7V_VL2P6V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V	(2)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P8V_VL2P7V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V	(3)
+#define AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V_VALUE	\
+	(AW87XXX_PID_60_UVLO_VTH_VH2P9V_VL2P8V << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+#define AW87XXX_PID_60_UVLO_VTH_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_UVLO_VTH_DEFAULT	\
+	(AW87XXX_PID_60_UVLO_VTH_DEFAULT_VALUE << AW87XXX_PID_60_UVLO_VTH_START_BIT)
+
+/* CP_LDO bit 3:2 (CP 0x77) */
+#define AW87XXX_PID_60_CP_LDO_START_BIT	(2)
+#define AW87XXX_PID_60_CP_LDO_BITS_LEN	(2)
+#define AW87XXX_PID_60_CP_LDO_MASK		\
+	(~(((1<<AW87XXX_PID_60_CP_LDO_BITS_LEN)-1) << AW87XXX_PID_60_CP_LDO_START_BIT))
+
+#define AW87XXX_PID_60_CP_LDO_4P75V		(0)
+#define AW87XXX_PID_60_CP_LDO_4P75V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_4P75V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5V		(1)
+#define AW87XXX_PID_60_CP_LDO_5V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5P25V		(2)
+#define AW87XXX_PID_60_CP_LDO_5P25V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5P25V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_5P5V		(3)
+#define AW87XXX_PID_60_CP_LDO_5P5V_VALUE	\
+	(AW87XXX_PID_60_CP_LDO_5P5V << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+#define AW87XXX_PID_60_CP_LDO_DEFAULT_VALUE	(0x2)
+#define AW87XXX_PID_60_CP_LDO_DEFAULT	\
+	(AW87XXX_PID_60_CP_LDO_DEFAULT_VALUE << AW87XXX_PID_60_CP_LDO_START_BIT)
+
+/* default value of CP (0x77) */
+/* #define AW87XXX_PID_60_CP_DEFAULT		(0x5A) */
+
+/* TEST_GTDR (0x78) detail */
+/* TEST_OC bit 0 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_TEST_OC_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_OC_BITS_LEN	(1)
+#define AW87XXX_PID_60_TEST_OC_MASK		\
+	(~(((1<<AW87XXX_PID_60_TEST_OC_BITS_LEN)-1) << AW87XXX_PID_60_TEST_OC_START_BIT))
+
+#define AW87XXX_PID_60_TEST_OC_DISABLE	(0)
+#define AW87XXX_PID_60_TEST_OC_DISABLE_VALUE	\
+	(AW87XXX_PID_60_TEST_OC_DISABLE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+#define AW87XXX_PID_60_TEST_OC_ENABLE	(1)
+#define AW87XXX_PID_60_TEST_OC_ENABLE_VALUE	\
+	(AW87XXX_PID_60_TEST_OC_ENABLE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+#define AW87XXX_PID_60_TEST_OC_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_OC_DEFAULT	\
+	(AW87XXX_PID_60_TEST_OC_DEFAULT_VALUE << AW87XXX_PID_60_TEST_OC_START_BIT)
+
+/* OC_DEBUG_EN bit 1 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_OC_DEBUG_EN_START_BIT	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DEBUG_EN_BITS_LEN)-1) << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT))
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_DISABLE	(0)
+#define AW87XXX_PID_60_OC_DEBUG_EN_DISABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_DISABLE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_ENABLE	(1)
+#define AW87XXX_PID_60_OC_DEBUG_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_ENABLE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT	\
+	(AW87XXX_PID_60_OC_DEBUG_EN_DEFAULT_VALUE << AW87XXX_PID_60_OC_DEBUG_EN_START_BIT)
+
+/* LN_RON_T_N bit 4 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_LN_RON_T_N_START_BIT	(4)
+#define AW87XXX_PID_60_LN_RON_T_N_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_RON_T_N_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_RON_T_N_BITS_LEN)-1) << AW87XXX_PID_60_LN_RON_T_N_START_BIT))
+
+#define AW87XXX_PID_60_LN_RON_T_N_DISABLE	(0)
+#define AW87XXX_PID_60_LN_RON_T_N_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_N_DISABLE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_N_ENALBE	(1)
+#define AW87XXX_PID_60_LN_RON_T_N_ENALBE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_N_ENALBE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_N_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_LN_RON_T_N_DEFAULT	\
+	(AW87XXX_PID_60_LN_RON_T_N_DEFAULT_VALUE << AW87XXX_PID_60_LN_RON_T_N_START_BIT)
+
+/* LN_RON_T_P bit 5 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_LN_RON_T_P_START_BIT	(5)
+#define AW87XXX_PID_60_LN_RON_T_P_BITS_LEN	(1)
+#define AW87XXX_PID_60_LN_RON_T_P_MASK	\
+	(~(((1<<AW87XXX_PID_60_LN_RON_T_P_BITS_LEN)-1) << AW87XXX_PID_60_LN_RON_T_P_START_BIT))
+
+#define AW87XXX_PID_60_LN_RON_T_P_DISABLE	(0)
+#define AW87XXX_PID_60_LN_RON_T_P_DISABLE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_P_DISABLE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_P_ENALBE	(1)
+#define AW87XXX_PID_60_LN_RON_T_P_ENALBE_VALUE	\
+	(AW87XXX_PID_60_LN_RON_T_P_ENALBE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_LN_RON_T_P_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_LN_RON_T_P_DEFAULT	\
+	(AW87XXX_PID_60_LN_RON_T_P_DEFAULT_VALUE << AW87XXX_PID_60_LN_RON_T_P_START_BIT)
+
+/* HN_RON_T_N bit 6 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_HN_RON_T_N_START_BIT	(6)
+#define AW87XXX_PID_60_HN_RON_T_N_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_RON_T_N_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_RON_T_N_BITS_LEN)-1) << AW87XXX_PID_60_HN_RON_T_N_START_BIT))
+
+#define AW87XXX_PID_60_HN_RON_T_N_DISABLE	(0)
+#define AW87XXX_PID_60_HN_RON_T_N_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_N_DISABLE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_N_ENALBE	(1)
+#define AW87XXX_PID_60_HN_RON_T_N_ENALBE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_N_ENALBE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_N_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_HN_RON_T_N_DEFAULT	\
+	(AW87XXX_PID_60_HN_RON_T_N_DEFAULT_VALUE << AW87XXX_PID_60_HN_RON_T_N_START_BIT)
+
+/* HN_RON_T_P bit 7 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_HN_RON_T_P_START_BIT	(7)
+#define AW87XXX_PID_60_HN_RON_T_P_BITS_LEN	(1)
+#define AW87XXX_PID_60_HN_RON_T_P_MASK	\
+	(~(((1<<AW87XXX_PID_60_HN_RON_T_P_BITS_LEN)-1) << AW87XXX_PID_60_HN_RON_T_P_START_BIT))
+
+#define AW87XXX_PID_60_HN_RON_T_P_DISABLE	(0)
+#define AW87XXX_PID_60_HN_RON_T_P_DISABLE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_P_DISABLE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_P_ENALBE	(1)
+#define AW87XXX_PID_60_HN_RON_T_P_ENALBE_VALUE	\
+	(AW87XXX_PID_60_HN_RON_T_P_ENALBE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+#define AW87XXX_PID_60_HN_RON_T_P_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_HN_RON_T_P_DEFAULT	\
+	(AW87XXX_PID_60_HN_RON_T_P_DEFAULT_VALUE << AW87XXX_PID_60_HN_RON_T_P_START_BIT)
+
+/* OC_DEBUG_SEL bit 3:2 (TEST_GTDR 0x78) */
+#define AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_BITS_LEN	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DEBUG_SEL_BITS_LEN)-1) << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT))
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPP	(0)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPP_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VOPP << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPN	(1)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VOPN_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VOPN << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONP	(2)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONP_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VONP << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONN	(3)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_VONN_VALUE	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_VONN << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+#define AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT	\
+	(AW87XXX_PID_60_OC_DEBUG_SEL_DEFAULT_VALUE << AW87XXX_PID_60_OC_DEBUG_SEL_START_BIT)
+
+/* default value of TEST_GTDR (0x78) */
+/* #define AW87XXX_PID_60_TEST_GTDR_DEFAULT		(0x00) */
+
+/* TEST_BST (0x79) detail */
+/* BST_LNMOS_TEST bit 0 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_LNMOS_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_DIABLE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_ENABLE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_LNMOS_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_LNMOS_TEST_START_BIT)
+
+/* BST_HNMOS_TEST bit 1 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_HNMOS_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_DIABLE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_ENABLE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_HNMOS_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_HNMOS_TEST_START_BIT)
+
+/* BST_SCP_TEST bit 2 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_SCP_TEST_START_BIT	(2)
+#define AW87XXX_PID_60_BST_SCP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_SCP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_SCP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_SCP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_SCP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_SCP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_TEST_DIABLE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_SCP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_SCP_TEST_ENABLE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_SCP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_SCP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_SCP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_SCP_TEST_START_BIT)
+
+/* ANTIR_TEST bit 3 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_ANTIR_TEST_START_BIT	(3)
+#define AW87XXX_PID_60_ANTIR_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_ANTIR_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_ANTIR_TEST_BITS_LEN)-1) << AW87XXX_PID_60_ANTIR_TEST_START_BIT))
+
+#define AW87XXX_PID_60_ANTIR_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_ANTIR_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_ANTIR_TEST_DIABLE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+#define AW87XXX_PID_60_ANTIR_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_ANTIR_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_ANTIR_TEST_ENABLE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+#define AW87XXX_PID_60_ANTIR_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_ANTIR_TEST_DEFAULT	\
+	(AW87XXX_PID_60_ANTIR_TEST_DEFAULT_VALUE << AW87XXX_PID_60_ANTIR_TEST_START_BIT)
+
+/* BST_PEAK_TEST bit 4 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_PEAK_TEST_START_BIT	(4)
+#define AW87XXX_PID_60_BST_PEAK_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_PEAK_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_PEAK_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_BST_PEAK_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_DISABLE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_PEAK_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_ENABLE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_PEAK_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_PEAK_TEST_START_BIT)
+
+/* BST_OVP_TEST bit 5 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_OVP_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_BST_OVP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_OVP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_OVP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_OVP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_OVP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_OVP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_TEST_DIABLE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_OVP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_OVP_TEST_ENABLE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_OVP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_OVP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_OVP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_OVP_TEST_START_BIT)
+
+/* BST_TEST_EN bit 6 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_BST_TEST_EN_START_BIT	(6)
+#define AW87XXX_PID_60_BST_TEST_EN_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_TEST_EN_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_TEST_EN_BITS_LEN)-1) << AW87XXX_PID_60_BST_TEST_EN_START_BIT))
+
+#define AW87XXX_PID_60_BST_TEST_EN_DIABLE	(0)
+#define AW87XXX_PID_60_BST_TEST_EN_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_EN_DIABLE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_EN_ENABLE	(1)
+#define AW87XXX_PID_60_BST_TEST_EN_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_EN_ENABLE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_EN_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_TEST_EN_DEFAULT	\
+	(AW87XXX_PID_60_BST_TEST_EN_DEFAULT_VALUE << AW87XXX_PID_60_BST_TEST_EN_START_BIT)
+
+/* OC_DISABLE bit 7 (TEST_BST 0x79) */
+#define AW87XXX_PID_60_OC_DISABLE_START_BIT	(7)
+#define AW87XXX_PID_60_OC_DISABLE_BITS_LEN	(1)
+#define AW87XXX_PID_60_OC_DISABLE_MASK	\
+	(~(((1<<AW87XXX_PID_60_OC_DISABLE_BITS_LEN)-1) << AW87XXX_PID_60_OC_DISABLE_START_BIT))
+
+#define AW87XXX_PID_60_OC_DISABLE_ENABLE	(0)
+#define AW87XXX_PID_60_OC_DISABLE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_OC_DISABLE_ENABLE << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_60_OC_DISABLE_SHUTDOWN	(1)
+#define AW87XXX_PID_60_OC_DISABLE_SHUTDOWN_VALUE	\
+	(AW87XXX_PID_60_OC_DISABLE_SHUTDOWN << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+#define AW87XXX_PID_60_OC_DISABLE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_OC_DISABLE_DEFAULT	\
+	(AW87XXX_PID_60_OC_DISABLE_DEFAULT_VALUE << AW87XXX_PID_60_OC_DISABLE_START_BIT)
+
+/* default value of TEST_BST (0x79) */
+/* #define AW87XXX_PID_60_TEST_BST_DEFAULT		(0x00) */
+
+/* TEST_MODE (0x7A) detail */
+/* PA_TEST_FORCE bit 3 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_PA_TEST_FORCE_START_BIT	(3)
+#define AW87XXX_PID_60_PA_TEST_FORCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_PA_TEST_FORCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_PA_TEST_FORCE_BITS_LEN)-1) << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT))
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_DISABLE	(0)
+#define AW87XXX_PID_60_PA_TEST_FORCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_DISABLE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_ENABLE	(1)
+#define AW87XXX_PID_60_PA_TEST_FORCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_ENABLE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT	\
+	(AW87XXX_PID_60_PA_TEST_FORCE_DEFAULT_VALUE << AW87XXX_PID_60_PA_TEST_FORCE_START_BIT)
+
+/* BST_TEST_FORCE bit 4 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_BST_TEST_FORCE_START_BIT	(4)
+#define AW87XXX_PID_60_BST_TEST_FORCE_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_TEST_FORCE_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_TEST_FORCE_BITS_LEN)-1) << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT))
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_DISABLE	(0)
+#define AW87XXX_PID_60_BST_TEST_FORCE_DISABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_DISABLE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_ENABLE	(1)
+#define AW87XXX_PID_60_BST_TEST_FORCE_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_ENABLE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+#define AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT	\
+	(AW87XXX_PID_60_BST_TEST_FORCE_DEFAULT_VALUE << AW87XXX_PID_60_BST_TEST_FORCE_START_BIT)
+
+/* EN_OT_TEST bit 5 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_EN_OT_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_EN_OT_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_OT_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_OT_TEST_BITS_LEN)-1) << AW87XXX_PID_60_EN_OT_TEST_START_BIT))
+
+#define AW87XXX_PID_60_EN_OT_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_OT_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_OT_TEST_DISABLE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_OT_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_OT_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_OT_TEST_ENABLE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_OT_TEST_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_OT_TEST_DEFAULT	\
+	(AW87XXX_PID_60_EN_OT_TEST_DEFAULT_VALUE << AW87XXX_PID_60_EN_OT_TEST_START_BIT)
+
+/* EN_TEST bit 6 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_EN_TEST_START_BIT	(6)
+#define AW87XXX_PID_60_EN_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_TEST_MASK		\
+	(~(((1<<AW87XXX_PID_60_EN_TEST_BITS_LEN)-1) << AW87XXX_PID_60_EN_TEST_START_BIT))
+
+#define AW87XXX_PID_60_EN_TEST_DISABLE	(0)
+#define AW87XXX_PID_60_EN_TEST_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TEST_DISABLE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_EN_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_TEST_ENABLE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+#define AW87XXX_PID_60_EN_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_EN_TEST_DEFAULT	\
+	(AW87XXX_PID_60_EN_TEST_DEFAULT_VALUE << AW87XXX_PID_60_EN_TEST_START_BIT)
+
+/* BST_BURST_TEST bit 7 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_BST_BURST_TEST_START_BIT	(7)
+#define AW87XXX_PID_60_BST_BURST_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_BST_BURST_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_BST_BURST_TEST_BITS_LEN)-1) << AW87XXX_PID_60_BST_BURST_TEST_START_BIT))
+
+#define AW87XXX_PID_60_BST_BURST_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_BST_BURST_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_TEST_DIABLE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_BST_BURST_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_BST_BURST_TEST_ENABLE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+#define AW87XXX_PID_60_BST_BURST_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_BST_BURST_TEST_DEFAULT	\
+	(AW87XXX_PID_60_BST_BURST_TEST_DEFAULT_VALUE << AW87XXX_PID_60_BST_BURST_TEST_START_BIT)
+
+/* TEST_ANALOG_CTRL bit 2:0 (TEST_MODE 0x7A) */
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_BITS_LEN	(3)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_ANALOG_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG	(0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VBG << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT	(1)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_COMPT << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD	(2)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_HALFVDD << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL	(3)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VCSEL << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL	(4)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VLSEL << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T	(5)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH1T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T	(6)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_MSBMVTH4T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T	(7)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T_VALUE	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_VCM2T << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_TEST_ANALOG_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_TEST_ANALOG_CTRL_START_BIT)
+
+/* default value of TEST_MODE (0x7A) */
+/* #define AW87XXX_PID_60_TEST_MODE_DEFAULT		(0x00) */
+
+/* TEST_CON (0x7B) detail */
+/* COMP_TEST bit 5 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_COMP_TEST_START_BIT	(5)
+#define AW87XXX_PID_60_COMP_TEST_BITS_LEN	(1)
+#define AW87XXX_PID_60_COMP_TEST_MASK	\
+	(~(((1<<AW87XXX_PID_60_COMP_TEST_BITS_LEN)-1) << AW87XXX_PID_60_COMP_TEST_START_BIT))
+
+#define AW87XXX_PID_60_COMP_TEST_DIABLE	(0)
+#define AW87XXX_PID_60_COMP_TEST_DIABLE_VALUE	\
+	(AW87XXX_PID_60_COMP_TEST_DIABLE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_COMP_TEST_ENABLE	(1)
+#define AW87XXX_PID_60_COMP_TEST_ENABLE_VALUE	\
+	(AW87XXX_PID_60_COMP_TEST_ENABLE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+#define AW87XXX_PID_60_COMP_TEST_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_COMP_TEST_DEFAULT	\
+	(AW87XXX_PID_60_COMP_TEST_DEFAULT_VALUE << AW87XXX_PID_60_COMP_TEST_START_BIT)
+
+/* REG_EN_ESD bit 6 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_REG_EN_ESD_START_BIT	(6)
+#define AW87XXX_PID_60_REG_EN_ESD_BITS_LEN	(1)
+#define AW87XXX_PID_60_REG_EN_ESD_MASK	\
+	(~(((1<<AW87XXX_PID_60_REG_EN_ESD_BITS_LEN)-1) << AW87XXX_PID_60_REG_EN_ESD_START_BIT))
+
+#define AW87XXX_PID_60_REG_EN_ESD_DISABLE	(0)
+#define AW87XXX_PID_60_REG_EN_ESD_DISABLE_VALUE	\
+	(AW87XXX_PID_60_REG_EN_ESD_DISABLE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_60_REG_EN_ESD_ENABLE	(1)
+#define AW87XXX_PID_60_REG_EN_ESD_ENABLE_VALUE	\
+	(AW87XXX_PID_60_REG_EN_ESD_ENABLE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+#define AW87XXX_PID_60_REG_EN_ESD_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_60_REG_EN_ESD_DEFAULT	\
+	(AW87XXX_PID_60_REG_EN_ESD_DEFAULT_VALUE << AW87XXX_PID_60_REG_EN_ESD_START_BIT)
+
+/* EN_POWER_MT bit 7 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_EN_POWER_MT_START_BIT	(7)
+#define AW87XXX_PID_60_EN_POWER_MT_BITS_LEN	(1)
+#define AW87XXX_PID_60_EN_POWER_MT_MASK	\
+	(~(((1<<AW87XXX_PID_60_EN_POWER_MT_BITS_LEN)-1) << AW87XXX_PID_60_EN_POWER_MT_START_BIT))
+
+#define AW87XXX_PID_60_EN_POWER_MT_DISABLE	(0)
+#define AW87XXX_PID_60_EN_POWER_MT_DISABLE_VALUE	\
+	(AW87XXX_PID_60_EN_POWER_MT_DISABLE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+#define AW87XXX_PID_60_EN_POWER_MT_ENABLE	(1)
+#define AW87XXX_PID_60_EN_POWER_MT_ENABLE_VALUE	\
+	(AW87XXX_PID_60_EN_POWER_MT_ENABLE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+#define AW87XXX_PID_60_EN_POWER_MT_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_EN_POWER_MT_DEFAULT	\
+	(AW87XXX_PID_60_EN_POWER_MT_DEFAULT_VALUE << AW87XXX_PID_60_EN_POWER_MT_START_BIT)
+
+/* TEST_DIGITAL_CTRL bit 4:0 (TEST_CON 0x7B) */
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT	(0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BITS_LEN	(5)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_DIGITAL_CTRL_BITS_LEN)-1) << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT))
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS	(0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVPS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2	(1)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTOVP2 << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS	(2)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTHNMOS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS	(3)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTLNMOS << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK	(4)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTPEAK << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ	(5)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTRSQ << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST	(6)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTBURST << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH	(7)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSSFINISH << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP	(8)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTSCP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP	(9)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTENCLAMP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD	(10)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_BSTNCD << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC	(11)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENSYNC << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA	(12)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ENOTA << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET	(13)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_NGDET << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN	(14)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN	(15)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN	(16)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEN << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP	(17)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_HNGTP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP	(18)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_LNGTP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP	(19)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_GATESENSEP << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST	(20)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_ADPBOOST << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE	(21)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW0ABOVE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE	(22)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_POVTHBELOW3ABOVE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC	(23)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC_VALUE	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_AMPOC << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT	\
+	(AW87XXX_PID_60_TEST_DIGITAL_CTRL_DEFAULT_VALUE << AW87XXX_PID_60_TEST_DIGITAL_CTRL_START_BIT)
+
+/* default value of TEST_CON (0x7B) */
+/* #define AW87XXX_PID_60_TEST_CON_DEFAULT		(0x00) */
+
+/* ENCR (0x7C) detail */
+/* TEST_REG_ENCRY bit 7:6 (ENCR 0x7C) */
+#define AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT	(6)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_BITS_LEN	(2)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_MASK	\
+	(~(((1<<AW87XXX_PID_60_TEST_REG_ENCRY_BITS_LEN)-1) << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT))
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0	(0)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE0 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1	(1)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE1 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2	(2)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CANNOT_WRITE2 << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE	(3)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE_VALUE	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_CAN_BE_WRITE << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+/*
+Fix me here:
+reg_addr:0x7C, reg_name:ENCR, field_name:TEST_REG_ENCRY, content:Encryption bits for test registers(78h~7Ch) , when0x7D=7a & test_Reg_Encry=11
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT_VALUE	(0x0)
+#define AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT	\
+	(AW87XXX_PID_60_TEST_REG_ENCRY_DEFAULT_VALUE << AW87XXX_PID_60_TEST_REG_ENCRY_START_BIT)
+
+/* PRODUCT_REG_ENCRY bit 5:0 (ENCR 0x7C) */
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT	(0)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_BITS_LEN	(6)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_MASK	\
+	(~(((1<<AW87XXX_PID_60_PRODUCT_REG_ENCRY_BITS_LEN)-1) << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT))
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560	(1)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87560 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561	(2)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87561 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562	(4)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87562 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501	(8)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501_VALUE	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_AW87501 << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+/*
+Fix me here:
+reg_addr:0x7C, reg_name:ENCR, field_name:PRODUCT_REG_ENCRY, content:Production encryption  register (when0x7D=7a & test_Reg_Encry=11 
+maybe need to fix manually
+*/
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT_VALUE	(0x1)
+#define AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT	\
+	(AW87XXX_PID_60_PRODUCT_REG_ENCRY_DEFAULT_VALUE << AW87XXX_PID_60_PRODUCT_REG_ENCRY_START_BIT)
+
+/* default value of ENCR (0x7C) */
+/* #define AW87XXX_PID_60_ENCR_DEFAULT		(0x01) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_60_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
new file mode 100644
index 000000000000..13280cdb5b2e
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_76_reg.h
@@ -0,0 +1,1205 @@
+#ifndef __AW87XXX_PID_76_REG_H__
+#define __AW87XXX_PID_76_REG_H__
+
+/* registers list */
+#define AW87XXX_PID_76_ID_REG			(0x00)
+#define AW87XXX_PID_76_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_76_MDCTRL_REG		(0x02)
+#define AW87XXX_PID_76_CPOVP_REG		(0x03)
+#define AW87XXX_PID_76_CPP_REG			(0x04)
+#define AW87XXX_PID_76_PAG_REG			(0x05)
+#define AW87XXX_PID_76_AGC3P_REG		(0x06)
+#define AW87XXX_PID_76_AGC3PA_REG		(0x07)
+#define AW87XXX_PID_76_AGC2P_REG		(0x08)
+#define AW87XXX_PID_76_AGC2PA_REG		(0x09)
+#define AW87XXX_PID_76_AGC1PA_REG		(0x0A)
+#define AW87XXX_PID_76_SYSST_REG		(0x59)
+#define AW87XXX_PID_76_SYSINT_REG		(0x60)
+#define AW87XXX_PID_76_DFT_SYSCTRL_REG		(0x61)
+#define AW87XXX_PID_76_DFT_MDCTRL_REG		(0x62)
+#define AW87XXX_PID_76_DFT_CPADP_REG		(0x63)
+#define AW87XXX_PID_76_DFT_AGCPA_REG		(0x64)
+#define AW87XXX_PID_76_DFT_POFR_REG		(0x65)
+#define AW87XXX_PID_76_DFT_OC_REG		(0x66)
+#define AW87XXX_PID_76_DFT_ADP1_REG		(0x67)
+#define AW87XXX_PID_76_DFT_REF_REG		(0x68)
+#define AW87XXX_PID_76_DFT_LDO_REG		(0x69)
+#define AW87XXX_PID_76_ADP1_REG			(0x70)
+#define AW87XXX_PID_76_ADP2_REG			(0x71)
+#define AW87XXX_PID_76_NG1_REG			(0x72)
+#define AW87XXX_PID_76_NG2_REG			(0x73)
+#define AW87XXX_PID_76_NG3_REG			(0x74)
+#define AW87XXX_PID_76_CP_REG			(0x75)
+#define AW87XXX_PID_76_AB_REG			(0x76)
+#define AW87XXX_PID_76_TEST_REG			(0x77)
+#define AW87XXX_PID_76_ENCR_REG			(0x78)
+#define AW87XXX_PID_76_DFT_ADP1_CHECK		(0x04)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_76_softrst_access[2] = {0x00, 0xaa};
+
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_76_REG_MAX				(0x79)
+
+#define REG_NONE_ACCESS					(0)
+#define REG_RD_ACCESS					(1 << 0)
+#define REG_WR_ACCESS					(1 << 1)
+
+const unsigned char aw87xxx_pid_76_reg_access[AW87XXX_PID_76_REG_MAX] = {
+	[AW87XXX_PID_76_ID_REG]		= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_MDCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CPOVP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CPP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_PAG_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC3P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC3PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC2P_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC2PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AGC1PA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_SYSST_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_SYSINT_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_76_DFT_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_MDCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_CPADP_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_AGCPA_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_POFR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_OC_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_ADP1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_REF_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_DFT_LDO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ADP1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ADP2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_NG3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_CP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_AB_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_TEST_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_76_ENCR_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+/* detail information of registers begin */
+/* ID (0x00) detail */
+/* IDCODE bit 7:0 (ID 0x00) */
+#define AW87XXX_PID_76_IDCODE_START_BIT	(0)
+#define AW87XXX_PID_76_IDCODE_BITS_LEN	(8)
+#define AW87XXX_PID_76_IDCODE_MASK		\
+	(~(((1<<AW87XXX_PID_76_IDCODE_BITS_LEN)-1) << AW87XXX_PID_76_IDCODE_START_BIT))
+
+#define AW87XXX_PID_76_IDCODE_DEFAULT_VALUE	(0x76)
+#define AW87XXX_PID_76_IDCODE_DEFAULT	\
+	(AW87XXX_PID_76_IDCODE_DEFAULT_VALUE << AW87XXX_PID_76_IDCODE_START_BIT)
+
+/* default value of ID (0x00) */
+/* #define AW87XXX_PID_76_ID_DEFAULT		(0x76) */
+
+/* SYSCTRL (0x01) detail */
+/* EN_PA bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_EN_PA_START_BIT	(2)
+#define AW87XXX_PID_76_EN_PA_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_PA_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_PA_BITS_LEN)-1) << AW87XXX_PID_76_EN_PA_START_BIT))
+
+#define AW87XXX_PID_76_EN_PA_DISABLE	(0)
+#define AW87XXX_PID_76_EN_PA_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_PA_DISABLE << AW87XXX_PID_76_EN_PA_START_BIT)
+
+#define AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB	(1)
+#define AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB_VALUE	\
+	(AW87XXX_PID_76_EN_PA_ENABLE_DEPENDS_ON_EN_AB << AW87XXX_PID_76_EN_PA_START_BIT)
+
+#define AW87XXX_PID_76_EN_PA_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_PA_DEFAULT	\
+	(AW87XXX_PID_76_EN_PA_DEFAULT_VALUE << AW87XXX_PID_76_EN_PA_START_BIT)
+
+/* EN_CP bit 1 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_EN_CP_START_BIT	(1)
+#define AW87XXX_PID_76_EN_CP_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_CP_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_CP_BITS_LEN)-1) << AW87XXX_PID_76_EN_CP_START_BIT))
+
+#define AW87XXX_PID_76_EN_CP_DISABLE_PVDD0	(0)
+#define AW87XXX_PID_76_EN_CP_DISABLE_PVDD0_VALUE	\
+	(AW87XXX_PID_76_EN_CP_DISABLE_PVDD0 << AW87XXX_PID_76_EN_CP_START_BIT)
+
+#define AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X	(1)
+#define AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X_VALUE	\
+	(AW87XXX_PID_76_EN_CP_ENABLE_DEPENDS_ON_EN_2X << AW87XXX_PID_76_EN_CP_START_BIT)
+
+#define AW87XXX_PID_76_EN_CP_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_CP_DEFAULT	\
+	(AW87XXX_PID_76_EN_CP_DEFAULT_VALUE << AW87XXX_PID_76_EN_CP_START_BIT)
+
+/* PU_CPPA bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_76_PU_CPPA_START_BIT	(0)
+#define AW87XXX_PID_76_PU_CPPA_BITS_LEN	(1)
+#define AW87XXX_PID_76_PU_CPPA_MASK		\
+	(~(((1<<AW87XXX_PID_76_PU_CPPA_BITS_LEN)-1) << AW87XXX_PID_76_PU_CPPA_START_BIT))
+
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN	(0)
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN_VALUE	\
+	(AW87XXX_PID_76_PU_CPPA_POWERMINUS_DOWN << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP	(1)
+#define AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP_VALUE	\
+	(AW87XXX_PID_76_PU_CPPA_POWERMINUS_UP << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+#define AW87XXX_PID_76_PU_CPPA_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PU_CPPA_DEFAULT	\
+	(AW87XXX_PID_76_PU_CPPA_DEFAULT_VALUE << AW87XXX_PID_76_PU_CPPA_START_BIT)
+
+/* default value of SYSCTRL (0x01) */
+/* #define AW87XXX_PID_76_SYSCTRL_DEFAULT		(0x06) */
+
+/* MDCTRL (0x02) detail */
+/* EN_ADAP bit 4 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_ADAP_START_BIT	(4)
+#define AW87XXX_PID_76_EN_ADAP_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_ADAP_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_ADAP_BITS_LEN)-1) << AW87XXX_PID_76_EN_ADAP_START_BIT))
+
+#define AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT	(0)
+#define AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT_VALUE	\
+	(AW87XXX_PID_76_EN_ADAP_DISABLEDEFAULT << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_76_EN_ADAP_ENABLE	(1)
+#define AW87XXX_PID_76_EN_ADAP_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_ADAP_ENABLE << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+#define AW87XXX_PID_76_EN_ADAP_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_ADAP_DEFAULT	\
+	(AW87XXX_PID_76_EN_ADAP_DEFAULT_VALUE << AW87XXX_PID_76_EN_ADAP_START_BIT)
+
+/* EN_2X bit 3 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_2X_START_BIT	(3)
+#define AW87XXX_PID_76_EN_2X_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_2X_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_2X_BITS_LEN)-1) << AW87XXX_PID_76_EN_2X_START_BIT))
+
+#define AW87XXX_PID_76_EN_2X_DISABLE	(0)
+#define AW87XXX_PID_76_EN_2X_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_2X_DISABLE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+#define AW87XXX_PID_76_EN_2X_ENABLE		(1)
+#define AW87XXX_PID_76_EN_2X_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_2X_ENABLE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+#define AW87XXX_PID_76_EN_2X_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_2X_DEFAULT	\
+	(AW87XXX_PID_76_EN_2X_DEFAULT_VALUE << AW87XXX_PID_76_EN_2X_START_BIT)
+
+/* EN_SPK bit 2 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_SPK_START_BIT	(2)
+#define AW87XXX_PID_76_EN_SPK_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_SPK_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_SPK_BITS_LEN)-1) << AW87XXX_PID_76_EN_SPK_START_BIT))
+
+#define AW87XXX_PID_76_EN_SPK_DISABLE	(0)
+#define AW87XXX_PID_76_EN_SPK_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_SPK_DISABLE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+#define AW87XXX_PID_76_EN_SPK_ENABLE	(1)
+#define AW87XXX_PID_76_EN_SPK_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_SPK_ENABLE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+#define AW87XXX_PID_76_EN_SPK_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_EN_SPK_DEFAULT	\
+	(AW87XXX_PID_76_EN_SPK_DEFAULT_VALUE << AW87XXX_PID_76_EN_SPK_START_BIT)
+
+/* EN_LG bit 1 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_LG_START_BIT	(1)
+#define AW87XXX_PID_76_EN_LG_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_LG_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_LG_BITS_LEN)-1) << AW87XXX_PID_76_EN_LG_START_BIT))
+
+#define AW87XXX_PID_76_EN_LG_DISABLE	(0)
+#define AW87XXX_PID_76_EN_LG_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_LG_DISABLE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+#define AW87XXX_PID_76_EN_LG_ENABLE		(1)
+#define AW87XXX_PID_76_EN_LG_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_LG_ENABLE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+#define AW87XXX_PID_76_EN_LG_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_LG_DEFAULT	\
+	(AW87XXX_PID_76_EN_LG_DEFAULT_VALUE << AW87XXX_PID_76_EN_LG_START_BIT)
+
+/* EN_AB bit 0 (MDCTRL 0x02) */
+#define AW87XXX_PID_76_EN_AB_START_BIT	(0)
+#define AW87XXX_PID_76_EN_AB_BITS_LEN	(1)
+#define AW87XXX_PID_76_EN_AB_MASK		\
+	(~(((1<<AW87XXX_PID_76_EN_AB_BITS_LEN)-1) << AW87XXX_PID_76_EN_AB_START_BIT))
+
+#define AW87XXX_PID_76_EN_AB_DISABLE	(0)
+#define AW87XXX_PID_76_EN_AB_DISABLE_VALUE	\
+	(AW87XXX_PID_76_EN_AB_DISABLE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+#define AW87XXX_PID_76_EN_AB_ENABLE		(1)
+#define AW87XXX_PID_76_EN_AB_ENABLE_VALUE	\
+	(AW87XXX_PID_76_EN_AB_ENABLE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+#define AW87XXX_PID_76_EN_AB_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_EN_AB_DEFAULT	\
+	(AW87XXX_PID_76_EN_AB_DEFAULT_VALUE << AW87XXX_PID_76_EN_AB_START_BIT)
+
+/* default value of MDCTRL (0x02) */
+/* #define AW87XXX_PID_76_MDCTRL_DEFAULT		(0x0C) */
+
+/* CPOVP (0x03) detail */
+/* CP_OVP1 bit 3:0 (CPOVP 0x03) */
+#define AW87XXX_PID_76_CP_OVP1_START_BIT	(0)
+#define AW87XXX_PID_76_CP_OVP1_BITS_LEN	(4)
+#define AW87XXX_PID_76_CP_OVP1_MASK		\
+	(~(((1<<AW87XXX_PID_76_CP_OVP1_BITS_LEN)-1) << AW87XXX_PID_76_CP_OVP1_START_BIT))
+
+#define AW87XXX_PID_76_CP_OVP1_6P0V		(0)
+#define AW87XXX_PID_76_CP_OVP1_6P0V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P0V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P25V	(1)
+#define AW87XXX_PID_76_CP_OVP1_6P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P5V		(2)
+#define AW87XXX_PID_76_CP_OVP1_6P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_6P75V	(3)
+#define AW87XXX_PID_76_CP_OVP1_6P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_6P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7V		(4)
+#define AW87XXX_PID_76_CP_OVP1_7V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P25V	(5)
+#define AW87XXX_PID_76_CP_OVP1_7P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P5V		(6)
+#define AW87XXX_PID_76_CP_OVP1_7P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_7P75V	(7)
+#define AW87XXX_PID_76_CP_OVP1_7P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_7P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8V		(8)
+#define AW87XXX_PID_76_CP_OVP1_8V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P25V	(9)
+#define AW87XXX_PID_76_CP_OVP1_8P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P5V		(10)
+#define AW87XXX_PID_76_CP_OVP1_8P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_8P75V	(11)
+#define AW87XXX_PID_76_CP_OVP1_8P75V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_8P75V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9V		(12)
+#define AW87XXX_PID_76_CP_OVP1_9V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9P25V	(13)
+#define AW87XXX_PID_76_CP_OVP1_9P25V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9P25V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_9P5V		(14)
+#define AW87XXX_PID_76_CP_OVP1_9P5V_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_9P5V << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP	(15)
+#define AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP_VALUE	\
+	(AW87XXX_PID_76_CP_OVP1_RESERVEDP_IF_SET_TURNS_TO_DEFAULTP << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+#define AW87XXX_PID_76_CP_OVP1_DEFAULT_VALUE	(8)
+#define AW87XXX_PID_76_CP_OVP1_DEFAULT	\
+	(AW87XXX_PID_76_CP_OVP1_DEFAULT_VALUE << AW87XXX_PID_76_CP_OVP1_START_BIT)
+
+/* default value of CPOVP (0x03) */
+/* #define AW87XXX_PID_76_CPOVP_DEFAULT		(0x08) */
+
+/* CPP (0x04) detail */
+/* CP_PEAK_CUR bit 4:2 (CPP 0x04) */
+#define AW87XXX_PID_76_CP_PEAK_CUR_START_BIT	(2)
+#define AW87XXX_PID_76_CP_PEAK_CUR_BITS_LEN	(3)
+#define AW87XXX_PID_76_CP_PEAK_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_PEAK_CUR_BITS_LEN)-1) << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT))
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_2A	(0)
+#define AW87XXX_PID_76_CP_PEAK_CUR_2A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_2A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_2P5A	(1)
+#define AW87XXX_PID_76_CP_PEAK_CUR_2P5A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_2P5A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_3A	(2)
+#define AW87XXX_PID_76_CP_PEAK_CUR_3A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_3A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_3P5A	(3)
+#define AW87XXX_PID_76_CP_PEAK_CUR_3P5A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_3P5A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_4A	(4)
+#define AW87XXX_PID_76_CP_PEAK_CUR_4A_VALUE	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_4A << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT	\
+	(AW87XXX_PID_76_CP_PEAK_CUR_DEFAULT_VALUE << AW87XXX_PID_76_CP_PEAK_CUR_START_BIT)
+
+/* CP_SOFT_CUR bit 1:0 (CPP 0x04) */
+#define AW87XXX_PID_76_CP_SOFT_CUR_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SOFT_CUR_BITS_LEN	(2)
+#define AW87XXX_PID_76_CP_SOFT_CUR_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SOFT_CUR_BITS_LEN)-1) << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT))
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P2A	(0)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P2A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P2A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P3A	(1)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P3A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P3A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P4A	(2)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P4A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P4A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P5A	(3)
+#define AW87XXX_PID_76_CP_SOFT_CUR_0P5A_VALUE	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_0P5A << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+#define AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT	\
+	(AW87XXX_PID_76_CP_SOFT_CUR_DEFAULT_VALUE << AW87XXX_PID_76_CP_SOFT_CUR_START_BIT)
+
+/* default value of CPP (0x04) */
+/* #define AW87XXX_PID_76_CPP_DEFAULT		(0x05) */
+
+/* PAG (0x05) detail */
+/* GAIN bit 4:0 (PAG 0x05) */
+#define AW87XXX_PID_76_GAIN_START_BIT	(0)
+#define AW87XXX_PID_76_GAIN_BITS_LEN	(5)
+#define AW87XXX_PID_76_GAIN_MASK		\
+	(~(((1<<AW87XXX_PID_76_GAIN_BITS_LEN)-1) << AW87XXX_PID_76_GAIN_START_BIT))
+
+#define AW87XXX_PID_76_GAIN_0DB			(0)
+#define AW87XXX_PID_76_GAIN_0DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_0DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_1P5DB		(1)
+#define AW87XXX_PID_76_GAIN_1P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_1P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_3DB			(2)
+#define AW87XXX_PID_76_GAIN_3DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_3DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_4P5DB		(3)
+#define AW87XXX_PID_76_GAIN_4P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_4P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_6DB			(4)
+#define AW87XXX_PID_76_GAIN_6DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_6DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_7P5DB		(5)
+#define AW87XXX_PID_76_GAIN_7P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_7P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_9DB			(6)
+#define AW87XXX_PID_76_GAIN_9DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_9DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_10P5DB		(7)
+#define AW87XXX_PID_76_GAIN_10P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_10P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_12DB		(8)
+#define AW87XXX_PID_76_GAIN_12DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_12DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_13P5DB		(9)
+#define AW87XXX_PID_76_GAIN_13P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_13P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_15DB		(10)
+#define AW87XXX_PID_76_GAIN_15DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_15DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_16P5DB		(11)
+#define AW87XXX_PID_76_GAIN_16P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_16P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_18DB		(12)
+#define AW87XXX_PID_76_GAIN_18DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_18DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_19P5DB		(13)
+#define AW87XXX_PID_76_GAIN_19P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_19P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_21DB		(14)
+#define AW87XXX_PID_76_GAIN_21DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_21DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_22P5DB		(15)
+#define AW87XXX_PID_76_GAIN_22P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_22P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_24DB		(16)
+#define AW87XXX_PID_76_GAIN_24DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_24DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_25P5DB		(17)
+#define AW87XXX_PID_76_GAIN_25P5DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_25P5DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_27DB		(18)
+#define AW87XXX_PID_76_GAIN_27DB_VALUE	\
+	(AW87XXX_PID_76_GAIN_27DB << AW87XXX_PID_76_GAIN_START_BIT)
+
+#define AW87XXX_PID_76_GAIN_DEFAULT_VALUE	(12)
+#define AW87XXX_PID_76_GAIN_DEFAULT		\
+	(AW87XXX_PID_76_GAIN_DEFAULT_VALUE << AW87XXX_PID_76_GAIN_START_BIT)
+
+/* default value of PAG (0x05) */
+/* #define AW87XXX_PID_76_PAG_DEFAULT		(0x0C) */
+
+/* AGC3P (0x06) detail */
+/* AGC3PO bit 3:0 (AGC3P 0x06) */
+#define AW87XXX_PID_76_AGC3PO_START_BIT	(0)
+#define AW87XXX_PID_76_AGC3PO_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC3PO_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3PO_BITS_LEN)-1) << AW87XXX_PID_76_AGC3PO_START_BIT))
+
+#define AW87XXX_PID_76_AGC3PO_0P2W4		(0)
+#define AW87XXX_PID_76_AGC3PO_0P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P4W4		(1)
+#define AW87XXX_PID_76_AGC3PO_0P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P6W4		(2)
+#define AW87XXX_PID_76_AGC3PO_0P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_0P8W4		(3)
+#define AW87XXX_PID_76_AGC3PO_0P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_0P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P0W4		(4)
+#define AW87XXX_PID_76_AGC3PO_1P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P2W4		(5)
+#define AW87XXX_PID_76_AGC3PO_1P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P4W4		(6)
+#define AW87XXX_PID_76_AGC3PO_1P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P6W4		(7)
+#define AW87XXX_PID_76_AGC3PO_1P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_1P8W4		(8)
+#define AW87XXX_PID_76_AGC3PO_1P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_1P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P0W4		(9)
+#define AW87XXX_PID_76_AGC3PO_2P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P2W4		(10)
+#define AW87XXX_PID_76_AGC3PO_2P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P2W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P4W4		(11)
+#define AW87XXX_PID_76_AGC3PO_2P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P4W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P6W4		(12)
+#define AW87XXX_PID_76_AGC3PO_2P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P6W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_2P8W4		(13)
+#define AW87XXX_PID_76_AGC3PO_2P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_2P8W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_3P0W4		(14)
+#define AW87XXX_PID_76_AGC3PO_3P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_3P0W4 << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_AGC3_OFF	(15)
+#define AW87XXX_PID_76_AGC3PO_AGC3_OFF_VALUE	\
+	(AW87XXX_PID_76_AGC3PO_AGC3_OFF << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC3PO_DEFAULT_VALUE	(7)
+#define AW87XXX_PID_76_AGC3PO_DEFAULT	\
+	(AW87XXX_PID_76_AGC3PO_DEFAULT_VALUE << AW87XXX_PID_76_AGC3PO_START_BIT)
+
+/* default value of AGC3P (0x06) */
+/* #define AW87XXX_PID_76_AGC3P_DEFAULT		(0x07) */
+
+/* AGC3PA (0x07) detail */
+/* AGC3RT bit 7:5 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3RT_START_BIT	(5)
+#define AW87XXX_PID_76_AGC3RT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC3RT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3RT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3RT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3RT_5P12MSDB	(0)
+#define AW87XXX_PID_76_AGC3RT_5P12MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_5P12MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_10P24MSDB	(1)
+#define AW87XXX_PID_76_AGC3RT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_10P24MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_20P48MSDB	(2)
+#define AW87XXX_PID_76_AGC3RT_20P48MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_20P48MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_41MSDB	(3)
+#define AW87XXX_PID_76_AGC3RT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_41MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_82MSDB	(4)
+#define AW87XXX_PID_76_AGC3RT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_82MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_164MSDB	(5)
+#define AW87XXX_PID_76_AGC3RT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_164MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_328MSDB	(6)
+#define AW87XXX_PID_76_AGC3RT_328MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_328MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_656MSDB	(7)
+#define AW87XXX_PID_76_AGC3RT_656MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3RT_656MSDB << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3RT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC3RT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3RT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3RT_START_BIT)
+
+/* AGC3AT bit 4:2 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3AT_START_BIT	(2)
+#define AW87XXX_PID_76_AGC3AT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC3AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC3AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3AT_1P28MSDB	(0)
+#define AW87XXX_PID_76_AGC3AT_1P28MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_1P28MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_2P56MSDB	(1)
+#define AW87XXX_PID_76_AGC3AT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_2P56MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_10P24MSDB	(2)
+#define AW87XXX_PID_76_AGC3AT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_10P24MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_41MSDB	(3)
+#define AW87XXX_PID_76_AGC3AT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_41MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_82MSDB	(4)
+#define AW87XXX_PID_76_AGC3AT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_82MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_164MSDB	(5)
+#define AW87XXX_PID_76_AGC3AT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_164MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_328MSDB	(6)
+#define AW87XXX_PID_76_AGC3AT_328MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_328MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_656MSDB	(7)
+#define AW87XXX_PID_76_AGC3AT_656MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3AT_656MSDB << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3AT_DEFAULT_VALUE	(3)
+#define AW87XXX_PID_76_AGC3AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3AT_START_BIT)
+
+/* AGC3FSAT bit 1:0 (AGC3PA 0x07) */
+#define AW87XXX_PID_76_AGC3FSAT_START_BIT	(0)
+#define AW87XXX_PID_76_AGC3FSAT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC3FSAT_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC3FSAT_BITS_LEN)-1) << AW87XXX_PID_76_AGC3FSAT_START_BIT))
+
+#define AW87XXX_PID_76_AGC3FSAT_10P24MSDB	(0)
+#define AW87XXX_PID_76_AGC3FSAT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_10P24MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_20P48MSDB	(1)
+#define AW87XXX_PID_76_AGC3FSAT_20P48MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_20P48MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_41MSDB	(2)
+#define AW87XXX_PID_76_AGC3FSAT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_41MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_82MSDB	(3)
+#define AW87XXX_PID_76_AGC3FSAT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC3FSAT_82MSDB << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC3FSAT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC3FSAT_DEFAULT	\
+	(AW87XXX_PID_76_AGC3FSAT_DEFAULT_VALUE << AW87XXX_PID_76_AGC3FSAT_START_BIT)
+
+/* default value of AGC3PA (0x07) */
+/* #define AW87XXX_PID_76_AGC3PA_DEFAULT		(0x4E) */
+
+/* AGC2P (0x08) detail */
+/* AGC2PO bit 3:0 (AGC2P 0x08) */
+#define AW87XXX_PID_76_AGC2PO_START_BIT	(0)
+#define AW87XXX_PID_76_AGC2PO_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC2PO_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC2PO_BITS_LEN)-1) << AW87XXX_PID_76_AGC2PO_START_BIT))
+
+#define AW87XXX_PID_76_AGC2PO_0P8W4		(0)
+#define AW87XXX_PID_76_AGC2PO_0P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_0P8W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_1P2W4		(1)
+#define AW87XXX_PID_76_AGC2PO_1P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_1P2W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_1P6W4		(2)
+#define AW87XXX_PID_76_AGC2PO_1P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_1P6W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P0W4		(3)
+#define AW87XXX_PID_76_AGC2PO_2P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P0W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P4W4		(4)
+#define AW87XXX_PID_76_AGC2PO_2P4W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P4W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_2P8W4		(5)
+#define AW87XXX_PID_76_AGC2PO_2P8W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_2P8W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_3P2W4		(6)
+#define AW87XXX_PID_76_AGC2PO_3P2W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_3P2W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_3P6W4		(7)
+#define AW87XXX_PID_76_AGC2PO_3P6W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_3P6W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_4P0W4		(8)
+#define AW87XXX_PID_76_AGC2PO_4P0W4_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_4P0W4 << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_AGC2_OFF	(9)
+#define AW87XXX_PID_76_AGC2PO_AGC2_OFF_VALUE	\
+	(AW87XXX_PID_76_AGC2PO_AGC2_OFF << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+#define AW87XXX_PID_76_AGC2PO_DEFAULT_VALUE	(6)
+#define AW87XXX_PID_76_AGC2PO_DEFAULT	\
+	(AW87XXX_PID_76_AGC2PO_DEFAULT_VALUE << AW87XXX_PID_76_AGC2PO_START_BIT)
+
+/* default value of AGC2P (0x08) */
+/* #define AW87XXX_PID_76_AGC2P_DEFAULT		(0x06) */
+
+/* AGC2PA (0x09) detail */
+/* AGC2AT bit 4:2 (AGC2PA 0x09) */
+#define AW87XXX_PID_76_AGC2AT_START_BIT	(2)
+#define AW87XXX_PID_76_AGC2AT_BITS_LEN	(3)
+#define AW87XXX_PID_76_AGC2AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC2AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC2AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC2AT_0P16MSDB	(0)
+#define AW87XXX_PID_76_AGC2AT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P16MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_0P32MSDB	(1)
+#define AW87XXX_PID_76_AGC2AT_0P32MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P32MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_0P64MSDB	(2)
+#define AW87XXX_PID_76_AGC2AT_0P64MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_0P64MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_2P56MSDB	(3)
+#define AW87XXX_PID_76_AGC2AT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_2P56MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_10P24MSDB	(4)
+#define AW87XXX_PID_76_AGC2AT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_10P24MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_41MSDB	(5)
+#define AW87XXX_PID_76_AGC2AT_41MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_41MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_82MSDB	(6)
+#define AW87XXX_PID_76_AGC2AT_82MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_82MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_164MSDB	(7)
+#define AW87XXX_PID_76_AGC2AT_164MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2AT_164MSDB << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2AT_DEFAULT_VALUE	(2)
+#define AW87XXX_PID_76_AGC2AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC2AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC2AT_START_BIT)
+
+/* AGC2FSAT bit 1:0 (AGC2PA 0x09) */
+#define AW87XXX_PID_76_AGC2FSAT_START_BIT	(0)
+#define AW87XXX_PID_76_AGC2FSAT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC2FSAT_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC2FSAT_BITS_LEN)-1) << AW87XXX_PID_76_AGC2FSAT_START_BIT))
+
+#define AW87XXX_PID_76_AGC2FSAT_0P16MSDB	(0)
+#define AW87XXX_PID_76_AGC2FSAT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_0P16MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_0P64MSDB	(1)
+#define AW87XXX_PID_76_AGC2FSAT_0P64MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_0P64MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_2P56MSDB	(2)
+#define AW87XXX_PID_76_AGC2FSAT_2P56MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_2P56MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_10P24MSDB	(3)
+#define AW87XXX_PID_76_AGC2FSAT_10P24MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC2FSAT_10P24MSDB << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+#define AW87XXX_PID_76_AGC2FSAT_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_AGC2FSAT_DEFAULT	\
+	(AW87XXX_PID_76_AGC2FSAT_DEFAULT_VALUE << AW87XXX_PID_76_AGC2FSAT_START_BIT)
+
+/* default value of AGC2PA (0x09) */
+/* #define AW87XXX_PID_76_AGC2PA_DEFAULT		(0x08) */
+
+/* AGC1PA (0x0A) detail */
+/* AGC1THVTH bit 6:3 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_AGC1THVTH_START_BIT	(3)
+#define AW87XXX_PID_76_AGC1THVTH_BITS_LEN	(4)
+#define AW87XXX_PID_76_AGC1THVTH_MASK	\
+	(~(((1<<AW87XXX_PID_76_AGC1THVTH_BITS_LEN)-1) << AW87XXX_PID_76_AGC1THVTH_START_BIT))
+
+#define AW87XXX_PID_76_AGC1THVTH_5V		(0)
+#define AW87XXX_PID_76_AGC1THVTH_5V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P2V	(1)
+#define AW87XXX_PID_76_AGC1THVTH_5P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P4V	(2)
+#define AW87XXX_PID_76_AGC1THVTH_5P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P6V	(3)
+#define AW87XXX_PID_76_AGC1THVTH_5P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_5P8V	(4)
+#define AW87XXX_PID_76_AGC1THVTH_5P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_5P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P0V	(5)
+#define AW87XXX_PID_76_AGC1THVTH_6P0V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P0V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P2V	(6)
+#define AW87XXX_PID_76_AGC1THVTH_6P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P4V	(7)
+#define AW87XXX_PID_76_AGC1THVTH_6P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P6V	(8)
+#define AW87XXX_PID_76_AGC1THVTH_6P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_6P8V	(9)
+#define AW87XXX_PID_76_AGC1THVTH_6P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_6P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7V		(10)
+#define AW87XXX_PID_76_AGC1THVTH_7V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P2V	(11)
+#define AW87XXX_PID_76_AGC1THVTH_7P2V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P2V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P4V	(12)
+#define AW87XXX_PID_76_AGC1THVTH_7P4V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P4V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P6V	(13)
+#define AW87XXX_PID_76_AGC1THVTH_7P6V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P6V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_7P8V	(14)
+#define AW87XXX_PID_76_AGC1THVTH_7P8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_7P8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_8V		(15)
+#define AW87XXX_PID_76_AGC1THVTH_8V_VALUE	\
+	(AW87XXX_PID_76_AGC1THVTH_8V << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+#define AW87XXX_PID_76_AGC1THVTH_DEFAULT_VALUE	(9)
+#define AW87XXX_PID_76_AGC1THVTH_DEFAULT	\
+	(AW87XXX_PID_76_AGC1THVTH_DEFAULT_VALUE << AW87XXX_PID_76_AGC1THVTH_START_BIT)
+
+/* AGC1AT bit 2:1 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_AGC1AT_START_BIT	(1)
+#define AW87XXX_PID_76_AGC1AT_BITS_LEN	(2)
+#define AW87XXX_PID_76_AGC1AT_MASK		\
+	(~(((1<<AW87XXX_PID_76_AGC1AT_BITS_LEN)-1) << AW87XXX_PID_76_AGC1AT_START_BIT))
+
+#define AW87XXX_PID_76_AGC1AT_0P04MSDB	(0)
+#define AW87XXX_PID_76_AGC1AT_0P04MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P04MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P08MSDB	(1)
+#define AW87XXX_PID_76_AGC1AT_0P08MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P08MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P16MSDB	(2)
+#define AW87XXX_PID_76_AGC1AT_0P16MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P16MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_0P32MSDB	(3)
+#define AW87XXX_PID_76_AGC1AT_0P32MSDB_VALUE	\
+	(AW87XXX_PID_76_AGC1AT_0P32MSDB << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+#define AW87XXX_PID_76_AGC1AT_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_AGC1AT_DEFAULT	\
+	(AW87XXX_PID_76_AGC1AT_DEFAULT_VALUE << AW87XXX_PID_76_AGC1AT_START_BIT)
+
+/* PD_AGC1 bit 0 (AGC1PA 0x0A) */
+#define AW87XXX_PID_76_PD_AGC1_START_BIT	(0)
+#define AW87XXX_PID_76_PD_AGC1_BITS_LEN	(1)
+#define AW87XXX_PID_76_PD_AGC1_MASK		\
+	(~(((1<<AW87XXX_PID_76_PD_AGC1_BITS_LEN)-1) << AW87XXX_PID_76_PD_AGC1_START_BIT))
+
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP	(0)
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP_VALUE	\
+	(AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_UP << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN	(1)
+#define AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN_VALUE	\
+	(AW87XXX_PID_76_PD_AGC1_AGC1_FUNCTION_POWERMINUS_DOWN << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+#define AW87XXX_PID_76_PD_AGC1_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PD_AGC1_DEFAULT	\
+	(AW87XXX_PID_76_PD_AGC1_DEFAULT_VALUE << AW87XXX_PID_76_PD_AGC1_START_BIT)
+
+/* default value of AGC1PA (0x0A) */
+/* #define AW87XXX_PID_76_AGC1PA_DEFAULT		(0x4A) */
+
+/* SYSST (0x59) detail */
+/* UVLOS bit 7 (SYSST 0x59) */
+#define AW87XXX_PID_76_UVLOS_START_BIT	(7)
+#define AW87XXX_PID_76_UVLOS_BITS_LEN	(1)
+#define AW87XXX_PID_76_UVLOS_MASK		\
+	(~(((1<<AW87XXX_PID_76_UVLOS_BITS_LEN)-1) << AW87XXX_PID_76_UVLOS_START_BIT))
+
+#define AW87XXX_PID_76_UVLOS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_UVLOS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_UVLOS_NORMAL_OPERATION << AW87XXX_PID_76_UVLOS_START_BIT)
+
+#define AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE	(1)
+#define AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE_VALUE	\
+	(AW87XXX_PID_76_UVLOS_VBAT_UNDER_VOLTAGE << AW87XXX_PID_76_UVLOS_START_BIT)
+
+#define AW87XXX_PID_76_UVLOS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_UVLOS_DEFAULT	\
+	(AW87XXX_PID_76_UVLOS_DEFAULT_VALUE << AW87XXX_PID_76_UVLOS_START_BIT)
+
+/* OTNS bit 6 (SYSST 0x59) */
+#define AW87XXX_PID_76_OTNS_START_BIT	(6)
+#define AW87XXX_PID_76_OTNS_BITS_LEN	(1)
+#define AW87XXX_PID_76_OTNS_MASK		\
+	(~(((1<<AW87XXX_PID_76_OTNS_BITS_LEN)-1) << AW87XXX_PID_76_OTNS_START_BIT))
+
+#define AW87XXX_PID_76_OTNS_DETECTED	(0)
+#define AW87XXX_PID_76_OTNS_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OTNS_DETECTED << AW87XXX_PID_76_OTNS_START_BIT)
+
+#define AW87XXX_PID_76_OTNS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_76_OTNS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OTNS_NORMAL_OPERATION << AW87XXX_PID_76_OTNS_START_BIT)
+
+#define AW87XXX_PID_76_OTNS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_OTNS_DEFAULT		\
+	(AW87XXX_PID_76_OTNS_DEFAULT_VALUE << AW87XXX_PID_76_OTNS_START_BIT)
+
+/* OC_FLAGS bit 5 (SYSST 0x59) */
+#define AW87XXX_PID_76_OC_FLAGS_START_BIT	(5)
+#define AW87XXX_PID_76_OC_FLAGS_BITS_LEN	(1)
+#define AW87XXX_PID_76_OC_FLAGS_MASK	\
+	(~(((1<<AW87XXX_PID_76_OC_FLAGS_BITS_LEN)-1) << AW87XXX_PID_76_OC_FLAGS_START_BIT))
+
+#define AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGS_NORMAL_OPERATION << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGS_DETECTED	(1)
+#define AW87XXX_PID_76_OC_FLAGS_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGS_DETECTED << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OC_FLAGS_DEFAULT	\
+	(AW87XXX_PID_76_OC_FLAGS_DEFAULT_VALUE << AW87XXX_PID_76_OC_FLAGS_START_BIT)
+
+/* ADAP_CPS bit 4 (SYSST 0x59) */
+#define AW87XXX_PID_76_ADAP_CPS_START_BIT	(4)
+#define AW87XXX_PID_76_ADAP_CPS_BITS_LEN	(1)
+#define AW87XXX_PID_76_ADAP_CPS_MASK	\
+	(~(((1<<AW87XXX_PID_76_ADAP_CPS_BITS_LEN)-1) << AW87XXX_PID_76_ADAP_CPS_START_BIT))
+
+#define AW87XXX_PID_76_ADAP_CPS_1X_MODE	(0)
+#define AW87XXX_PID_76_ADAP_CPS_1X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPS_1X_MODE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPS_2X_MODE	(1)
+#define AW87XXX_PID_76_ADAP_CPS_2X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPS_2X_MODE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPS_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_76_ADAP_CPS_DEFAULT	\
+	(AW87XXX_PID_76_ADAP_CPS_DEFAULT_VALUE << AW87XXX_PID_76_ADAP_CPS_START_BIT)
+
+/* STARTOKS bit 3 (SYSST 0x59) */
+#define AW87XXX_PID_76_STARTOKS_START_BIT	(3)
+#define AW87XXX_PID_76_STARTOKS_BITS_LEN	(1)
+#define AW87XXX_PID_76_STARTOKS_MASK	\
+	(~(((1<<AW87XXX_PID_76_STARTOKS_BITS_LEN)-1) << AW87XXX_PID_76_STARTOKS_START_BIT))
+
+#define AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED	(0)
+#define AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_STARTOKS_CP_START_FAIL_DECTECTED << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION	(1)
+#define AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_STARTOKS_NORMAL_OPERATION << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_STARTOKS_DEFAULT	\
+	(AW87XXX_PID_76_STARTOKS_DEFAULT_VALUE << AW87XXX_PID_76_STARTOKS_START_BIT)
+
+/* OVP1S bit 2 (SYSST 0x59) */
+#define AW87XXX_PID_76_OVP1S_START_BIT	(2)
+#define AW87XXX_PID_76_OVP1S_BITS_LEN	(1)
+#define AW87XXX_PID_76_OVP1S_MASK		\
+	(~(((1<<AW87XXX_PID_76_OVP1S_BITS_LEN)-1) << AW87XXX_PID_76_OVP1S_START_BIT))
+
+#define AW87XXX_PID_76_OVP1S_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_OVP1S_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_OVP1S_NORMAL_OPERATION << AW87XXX_PID_76_OVP1S_START_BIT)
+
+#define AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED	(1)
+#define AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OVP1S_CP_OVP_DETECTED << AW87XXX_PID_76_OVP1S_START_BIT)
+
+#define AW87XXX_PID_76_OVP1S_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OVP1S_DEFAULT	\
+	(AW87XXX_PID_76_OVP1S_DEFAULT_VALUE << AW87XXX_PID_76_OVP1S_START_BIT)
+
+/* PORNS bit 1 (SYSST 0x59) */
+#define AW87XXX_PID_76_PORNS_START_BIT	(1)
+#define AW87XXX_PID_76_PORNS_BITS_LEN	(1)
+#define AW87XXX_PID_76_PORNS_MASK		\
+	(~(((1<<AW87XXX_PID_76_PORNS_BITS_LEN)-1) << AW87XXX_PID_76_PORNS_START_BIT))
+
+#define AW87XXX_PID_76_PORNS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PORNS_DEFAULT	\
+	(AW87XXX_PID_76_PORNS_DEFAULT_VALUE << AW87XXX_PID_76_PORNS_START_BIT)
+
+/* CP_SHORTS bit 0 (SYSST 0x59) */
+#define AW87XXX_PID_76_CP_SHORTS_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SHORTS_BITS_LEN	(1)
+#define AW87XXX_PID_76_CP_SHORTS_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SHORTS_BITS_LEN)-1) << AW87XXX_PID_76_CP_SHORTS_START_BIT))
+
+#define AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION	(0)
+#define AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTS_NORMAL_OPERATION << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED	(1)
+#define AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTS_CHARGE_PUMP_SHORT_DECTECTED << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTS_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_CP_SHORTS_DEFAULT	\
+	(AW87XXX_PID_76_CP_SHORTS_DEFAULT_VALUE << AW87XXX_PID_76_CP_SHORTS_START_BIT)
+
+/* default value of SYSST (0x59) */
+/* #define AW87XXX_PID_76_SYSST_DEFAULT		(0xD0) */
+
+/* SYSINT (0x60) detail */
+/* UVLOI bit 7 (SYSINT 0x60) */
+#define AW87XXX_PID_76_UVLOI_START_BIT	(7)
+#define AW87XXX_PID_76_UVLOI_BITS_LEN	(1)
+#define AW87XXX_PID_76_UVLOI_MASK		\
+	(~(((1<<AW87XXX_PID_76_UVLOI_BITS_LEN)-1) << AW87XXX_PID_76_UVLOI_START_BIT))
+
+#define AW87XXX_PID_76_UVLOI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_UVLOI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_UVLOI_NOT_CHANGE << AW87XXX_PID_76_UVLOI_START_BIT)
+
+#define AW87XXX_PID_76_UVLOI_DETECTED	(1)
+#define AW87XXX_PID_76_UVLOI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_UVLOI_DETECTED << AW87XXX_PID_76_UVLOI_START_BIT)
+
+#define AW87XXX_PID_76_UVLOI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_UVLOI_DEFAULT	\
+	(AW87XXX_PID_76_UVLOI_DEFAULT_VALUE << AW87XXX_PID_76_UVLOI_START_BIT)
+
+/* OTNI bit 6 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OTNI_START_BIT	(6)
+#define AW87XXX_PID_76_OTNI_BITS_LEN	(1)
+#define AW87XXX_PID_76_OTNI_MASK		\
+	(~(((1<<AW87XXX_PID_76_OTNI_BITS_LEN)-1) << AW87XXX_PID_76_OTNI_START_BIT))
+
+#define AW87XXX_PID_76_OTNI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OTNI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OTNI_NOT_CHANGE << AW87XXX_PID_76_OTNI_START_BIT)
+
+#define AW87XXX_PID_76_OTNI_DETECTED	(1)
+#define AW87XXX_PID_76_OTNI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OTNI_DETECTED << AW87XXX_PID_76_OTNI_START_BIT)
+
+#define AW87XXX_PID_76_OTNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OTNI_DEFAULT		\
+	(AW87XXX_PID_76_OTNI_DEFAULT_VALUE << AW87XXX_PID_76_OTNI_START_BIT)
+
+/* OC_FLAGI bit 5 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OC_FLAGI_START_BIT	(5)
+#define AW87XXX_PID_76_OC_FLAGI_BITS_LEN	(1)
+#define AW87XXX_PID_76_OC_FLAGI_MASK	\
+	(~(((1<<AW87XXX_PID_76_OC_FLAGI_BITS_LEN)-1) << AW87XXX_PID_76_OC_FLAGI_START_BIT))
+
+#define AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGI_NOT_CHANGE << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGI_DETECTED	(1)
+#define AW87XXX_PID_76_OC_FLAGI_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OC_FLAGI_DETECTED << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+#define AW87XXX_PID_76_OC_FLAGI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OC_FLAGI_DEFAULT	\
+	(AW87XXX_PID_76_OC_FLAGI_DEFAULT_VALUE << AW87XXX_PID_76_OC_FLAGI_START_BIT)
+
+/* ADAP_CPI bit 4 (SYSINT 0x60) */
+#define AW87XXX_PID_76_ADAP_CPI_START_BIT	(4)
+#define AW87XXX_PID_76_ADAP_CPI_BITS_LEN	(1)
+#define AW87XXX_PID_76_ADAP_CPI_MASK	\
+	(~(((1<<AW87XXX_PID_76_ADAP_CPI_BITS_LEN)-1) << AW87XXX_PID_76_ADAP_CPI_START_BIT))
+
+#define AW87XXX_PID_76_ADAP_CPI_1X_MODE	(0)
+#define AW87XXX_PID_76_ADAP_CPI_1X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPI_1X_MODE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPI_2X_MODE	(1)
+#define AW87XXX_PID_76_ADAP_CPI_2X_MODE_VALUE	\
+	(AW87XXX_PID_76_ADAP_CPI_2X_MODE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+#define AW87XXX_PID_76_ADAP_CPI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_ADAP_CPI_DEFAULT	\
+	(AW87XXX_PID_76_ADAP_CPI_DEFAULT_VALUE << AW87XXX_PID_76_ADAP_CPI_START_BIT)
+
+/* STARTOKI bit 3 (SYSINT 0x60) */
+#define AW87XXX_PID_76_STARTOKI_START_BIT	(3)
+#define AW87XXX_PID_76_STARTOKI_BITS_LEN	(1)
+#define AW87XXX_PID_76_STARTOKI_MASK	\
+	(~(((1<<AW87XXX_PID_76_STARTOKI_BITS_LEN)-1) << AW87XXX_PID_76_STARTOKI_START_BIT))
+
+#define AW87XXX_PID_76_STARTOKI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_STARTOKI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_STARTOKI_NOT_CHANGE << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKI_DECTECTED	(1)
+#define AW87XXX_PID_76_STARTOKI_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_STARTOKI_DECTECTED << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+#define AW87XXX_PID_76_STARTOKI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_STARTOKI_DEFAULT	\
+	(AW87XXX_PID_76_STARTOKI_DEFAULT_VALUE << AW87XXX_PID_76_STARTOKI_START_BIT)
+
+/* OVP1I bit 2 (SYSINT 0x60) */
+#define AW87XXX_PID_76_OVP1I_START_BIT	(2)
+#define AW87XXX_PID_76_OVP1I_BITS_LEN	(1)
+#define AW87XXX_PID_76_OVP1I_MASK		\
+	(~(((1<<AW87XXX_PID_76_OVP1I_BITS_LEN)-1) << AW87XXX_PID_76_OVP1I_START_BIT))
+
+#define AW87XXX_PID_76_OVP1I_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_OVP1I_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_OVP1I_NOT_CHANGE << AW87XXX_PID_76_OVP1I_START_BIT)
+
+#define AW87XXX_PID_76_OVP1I_DETECTED	(1)
+#define AW87XXX_PID_76_OVP1I_DETECTED_VALUE	\
+	(AW87XXX_PID_76_OVP1I_DETECTED << AW87XXX_PID_76_OVP1I_START_BIT)
+
+#define AW87XXX_PID_76_OVP1I_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_OVP1I_DEFAULT	\
+	(AW87XXX_PID_76_OVP1I_DEFAULT_VALUE << AW87XXX_PID_76_OVP1I_START_BIT)
+
+/* PORNI bit 1 (SYSINT 0x60) */
+#define AW87XXX_PID_76_PORNI_START_BIT	(1)
+#define AW87XXX_PID_76_PORNI_BITS_LEN	(1)
+#define AW87XXX_PID_76_PORNI_MASK		\
+	(~(((1<<AW87XXX_PID_76_PORNI_BITS_LEN)-1) << AW87XXX_PID_76_PORNI_START_BIT))
+
+#define AW87XXX_PID_76_PORNI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_PORNI_DEFAULT	\
+	(AW87XXX_PID_76_PORNI_DEFAULT_VALUE << AW87XXX_PID_76_PORNI_START_BIT)
+
+/* CP_SHORTI bit 0 (SYSINT 0x60) */
+#define AW87XXX_PID_76_CP_SHORTI_START_BIT	(0)
+#define AW87XXX_PID_76_CP_SHORTI_BITS_LEN	(1)
+#define AW87XXX_PID_76_CP_SHORTI_MASK	\
+	(~(((1<<AW87XXX_PID_76_CP_SHORTI_BITS_LEN)-1) << AW87XXX_PID_76_CP_SHORTI_START_BIT))
+
+#define AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE	(0)
+#define AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTI_NOT_CHANGE << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED	(1)
+#define AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED_VALUE	\
+	(AW87XXX_PID_76_CP_SHORTI_SHORT_DECTECTED << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+#define AW87XXX_PID_76_CP_SHORTI_DEFAULT_VALUE	(0)
+#define AW87XXX_PID_76_CP_SHORTI_DEFAULT	\
+	(AW87XXX_PID_76_CP_SHORTI_DEFAULT_VALUE << AW87XXX_PID_76_CP_SHORTI_START_BIT)
+
+/* default value of SYSINT (0x60) */
+/* #define AW87XXX_PID_76_SYSINT_DEFAULT		(0x00) */
+
+/* detail information of registers end */
+
+#endif  /* #ifndef  __AW87XXX_PID_76_REG_H__ */
\ No newline at end of file
diff --git a/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h b/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h
new file mode 100644
index 000000000000..27baeb96ce7c
--- /dev/null
+++ b/sound/soc/codecs/aw87xxx/aw87xxx_pid_9b_reg.h
@@ -0,0 +1,81 @@
+#ifndef __AW87XXX_PID_9B_REG_H__
+#define __AW87XXX_PID_9B_REG_H__
+
+#define AW87XXX_PID_9B_CHIPID_REG		(0x00)
+#define AW87XXX_PID_9B_SYSCTRL_REG		(0x01)
+#define AW87XXX_PID_9B_BATSAFE_REG		(0x02)
+#define AW87XXX_PID_9B_BOV_REG			(0x03)
+#define AW87XXX_PID_9B_BP_REG			(0x04)
+#define AW87XXX_PID_9B_GAIN_REG			(0x05)
+#define AW87XXX_PID_9B_AGC3_PO_REG		(0x06)
+#define AW87XXX_PID_9B_AGC3_REG			(0x07)
+#define AW87XXX_PID_9B_AGC2_REG			(0x08)
+#define AW87XXX_PID_9B_AGC1_REG			(0x09)
+
+#define AW87XXX_PID_9B_SYSCTRL_DEFAULT		(0x03)
+
+/********************************************
+ * soft control info
+ * If you need to update this file, add this information manually
+ *******************************************/
+unsigned char aw87xxx_pid_9b_softrst_access[2] = {0x00, 0xaa};
+
+/********************************************
+ * Register Access
+ *******************************************/
+#define AW87XXX_PID_9B_REG_MAX			(0x64)
+
+#define REG_NONE_ACCESS		(0)
+#define REG_RD_ACCESS		(1 << 0)
+#define REG_WR_ACCESS		(1 << 1)
+
+const unsigned char aw87xxx_pid_9b_reg_access[AW87XXX_PID_9B_REG_MAX] = {
+	[AW87XXX_PID_9B_CHIPID_REG]	= (REG_RD_ACCESS),
+	[AW87XXX_PID_9B_SYSCTRL_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BATSAFE_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BOV_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_BP_REG]		= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_GAIN_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC3_PO_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC3_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC2_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+	[AW87XXX_PID_9B_AGC1_REG]	= (REG_RD_ACCESS | REG_WR_ACCESS),
+};
+
+
+#define AW87XXX_PID_9B_ENCRYPTION_REG		(0x64)
+#define AW87XXX_PID_9B_ENCRYPTION_BOOST_OUTPUT_SET	(0x2C)
+
+/* REG_EN_SW bit 2 (SYSCTRL 0x01) */
+#define AW87XXX_PID_9B_REG_EN_SW_START_BIT	(2)
+#define AW87XXX_PID_9B_REG_EN_SW_BITS_LEN	(1)
+#define AW87XXX_PID_9B_REG_EN_SW_MASK	\
+	(~(((1<<AW87XXX_PID_9B_REG_EN_SW_BITS_LEN)-1) << AW87XXX_PID_9B_REG_EN_SW_START_BIT))
+
+#define AW87XXX_PID_9B_REG_EN_SW_DISABLE	(0)
+#define AW87XXX_PID_9B_REG_EN_SW_DISABLE_VALUE	\
+	(AW87XXX_PID_9B_REG_EN_SW_DISABLE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_9B_REG_EN_SW_ENABLE		(1)
+#define AW87XXX_PID_9B_REG_EN_SW_ENABLE_VALUE	\
+	(AW87XXX_PID_9B_REG_EN_SW_ENABLE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+#define AW87XXX_PID_9B_REG_EN_SW_DEFAULT_VALUE	(1)
+#define AW87XXX_PID_9B_REG_EN_SW_DEFAULT	\
+	(AW87XXX_PID_9B_REG_EN_SW_DEFAULT_VALUE << AW87XXX_PID_9B_REG_EN_SW_START_BIT)
+
+/* SPK_MODE bit 0 (SYSCTRL 0x01) */
+#define AW87XXX_PID_9B_SPK_MODE_START_BIT	(0)
+#define AW87XXX_PID_9B_SPK_MODE_BITS_LEN	(1)
+#define AW87XXX_PID_9B_SPK_MODE_MASK	\
+	(~(((1<<AW87XXX_PID_9B_SPK_MODE_BITS_LEN)-1) << AW87XXX_PID_9B_SPK_MODE_START_BIT))
+
+#define AW87XXX_PID_9B_SPK_MODE_DISABLE	(0)
+#define AW87XXX_PID_9B_SPK_MODE_DISABLE_VALUE	\
+	(AW87XXX_PID_9B_SPK_MODE_DISABLE << AW87XXX_PID_9B_SPK_MODE_START_BIT)
+
+#define AW87XXX_PID_9B_SPK_MODE_ENABLE	(1)
+#define AW87XXX_PID_9B_SPK_MODE_ENABLE_VALUE	\
+	(AW87XXX_PID_9B_SPK_MODE_ENABLE << AW87XXX_PID_9B_SPK_MODE_START_BIT)
+
+#endif
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Mon, 28 Oct 2024 00:16:12 +0100
Subject: Codec: aw87xxx: add dmi match for handheld devices

---
 sound/soc/codecs/aw87xxx/aw87xxx.c | 51 ++++++++++++++++++++++++++++--
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/sound/soc/codecs/aw87xxx/aw87xxx.c b/sound/soc/codecs/aw87xxx/aw87xxx.c
index 837a60deab9d..3d732400e449 100644
--- a/sound/soc/codecs/aw87xxx/aw87xxx.c
+++ b/sound/soc/codecs/aw87xxx/aw87xxx.c
@@ -33,6 +33,7 @@
 #include <linux/io.h>
 #include <linux/init.h>
 #include <linux/pci.h>
+#include <linux/dmi.h>
 #include <linux/dma-mapping.h>
 #include <linux/gameport.h>
 #include <linux/moduleparam.h>
@@ -841,6 +842,48 @@ static void aw87xxx_fw_load_work_routine(struct work_struct *work)
 	}
 }
 
+static const struct dmi_system_id firmware_names[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "KUN"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_kun.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "Loki MiniPro"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_minipro.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "AIR 1S"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_air1s.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "AIR Plus"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_airplus.bin",
+	},
+	{
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AYANEO"),
+		  DMI_MATCH(DMI_PRODUCT_NAME, "FLIP"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_flip.bin",
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "NEO-01"),
+		},
+		.driver_data = (void *)"aw87xxx_acf_orangepi.bin",
+	},
+	{}
+};
+
 static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
 {
 #ifdef AW_CFG_UPDATE_DELAY
@@ -848,8 +891,12 @@ static void aw87xxx_fw_load_init(struct aw87xxx *aw87xxx)
 #else
 	int cfg_timer_val = 0;
 #endif
-	AW_DEV_LOGI(aw87xxx->dev, "enter");
-	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", AW87XXX_FW_BIN_NAME);
+	const struct dmi_system_id *fwname_sysid = dmi_first_match(firmware_names);
+	const char *fwname = fwname_sysid ?
+		fwname_sysid->driver_data : AW87XXX_FW_BIN_NAME;
+
+	AW_DEV_LOGI(aw87xxx->dev, "loading firmware name: [%s]", fwname);
+	snprintf(aw87xxx->fw_name, AW87XXX_FW_NAME_MAX, "%s", fwname);
 	aw87xxx_acf_init(&aw87xxx->aw_dev, &aw87xxx->acf_info, aw87xxx->dev_index);
 
 	INIT_DELAYED_WORK(&aw87xxx->fw_load_work, aw87xxx_fw_load_work_routine);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: fewtarius <fewtarius@steamfork.org>
Date: Fri, 26 Jul 2024 22:28:04 +0200
Subject: ALSA: hda/realtek: Add Ayaneo Air 1S audio quirk

Co-developed-by: linh1987
---
 sound/hda/codecs/realtek/alc269.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/sound/hda/codecs/realtek/alc269.c b/sound/hda/codecs/realtek/alc269.c
index 07ea76efa5de..4d08aa8a407b 100644
--- a/sound/hda/codecs/realtek/alc269.c
+++ b/sound/hda/codecs/realtek/alc269.c
@@ -3479,6 +3479,7 @@ enum {
 	ALC269VB_FIXUP_ASUS_ZENBOOK,
 	ALC269VB_FIXUP_ASUS_ZENBOOK_UX31A,
 	ALC269VB_FIXUP_ASUS_MIC_NO_PRESENCE,
+	ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX,
 	ALC269_FIXUP_LIMIT_INT_MIC_BOOST_MUTE_LED,
 	ALC269VB_FIXUP_ORDISSIMO_EVE2,
 	ALC283_FIXUP_CHROME_BOOK,
@@ -4206,6 +4207,13 @@ static const struct hda_fixup alc269_fixups[] = {
 		.chained = true,
 		.chain_id = ALC269_FIXUP_HEADSET_MIC
 	},
+	[ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			{ 0x1a, 0x90170110 },
+			{ }
+		},
+	},
 	[ALC269_FIXUP_LIMIT_INT_MIC_BOOST_MUTE_LED] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc269_fixup_limit_int_mic_boost,
@@ -7178,6 +7186,7 @@ static const struct hda_quirk alc269_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x2782, 0x1705, "MEDION E15433", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1707, "Vaio VJFE-ADL", ALC298_FIXUP_SPK_VOLUME),
 	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
+	SND_PCI_QUIRK(0x1f66, 0x0103, "AYANEO AIR 1S", ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX),
 	SND_PCI_QUIRK(0x8086, 0x2074, "Intel NUC 8", ALC233_FIXUP_INTEL_NUC8_DMIC),
 	SND_PCI_QUIRK(0x8086, 0x2080, "Intel NUC 8 Rugged", ALC256_FIXUP_INTEL_NUC8_RUGGED),
 	SND_PCI_QUIRK(0x8086, 0x2081, "Intel NUC 10", ALC256_FIXUP_INTEL_NUC10),
@@ -7303,6 +7312,7 @@ static const struct hda_model_fixup alc269_fixup_models[] = {
 	{.id = ALC269VB_FIXUP_ASUS_ZENBOOK, .name = "asus-zenbook"},
 	{.id = ALC269VB_FIXUP_ASUS_ZENBOOK_UX31A, .name = "asus-zenbook-ux31a"},
 	{.id = ALC269VB_FIXUP_ORDISSIMO_EVE2, .name = "ordissimo"},
+	{.id = ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX, .name = "ayaneo-speaker-pin-fix"},
 	{.id = ALC282_FIXUP_ASUS_TX300, .name = "asus-tx300"},
 	{.id = ALC283_FIXUP_INT_MIC, .name = "alc283-int-mic"},
 	{.id = ALC290_FIXUP_MONO_SPEAKERS_HSJACK, .name = "mono-speakers"},
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: CVMagic <546352+CVMagic@users.noreply.github.com>
Date: Fri, 22 Sep 2023 21:53:06 +0200
Subject: ALSA: hda/realtek: Use DMI matching for Ayaneo Geek, Ayaneo 2, and
 Ayn MiniPro

Co-developed-by: Bouke Sybren Haarsma <boukehaarsma23@gmail.com>
---
 sound/hda/codecs/realtek/alc269.c | 51 ++++++++++++++++++++++++++++++-
 1 file changed, 50 insertions(+), 1 deletion(-)

diff --git a/sound/hda/codecs/realtek/alc269.c b/sound/hda/codecs/realtek/alc269.c
index 4d08aa8a407b..d519021bfb08 100644
--- a/sound/hda/codecs/realtek/alc269.c
+++ b/sound/hda/codecs/realtek/alc269.c
@@ -2545,6 +2545,20 @@ static void alc294_gx502_toggle_output(struct hda_codec *codec,
 		alc_write_coef_idx(codec, 0x10, 0x0a20);
 }
 
+static void alc269_fixup_headphone_volume(struct hda_codec *codec,
+					const struct hda_fixup *fix, int action)
+{
+	/* Pin 0x21: Some devices share 0x14 for headphones and speakers.
+	 * This will fix ensure these devices have volume controls. */
+	if (!is_jack_detectable(codec, 0x21))
+		return;
+
+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
+		static const hda_nid_t conn1[] = { 0x02 };
+		snd_hda_override_conn_list(codec, 0x14, ARRAY_SIZE(conn1), conn1);
+	}
+}
+
 static void alc294_fixup_gx502_hp(struct hda_codec *codec,
 					const struct hda_fixup *fix, int action)
 {
@@ -3466,6 +3480,8 @@ enum {
 	ALC269_FIXUP_DELL4_MIC_NO_PRESENCE,
 	ALC269_FIXUP_DELL4_MIC_NO_PRESENCE_QUIET,
 	ALC269_FIXUP_HEADSET_MODE,
+	ALC269_FIXUP_DMI_MATCH,
+	ALC269_FIXUP_AYA_HEADSET_VOLUME,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC269_FIXUP_ASPIRE_HEADSET_MIC,
 	ALC269_FIXUP_ASUS_X101_FUNC,
@@ -3740,6 +3756,30 @@ enum {
 	ALC269_FIXUP_POSITIVO_P15X_HEADSET_MIC,
 };
 
+/* A special fixup for AYN and AYANEO handhelds as both
+*  have the same PCI SSID as well as the same codec, but
+*  require different quirks, falling back to DMI matching.
+*/
+static void alc269_fixup_match_via_dmi(struct hda_codec *codec,
+                                        const struct hda_fixup *fix, int action)
+{
+	int alc269_fix_id;
+	const char *board_name = dmi_get_system_info(DMI_BOARD_NAME);
+
+	if (dmi_name_in_vendors("AYANEO") || dmi_name_in_vendors("AYADEVICE") || dmi_name_in_vendors("AYA DEVICE")) {
+		if (board_name && (strcmp(board_name, "AYANEO 2") || strcmp(board_name, "AYANEO 2S") || strcmp(board_name, "GEEK") || strcmp(board_name, "GEEK 1S"))) {
+			alc269_fix_id = ALC269_FIXUP_AYA_HEADSET_VOLUME;
+		} else {
+			return;
+		}
+	} else if (dmi_name_in_vendors("ayn") && strcmp(board_name, "Loki MiniPro")) {
+		alc269_fix_id = ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX;
+	} else {
+		return;
+	}
+	__snd_hda_apply_fixup(codec, alc269_fix_id, action, 0);
+}
+
 /* A special fixup for Lenovo C940 and Yoga Duet 7;
  * both have the very same PCI SSID, and we need to apply different fixups
  * depending on the codec ID
@@ -5019,6 +5059,14 @@ static const struct hda_fixup alc269_fixups[] = {
 			{ 0x1b, 0x90170152 } /* use as internal speaker (back) */
 		}
 	},
+	[ALC269_FIXUP_DMI_MATCH] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc269_fixup_match_via_dmi,
+	},
+	[ALC269_FIXUP_AYA_HEADSET_VOLUME] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc269_fixup_headphone_volume,
+	},
 	[ALC299_FIXUP_PREDATOR_SPK] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -7185,8 +7233,9 @@ static const struct hda_quirk alc269_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x2782, 0x1701, "Infinix Y4 Max", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1705, "MEDION E15433", ALC269VC_FIXUP_INFINIX_Y4_MAX),
 	SND_PCI_QUIRK(0x2782, 0x1707, "Vaio VJFE-ADL", ALC298_FIXUP_SPK_VOLUME),
-	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
+	SND_PCI_QUIRK(0x1f66, 0x0101, "AYANEO 2/GEEK/Ayn MiniPro", ALC269_FIXUP_DMI_MATCH),
 	SND_PCI_QUIRK(0x1f66, 0x0103, "AYANEO AIR 1S", ALC269VB_FIXUP_AYANEO_SPKR_PIN_FIX),
+	SND_PCI_QUIRK(0x2782, 0x4900, "MEDION E15443", ALC233_FIXUP_MEDION_MTL_SPK),
 	SND_PCI_QUIRK(0x8086, 0x2074, "Intel NUC 8", ALC233_FIXUP_INTEL_NUC8_DMIC),
 	SND_PCI_QUIRK(0x8086, 0x2080, "Intel NUC 8 Rugged", ALC256_FIXUP_INTEL_NUC8_RUGGED),
 	SND_PCI_QUIRK(0x8086, 0x2081, "Intel NUC 10", ALC256_FIXUP_INTEL_NUC10),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 15 Mar 2025 23:44:25 +0100
Subject: [TEMPORARY] remove bmi260 matches from bmi270 driver due to sleep
 issues

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/iio/imu/bmi270/bmi270_i2c.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/iio/imu/bmi270/bmi270_i2c.c b/drivers/iio/imu/bmi270/bmi270_i2c.c
index c77839b03a96..2e8088b94a63 100644
--- a/drivers/iio/imu/bmi270/bmi270_i2c.c
+++ b/drivers/iio/imu/bmi270/bmi270_i2c.c
@@ -40,7 +40,7 @@ static const struct i2c_device_id bmi270_i2c_id[] = {
 
 static const struct acpi_device_id bmi270_acpi_match[] = {
 	/* GPD Win Mini, Aya Neo AIR Pro, OXP Mini Pro, etc. */
-	{ "BMI0160",  (kernel_ulong_t)&bmi260_chip_info },
+	// { "BMI0160",  (kernel_ulong_t)&bmi260_chip_info },
 	{ }
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 16 Nov 2024 01:49:28 +0100
Subject: Documentation: PM: Add documentation for S0ix Standby States

---
 .../admin-guide/pm/standby-states.rst         | 130 ++++++++++++++++++
 Documentation/admin-guide/pm/system-wide.rst  |   1 +
 2 files changed, 131 insertions(+)
 create mode 100644 Documentation/admin-guide/pm/standby-states.rst

diff --git a/Documentation/admin-guide/pm/standby-states.rst b/Documentation/admin-guide/pm/standby-states.rst
new file mode 100644
index 000000000000..7a7e560915df
--- /dev/null
+++ b/Documentation/admin-guide/pm/standby-states.rst
@@ -0,0 +1,130 @@
+.. SPDX-License-Identifier: GPL-2.0
+.. include:: <isonum.txt>
+
+=====================
+S0ix Standby States
+=====================
+
+:Copyright: |copy| 2024 Antheas Kapenekakis
+
+:Author: Antheas Kapenekakis <lkml@antheas.dev>
+
+With the advent of modern mobile devices, users have become accustomed to instant
+wake-up times and always-on connectivity. To meet these expectations, modern
+standby was created, which is a standard that allows the platform to seamlessly
+transition between an S3-like low-power idle state and a set of low power active
+states, where connectivity is maintained, and the system is responsive to user
+input. Current x86 hardware supports 5 different standby states, which are:
+"Deepest run-time idle platform state" or "DRIPS" (S3-like), "Sleep", "Resume",
+"Screen Off", and "Active".
+
+The system begins in the "Active" state. Either due to user inactivity or
+user action (e.g., pressing the power button), it transitions to the "Screen Off"
+state. Afterwards, it is free to transition between the "Sleep", "DRIPS", and
+"Screen Off" states until user action is received. Once that happens, the system
+begins to transition to the "Active" state. From "DRIPS" or "Sleep", it
+transitions to "Resume", where the Power Limit (PLx) is restored to its normal
+level, to speed up finishing "Sleep". Then, it transitions to "Screen Off".
+If on "Screen Off" or after the transition, the display is prepared to turn on
+and the system transitions to "Active" alongside turning it on.
+
+To maintain battery life, in the Windows implementation, the system is allocated
+a maximum percentage of battery and time it can use while staying in idle states.
+By default, this is 5% of battery or up to 2 days, where the system designer/OEM
+is able to tweak these values. If the system exceeds either the battery
+percentage or time limit, it enters hibernation (S4), through a concept
+called "Adaptive Hibernate".
+
+
+S0ix Standby States
+==================================
+The following idle states are supported::
+
+    <DRIPS>  <Sleep>  <Screen Off>  <Active>
+                 <Resume>  
+
+.. _s2idle_drips:
+
+DRIPS
+-----
+
+The "Deepest run-time idle platform state" or "DRIPS" is the lowest power idle
+state that the system can enter. It is similar to the S3 state, with the
+difference that the system may wake up faster than S3 and due to a larger number
+of interrupts (e.g., fingerprint sensor, touchpad, touchscreen). This state
+is entered when the system is told to suspend to idle, through conventional
+means (see :doc:`sleep states <sleep-states>`). The system can only transition
+to DRIPS while in the "Sleep" state. If it is not, the kernel will automatically
+transition to the "Sleep" state before beginning the suspend sequence and
+restore the previous state afterwards.
+
+.. _s2idle_sleep:
+
+Sleep
+-----
+
+The "Sleep" state is a low power idle state where the kernel is fully active.
+However, userspace has been partially frozen, particularly desktop applications,
+and only essential "value adding" activities are allowed to run. This is not
+enforced by the kernel, it is the responsibility of userspace (e.g., systemd).
+Hardware wise, the Sleep Entry and Exit firmware notifications are fired, which
+may lower the Power Limit (PLx), pulse the suspend light, turn off the keyboard
+lighting or disable a handheld device's gamepad (Lenovo Legion Go).
+
+.. _s2idle_resume:
+
+Resume
+------
+
+The "Resume" state is a faux "Sleep" state that is used to fire the Turn On
+Display firmware notification when the system is in the "Sleep" state but
+intends to turn on the display. It solves the problem of system designers
+limiting the Power Limit (PLx) while the system is in the "Sleep" state causing
+the system to wake up slower than desired. This firmware notification is used
+to restore the normal Power Limit of the system, while having it stay in the
+"Sleep" state.  As such, the system can only transition to the "Resume" state
+while in the "Sleep" state.
+
+.. _s2idle_screen_off:
+
+Screen Off
+----------
+
+The "Screen Off" state is the state the system enters when all its displays
+(virtual or real) turn off. It is used to signify the user is not actively
+using the system. The associated firmware notifications of "Display On" and
+"Display Off" can be used by manufacturers to turn off certain hardware
+components that are associated with the display being on, e.g., a handheld
+device's controller and RGB (Asus ROG Ally, OneXPlayer devices). Windows
+implements a 5-second grace period before firing this callback when the
+screen turns off due to inactivity.
+
+.. _s2idle_active:
+
+Active
+------
+
+Finally, the "Active" state is the default state of the system and the one it
+has when it is turned on. It is the state where the system is fully operational,
+the displays of the device are on, and the user is actively interacting with
+the system.
+
+Basic ``sysfs`` Interface for S0ix Standby transitions
+=============================================================
+
+The file :file:`/sys/power/standby` can be used to transition the system between
+the different standby states. The file accepts the following values: ``active``,
+``screen_off``, ``sleep``, and ``resume``. File writes will block until the
+transition completes. It will return ``-EINVAL`` when asking for an unsupported
+state or, e.g., requesting ``resume`` when not in the ``sleep`` state. If there
+is an error during the transition, the transition will pause on the last
+error-free state and return an error. The file can be read to retrieve the current
+state (and potential ones) with the following format:
+``[active] screen_off sleep resume``. The state "DRIPS" is omitted, as it is
+entered through the conventional suspend to idle path and userspace will never
+be able to see its value due to being suspended.
+
+Before entering the "Screen Off" state or suspending, it is recommended that
+userspace marks all CRTCs as inactive (DPMS). Otherwise, there will be a split
+second where the display of the device is on, but the presentation of the system
+is inactive (e.g., the power button pulses), which is undesirable.
\ No newline at end of file
diff --git a/Documentation/admin-guide/pm/system-wide.rst b/Documentation/admin-guide/pm/system-wide.rst
index 1a1924d71006..411775fae4ac 100644
--- a/Documentation/admin-guide/pm/system-wide.rst
+++ b/Documentation/admin-guide/pm/system-wide.rst
@@ -8,4 +8,5 @@ System-Wide Power Management
    :maxdepth: 2
 
    sleep-states
+   standby-states
    suspend-flows
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 18 Sep 2024 23:53:53 +0200
Subject: acpi/x86: s2idle: add support for Display Off and Display On
 callbacks

The Display Off and Display On firmware notifications are meant to signify
the system entering a state where the user is not actively interacting
with it (i.e., in Windows this state is called "Screen Off" and the
system enters it once it turns the screen off e.g., due to inactivity).

Currently, these functions are called within the suspend sequence, which
causes issues when these notifications interact with e.g., a USB device
and makes them unable to be called as part of the screen turning off.

This patch adds a set of callbacks to allow calling the Display On/Off
notifications outside of the suspend/resume path.

Co-Developed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 include/linux/suspend.h |  2 ++
 kernel/power/suspend.c  | 10 ++++++++++
 2 files changed, 12 insertions(+)

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 317ae31e89b3..e01995515c7c 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -132,6 +132,7 @@ struct platform_suspend_ops {
 };
 
 struct platform_s2idle_ops {
+	int (*display_off)(void);
 	int (*begin)(void);
 	int (*prepare)(void);
 	int (*prepare_late)(void);
@@ -140,6 +141,7 @@ struct platform_s2idle_ops {
 	void (*restore_early)(void);
 	void (*restore)(void);
 	void (*end)(void);
+	int (*display_on)(void);
 };
 
 #ifdef CONFIG_SUSPEND
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 9c13e819db84..85cda200fb37 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -280,6 +280,16 @@ static bool sleep_state_supported(suspend_state_t state)
 	       (valid_state(state) && !cxl_mem_active());
 }
 
+static int platform_standby_display_off(void)
+{
+	return s2idle_ops && s2idle_ops->display_off ? s2idle_ops->display_off() : 0;
+}
+
+static int platform_standby_display_on(void)
+{
+	return s2idle_ops && s2idle_ops->display_on ? s2idle_ops->display_on() : 0;
+}
+
 static int platform_suspend_prepare(suspend_state_t state)
 {
 	return state != PM_SUSPEND_TO_IDLE && suspend_ops->prepare ?
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 25 Sep 2024 14:10:11 +0200
Subject: acpi/x86: s2idle: add support for Sleep Entry and Sleep Exit
 callbacks

The Sleep Entry and Sleep Exit firmware notifications allow the platform
to enter Modern Standby. In this state, if supported, the platform turns
off auxiliary USB devices (e.g., the controllers of the Legion Go),
makes the power light of the device flash, and lowers the power envelope
to a minimum that still allows for software activity without affecting
battery life.

Allow for entering this state prior to initiating the suspend sequence.
This fixes issues where the EC or the USB of the device need time to
power down before entering the suspend sequence, and allows for entering
this power state without suspending the device.

Suggested-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 include/linux/suspend.h |  2 ++
 kernel/power/suspend.c  | 10 ++++++++++
 2 files changed, 12 insertions(+)

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e01995515c7c..7bb1367cf217 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -133,6 +133,7 @@ struct platform_suspend_ops {
 
 struct platform_s2idle_ops {
 	int (*display_off)(void);
+	int (*sleep_entry)(void);
 	int (*begin)(void);
 	int (*prepare)(void);
 	int (*prepare_late)(void);
@@ -141,6 +142,7 @@ struct platform_s2idle_ops {
 	void (*restore_early)(void);
 	void (*restore)(void);
 	void (*end)(void);
+	int (*sleep_exit)(void);
 	int (*display_on)(void);
 };
 
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 85cda200fb37..4e9481f350f4 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -285,6 +285,16 @@ static int platform_standby_display_off(void)
 	return s2idle_ops && s2idle_ops->display_off ? s2idle_ops->display_off() : 0;
 }
 
+static int platform_standby_sleep_entry(void)
+{
+	return s2idle_ops && s2idle_ops->sleep_entry ? s2idle_ops->sleep_entry() : 0;
+}
+
+static int platform_standby_sleep_exit(void)
+{
+	return s2idle_ops && s2idle_ops->sleep_exit ? s2idle_ops->sleep_exit() : 0;
+}
+
 static int platform_standby_display_on(void)
 {
 	return s2idle_ops && s2idle_ops->display_on ? s2idle_ops->display_on() : 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 16:47:47 +0100
Subject: acpi/x86: s2idle: add support for Turn On Display callback

The Turn On Display callback was introduced in Windows 22H2, to allow
devices to resume faster from sleep. Essentially, if the device lowers
its power limit (PLx) while it is in the Sleep state, this might lengthen
the suspend sequence in an undesirable manner. Therefore, this callback
can be used to restore PLx while still remaining in the sleep state.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 include/linux/suspend.h | 1 +
 kernel/power/suspend.c  | 7 +++++++
 2 files changed, 8 insertions(+)

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index 7bb1367cf217..e5b214222d66 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -142,6 +142,7 @@ struct platform_s2idle_ops {
 	void (*restore_early)(void);
 	void (*restore)(void);
 	void (*end)(void);
+	int (*turn_on_display)(void);
 	int (*sleep_exit)(void);
 	int (*display_on)(void);
 };
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 4e9481f350f4..a811b39346e5 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -290,6 +290,13 @@ static int platform_standby_sleep_entry(void)
 	return s2idle_ops && s2idle_ops->sleep_entry ? s2idle_ops->sleep_entry() : 0;
 }
 
+static int platform_standby_turn_on_display(void)
+{
+	return s2idle_ops && s2idle_ops->turn_on_display ?
+		       s2idle_ops->turn_on_display() :
+		       0;
+}
+
 static int platform_standby_sleep_exit(void)
 {
 	return s2idle_ops && s2idle_ops->sleep_exit ? s2idle_ops->sleep_exit() : 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 19:55:54 +0100
Subject: acpi/x86: s2idle: add modern standby transition function

Add a new function to transition modern standby states and call it
as part of the suspend sequence to make sure it begins under the
Modern Standby "Sleep" state.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 include/linux/suspend.h |  11 ++++
 kernel/power/power.h    |   1 +
 kernel/power/suspend.c  | 119 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 131 insertions(+)

diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index e5b214222d66..a9d4a9c88115 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -40,6 +40,15 @@ typedef int __bitwise suspend_state_t;
 #define PM_SUSPEND_MIN		PM_SUSPEND_TO_IDLE
 #define PM_SUSPEND_MAX		((__force suspend_state_t) 4)
 
+typedef int __bitwise standby_state_t;
+
+#define PM_STANDBY_ACTIVE		((__force standby_state_t) 0)
+#define PM_STANDBY_SCREEN_OFF	((__force standby_state_t) 1)
+#define PM_STANDBY_SLEEP		((__force standby_state_t) 2)
+#define PM_STANDBY_RESUME		((__force standby_state_t) 3)
+#define PM_STANDBY_MIN			PM_STANDBY_ACTIVE
+#define PM_STANDBY_MAX			((__force standby_state_t) 4)
+
 /**
  * struct platform_suspend_ops - Callbacks for managing platform dependent
  *	system sleep states.
@@ -281,6 +290,8 @@ extern void arch_suspend_enable_irqs(void);
 
 extern int pm_suspend(suspend_state_t state);
 extern bool sync_on_suspend_enabled;
+extern int pm_standby_transition(standby_state_t state, bool skip_transition);
+extern int pm_standby_state(void);
 #else /* !CONFIG_SUSPEND */
 #define suspend_valid_only_mem	NULL
 
diff --git a/kernel/power/power.h b/kernel/power/power.h
index 7ccd709af93f..7e6bef368b2d 100644
--- a/kernel/power/power.h
+++ b/kernel/power/power.h
@@ -215,6 +215,7 @@ extern void swsusp_show_speed(ktime_t, ktime_t, unsigned int, char *);
 extern const char * const pm_labels[];
 extern const char *pm_states[];
 extern const char *mem_sleep_states[];
+extern const char *standby_states[];
 
 extern int suspend_devices_and_enter(suspend_state_t state);
 #else /* !CONFIG_SUSPEND */
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index a811b39346e5..72f1c63900a9 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -47,12 +47,21 @@ static const char * const mem_sleep_labels[] = {
 	[PM_SUSPEND_MEM] = "deep",
 };
 const char *mem_sleep_states[PM_SUSPEND_MAX];
+static const char * const standby_labels[] = {
+	[PM_STANDBY_ACTIVE] = "active",
+	[PM_STANDBY_SCREEN_OFF] = "screen_off",
+	[PM_STANDBY_SLEEP] = "sleep",
+	[PM_STANDBY_RESUME] = "resume",
+};
+const char *standby_states[PM_STANDBY_MAX];
 
 suspend_state_t mem_sleep_current = PM_SUSPEND_TO_IDLE;
 suspend_state_t mem_sleep_default = PM_SUSPEND_MAX;
 suspend_state_t pm_suspend_target_state;
 EXPORT_SYMBOL_GPL(pm_suspend_target_state);
 
+standby_state_t standby_current = PM_STANDBY_ACTIVE;
+
 unsigned int pm_suspend_global_flags;
 EXPORT_SYMBOL_GPL(pm_suspend_global_flags);
 
@@ -214,6 +223,17 @@ void __init pm_states_init(void)
 		s2idle_unsupported = true;
 		pr_info("Steam Deck quirk - no s2idle allowed!\n");
 	}
+
+	/* All systems support the "active" state. */
+	standby_states[PM_STANDBY_ACTIVE] = standby_labels[PM_STANDBY_ACTIVE];
+	/* 
+	 * Not all systems support these states, where they will have increased
+	 * power consumption. If deemed necessary, they should be gated to not
+	 * mislead userspace.
+	 */
+	standby_states[PM_STANDBY_SCREEN_OFF] = standby_labels[PM_STANDBY_SCREEN_OFF];
+	standby_states[PM_STANDBY_SLEEP] = standby_labels[PM_STANDBY_SLEEP];
+	standby_states[PM_STANDBY_RESUME] = standby_labels[PM_STANDBY_RESUME];
 }
 
 static int __init mem_sleep_default_setup(char *str)
@@ -380,6 +400,100 @@ static bool platform_suspend_again(suspend_state_t state)
 		suspend_ops->suspend_again() : false;
 }
 
+static int platform_standby_transition_internal(standby_state_t state)
+{
+	int error;
+
+	if (state == standby_current)
+		return 0;
+	if (state > PM_STANDBY_MAX)
+		return -EINVAL;
+
+	pm_pr_dbg("Transitioning from standby state %s to %s\n",
+		  standby_states[standby_current], standby_states[state]);
+
+	/* Resume can only be entered if we are on the sleep state. */
+	if (state == PM_STANDBY_RESUME) {
+		if (standby_current != PM_STANDBY_SLEEP)
+			return -EINVAL;
+		standby_current = PM_STANDBY_RESUME;
+		return platform_standby_turn_on_display();
+	}
+
+	/* 
+	 * The system should not be able to re-enter Sleep from resume as it
+	 * is undefined behavior. As part of setting the state to "Resume",
+	 * were promised a transition to "Screen Off" or "Active".
+	 */
+	if (standby_current == PM_STANDBY_RESUME && state == PM_STANDBY_SLEEP)
+		return -EINVAL;
+
+	/* Resume is the Sleep state logic-wise. */
+	if (standby_current == PM_STANDBY_RESUME)
+		standby_current = PM_STANDBY_SLEEP;
+
+	if (standby_current < state) {
+		for (; standby_current < state; standby_current++) {
+			switch (standby_current + 1) {
+			case PM_STANDBY_SCREEN_OFF:
+				error = platform_standby_display_off();
+				break;
+			case PM_STANDBY_SLEEP:
+				error = platform_standby_sleep_entry();
+				break;
+			}
+
+			if (error)
+				return error;
+		}
+	} else if (standby_current > state) {
+		for (; standby_current > state; standby_current--) {
+			switch (standby_current) {
+			case PM_STANDBY_SLEEP:
+				error = platform_standby_sleep_exit();
+				break;
+			case PM_STANDBY_SCREEN_OFF:
+				error = platform_standby_display_on();
+				break;
+			}
+
+			if (error)
+				return error;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * pm_standby_transition - Transition between Modern Standby states
+ * 
+ * Fires the appropriate firmware notifications to transition to the requested
+ * state. Returns an error if the transition fails. The function does not
+ * rollback. It is up to userspace to handle the error and re-transition when
+ * appropriate. skip_transition can be used after hibernation power on to
+ * sync the kernel state with the firmware state. It is up to the caller
+ * to lock system sleep.
+ */
+int pm_standby_transition(standby_state_t state, bool skip_transition)
+{
+	if (skip_transition) {
+		standby_current = state;
+		return 0;
+	}
+	return platform_standby_transition_internal(state);
+}
+EXPORT_SYMBOL_GPL(pm_standby_transition);
+
+/**
+ * pm_standby_state - Returns the current standby state
+ */
+int pm_standby_state(void)
+{
+	return standby_current;
+}
+EXPORT_SYMBOL_GPL(pm_standby_state);
+
 #ifdef CONFIG_PM_DEBUG
 static unsigned int pm_test_delay = 5;
 module_param(pm_test_delay, uint, 0644);
@@ -635,6 +749,9 @@ static int enter_state(suspend_state_t state)
 	if (!mutex_trylock(&system_transition_mutex))
 		return -EBUSY;
 
+	standby_state_t standby_prior = standby_current;
+	platform_standby_transition_internal(PM_STANDBY_SLEEP);
+
 	if (state == PM_SUSPEND_TO_IDLE)
 		s2idle_begin();
 
@@ -662,6 +779,8 @@ static int enter_state(suspend_state_t state)
 	pm_pr_dbg("Finishing wakeup.\n");
 	suspend_finish();
  Unlock:
+	platform_standby_transition_internal(standby_prior);
+
 	mutex_unlock(&system_transition_mutex);
 	return error;
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 17:35:05 +0100
Subject: acpi/x86: s2idle: rename Screen On/Off to Display On/Off

Microsoft and Intel use the term "Display" to refer to the _DSM 3,4
calls and the term "Screen" for the state ("Screen Off"). Currently,
the code uses "Screen On/Off" to name the variables, which is about
to become confusing as they become callbacks. To prepare for that,
rename the variables to "Display On/Off".

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 36 ++++++++++++++++++------------------
 1 file changed, 18 insertions(+), 18 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index dd0b40b9bbe8..7391f87f3aa0 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -39,8 +39,8 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_DSM_UUID	"c4eb40a0-6cd2-11e2-bcfd-0800200c9a66"
 
 #define ACPI_LPS0_GET_DEVICE_CONSTRAINTS	1
-#define ACPI_LPS0_SCREEN_OFF	3
-#define ACPI_LPS0_SCREEN_ON	4
+#define ACPI_LPS0_DISPLAY_OFF	3
+#define ACPI_LPS0_DISPLAY_ON	4
 #define ACPI_LPS0_ENTRY		5
 #define ACPI_LPS0_EXIT		6
 #define ACPI_LPS0_MS_ENTRY      7
@@ -50,8 +50,8 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_DSM_UUID_AMD      "e3f32452-febc-43ce-9039-932122d37721"
 #define ACPI_LPS0_ENTRY_AMD         2
 #define ACPI_LPS0_EXIT_AMD          3
-#define ACPI_LPS0_SCREEN_OFF_AMD    4
-#define ACPI_LPS0_SCREEN_ON_AMD     5
+#define ACPI_LPS0_DISPLAY_OFF_AMD   4
+#define ACPI_LPS0_DISPLAY_ON_AMD    5
 
 static acpi_handle lps0_device_handle;
 static guid_t lps0_dsm_guid;
@@ -361,10 +361,10 @@ static const char *acpi_sleep_dsm_state_to_str(unsigned int state)
 {
 	if (lps0_dsm_func_mask_microsoft || !acpi_s2idle_vendor_amd()) {
 		switch (state) {
-		case ACPI_LPS0_SCREEN_OFF:
-			return "screen off";
-		case ACPI_LPS0_SCREEN_ON:
-			return "screen on";
+		case ACPI_LPS0_DISPLAY_OFF:
+			return "display off";
+		case ACPI_LPS0_DISPLAY_ON:
+			return "display on";
 		case ACPI_LPS0_ENTRY:
 			return "lps0 entry";
 		case ACPI_LPS0_EXIT:
@@ -376,10 +376,10 @@ static const char *acpi_sleep_dsm_state_to_str(unsigned int state)
 		}
 	} else {
 		switch (state) {
-		case ACPI_LPS0_SCREEN_ON_AMD:
-			return "screen on";
-		case ACPI_LPS0_SCREEN_OFF_AMD:
-			return "screen off";
+		case ACPI_LPS0_DISPLAY_ON_AMD:
+			return "display on";
+		case ACPI_LPS0_DISPLAY_OFF_AMD:
+			return "display off";
 		case ACPI_LPS0_ENTRY_AMD:
 			return "lps0 entry";
 		case ACPI_LPS0_EXIT_AMD:
@@ -552,12 +552,12 @@ int acpi_s2idle_prepare_late(void)
 	/* Screen off */
 	if (lps0_dsm_func_mask > 0)
 		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
-					ACPI_LPS0_SCREEN_OFF_AMD :
-					ACPI_LPS0_SCREEN_OFF,
+					ACPI_LPS0_DISPLAY_OFF_AMD :
+					ACPI_LPS0_DISPLAY_OFF,
 					lps0_dsm_func_mask, lps0_dsm_guid);
 
 	if (lps0_dsm_func_mask_microsoft > 0)
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_DISPLAY_OFF,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 
 	/* LPS0 entry */
@@ -626,12 +626,12 @@ void acpi_s2idle_restore_early(void)
 
 	/* Screen on */
 	if (lps0_dsm_func_mask_microsoft > 0)
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_DISPLAY_ON,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 	if (lps0_dsm_func_mask > 0)
 		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
-					ACPI_LPS0_SCREEN_ON_AMD :
-					ACPI_LPS0_SCREEN_ON,
+						ACPI_LPS0_DISPLAY_ON_AMD :
+						ACPI_LPS0_DISPLAY_ON,
 					lps0_dsm_func_mask, lps0_dsm_guid);
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 17:38:04 +0100
Subject: acpi/x86: s2idle: call Display On/Off as part of callbacks

Move the Display On/Off notifications into dedicated callbacks that gate
the ACPI mutex, so they can be called outside of the suspend path.

Co-Developed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 67 +++++++++++++++++++++++++++++----------
 1 file changed, 51 insertions(+), 16 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 7391f87f3aa0..c0ab4d4f01be 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -60,6 +60,7 @@ static int lps0_dsm_func_mask;
 static guid_t lps0_dsm_guid_microsoft;
 static int lps0_dsm_func_mask_microsoft;
 static int lps0_dsm_state;
+static bool lps0_dsm_in_display_off;
 
 /* Device constraint entry structure */
 struct lpi_device_info {
@@ -539,17 +540,18 @@ static struct acpi_scan_handler lps0_handler = {
 	.attach = lps0_device_attach,
 };
 
-int acpi_s2idle_prepare_late(void)
+static int acpi_s2idle_display_off(void)
 {
-	struct acpi_s2idle_dev_ops *handler;
-
 	if (!lps0_device_handle || sleep_no_lps0)
 		return 0;
 
-	if (pm_debug_messages_on)
-		lpi_check_constraints();
+	if (WARN_ON(lps0_dsm_in_display_off))
+		return -EINVAL;
+
+	lps0_dsm_in_display_off = true;
+	acpi_scan_lock_acquire();
 
-	/* Screen off */
+	/* Display off */
 	if (lps0_dsm_func_mask > 0)
 		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
 					ACPI_LPS0_DISPLAY_OFF_AMD :
@@ -560,6 +562,47 @@ int acpi_s2idle_prepare_late(void)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_DISPLAY_OFF,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 
+	acpi_scan_lock_release();
+
+	return 0;
+}
+
+static int acpi_s2idle_display_on(void)
+{
+	if (!lps0_device_handle || sleep_no_lps0)
+		return 0;
+
+	if (WARN_ON(!lps0_dsm_in_display_off))
+		return -EINVAL;
+
+	lps0_dsm_in_display_off = false;
+	acpi_scan_lock_acquire();
+
+	/* Display on */
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_DISPLAY_ON,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+	if (lps0_dsm_func_mask > 0)
+		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
+					ACPI_LPS0_DISPLAY_ON_AMD :
+					ACPI_LPS0_DISPLAY_ON,
+					lps0_dsm_func_mask, lps0_dsm_guid);
+
+	acpi_scan_lock_release();
+
+	return 0;
+}
+
+int acpi_s2idle_prepare_late(void)
+{
+	struct acpi_s2idle_dev_ops *handler;
+
+	if (!lps0_device_handle || sleep_no_lps0)
+		return 0;
+
+	if (pm_debug_messages_on)
+		lpi_check_constraints();
+
 	/* LPS0 entry */
 	if (lps0_dsm_func_mask > 0 && acpi_s2idle_vendor_amd())
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY_AMD,
@@ -623,19 +666,10 @@ void acpi_s2idle_restore_early(void)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 	}
-
-	/* Screen on */
-	if (lps0_dsm_func_mask_microsoft > 0)
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_DISPLAY_ON,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	if (lps0_dsm_func_mask > 0)
-		acpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?
-						ACPI_LPS0_DISPLAY_ON_AMD :
-						ACPI_LPS0_DISPLAY_ON,
-					lps0_dsm_func_mask, lps0_dsm_guid);
 }
 
 static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
+	.display_off = acpi_s2idle_display_off,
 	.begin = acpi_s2idle_begin,
 	.prepare = acpi_s2idle_prepare,
 	.prepare_late = acpi_s2idle_prepare_late,
@@ -644,6 +678,7 @@ static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
 	.restore_early = acpi_s2idle_restore_early,
 	.restore = acpi_s2idle_restore,
 	.end = acpi_s2idle_end,
+	.display_on = acpi_s2idle_display_on,
 };
 
 void __init acpi_s2idle_setup(void)
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 16 Nov 2024 09:55:43 +0100
Subject: acpi/x86: s2idle: rename MS Exit/Entry to Sleep Exit/Entry

Microsoft refers to the _DSMs 7,8 as "Sleep Entry" and "Sleep Exit".
Currently, the code uses "MS Entry/Exit" to name the variables, which is
confusing as it could either mean "Modern Standby" or "Microsoft" and is
not representative of the state. Rename as part of converting it into
a transition.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index c0ab4d4f01be..99e5f0938e53 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -43,8 +43,8 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_DISPLAY_ON	4
 #define ACPI_LPS0_ENTRY		5
 #define ACPI_LPS0_EXIT		6
-#define ACPI_LPS0_MS_ENTRY      7
-#define ACPI_LPS0_MS_EXIT       8
+#define ACPI_LPS0_SLEEP_ENTRY      7
+#define ACPI_LPS0_SLEEP_EXIT       8
 
 /* AMD */
 #define ACPI_LPS0_DSM_UUID_AMD      "e3f32452-febc-43ce-9039-932122d37721"
@@ -370,10 +370,10 @@ static const char *acpi_sleep_dsm_state_to_str(unsigned int state)
 			return "lps0 entry";
 		case ACPI_LPS0_EXIT:
 			return "lps0 exit";
-		case ACPI_LPS0_MS_ENTRY:
-			return "lps0 ms entry";
-		case ACPI_LPS0_MS_EXIT:
-			return "lps0 ms exit";
+		case ACPI_LPS0_SLEEP_ENTRY:
+			return "sleep entry";
+		case ACPI_LPS0_SLEEP_EXIT:
+			return "sleep exit";
 		}
 	} else {
 		switch (state) {
@@ -610,7 +610,7 @@ int acpi_s2idle_prepare_late(void)
 
 	if (lps0_dsm_func_mask_microsoft > 0) {
 		/* Modern Standby entry */
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_ENTRY,
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_ENTRY,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
@@ -663,7 +663,7 @@ void acpi_s2idle_restore_early(void)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 		/* Modern Standby exit */
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_EXIT,
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
 	}
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 25 Sep 2024 14:41:03 +0200
Subject: acpi/x86: s2idle: call Sleep Entry/Exit as part of callbacks

Move the Sleep Entry/Exit notifications outside the suspend sequence,
with their own ACPI lock, as was done for Display On/Off.

Suggested-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 57 ++++++++++++++++++++++++++++++++-------
 1 file changed, 47 insertions(+), 10 deletions(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 99e5f0938e53..b2c98f561e42 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -61,6 +61,7 @@ static guid_t lps0_dsm_guid_microsoft;
 static int lps0_dsm_func_mask_microsoft;
 static int lps0_dsm_state;
 static bool lps0_dsm_in_display_off;
+static bool lps0_dsm_in_sleep;
 
 /* Device constraint entry structure */
 struct lpi_device_info {
@@ -567,6 +568,48 @@ static int acpi_s2idle_display_off(void)
 	return 0;
 }
 
+static int acpi_s2idle_sleep_entry(void)
+{
+	if (!lps0_device_handle || sleep_no_lps0 || lps0_dsm_func_mask_microsoft <= 0)
+		return 0;
+
+	if (WARN_ON(lps0_dsm_in_sleep))
+		return -EINVAL;
+
+	lps0_dsm_in_sleep = true;
+	acpi_scan_lock_acquire();
+
+	/* Modern Standby Sleep Entry */
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_ENTRY,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	acpi_scan_lock_release();
+
+	return 0;
+}
+
+static int acpi_s2idle_sleep_exit(void)
+{
+	if (!lps0_device_handle || sleep_no_lps0 || lps0_dsm_func_mask_microsoft <= 0)
+		return 0;
+
+	if (WARN_ON(!lps0_dsm_in_sleep))
+		return -EINVAL;
+
+	lps0_dsm_in_sleep = false;
+	acpi_scan_lock_acquire();
+
+	/* Modern Standby Sleep Exit */
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_EXIT,
+				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+
+	acpi_scan_lock_release();
+
+	return 0;
+}
+
 static int acpi_s2idle_display_on(void)
 {
 	if (!lps0_device_handle || sleep_no_lps0)
@@ -608,13 +651,9 @@ int acpi_s2idle_prepare_late(void)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY_AMD,
 					lps0_dsm_func_mask, lps0_dsm_guid);
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
-		/* Modern Standby entry */
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_ENTRY,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	}
 
 	if (lps0_dsm_func_mask > 0 && !acpi_s2idle_vendor_amd())
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,
@@ -659,17 +698,14 @@ void acpi_s2idle_restore_early(void)
 					ACPI_LPS0_EXIT,
 					lps0_dsm_func_mask, lps0_dsm_guid);
 
-	if (lps0_dsm_func_mask_microsoft > 0) {
+	if (lps0_dsm_func_mask_microsoft > 0)
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,
 				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-		/* Modern Standby exit */
-		acpi_sleep_run_lps0_dsm(ACPI_LPS0_SLEEP_EXIT,
-				lps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);
-	}
 }
 
 static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
 	.display_off = acpi_s2idle_display_off,
+	.sleep_entry = acpi_s2idle_sleep_entry,
 	.begin = acpi_s2idle_begin,
 	.prepare = acpi_s2idle_prepare,
 	.prepare_late = acpi_s2idle_prepare_late,
@@ -678,6 +714,7 @@ static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
 	.restore_early = acpi_s2idle_restore_early,
 	.restore = acpi_s2idle_restore,
 	.end = acpi_s2idle_end,
+	.sleep_exit = acpi_s2idle_sleep_exit,
 	.display_on = acpi_s2idle_display_on,
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 17:26:46 +0100
Subject: acpi/x86: s2idle: add Turn On Display and call as part of callback

The Turn On Display callback was introduced in Windows 22H2, to allow
devices to resume faster from sleep. Essentially, if the device lowers
its power limit (PLx) while it is in the Sleep state, this might lengthen
the suspend sequence in an undesirable manner. Implement this callback,
which corresponds to Modern Standby Firmware notification (_DSM) 9.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index b2c98f561e42..2d097d020e3b 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -45,6 +45,7 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_EXIT		6
 #define ACPI_LPS0_SLEEP_ENTRY      7
 #define ACPI_LPS0_SLEEP_EXIT       8
+#define ACPI_LPS0_TURN_ON_DISPLAY  9
 
 /* AMD */
 #define ACPI_LPS0_DSM_UUID_AMD      "e3f32452-febc-43ce-9039-932122d37721"
@@ -375,6 +376,8 @@ static const char *acpi_sleep_dsm_state_to_str(unsigned int state)
 			return "sleep entry";
 		case ACPI_LPS0_SLEEP_EXIT:
 			return "sleep exit";
+		case ACPI_LPS0_TURN_ON_DISPLAY:
+			return "turn on display";
 		}
 	} else {
 		switch (state) {
@@ -589,6 +592,29 @@ static int acpi_s2idle_sleep_entry(void)
 	return 0;
 }
 
+static int acpi_s2idle_turn_on_display(void)
+{
+	if (!lps0_device_handle || sleep_no_lps0 ||
+	    lps0_dsm_func_mask_microsoft <= 0)
+		return 0;
+
+	/* This call is only valid while we are in a sleep state */
+	if (WARN_ON(!lps0_dsm_in_sleep))
+		return -EINVAL;
+
+	acpi_scan_lock_acquire();
+
+	/* Modern Standby Turn On Display */
+	if (lps0_dsm_func_mask_microsoft > 0)
+		acpi_sleep_run_lps0_dsm(ACPI_LPS0_TURN_ON_DISPLAY,
+					lps0_dsm_func_mask_microsoft,
+					lps0_dsm_guid_microsoft);
+
+	acpi_scan_lock_release();
+
+	return 0;
+}
+
 static int acpi_s2idle_sleep_exit(void)
 {
 	if (!lps0_device_handle || sleep_no_lps0 || lps0_dsm_func_mask_microsoft <= 0)
@@ -714,6 +740,7 @@ static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
 	.restore_early = acpi_s2idle_restore_early,
 	.restore = acpi_s2idle_restore,
 	.end = acpi_s2idle_end,
+	.turn_on_display = acpi_s2idle_turn_on_display,
 	.sleep_exit = acpi_s2idle_sleep_exit,
 	.display_on = acpi_s2idle_display_on,
 };
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 18:25:44 +0100
Subject: acpi/x86: s2idle: add quirk table for modern standby delays

Unfortunately, some modern standby systems, including the ROG Ally, rely
on a delay between modern standby transitions. Add a quirk table for
introducing delays between modern standby transitions, and quirk the
ROG Ally on "Display Off", which needs a bit of time to turn off its
controllers prior to suspending.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 62 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 62 insertions(+)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 2d097d020e3b..ba1a38d355a4 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -18,6 +18,7 @@
 #include <linux/acpi.h>
 #include <linux/device.h>
 #include <linux/dmi.h>
+#include <linux/delay.h>
 #include <linux/suspend.h>
 
 #include "../sleep.h"
@@ -91,11 +92,50 @@ struct lpi_device_constraint_amd {
 	int min_dstate;
 };
 
+struct s2idle_delay_quirks {
+	int delay_display_off;
+	int delay_sleep_entry;
+	int delay_sleep_exit;
+	int delay_display_on;
+};
+
+/*
+ * The ROG Ally series disconnects its controllers on Display Off and performs
+ * a fancy shutdown sequence, which requires around half a second to complete.
+ * If the power is cut earlier by entering it into D3, the original Ally unit
+ * might not disconnect its XInput MCU, causing excess battery drain, and the
+ * Ally X will make the controller restart post-suspend. In addition, the EC 
+ * of the device rarely (1/20 attempts) may get stuck asserting PROCHOT after 
+ * suspend (for various reasons), so split the delay between Display Off and
+ * Sleep Entry.
+ */
+static const struct s2idle_delay_quirks rog_ally_quirks = {
+	.delay_display_off = 350,
+	.delay_sleep_entry = 150,
+};
+
+static const struct dmi_system_id s2idle_delay_quirks[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
+		},
+		.driver_data = (void *)&rog_ally_quirks
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
+		},
+		.driver_data = (void *)&rog_ally_quirks
+	},
+	{}
+};
+
 static LIST_HEAD(lps0_s2idle_devops_head);
 
 static struct lpi_constraints *lpi_constraints_table;
 static int lpi_constraints_table_size;
 static int rev_id;
+struct s2idle_delay_quirks *delay_quirks;
 
 #define for_each_lpi_constraint(entry)						\
 	for (int i = 0;								\
@@ -462,6 +502,8 @@ static const struct acpi_device_id amd_hid_ids[] = {
 static int lps0_device_attach(struct acpi_device *adev,
 			      const struct acpi_device_id *not_used)
 {
+	unsigned int sleep_flags;
+
 	if (lps0_device_handle)
 		return 0;
 
@@ -536,6 +578,12 @@ static int lps0_device_attach(struct acpi_device *adev,
 	 */
 	acpi_ec_mark_gpe_for_wake();
 
+	sleep_flags = lock_system_sleep();
+	const struct dmi_system_id *s2idle_sysid =
+		dmi_first_match(s2idle_delay_quirks);
+	delay_quirks = s2idle_sysid ? s2idle_sysid->driver_data : NULL;
+	unlock_system_sleep(sleep_flags);
+
 	return 0;
 }
 
@@ -568,6 +616,9 @@ static int acpi_s2idle_display_off(void)
 
 	acpi_scan_lock_release();
 
+	if (delay_quirks && delay_quirks->delay_display_off)
+		msleep(delay_quirks->delay_display_off);
+
 	return 0;
 }
 
@@ -589,6 +640,9 @@ static int acpi_s2idle_sleep_entry(void)
 
 	acpi_scan_lock_release();
 
+	if (delay_quirks && delay_quirks->delay_sleep_entry)
+		msleep(delay_quirks->delay_sleep_entry);
+
 	return 0;
 }
 
@@ -624,6 +678,10 @@ static int acpi_s2idle_sleep_exit(void)
 		return -EINVAL;
 
 	lps0_dsm_in_sleep = false;
+
+	if (delay_quirks && delay_quirks->delay_sleep_exit)
+		msleep(delay_quirks->delay_sleep_exit);
+
 	acpi_scan_lock_acquire();
 
 	/* Modern Standby Sleep Exit */
@@ -645,6 +703,10 @@ static int acpi_s2idle_display_on(void)
 		return -EINVAL;
 
 	lps0_dsm_in_display_off = false;
+
+	if (delay_quirks && delay_quirks->delay_display_on)
+		msleep(delay_quirks->delay_display_on);
+
 	acpi_scan_lock_acquire();
 
 	/* Display on */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 31 Jan 2025 17:05:49 +0100
Subject: acpi/x86: s2idle: Add AC/DC burst wakeup support

According to Microsoft, when a power capable dock/charger is
attached/detached to the device, the SOC is expected to wake up.
Further, when the event is a connection to AC, the display of the
system is expected to turn on for five seconds.

The absence of this feature causes an issue where the original Ally
unit will get stuck in prochot.

Add the ability for s2idle to wake up the system from sleep on adapter
changes when s2idle is set as a wakeup source.

Co-developed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 35 ++++++++++++++++++++++++++++++++++-
 1 file changed, 34 insertions(+), 1 deletion(-)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index ba1a38d355a4..343d960df04b 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -19,6 +19,7 @@
 #include <linux/device.h>
 #include <linux/dmi.h>
 #include <linux/delay.h>
+#include <linux/power_supply.h>
 #include <linux/suspend.h>
 
 #include "../sleep.h"
@@ -55,6 +56,7 @@ static const struct acpi_device_id lps0_device_ids[] = {
 #define ACPI_LPS0_DISPLAY_OFF_AMD   4
 #define ACPI_LPS0_DISPLAY_ON_AMD    5
 
+static struct acpi_device *lps0_device;
 static acpi_handle lps0_device_handle;
 static guid_t lps0_dsm_guid;
 static int lps0_dsm_func_mask;
@@ -64,6 +66,7 @@ static int lps0_dsm_func_mask_microsoft;
 static int lps0_dsm_state;
 static bool lps0_dsm_in_display_off;
 static bool lps0_dsm_in_sleep;
+static int lps0_ac_state;
 
 /* Device constraint entry structure */
 struct lpi_device_info {
@@ -97,6 +100,7 @@ struct s2idle_delay_quirks {
 	int delay_sleep_entry;
 	int delay_sleep_exit;
 	int delay_display_on;
+	bool wake_on_ac;
 };
 
 /*
@@ -115,6 +119,7 @@ static const struct s2idle_delay_quirks rog_ally_quirks = {
 };
 
 static const struct dmi_system_id s2idle_delay_quirks[] = {
+	/* ROG Ally */
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
@@ -554,6 +559,8 @@ static int lps0_device_attach(struct acpi_device *adev,
 		return 0; //function evaluation failed
 
 	lps0_device_handle = adev->handle;
+	lps0_device = adev;
+	device_set_wakeup_capable(&adev->dev, true);
 
 	if (acpi_s2idle_vendor_amd())
 		lpi_device_get_constraints_amd();
@@ -582,6 +589,8 @@ static int lps0_device_attach(struct acpi_device *adev,
 	const struct dmi_system_id *s2idle_sysid =
 		dmi_first_match(s2idle_delay_quirks);
 	delay_quirks = s2idle_sysid ? s2idle_sysid->driver_data : NULL;
+	if (delay_quirks && delay_quirks->wake_on_ac)
+		device_set_wakeup_enable(&lps0_device->dev, true);
 	unlock_system_sleep(sleep_flags);
 
 	return 0;
@@ -724,6 +733,26 @@ static int acpi_s2idle_display_on(void)
 	return 0;
 }
 
+static void acpi_s2idle_check_ac(void)
+{
+	/* if configured, wake system from AC adapter changes */
+	if (device_may_wakeup(&lps0_device->dev) &&
+	    power_supply_is_system_supplied() != lps0_ac_state) {
+		if (pm_debug_messages_on)
+			acpi_handle_info(lps0_device_handle,
+					 "AC adapter state changed\n");
+		acpi_pm_wakeup_event(&lps0_device->dev);
+	}
+}
+
+static int acpi_s2idle_begin_wrap(void)
+{
+	/* capture AC adapter state */
+	lps0_ac_state = power_supply_is_system_supplied();
+
+	return acpi_s2idle_begin();
+}
+
 int acpi_s2idle_prepare_late(void)
 {
 	struct acpi_s2idle_dev_ops *handler;
@@ -734,6 +763,8 @@ int acpi_s2idle_prepare_late(void)
 	if (pm_debug_messages_on)
 		lpi_check_constraints();
 
+	acpi_s2idle_check_ac();
+
 	/* LPS0 entry */
 	if (lps0_dsm_func_mask > 0 && acpi_s2idle_vendor_amd())
 		acpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY_AMD,
@@ -766,6 +797,8 @@ void acpi_s2idle_check(void)
 		if (handler->check)
 			handler->check();
 	}
+
+	acpi_s2idle_check_ac();
 }
 
 void acpi_s2idle_restore_early(void)
@@ -794,7 +827,7 @@ void acpi_s2idle_restore_early(void)
 static const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {
 	.display_off = acpi_s2idle_display_off,
 	.sleep_entry = acpi_s2idle_sleep_entry,
-	.begin = acpi_s2idle_begin,
+	.begin = acpi_s2idle_begin_wrap,
 	.prepare = acpi_s2idle_prepare,
 	.prepare_late = acpi_s2idle_prepare_late,
 	.check = acpi_s2idle_check,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 4 Feb 2025 20:54:42 +0100
Subject: acpi/x86: s2idle: allow adding a delay before suspend sequence

Some devices that draw a lot of power before sleep might have trouble
with a fast transition to sleep which can cause their APU to enter
an invalid state. Add a bit of delay after freezing userspace which
to allow power draw to lower before beginning the suspend sequence.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 343d960df04b..86adad4a7f25 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -100,6 +100,7 @@ struct s2idle_delay_quirks {
 	int delay_sleep_entry;
 	int delay_sleep_exit;
 	int delay_display_on;
+	int delay_begin;
 	bool wake_on_ac;
 };
 
@@ -118,6 +119,10 @@ static const struct s2idle_delay_quirks rog_ally_quirks = {
 	.delay_sleep_entry = 150,
 };
 
+static const struct s2idle_delay_quirks legion_go_s_quirks = {
+	.delay_begin = 500,
+};
+
 static const struct dmi_system_id s2idle_delay_quirks[] = {
 	/* ROG Ally */
 	{
@@ -132,6 +137,31 @@ static const struct dmi_system_id s2idle_delay_quirks[] = {
 		},
 		.driver_data = (void *)&rog_ally_quirks
 	},
+	/* Legion Go S */
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "83L3"),
+		},
+		.driver_data = (void *)&legion_go_s_quirks
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "83N6"),
+		},
+		.driver_data = (void *)&legion_go_s_quirks
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "83Q2"),
+		},
+		.driver_data = (void *)&legion_go_s_quirks
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_PRODUCT_NAME, "83Q3"),
+		},
+		.driver_data = (void *)&legion_go_s_quirks
+	},
 	{}
 };
 
@@ -750,6 +780,10 @@ static int acpi_s2idle_begin_wrap(void)
 	/* capture AC adapter state */
 	lps0_ac_state = power_supply_is_system_supplied();
 
+	/* Add a bit of delay to let TDP come down after userspace freeze */
+	if (delay_quirks && delay_quirks->delay_begin)
+		msleep(delay_quirks->delay_begin);
+
 	return acpi_s2idle_begin();
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 19 Sep 2024 00:29:59 +0200
Subject: platform/x86: asus-wmi: remove Ally (1st gen) and Ally X suspend
 quirk

By moving the Display On/Off calls outside of the suspend sequence and
introducing a slight delay after Display Off, the ROG Ally controller
functions exactly as it does in Windows.

Therefore, remove the quirk that fixed the controller only when the
mcu_powersave attribute was disabled, while adding a large amount of
delay to the suspend and wake process.

Reviewed-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/asus-wmi.c | 54 ---------------------------------
 1 file changed, 54 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 2bccb28d8e41..0d1c07226c7b 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -139,29 +139,10 @@ module_param(fnlock_default, bool, 0444);
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
-#define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
-
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
 static int throttle_thermal_policy_write(struct asus_wmi *);
 
-static const struct dmi_system_id asus_ally_mcu_quirk[] = {
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC71L"),
-		},
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_NAME, "RC72L"),
-		},
-	},
-	{ },
-};
-
 static bool ashs_present(void)
 {
 	int i = 0;
@@ -275,9 +256,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -4924,8 +4902,6 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
 	asus->oobe_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_OOBE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-						&& dmi_check_system(asus_ally_mcu_quirk);
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -5112,34 +5088,6 @@ static int asus_hotk_resume(struct device *device)
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -5191,8 +5139,6 @@ static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
-	.prepare = asus_hotk_prepare,
 };
 
 /* Registration ***************************************************************/
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 25 Jan 2025 16:49:52 +0100
Subject: PM: hibernate: Enter s2idle sleep state before hibernation

Windows enters the s2idle screen_off state before hibernation, which
turns off e.g., the keyboard light and in some devices pulses the
suspend light. It may also turn off auxiliaries prior to hibernation.
These auxiliaries are 1) not used to maintain the swap of the system
and 2) can misbehave during the wake-ups in hibernation.

One example is the OneXPlayer X1 controller, which will have its
vibration motor stuck on, if it is not first deactivated by entering
the sleep state.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 kernel/power/hibernate.c | 28 +++++++++++++++++++++++++++-
 1 file changed, 27 insertions(+), 1 deletion(-)

diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index 26e0e662e8f2..433b50555f35 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -787,6 +787,10 @@ int hibernate(void)
 	bool snapshot_test = false;
 	unsigned int sleep_flags;
 	int error;
+	bool powered_down = false;
+#ifdef CONFIG_SUSPEND
+	standby_state_t previous_standby;
+#endif
 
 	if (!hibernation_available()) {
 		pm_pr_dbg("Hibernation not available.\n");
@@ -812,6 +816,13 @@ int hibernate(void)
 	}
 
 	pr_info("hibernation entry\n");
+
+#if CONFIG_SUSPEND
+	/* Correct state to enter hibernation is screen_off. */ 
+	previous_standby = pm_standby_state();
+	pm_standby_transition(PM_STANDBY_SCREEN_OFF, false);
+#endif
+
 	pm_prepare_console();
 	error = pm_notifier_call_chain_robust(PM_HIBERNATION_PREPARE, PM_POST_HIBERNATION);
 	if (error)
@@ -864,8 +875,10 @@ int hibernate(void)
 		if (!error) {
 			if (hibernation_mode == HIBERNATION_TEST_RESUME)
 				snapshot_test = true;
-			else
+			else {
+				powered_down = true;
 				power_down();
+			}
 		}
 		in_suspend = 0;
 		pm_restore_gfp_mask();
@@ -891,6 +904,19 @@ int hibernate(void)
 	filesystems_thaw();
 	pm_notifier_call_chain(PM_POST_HIBERNATION);
  Restore:
+#if CONFIG_SUSPEND
+	/*
+	 * If we powered down, system will restore to the active state but
+	 * the suspend module will remember the previous state so we need
+	 * to sync it. If the hibernation fails or we performed a snapshot
+	 * test, we need to restore userspace's standby state.
+	 */
+	if (powered_down)
+		pm_standby_transition(PM_STANDBY_ACTIVE, true);
+	else
+		pm_standby_transition(previous_standby, false);
+#endif
+
 	pm_restore_console();
 	hibernate_release();
  Unlock:
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 15 Nov 2024 20:16:02 +0100
Subject: PM: standby: Add sysfs attribute for modern standby transitions

Add a sysfs attribute to allow informing the kernel about the current
standby state, those being: "active", "screen_off", "sleep", and
"resume" (to prepare turning the display on). The final modern
standby state DRIPS is omitted, as that is entered during the kernel
suspend process and userspace will never see it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 kernel/power/main.c | 82 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 82 insertions(+)

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 3cf2d7e72567..d866259f64af 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -761,6 +761,87 @@ static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,
 
 power_attr(state);
 
+#ifdef CONFIG_SUSPEND
+/*
+ * standby - control system s2idle standby state.
+ *
+ * show() returns available standby states, which may be "active", "screen_off",
+ * "sleep" and "resume" (still in sleep but preparing to turn on display).
+ * See Documentation/admin-guide/pm/standby-states.rst for a description of
+ * what they mean.
+ *
+ * store() accepts one of those strings, translates it into the proper
+ * enumerated value, and initiates a transition to that standby state.
+ * 
+ * When the system suspends, it will first enter the state "sleep", suspend,
+ * and then restore the last state before entering "sleep". I.e., if userspace 
+ * is not S0ix-aware, the transitions expected by Modern Standby devices will 
+ * always be performed.
+ */
+static ssize_t standby_show(struct kobject *kobj, struct kobj_attribute *attr,
+			  char *buf)
+{
+	unsigned int sleep_flags;
+	char *s = buf;
+	standby_state_t i;
+	
+	sleep_flags = lock_system_sleep();
+	standby_state_t curr = pm_standby_state();
+	unlock_system_sleep(sleep_flags);
+
+	if (curr < 0)
+		return -EBUSY;
+
+	for (i = PM_STANDBY_MIN; i < PM_STANDBY_MAX; i++)
+		if (standby_states[i])
+			s += sprintf(s, curr == i ? "[%s] ": "%s ", standby_states[i]);
+
+	if (s != buf)
+		/* convert the last space to a newline */
+		*(s - 1) = '\n';
+	return (s - buf);
+}
+
+static standby_state_t decode_standby_state(const char *buf, size_t n)
+{
+	standby_state_t state;
+	char *p;
+	int len;
+
+	p = memchr(buf, '\n', n);
+	len = p ? p - buf : n;
+
+	for (state = PM_STANDBY_MIN; state < PM_STANDBY_MAX; state++) {
+		const char *label = standby_states[state];
+
+		if (label && len == strlen(label) && !strncmp(buf, label, len))
+			return state;
+	}
+
+	return PM_STANDBY_MAX;
+}
+
+static ssize_t standby_store(struct kobject *kobj, struct kobj_attribute *attr,
+			   const char *buf, size_t n)
+{
+	unsigned int sleep_flags;
+	standby_state_t state;
+
+	state = decode_standby_state(buf, n);
+
+	if (state >= PM_STANDBY_MAX)
+		return -EINVAL;
+
+	sleep_flags = lock_system_sleep();
+	int error = pm_standby_transition(state, false);
+	unlock_system_sleep(sleep_flags);
+	
+	return error ? error : n;
+}
+
+power_attr(standby);
+#endif
+
 #ifdef CONFIG_PM_SLEEP
 /*
  * The 'wakeup_count' attribute, along with the functions defined in
@@ -1015,6 +1096,7 @@ static struct attribute * g[] = {
 #ifdef CONFIG_SUSPEND
 	&mem_sleep_attr.attr,
 	&sync_on_suspend_attr.attr,
+	&standby_attr.attr,
 #endif
 #ifdef CONFIG_PM_AUTOSLEEP
 	&autosleep_attr.attr,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Jan 2025 22:15:15 +0100
Subject: [HACK] ACPI: s2idle: Trigger _WAK as part of exiting s2idle

Certain OneXPlayer and GPD devices contain a hibernation feature where
the EC wakes up the device and pretends to overheat, causing Windows to
hibernate. This is a three part process, where after the device enters
S2idle through calling any _DSM callback (e.g., Sleep Entry, LPS0
Entry), they begin a counter that measures how much battery is drained.
Once it is at 5%, the EC of the device wakes it up if its in LPS0 by
pressing the powerbutton, and once it is in Modern Standby again, it
triggers the overheat event.

For some reason, this notification is missed in Linux after wake-up.
So call _WAK when exiting s2idle, which sets OSFG to 1 and has the
EC resend overheat notification by triggering Query 0x58.

The three OXP devices have no side effects, they only set OSFG. For
GPD, we do S3, which has also sets some other variables.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/sleep.c | 59 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 59 insertions(+)

diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c
index c8ee8e42b0f6..7671f3140145 100644
--- a/drivers/acpi/sleep.c
+++ b/drivers/acpi/sleep.c
@@ -810,8 +810,56 @@ bool acpi_s2idle_wake(void)
 	return false;
 }
 
+static const struct dmi_system_id dmi_table_wak[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1 A"),
+		},
+		.driver_data = (void *)ACPI_STATE_S0,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1 i"),
+		},
+		.driver_data = (void *)ACPI_STATE_S0,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1Pro"),
+		},
+		.driver_data = (void *)ACPI_STATE_S0,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1 mini"),
+		},
+		.driver_data = (void *)ACPI_STATE_S0,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-04"),
+		},
+		.driver_data = (void *)ACPI_STATE_S3,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-05"),
+		},
+		.driver_data = (void *)ACPI_STATE_S3,
+	},
+	{} /* Terminating entry */
+};
+
 void acpi_s2idle_restore(void)
 {
+	const struct dmi_system_id *wak_entry;
+
 	/*
 	 * Drain pending events before restoring the working-state configuration
 	 * of GPEs.
@@ -825,6 +873,17 @@ void acpi_s2idle_restore(void)
 	acpi_enable_all_runtime_gpes();
 
 	acpi_disable_wakeup_devices(ACPI_STATE_S0);
+	wak_entry = dmi_first_match(dmi_table_wak);
+	if (wak_entry) {
+		/*
+		 * Force _WAK to run so that OSFG is set to 1 and the EC
+		 * re-enumerates. GPD Win Max 2 needs to exit S3 which also has
+		 * other side effects. OXP devices run the outer loop with s0.
+		 */
+		pr_info("Executing _WAK for state S%d\n",
+			(u8)(uintptr_t) wak_entry->driver_data);
+		acpi_leave_sleep_state((u8)(uintptr_t) wak_entry->driver_data);
+	}
 
 	if (acpi_sci_irq_valid()) {
 		acpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Armin Wolf <W_Armin@gmx.de>
Date: Sun, 11 May 2025 22:44:18 +0200
Subject: platform/x86: msi-wmi-platform: Use input buffer for returning result

Modify msi_wmi_platform_query() to reuse the input buffer for
returning the result of a WMI method call. Using a separate output
buffer to return the result is unnecessary because the WMI interface
requires both buffers to have the same length anyway.

Co-developed-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 53 ++++++++++++-------------
 1 file changed, 26 insertions(+), 27 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index dc5e9878cb68..41218a9d6e35 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -21,6 +21,7 @@
 #include <linux/mutex.h>
 #include <linux/printk.h>
 #include <linux/rwsem.h>
+#include <linux/string.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
 
@@ -140,19 +141,19 @@ static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, siz
 }
 
 static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
-				  enum msi_wmi_platform_method method, u8 *input,
-				  size_t input_length, u8 *output, size_t output_length)
+				  enum msi_wmi_platform_method method, u8 *buffer,
+				  size_t length)
 {
 	struct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };
 	struct acpi_buffer in = {
-		.length = input_length,
-		.pointer = input
+		.length = length,
+		.pointer = buffer
 	};
 	union acpi_object *obj;
 	acpi_status status;
 	int ret;
 
-	if (!input_length || !output_length)
+	if (!length)
 		return -EINVAL;
 
 	/*
@@ -169,7 +170,7 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	if (!obj)
 		return -ENODATA;
 
-	ret = msi_wmi_platform_parse_buffer(obj, output, output_length);
+	ret = msi_wmi_platform_parse_buffer(obj, buffer, length);
 	kfree(obj);
 
 	return ret;
@@ -185,17 +186,15 @@ static int msi_wmi_platform_read(struct device *dev, enum hwmon_sensor_types typ
 				 int channel, long *val)
 {
 	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	u16 value;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buf, sizeof(buf));
 	if (ret < 0)
 		return ret;
 
-	value = get_unaligned_be16(&output[channel * 2 + 1]);
+	value = get_unaligned_be16(&buffer[channel * 2 + 1]);
 	if (!value)
 		*val = 0;
 	else
@@ -245,13 +244,17 @@ static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input,
 		return ret;
 
 	down_write(&data->buffer_lock);
-	ret = msi_wmi_platform_query(data->data, data->method, payload, data->length, data->buffer,
+	ret = msi_wmi_platform_query(data->data, data->method, data->buffer,
 				     data->length);
 	up_write(&data->buffer_lock);
 
 	if (ret < 0)
 		return ret;
 
+	down_write(&data->buffer_lock);
+	memcpy(data->buffer, payload, data->length);
+	up_write(&data->buffer_lock);
+
 	return length;
 }
 
@@ -348,23 +351,21 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 
 static int msi_wmi_platform_ec_init(struct msi_wmi_platform_data *data)
 {
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	u8 flags;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_EC, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_EC, buffer, sizeof(buffer));
 	if (ret < 0)
 		return ret;
 
-	flags = output[MSI_PLATFORM_EC_FLAGS_OFFSET];
+	flags = buffer[MSI_PLATFORM_EC_FLAGS_OFFSET];
 
 	dev_dbg(&data->wdev->dev, "EC RAM version %lu.%lu\n",
 		FIELD_GET(MSI_PLATFORM_EC_MAJOR_MASK, flags),
 		FIELD_GET(MSI_PLATFORM_EC_MINOR_MASK, flags));
 	dev_dbg(&data->wdev->dev, "EC firmware version %.28s\n",
-		&output[MSI_PLATFORM_EC_VERSION_OFFSET]);
+		&buffer[MSI_PLATFORM_EC_VERSION_OFFSET]);
 
 	if (!(flags & MSI_PLATFORM_EC_IS_TIGERLAKE)) {
 		if (!force)
@@ -378,27 +379,25 @@ static int msi_wmi_platform_ec_init(struct msi_wmi_platform_data *data)
 
 static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 {
-	u8 input[32] = { 0 };
-	u8 output[32];
+	u8 buffer[32] = { 0 };
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_WMI, input, sizeof(input), output,
-				     sizeof(output));
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_WMI, buffer, sizeof(buffer));
 	if (ret < 0)
 		return ret;
 
 	dev_dbg(&data->wdev->dev, "WMI interface version %u.%u\n",
-		output[MSI_PLATFORM_WMI_MAJOR_OFFSET],
-		output[MSI_PLATFORM_WMI_MINOR_OFFSET]);
+		buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET],
+		buffer[MSI_PLATFORM_WMI_MINOR_OFFSET]);
 
-	if (output[MSI_PLATFORM_WMI_MAJOR_OFFSET] != MSI_WMI_PLATFORM_INTERFACE_VERSION) {
+	if (buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET] != MSI_WMI_PLATFORM_INTERFACE_VERSION) {
 		if (!force)
 			return -ENODEV;
 
 		dev_warn(&data->wdev->dev,
 			 "Loading despite unsupported WMI interface version (%u.%u)\n",
-			 output[MSI_PLATFORM_WMI_MAJOR_OFFSET],
-			 output[MSI_PLATFORM_WMI_MINOR_OFFSET]);
+			 buffer[MSI_PLATFORM_WMI_MAJOR_OFFSET],
+			 buffer[MSI_PLATFORM_WMI_MINOR_OFFSET]);
 	}
 
 	return 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:19 +0200
Subject: platform/x86: msi-wmi-platform: Add unlocked msi_wmi_platform_query

This driver requires to be able to handle transactions that perform
multiple WMI actions at a time. Therefore, it needs to be able to
lock the wmi_lock mutex for multiple operations.

Add msi_wmi_platform_query_unlocked() to allow the caller to
perform the WMI query without locking the wmi_lock mutex, by
renaming the existing function and adding a new one that only
locks the mutex.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 27 ++++++++++++++++---------
 1 file changed, 17 insertions(+), 10 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 41218a9d6e35..f0d1b8e1a2fe 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -140,7 +140,7 @@ static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, siz
 	return 0;
 }
 
-static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
+static int msi_wmi_platform_query_unlocked(struct msi_wmi_platform_data *data,
 				  enum msi_wmi_platform_method method, u8 *buffer,
 				  size_t length)
 {
@@ -156,15 +156,9 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	if (!length)
 		return -EINVAL;
 
-	/*
-	 * The ACPI control method responsible for handling the WMI method calls
-	 * is not thread-safe. Because of this we have to do the locking ourself.
-	 */
-	scoped_guard(mutex, &data->wmi_lock) {
-		status = wmidev_evaluate_method(data->wdev, 0x0, method, &in, &out);
-		if (ACPI_FAILURE(status))
-			return -EIO;
-	}
+	status = wmidev_evaluate_method(data->wdev, 0x0, method, &in, &out);
+	if (ACPI_FAILURE(status))
+		return -EIO;
 
 	obj = out.pointer;
 	if (!obj)
@@ -176,6 +170,19 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	return ret;
 }
 
+static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
+				  enum msi_wmi_platform_method method, u8 *buffer,
+				  size_t length)
+{
+	/*
+	 * The ACPI control method responsible for handling the WMI method calls
+	 * is not thread-safe. Because of this we have to do the locking ourself.
+	 */
+	scoped_guard(mutex, &data->wmi_lock) {
+		return msi_wmi_platform_query_unlocked(data, method, buffer, length);
+	}
+}
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:20 +0200
Subject: platform/x86: msi-wmi-platform: Add quirk system

MSI uses the WMI interface as a passthrough for writes to the EC
and uses a board name match and a quirk table from userspace on
Windows. Therefore, there is no auto-detection functionality and
we have to fallback to a quirk table.

Introduce it here, prior to starting to add features to it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 55 +++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index f0d1b8e1a2fe..5a9a10037387 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -14,6 +14,7 @@
 #include <linux/debugfs.h>
 #include <linux/device.h>
 #include <linux/device/driver.h>
+#include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/hwmon.h>
 #include <linux/kernel.h>
@@ -79,8 +80,12 @@ enum msi_wmi_platform_method {
 	MSI_PLATFORM_GET_WMI		= 0x1d,
 };
 
+struct msi_wmi_platform_quirk {
+};
+
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
+	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 };
 
@@ -124,6 +129,49 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 	"get_wmi"
 };
 
+static struct msi_wmi_platform_quirk quirk_default = {};
+static struct msi_wmi_platform_quirk quirk_gen1 = {
+};
+static struct msi_wmi_platform_quirk quirk_gen2 = {
+};
+static struct msi_wmi_platform_quirk quirk_amd = {
+};
+
+static const struct dmi_system_id msi_quirks[] = {
+	{
+		.ident = "MSI Claw (gen 1)",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T41"),
+		},
+		.driver_data = &quirk_gen1,
+	},
+	{
+		.ident = "MSI Claw AI+ 7",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T42"),
+		},
+		.driver_data = &quirk_gen2,
+	},
+	{
+		.ident = "MSI Claw AI+ 8",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T52"),
+		},
+		.driver_data = &quirk_gen2,
+	},
+	{
+		.ident = "MSI Claw A8",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T8K"),
+		},
+		.driver_data = &quirk_amd,
+	},
+};
+
 static int msi_wmi_platform_parse_buffer(union acpi_object *obj, u8 *output, size_t length)
 {
 	if (obj->type != ACPI_TYPE_BUFFER)
@@ -413,6 +461,7 @@ static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 {
 	struct msi_wmi_platform_data *data;
+	const struct dmi_system_id *dmi_id;
 	int ret;
 
 	data = devm_kzalloc(&wdev->dev, sizeof(*data), GFP_KERNEL);
@@ -422,6 +471,12 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	data->wdev = wdev;
 	dev_set_drvdata(&wdev->dev, data);
 
+	dmi_id = dmi_first_match(msi_quirks);
+	if (dmi_id)
+		data->quirks = dmi_id->driver_data;
+	else
+		data->quirks = &quirk_default;
+
 	ret = devm_mutex_init(&wdev->dev, &data->wmi_lock);
 	if (ret < 0)
 		return ret;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Armin Wolf <W_Armin@gmx.de>
Date: Sun, 11 May 2025 22:44:21 +0200
Subject: platform/x86: msi-wmi-platform: Add support for fan control

Adds fan curve support for the MSI platform. These devices contain
support for two fans, where they are named CPU and GPU but in the
case of the Claw series just map to left and right fan.

Co-developed-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../wmi/devices/msi-wmi-platform.rst          |  26 ++
 drivers/platform/x86/msi-wmi-platform.c       | 328 +++++++++++++++++-
 2 files changed, 337 insertions(+), 17 deletions(-)

diff --git a/Documentation/wmi/devices/msi-wmi-platform.rst b/Documentation/wmi/devices/msi-wmi-platform.rst
index 73197b31926a..704bfdac5203 100644
--- a/Documentation/wmi/devices/msi-wmi-platform.rst
+++ b/Documentation/wmi/devices/msi-wmi-platform.rst
@@ -169,6 +169,32 @@ The fan RPM readings can be calculated with the following formula:
 
 If the fan speed reading is zero, then the fan RPM is zero too.
 
+The subfeature ``0x01`` is used to retrieve the fan speed table for the CPU fan. The output
+data contains the fan speed table and two bytes with unknown data. The fan speed table
+consists of six 8-bit entries, each containing a fan speed value in percent.
+
+The subfeature ``0x02`` is used tho retrieve the same data for the GPU fan.
+
+WMI method Set_Fan()
+--------------------
+
+The fan speed tables can be accessed using subfeature ``0x01`` (CPU fan) and subfeature ``0x02``
+(GPU fan). The input data has the same format as the output data of the ``Get_Fan`` WMI method.
+
+WMI method Get_AP()
+-------------------
+
+The current fan mode can be accessed using subfeature ``0x01``. The output data contains a flag
+byte and two bytes of unknown data. If the 7th bit inside the flag byte is cleared then all fans
+are operating in automatic mode, otherwise the fans operate based on the fan speed tables
+accessible thru the ``Get_Fan``/``Set_Fan`` WMI methods.
+
+WMI method Set_AP()
+-------------------
+
+The current fan mode can be changed using subfeature ``0x01``. The input data has the same format
+as the output data of the ``Get_AP`` WMI method.
+
 WMI method Get_WMI()
 --------------------
 
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 5a9a10037387..b9f8ace23b8e 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -16,13 +16,18 @@
 #include <linux/device/driver.h>
 #include <linux/dmi.h>
 #include <linux/errno.h>
+#include <linux/fixp-arith.h>
 #include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
 #include <linux/kernel.h>
+#include <linux/kstrtox.h>
+#include <linux/minmax.h>
 #include <linux/module.h>
 #include <linux/mutex.h>
 #include <linux/printk.h>
 #include <linux/rwsem.h>
 #include <linux/string.h>
+#include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
 
@@ -34,9 +39,11 @@
 
 #define MSI_WMI_PLATFORM_INTERFACE_VERSION	2
 
+/* Get_WMI() WMI method */
 #define MSI_PLATFORM_WMI_MAJOR_OFFSET	1
 #define MSI_PLATFORM_WMI_MINOR_OFFSET	2
 
+/* Get_EC() and Set_EC() WMI methods */
 #define MSI_PLATFORM_EC_FLAGS_OFFSET	1
 #define MSI_PLATFORM_EC_MINOR_MASK	GENMASK(3, 0)
 #define MSI_PLATFORM_EC_MAJOR_MASK	GENMASK(5, 4)
@@ -44,6 +51,18 @@
 #define MSI_PLATFORM_EC_IS_TIGERLAKE	BIT(7)
 #define MSI_PLATFORM_EC_VERSION_OFFSET	2
 
+/* Get_Fan() and Set_Fan() WMI methods */
+#define MSI_PLATFORM_FAN_SUBFEATURE_FAN_SPEED		0x0
+#define MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE	0x1
+#define MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE	0x2
+#define MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE	0x1
+#define MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE	0x2
+
+/* Get_AP() and Set_AP() WMI methods */
+#define MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE	0x1
+#define MSI_PLATFORM_AP_FAN_FLAGS_OFFSET	1
+#define MSI_PLATFORM_AP_ENABLE_FAN_TABLES	BIT(7)
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -231,9 +250,201 @@ static int msi_wmi_platform_query(struct msi_wmi_platform_data *data,
 	}
 }
 
+static ssize_t msi_wmi_platform_fan_table_show(struct device *dev, struct device_attribute *attr,
+					       char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	u8 fan_percent;
+	int ret;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	fan_percent = buffer[sattr->index + 1];
+	if (fan_percent > 100)
+		return -EIO;
+
+	return sysfs_emit(buf, "%d\n", fixp_linear_interpolate(0, 0, 100, 255, fan_percent));
+}
+
+static ssize_t msi_wmi_platform_fan_table_store(struct device *dev, struct device_attribute *attr,
+						const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	long speed;
+	int ret;
+
+	ret = kstrtol(buf, 10, &speed);
+	if (ret < 0)
+		return ret;
+
+	speed = clamp_val(speed, 0, 255);
+
+	guard(mutex)(&data->wmi_lock);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_GET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	buffer[0] = sattr->nr;
+	buffer[sattr->index + 1] = fixp_linear_interpolate(0, 0, 255, 100, speed);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t msi_wmi_platform_temp_table_show(struct device *dev, struct device_attribute *attr,
+						char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	u8 temp_c;
+	int ret;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_TEMPERATURE,
+				     buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	temp_c = buffer[sattr->index + 1];
+
+	return sysfs_emit(buf, "%d\n", temp_c);
+}
+
+static ssize_t msi_wmi_platform_temp_table_store(struct device *dev, struct device_attribute *attr,
+						 const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { sattr->nr };
+	long temp_c;
+	int ret;
+
+	ret = kstrtol(buf, 10, &temp_c);
+	if (ret < 0)
+		return ret;
+
+	temp_c = clamp_val(temp_c, 0, 255);
+
+	guard(mutex)(&data->wmi_lock);
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_GET_TEMPERATURE,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	buffer[0] = sattr->nr;
+	buffer[sattr->index + 1] = temp_c;
+
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_TEMPERATURE,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x0);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x6);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE, 0x7);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point1_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x1);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point2_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x2);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point3_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point4_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point5_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm1_auto_point6_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE, 0x6);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x0);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x6);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_temp, msi_wmi_platform_temp_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE, 0x7);
+
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point1_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x1);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point2_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x2);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point3_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x3);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point4_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x4);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point5_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x5);
+static SENSOR_DEVICE_ATTR_2_RW(pwm2_auto_point6_pwm, msi_wmi_platform_fan_table,
+			       MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE, 0x6);
+
+static struct attribute *msi_wmi_platform_hwmon_attrs[] = {
+	&sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point6_temp.dev_attr.attr,
+
+	&sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm1_auto_point6_pwm.dev_attr.attr,
+
+	&sensor_dev_attr_pwm2_auto_point1_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point2_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point3_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point4_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point5_temp.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point6_temp.dev_attr.attr,
+
+	&sensor_dev_attr_pwm2_auto_point1_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point2_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point3_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point4_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point5_pwm.dev_attr.attr,
+	&sensor_dev_attr_pwm2_auto_point6_pwm.dev_attr.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(msi_wmi_platform_hwmon);
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
+	if (type == hwmon_pwm && attr == hwmon_pwm_enable)
+		return 0644;
+
 	return 0444;
 }
 
@@ -243,24 +454,102 @@ static int msi_wmi_platform_read(struct device *dev, enum hwmon_sensor_types typ
 	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
 	u8 buffer[32] = { 0 };
 	u16 value;
+	u8 flags;
 	int ret;
 
-	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buf, sizeof(buf));
-	if (ret < 0)
-		return ret;
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			buffer[0] = MSI_PLATFORM_FAN_SUBFEATURE_FAN_SPEED;
+			ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_FAN, buffer,
+						     sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			value = get_unaligned_be16(&buffer[channel * 2 + 1]);
+			if (!value)
+				*val = 0;
+			else
+				*val = 480000 / value;
+
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_AP, buffer,
+						     sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			flags = buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET];
+			if (flags & MSI_PLATFORM_AP_ENABLE_FAN_TABLES)
+				*val = 1;
+			else
+				*val = 2;
+
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
+}
 
-	value = get_unaligned_be16(&buffer[channel * 2 + 1]);
-	if (!value)
-		*val = 0;
-	else
-		*val = 480000 / value;
+static int msi_wmi_platform_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,
+				  int channel, long val)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { };
+	int ret;
 
-	return 0;
+	guard(mutex)(&data->wmi_lock);
+
+	switch (type) {
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			ret = msi_wmi_platform_query_unlocked(
+				data, MSI_PLATFORM_GET_AP, buffer,
+				sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			buffer[0] = MSI_PLATFORM_AP_SUBFEATURE_FAN_MODE;
+			switch (val) {
+			case 1:
+				buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET] |=
+					MSI_PLATFORM_AP_ENABLE_FAN_TABLES;
+				break;
+			case 2:
+				buffer[MSI_PLATFORM_AP_FAN_FLAGS_OFFSET] &=
+					~MSI_PLATFORM_AP_ENABLE_FAN_TABLES;
+				break;
+			default:
+				return -EINVAL;
+			}
+
+			return msi_wmi_platform_query_unlocked(
+				data, MSI_PLATFORM_SET_AP, buffer,
+				sizeof(buffer));
+		default:
+			return -EOPNOTSUPP;
+		}
+	default:
+		return -EOPNOTSUPP;
+	}
 }
 
 static const struct hwmon_ops msi_wmi_platform_ops = {
 	.is_visible = msi_wmi_platform_is_visible,
 	.read = msi_wmi_platform_read,
+	.write = msi_wmi_platform_write,
 };
 
 static const struct hwmon_channel_info * const msi_wmi_platform_info[] = {
@@ -270,6 +559,10 @@ static const struct hwmon_channel_info * const msi_wmi_platform_info[] = {
 			   HWMON_F_INPUT,
 			   HWMON_F_INPUT
 			   ),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE,
+			   HWMON_PWM_ENABLE
+			   ),
 	NULL
 };
 
@@ -278,8 +571,8 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
-static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input, size_t length,
-				      loff_t *offset)
+static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
+					      size_t length, loff_t *offset)
 {
 	struct seq_file *seq = fp->private_data;
 	struct msi_wmi_platform_debugfs_data *data = seq->private;
@@ -313,7 +606,7 @@ static ssize_t msi_wmi_platform_write(struct file *fp, const char __user *input,
 	return length;
 }
 
-static int msi_wmi_platform_show(struct seq_file *seq, void *p)
+static int msi_wmi_platform_debugfs_show(struct seq_file *seq, void *p)
 {
 	struct msi_wmi_platform_debugfs_data *data = seq->private;
 	int ret;
@@ -325,19 +618,19 @@ static int msi_wmi_platform_show(struct seq_file *seq, void *p)
 	return ret;
 }
 
-static int msi_wmi_platform_open(struct inode *inode, struct file *fp)
+static int msi_wmi_platform_debugfs_open(struct inode *inode, struct file *fp)
 {
 	struct msi_wmi_platform_debugfs_data *data = inode->i_private;
 
 	/* The seq_file uses the last byte of the buffer for detecting buffer overflows */
-	return single_open_size(fp, msi_wmi_platform_show, data, data->length + 1);
+	return single_open_size(fp, msi_wmi_platform_debugfs_show, data, data->length + 1);
 }
 
 static const struct file_operations msi_wmi_platform_debugfs_fops = {
 	.owner = THIS_MODULE,
-	.open = msi_wmi_platform_open,
+	.open = msi_wmi_platform_debugfs_open,
 	.read = seq_read,
-	.write = msi_wmi_platform_write,
+	.write = msi_wmi_platform_debugfs_write,
 	.llseek = seq_lseek,
 	.release = single_release,
 };
@@ -399,7 +692,8 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 	struct device *hdev;
 
 	hdev = devm_hwmon_device_register_with_info(&data->wdev->dev, "msi_wmi_platform", data,
-						    &msi_wmi_platform_chip_info, NULL);
+						    &msi_wmi_platform_chip_info,
+						    msi_wmi_platform_hwmon_groups);
 
 	return PTR_ERR_OR_ZERO(hdev);
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:22 +0200
Subject: platform/x86: msi-wmi-platform: Add platform profile through shift
 mode

MSI's version of platform profile in Windows is called shift mode.
Introduce it here, and add a profile handler to it.

It has 5 modes: sport, comfort, green, eco, and user.
Confusingly, for the Claw, MSI only uses sport, green, and eco,
where they correspond to performance, balanced, and low-power.
Therefore, comfort is mapped to balanced-performance, and user to
custom.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 113 ++++++++++++++++++++++++
 2 files changed, 114 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 34528f85e632..941075ed9826 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -551,6 +551,7 @@ config MSI_WMI_PLATFORM
 	tristate "MSI WMI Platform features"
 	depends on ACPI_WMI
 	depends on HWMON
+	select ACPI_PLATFORM_PROFILE
 	help
 	  Say Y here if you want to have support for WMI-based platform features
 	  like fan sensor access on MSI machines.
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index b9f8ace23b8e..6ad6c2064800 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -17,6 +17,7 @@
 #include <linux/dmi.h>
 #include <linux/errno.h>
 #include <linux/fixp-arith.h>
+#include <linux/platform_profile.h>
 #include <linux/hwmon.h>
 #include <linux/hwmon-sysfs.h>
 #include <linux/kernel.h>
@@ -63,6 +64,16 @@
 #define MSI_PLATFORM_AP_FAN_FLAGS_OFFSET	1
 #define MSI_PLATFORM_AP_ENABLE_FAN_TABLES	BIT(7)
 
+/* Get_Data() and Set_Data() Shift Mode Register */
+#define MSI_PLATFORM_SHIFT_ADDR		0xd2
+#define MSI_PLATFORM_SHIFT_DISABLE	BIT(7)
+#define MSI_PLATFORM_SHIFT_ENABLE	(BIT(7) | BIT(6))
+#define MSI_PLATFORM_SHIFT_SPORT	(MSI_PLATFORM_SHIFT_ENABLE + 4)
+#define MSI_PLATFORM_SHIFT_COMFORT	(MSI_PLATFORM_SHIFT_ENABLE + 0)
+#define MSI_PLATFORM_SHIFT_GREEN	(MSI_PLATFORM_SHIFT_ENABLE + 1)
+#define MSI_PLATFORM_SHIFT_ECO		(MSI_PLATFORM_SHIFT_ENABLE + 2)
+#define MSI_PLATFORM_SHIFT_USER		(MSI_PLATFORM_SHIFT_ENABLE + 3)
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -100,12 +111,14 @@ enum msi_wmi_platform_method {
 };
 
 struct msi_wmi_platform_quirk {
+	bool shift_mode;	/* Shift mode is supported */
 };
 
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
+	struct device *ppdev;
 };
 
 struct msi_wmi_platform_debugfs_data {
@@ -150,8 +163,10 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
+	.shift_mode = true
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
+	.shift_mode = true
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
 };
@@ -571,6 +586,90 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
+static int msi_wmi_platform_profile_probe(void *drvdata, unsigned long *choices)
+{
+	set_bit(PLATFORM_PROFILE_LOW_POWER, choices);
+	set_bit(PLATFORM_PROFILE_BALANCED, choices);
+	set_bit(PLATFORM_PROFILE_BALANCED_PERFORMANCE, choices);
+	set_bit(PLATFORM_PROFILE_PERFORMANCE, choices);
+	return 0;
+}
+
+static int msi_wmi_platform_profile_get(struct device *dev,
+					enum platform_profile_option *profile)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	int ret;
+
+	u8 buffer[32] = { };
+
+	buffer[0] = MSI_PLATFORM_SHIFT_ADDR;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_DATA, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	if (buffer[0] != 1)
+		return -EINVAL;
+
+	switch (buffer[1]) {
+	case MSI_PLATFORM_SHIFT_SPORT:
+		*profile = PLATFORM_PROFILE_PERFORMANCE;
+		return 0;
+	case MSI_PLATFORM_SHIFT_COMFORT:
+		*profile = PLATFORM_PROFILE_BALANCED_PERFORMANCE;
+		return 0;
+	case MSI_PLATFORM_SHIFT_GREEN:
+		*profile = PLATFORM_PROFILE_BALANCED;
+		return 0;
+	case MSI_PLATFORM_SHIFT_ECO:
+		*profile = PLATFORM_PROFILE_LOW_POWER;
+		return 0;
+	case MSI_PLATFORM_SHIFT_USER:
+		*profile = PLATFORM_PROFILE_CUSTOM;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int msi_wmi_platform_profile_set(struct device *dev,
+					enum platform_profile_option profile)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(dev);
+	u8 buffer[32] = { };
+
+	buffer[0] = MSI_PLATFORM_SHIFT_ADDR;
+
+	switch (profile) {
+	case PLATFORM_PROFILE_PERFORMANCE:
+		buffer[1] = MSI_PLATFORM_SHIFT_SPORT;
+		break;
+	case PLATFORM_PROFILE_BALANCED_PERFORMANCE:
+		buffer[1] = MSI_PLATFORM_SHIFT_COMFORT;
+		break;
+	case PLATFORM_PROFILE_BALANCED:
+		buffer[1] = MSI_PLATFORM_SHIFT_GREEN;
+		break;
+	case PLATFORM_PROFILE_LOW_POWER:
+		buffer[1] = MSI_PLATFORM_SHIFT_ECO;
+		break;
+	case PLATFORM_PROFILE_CUSTOM:
+		buffer[1] = MSI_PLATFORM_SHIFT_USER;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return msi_wmi_platform_query(data, MSI_PLATFORM_SET_DATA, buffer, sizeof(buffer));
+}
+
+static const struct platform_profile_ops msi_wmi_platform_profile_ops = {
+	.probe = msi_wmi_platform_profile_probe,
+	.profile_get = msi_wmi_platform_profile_get,
+	.profile_set = msi_wmi_platform_profile_set,
+};
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -752,6 +851,18 @@ static int msi_wmi_platform_init(struct msi_wmi_platform_data *data)
 	return 0;
 }
 
+static int msi_wmi_platform_profile_setup(struct msi_wmi_platform_data *data)
+{
+	if (!data->quirks->shift_mode)
+		return 0;
+
+	data->ppdev = devm_platform_profile_register(
+		&data->wdev->dev, "msi-wmi-platform", data,
+		&msi_wmi_platform_profile_ops);
+
+	return PTR_ERR_OR_ZERO(data->ppdev);
+}
+
 static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 {
 	struct msi_wmi_platform_data *data;
@@ -785,6 +896,8 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 
 	msi_wmi_platform_debugfs_init(data);
 
+	msi_wmi_platform_profile_setup(data);
+
 	return msi_wmi_platform_hwmon_init(data);
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:23 +0200
Subject: platform/x86: msi-wmi-platform: Add tunable support via firmware
 attributes

Adds PL1/PL2/SPL/SPPT/FPPT support through the firmware attributes
interface. The min and max values are quirked, and the attributes are
only defined if they are set to a non-zero value. These values are meant
to be set in conjunction with shift mode, where shift mode automatically
sets an upper bound those (e.g., low-power would be used with 8W).

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 382 +++++++++++++++++++++++-
 2 files changed, 381 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 941075ed9826..9b79d8012578 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -552,6 +552,7 @@ config MSI_WMI_PLATFORM
 	depends on ACPI_WMI
 	depends on HWMON
 	select ACPI_PLATFORM_PROFILE
+	select FW_ATTR_CLASS
 	help
 	  Say Y here if you want to have support for WMI-based platform features
 	  like fan sensor access on MSI machines.
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 6ad6c2064800..14420e5ea2a8 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -34,6 +34,8 @@
 
 #include <linux/unaligned.h>
 
+#include "firmware_attributes_class.h"
+
 #define DRIVER_NAME	"msi-wmi-platform"
 
 #define MSI_PLATFORM_GUID	"ABBC0F6E-8EA1-11d1-00A0-C90629100000"
@@ -74,6 +76,11 @@
 #define MSI_PLATFORM_SHIFT_ECO		(MSI_PLATFORM_SHIFT_ENABLE + 2)
 #define MSI_PLATFORM_SHIFT_USER		(MSI_PLATFORM_SHIFT_ENABLE + 3)
 
+/* Get_Data() and Set_Data() Params */
+#define MSI_PLATFORM_PPT_PL1_SPL_ADDR	0x50
+#define MSI_PLATFORM_PPT_PL2_SPPT_ADDR	0x51
+#define MSI_PLATFORM_PPT_PL3_FPPT_ADDR	0x52
+
 static bool force;
 module_param_unsafe(force, bool, 0);
 MODULE_PARM_DESC(force, "Force loading without checking for supported WMI interface versions");
@@ -112,6 +119,10 @@ enum msi_wmi_platform_method {
 
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
+	int ppt_min;		/* Minimum PLx value */
+	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
+	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
+	int ppt_pl3_fppt;		/* Maximum FPPT value */
 };
 
 struct msi_wmi_platform_data {
@@ -119,6 +130,47 @@ struct msi_wmi_platform_data {
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct device *fw_attrs_dev;
+	struct kset *fw_attrs_kset;
+};
+
+enum msi_fw_attr_id {
+	MSI_ATTR_PPT_PL1_SPL,
+	MSI_ATTR_PPT_PL2_SPPT,
+	MSI_ATTR_PPT_PL3_FPPT,
+};
+
+static const char *const msi_fw_attr_name[] = {
+	[MSI_ATTR_PPT_PL1_SPL] = "ppt_pl1_spl",
+	[MSI_ATTR_PPT_PL2_SPPT] = "ppt_pl2_sppt",
+	[MSI_ATTR_PPT_PL3_FPPT] = "ppt_pl3_fppt",
+};
+
+static const char *const msi_fw_attr_desc[] = {
+	[MSI_ATTR_PPT_PL1_SPL] = "CPU Steady package limit (PL1/SPL)",
+	[MSI_ATTR_PPT_PL2_SPPT] = "CPU Boost slow package limit (PL2/SPPT)",
+	[MSI_ATTR_PPT_PL3_FPPT] = "CPU Boost fast package limit (FPPT)",
+};
+
+#define MSI_ATTR_LANGUAGE_CODE "en_US.UTF-8"
+
+struct msi_fw_attr {
+	struct msi_wmi_platform_data *data;
+	enum msi_fw_attr_id fw_attr_id;
+	struct attribute_group attr_group;
+	struct kobj_attribute display_name;
+	struct kobj_attribute current_value;
+	struct kobj_attribute min_value;
+	struct kobj_attribute max_value;
+
+	u32 min;
+	u32 max;
+
+	int (*get_value)(struct msi_wmi_platform_data *data,
+			 struct msi_fw_attr *fw_attr, char *buf);
+	ssize_t (*set_value)(struct msi_wmi_platform_data *data,
+			     struct msi_fw_attr *fw_attr, const char *buf,
+			     size_t count);
 };
 
 struct msi_wmi_platform_debugfs_data {
@@ -163,12 +215,23 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
-	.shift_mode = true
+	.shift_mode = true,
+	.ppt_min = 8,
+	.ppt_pl1_spl_max = 43,
+	.ppt_pl2_sppt_max = 45
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
-	.shift_mode = true
+	.shift_mode = true,
+	.ppt_min = 8,
+	.ppt_pl1_spl_max = 30,
+	.ppt_pl2_sppt_max = 37,
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
+	.shift_mode = true,
+	.ppt_min = 4,
+	.ppt_pl1_spl_max = 37,
+	.ppt_pl2_sppt_max = 45,
+	.ppt_pl3_fppt = 55
 };
 
 static const struct dmi_system_id msi_quirks[] = {
@@ -670,6 +733,317 @@ static const struct platform_profile_ops msi_wmi_platform_profile_ops = {
 	.profile_set = msi_wmi_platform_profile_set,
 };
 
+/* Firmware Attributes setup */
+static int data_get_addr(struct msi_wmi_platform_data *data,
+			 const enum msi_fw_attr_id id)
+{
+	switch (id) {
+	case MSI_ATTR_PPT_PL1_SPL:
+		return MSI_PLATFORM_PPT_PL1_SPL_ADDR;
+	case MSI_ATTR_PPT_PL2_SPPT:
+		return MSI_PLATFORM_PPT_PL2_SPPT_ADDR;
+	case MSI_ATTR_PPT_PL3_FPPT:
+		return MSI_PLATFORM_PPT_PL3_FPPT_ADDR;
+	default:
+		pr_warn("Invalid attribute id %d\n", id);
+		return -EINVAL;
+	}
+}
+
+static ssize_t data_set_value(struct msi_wmi_platform_data *data,
+			      struct msi_fw_attr *fw_attr, const char *buf,
+			      size_t count)
+{
+	u8 buffer[32] = { 0 };
+	int ret, fwid;
+	u32 value;
+
+	fwid = data_get_addr(data, fw_attr->fw_attr_id);
+	if (fwid < 0)
+		return fwid;
+
+	ret = kstrtou32(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	if (fw_attr->min >= 0 && value < fw_attr->min)
+		return -EINVAL;
+	if (fw_attr->max >= 0 && value > fw_attr->max)
+		return -EINVAL;
+
+	buffer[0] = fwid;
+	put_unaligned_le32(value, &buffer[1]);
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_SET_DATA, buffer, sizeof(buffer));
+	if (ret) {
+		pr_warn("Failed to set_data with id %d: %d\n",
+			fw_attr->fw_attr_id, ret);
+		return ret;
+	}
+
+	return count;
+}
+
+static int data_get_value(struct msi_wmi_platform_data *data,
+			  struct msi_fw_attr *fw_attr, char *buf)
+{
+	u8 buffer[32] = { 0 };
+	u32 value;
+	int ret, addr;
+
+	addr = data_get_addr(data, fw_attr->fw_attr_id);
+	if (addr < 0)
+		return addr;
+
+	buffer[0] = addr;
+
+	ret = msi_wmi_platform_query(data, MSI_PLATFORM_GET_DATA, buffer, sizeof(buffer));
+	if (ret) {
+		pr_warn("Failed to show set_data for id %d: %d\n",
+			fw_attr->fw_attr_id, ret);
+		return ret;
+	}
+
+	value = get_unaligned_le32(&buffer[1]);
+
+	return sysfs_emit(buf, "%d\n", value);
+}
+
+static ssize_t display_name_language_code_show(struct kobject *kobj, struct kobj_attribute *attr,
+					       char *buf)
+{
+	return sysfs_emit(buf, "%s\n", MSI_ATTR_LANGUAGE_CODE);
+}
+
+static struct kobj_attribute fw_attr_display_name_language_code =
+	__ATTR_RO(display_name_language_code);
+
+static ssize_t scalar_increment_show(struct kobject *kobj,
+					       struct kobj_attribute *attr,
+					       char *buf)
+{
+	return sysfs_emit(buf, "1\n");
+}
+
+static struct kobj_attribute fw_attr_scalar_increment =
+	__ATTR_RO(scalar_increment);
+
+static ssize_t pending_reboot_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "0\n");
+}
+
+static struct kobj_attribute fw_attr_pending_reboot = __ATTR_RO(pending_reboot);
+
+static ssize_t display_name_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, display_name);
+
+	return sysfs_emit(buf, "%s\n", msi_fw_attr_desc[fw_attr->fw_attr_id]);
+}
+
+static ssize_t current_value_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, current_value);
+
+	return fw_attr->get_value(fw_attr->data, fw_attr, buf);
+}
+
+static ssize_t current_value_store(struct kobject *kobj, struct kobj_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, current_value);
+
+	return fw_attr->set_value(fw_attr->data, fw_attr, buf, count);
+}
+
+static ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sysfs_emit(buf, "integer\n");
+}
+
+static struct kobj_attribute fw_attr_type_int = {
+	.attr = { .name = "type", .mode = 0444 },
+	.show = type_show,
+};
+
+static ssize_t min_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, min_value);
+
+	return sysfs_emit(buf, "%d\n", fw_attr->min);
+}
+
+static ssize_t max_value_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	struct msi_fw_attr *fw_attr =
+		container_of(attr, struct msi_fw_attr, max_value);
+
+	return sysfs_emit(buf, "%d\n", fw_attr->max);
+}
+
+#define FW_ATTR_ENUM_MAX_ATTRS  7
+
+static int
+msi_fw_attr_init(struct msi_wmi_platform_data *data,
+		 const enum msi_fw_attr_id fw_attr_id,
+		 struct kobj_attribute *fw_attr_type, const s32 min,
+		 const s32 max,
+		 int (*get_value)(struct msi_wmi_platform_data *data,
+				  struct msi_fw_attr *fw_attr, char *buf),
+		 ssize_t (*set_value)(struct msi_wmi_platform_data *data,
+				      struct msi_fw_attr *fw_attr,
+				      const char *buf, size_t count))
+{
+	struct msi_fw_attr *fw_attr;
+	struct attribute **attrs;
+	int idx = 0;
+
+	fw_attr = devm_kzalloc(&data->wdev->dev, sizeof(*fw_attr), GFP_KERNEL);
+	if (!fw_attr)
+		return -ENOMEM;
+
+	attrs = devm_kcalloc(&data->wdev->dev, FW_ATTR_ENUM_MAX_ATTRS + 1,
+			     sizeof(*attrs), GFP_KERNEL);
+	if (!attrs)
+		return -ENOMEM;
+
+	fw_attr->data = data;
+	fw_attr->fw_attr_id = fw_attr_id;
+	fw_attr->attr_group.name = msi_fw_attr_name[fw_attr_id];
+	fw_attr->attr_group.attrs = attrs;
+	fw_attr->get_value = get_value;
+	fw_attr->set_value = set_value;
+
+	attrs[idx++] = &fw_attr_type->attr;
+	if (fw_attr_type == &fw_attr_type_int)
+		attrs[idx++] = &fw_attr_scalar_increment.attr;
+	attrs[idx++] = &fw_attr_display_name_language_code.attr;
+
+	sysfs_attr_init(&fw_attr->display_name.attr);
+	fw_attr->display_name.attr.name = "display_name";
+	fw_attr->display_name.attr.mode = 0444;
+	fw_attr->display_name.show = display_name_show;
+	attrs[idx++] = &fw_attr->display_name.attr;
+
+	sysfs_attr_init(&fw_attr->current_value.attr);
+	fw_attr->current_value.attr.name = "current_value";
+	fw_attr->current_value.attr.mode = 0644;
+	fw_attr->current_value.show = current_value_show;
+	fw_attr->current_value.store = current_value_store;
+	attrs[idx++] = &fw_attr->current_value.attr;
+
+	if (min >= 0) {
+		fw_attr->min = min;
+		sysfs_attr_init(&fw_attr->min_value.attr);
+		fw_attr->min_value.attr.name = "min_value";
+		fw_attr->min_value.attr.mode = 0444;
+		fw_attr->min_value.show = min_value_show;
+		attrs[idx++] = &fw_attr->min_value.attr;
+	} else {
+		fw_attr->min = -1;
+	}
+
+	if (max >= 0) {
+		fw_attr->max = max;
+		sysfs_attr_init(&fw_attr->max_value.attr);
+		fw_attr->max_value.attr.name = "max_value";
+		fw_attr->max_value.attr.mode = 0444;
+		fw_attr->max_value.show = max_value_show;
+		attrs[idx++] = &fw_attr->max_value.attr;
+	} else {
+		fw_attr->max = -1;
+	}
+
+	attrs[idx] = NULL;
+	return sysfs_create_group(&data->fw_attrs_kset->kobj, &fw_attr->attr_group);
+}
+
+static void msi_kset_unregister(void *data)
+{
+	struct kset *kset = data;
+
+	sysfs_remove_file(&kset->kobj, &fw_attr_pending_reboot.attr);
+	kset_unregister(kset);
+}
+
+static void msi_fw_attrs_dev_unregister(void *data)
+{
+	struct device *fw_attrs_dev = data;
+
+	device_unregister(fw_attrs_dev);
+}
+
+static int msi_wmi_fw_attrs_init(struct msi_wmi_platform_data *data)
+{
+	int err;
+
+	data->fw_attrs_dev = device_create(&firmware_attributes_class, NULL, MKDEV(0, 0),
+						 NULL, "%s", DRIVER_NAME);
+	if (IS_ERR(data->fw_attrs_dev))
+		return PTR_ERR(data->fw_attrs_dev);
+
+	err = devm_add_action_or_reset(&data->wdev->dev,
+				       msi_fw_attrs_dev_unregister,
+				       data->fw_attrs_dev);
+	if (err)
+		return err;
+
+	data->fw_attrs_kset = kset_create_and_add("attributes", NULL,
+						  &data->fw_attrs_dev->kobj);
+	if (!data->fw_attrs_kset)
+		return -ENOMEM;
+
+	err = sysfs_create_file(&data->fw_attrs_kset->kobj,
+				&fw_attr_pending_reboot.attr);
+	if (err) {
+		kset_unregister(data->fw_attrs_kset);
+		return err;
+	}
+
+	err = devm_add_action_or_reset(&data->wdev->dev, msi_kset_unregister,
+				       data->fw_attrs_kset);
+	if (err)
+		return err;
+
+	if (data->quirks->ppt_pl1_spl_max) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL1_SPL,
+					&fw_attr_type_int, data->quirks->ppt_min,
+					data->quirks->ppt_pl1_spl_max,
+					&data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	if (data->quirks->ppt_pl2_sppt_max) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL2_SPPT,
+				       &fw_attr_type_int, data->quirks->ppt_min,
+				       data->quirks->ppt_pl2_sppt_max,
+				       &data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	if (data->quirks->ppt_pl3_fppt) {
+		err = msi_fw_attr_init(data, MSI_ATTR_PPT_PL3_FPPT,
+				       &fw_attr_type_int, data->quirks->ppt_min,
+				       data->quirks->ppt_pl3_fppt,
+				       &data_get_value, &data_set_value);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -894,6 +1268,10 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	if (ret < 0)
 		return ret;
 
+	ret = msi_wmi_fw_attrs_init(data);
+	if (ret < 0)
+		return ret;
+
 	msi_wmi_platform_debugfs_init(data);
 
 	msi_wmi_platform_profile_setup(data);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:24 +0200
Subject: platform/x86: msi-wmi-platform: Add charge_threshold support

The battery of MSI laptops supports charge threshold. Add support for it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig            |   1 +
 drivers/platform/x86/msi-wmi-platform.c | 111 ++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 9b79d8012578..940ae9b9e380 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -549,6 +549,7 @@ config MSI_WMI
 
 config MSI_WMI_PLATFORM
 	tristate "MSI WMI Platform features"
+	depends on ACPI_BATTERY
 	depends on ACPI_WMI
 	depends on HWMON
 	select ACPI_PLATFORM_PROFILE
diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 14420e5ea2a8..66fa939c4742 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -31,6 +31,7 @@
 #include <linux/sysfs.h>
 #include <linux/types.h>
 #include <linux/wmi.h>
+#include <acpi/battery.h>
 
 #include <linux/unaligned.h>
 
@@ -80,6 +81,7 @@
 #define MSI_PLATFORM_PPT_PL1_SPL_ADDR	0x50
 #define MSI_PLATFORM_PPT_PL2_SPPT_ADDR	0x51
 #define MSI_PLATFORM_PPT_PL3_FPPT_ADDR	0x52
+#define MSI_PLATFORM_BAT_ADDR	0xd7
 
 static bool force;
 module_param_unsafe(force, bool, 0);
@@ -119,6 +121,7 @@ enum msi_wmi_platform_method {
 
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
+	bool charge_threshold;	/* Charge threshold is supported */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
@@ -130,6 +133,7 @@ struct msi_wmi_platform_data {
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct acpi_battery_hook battery_hook;
 	struct device *fw_attrs_dev;
 	struct kset *fw_attrs_kset;
 };
@@ -216,18 +220,21 @@ static const char * const msi_wmi_platform_debugfs_names[] = {
 static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
 };
 static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
 };
 static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
+	.charge_threshold = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -1044,6 +1051,94 @@ static int msi_wmi_fw_attrs_init(struct msi_wmi_platform_data *data)
 	return 0;
 }
 
+static int msi_platform_psy_ext_get_prop(struct power_supply *psy,
+					 const struct power_supply_ext *ext,
+					 void *data,
+					 enum power_supply_property psp,
+					 union power_supply_propval *val)
+{
+	struct msi_wmi_platform_data *msi = data;
+	u8 buffer[32] = { 0 };
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD:
+		buffer[0] = MSI_PLATFORM_BAT_ADDR;
+		ret = msi_wmi_platform_query(msi, MSI_PLATFORM_GET_DATA,
+					     buffer, sizeof(buffer));
+		if (ret)
+			return ret;
+
+		val->intval = buffer[1] & ~BIT(7);
+		if (val->intval > 100)
+			return -EINVAL;
+
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int msi_platform_psy_ext_set_prop(struct power_supply *psy,
+					 const struct power_supply_ext *ext,
+					 void *data,
+					 enum power_supply_property psp,
+					 const union power_supply_propval *val)
+{
+	struct msi_wmi_platform_data *msi = data;
+	u8 buffer[32] = { 0 };
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD:
+		if (val->intval > 100)
+			return -EINVAL;
+		buffer[0] = MSI_PLATFORM_BAT_ADDR;
+		buffer[1] = val->intval | BIT(7);
+		return msi_wmi_platform_query(msi, MSI_PLATFORM_SET_DATA,
+					      buffer, sizeof(buffer));
+	default:
+		return -EINVAL;
+	}
+}
+
+static int
+msi_platform_psy_prop_is_writeable(struct power_supply *psy,
+				   const struct power_supply_ext *ext,
+				   void *data, enum power_supply_property psp)
+{
+	return true;
+}
+
+static const enum power_supply_property oxp_psy_ext_props[] = {
+	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD,
+};
+
+static const struct power_supply_ext msi_platform_psy_ext = {
+	.name			= "msi-platform-charge-control",
+	.properties		= oxp_psy_ext_props,
+	.num_properties		= ARRAY_SIZE(oxp_psy_ext_props),
+	.get_property		= msi_platform_psy_ext_get_prop,
+	.set_property		= msi_platform_psy_ext_set_prop,
+	.property_is_writeable	= msi_platform_psy_prop_is_writeable,
+};
+
+static int msi_wmi_platform_battery_add(struct power_supply *battery,
+					struct acpi_battery_hook *hook)
+{
+	struct msi_wmi_platform_data *data =
+		container_of(hook, struct msi_wmi_platform_data, battery_hook);
+
+	return power_supply_register_extension(battery, &msi_platform_psy_ext,
+					       &data->wdev->dev, data);
+}
+
+static int msi_wmi_platform_battery_remove(struct power_supply *battery,
+					   struct acpi_battery_hook *hook)
+{
+	power_supply_unregister_extension(battery, &msi_platform_psy_ext);
+	return 0;
+}
+
 static ssize_t msi_wmi_platform_debugfs_write(struct file *fp, const char __user *input,
 					      size_t length, loff_t *offset)
 {
@@ -1272,6 +1367,13 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	if (ret < 0)
 		return ret;
 
+	if (data->quirks->charge_threshold) {
+		data->battery_hook.name = "MSI Battery";
+		data->battery_hook.add_battery = msi_wmi_platform_battery_add;
+		data->battery_hook.remove_battery = msi_wmi_platform_battery_remove;
+		battery_hook_register(&data->battery_hook);
+	}
+
 	msi_wmi_platform_debugfs_init(data);
 
 	msi_wmi_platform_profile_setup(data);
@@ -1279,6 +1381,14 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 	return msi_wmi_platform_hwmon_init(data);
 }
 
+static void msi_wmi_platform_remove(struct wmi_device *wdev)
+{
+	struct msi_wmi_platform_data *data = dev_get_drvdata(&wdev->dev);
+
+	if (data->quirks->charge_threshold)
+		battery_hook_unregister(&data->battery_hook);
+}
+
 static const struct wmi_device_id msi_wmi_platform_id_table[] = {
 	{ MSI_PLATFORM_GUID, NULL },
 	{ }
@@ -1292,6 +1402,7 @@ static struct wmi_driver msi_wmi_platform_driver = {
 	},
 	.id_table = msi_wmi_platform_id_table,
 	.probe = msi_wmi_platform_probe,
+	.remove = msi_wmi_platform_remove,
 	.no_singleton = true,
 };
 module_wmi_driver(msi_wmi_platform_driver);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:25 +0200
Subject: platform/x86: msi-wmi-platform: Drop excess fans in dual fan devices

Currently, the platform driver always exposes 4 fans, since the
underlying WMI interface reads 4 values from the EC. However, most
devices only have two fans. Therefore, at least in the case of the
Claw series, quirk the driver to only show two hwmon fans.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 29 ++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 66fa939c4742..871568a017b8 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -122,6 +122,7 @@ enum msi_wmi_platform_method {
 struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
 	bool charge_threshold;	/* Charge threshold is supported */
+	bool dual_fans;		/* For devices with two hwmon fans */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
@@ -221,6 +222,7 @@ static struct msi_wmi_platform_quirk quirk_default = {};
 static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
@@ -228,6 +230,7 @@ static struct msi_wmi_platform_quirk quirk_gen1 = {
 static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
@@ -235,6 +238,7 @@ static struct msi_wmi_platform_quirk quirk_gen2 = {
 static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
 	.charge_threshold = true,
+	.dual_fans = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -656,6 +660,23 @@ static const struct hwmon_chip_info msi_wmi_platform_chip_info = {
 	.info = msi_wmi_platform_info,
 };
 
+static const struct hwmon_channel_info * const msi_wmi_platform_info_dual[] = {
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT,
+			   HWMON_F_INPUT
+			   ),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_ENABLE,
+			   HWMON_PWM_ENABLE
+			   ),
+	NULL
+};
+
+static const struct hwmon_chip_info msi_wmi_platform_chip_info_dual = {
+	.ops = &msi_wmi_platform_ops,
+	.info = msi_wmi_platform_info_dual,
+};
+
 static int msi_wmi_platform_profile_probe(void *drvdata, unsigned long *choices)
 {
 	set_bit(PLATFORM_PROFILE_LOW_POWER, choices);
@@ -1259,9 +1280,11 @@ static int msi_wmi_platform_hwmon_init(struct msi_wmi_platform_data *data)
 {
 	struct device *hdev;
 
-	hdev = devm_hwmon_device_register_with_info(&data->wdev->dev, "msi_wmi_platform", data,
-						    &msi_wmi_platform_chip_info,
-						    msi_wmi_platform_hwmon_groups);
+	hdev = devm_hwmon_device_register_with_info(
+		&data->wdev->dev, "msi_wmi_platform", data,
+		data->quirks->dual_fans ? &msi_wmi_platform_chip_info_dual :
+					&msi_wmi_platform_chip_info,
+		msi_wmi_platform_hwmon_groups);
 
 	return PTR_ERR_OR_ZERO(hdev);
 }
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:26 +0200
Subject: platform/x86: msi-wmi-platform: Update header text

Update copyright information in the header and specify
that this driver also applies to handhelds.

Reviewed-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index 871568a017b8..d7cfdbb28e83 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -1,8 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * Linux driver for WMI platform features on MSI notebooks.
+ * Linux driver for WMI platform features on MSI notebooks and handhelds.
  *
- * Copyright (C) 2024 Armin Wolf <W_Armin@gmx.de>
+ * Copyright (C) 2024-2025 Armin Wolf <W_Armin@gmx.de>
+ * Copyright (C) 2025 Antheas Kapenekakis <lkml@antheas.dev>
  */
 
 #define pr_format(fmt) KBUILD_MODNAME ": " fmt
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 11 May 2025 22:44:27 +0200
Subject: platform/x86: msi-wmi-platform: Restore fan curves on PWM disable and
 unload

MSI software is a bit weird in that even when the manual fan curve is
disabled, the fan speed is still somewhat affected by the curve. So
we have to restore the fan curves on unload and PWM disable, as it
is done in Windows.

Suggested-by: Armin Wolf <W_Armin@gmx.de>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi-platform.c | 124 +++++++++++++++++++++++-
 1 file changed, 123 insertions(+), 1 deletion(-)

diff --git a/drivers/platform/x86/msi-wmi-platform.c b/drivers/platform/x86/msi-wmi-platform.c
index d7cfdbb28e83..896fb11af696 100644
--- a/drivers/platform/x86/msi-wmi-platform.c
+++ b/drivers/platform/x86/msi-wmi-platform.c
@@ -124,17 +124,26 @@ struct msi_wmi_platform_quirk {
 	bool shift_mode;	/* Shift mode is supported */
 	bool charge_threshold;	/* Charge threshold is supported */
 	bool dual_fans;		/* For devices with two hwmon fans */
+	bool restore_curves;	/* Restore factory curves on unload */
 	int ppt_min;		/* Minimum PLx value */
 	int ppt_pl1_spl_max;	/* Maximum PL1/SPL value */
 	int ppt_pl2_sppt_max;	/* Maximum PL2/SPPT value */
 	int ppt_pl3_fppt;		/* Maximum FPPT value */
 };
 
+struct msi_wmi_platform_factory_curves {
+	u8 cpu_fan_table[32];
+	u8 gpu_fan_table[32];
+	u8 cpu_temp_table[32];
+	u8 gpu_temp_table[32];
+};
+
 struct msi_wmi_platform_data {
 	struct wmi_device *wdev;
 	struct msi_wmi_platform_quirk *quirks;
 	struct mutex wmi_lock;	/* Necessary when calling WMI methods */
 	struct device *ppdev;
+	struct msi_wmi_platform_factory_curves factory_curves;
 	struct acpi_battery_hook battery_hook;
 	struct device *fw_attrs_dev;
 	struct kset *fw_attrs_kset;
@@ -224,6 +233,7 @@ static struct msi_wmi_platform_quirk quirk_gen1 = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 43,
 	.ppt_pl2_sppt_max = 45
@@ -232,6 +242,7 @@ static struct msi_wmi_platform_quirk quirk_gen2 = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 8,
 	.ppt_pl1_spl_max = 30,
 	.ppt_pl2_sppt_max = 37,
@@ -240,6 +251,7 @@ static struct msi_wmi_platform_quirk quirk_amd = {
 	.shift_mode = true,
 	.charge_threshold = true,
 	.dual_fans = true,
+	.restore_curves = true,
 	.ppt_min = 4,
 	.ppt_pl1_spl_max = 37,
 	.ppt_pl2_sppt_max = 45,
@@ -529,6 +541,94 @@ static struct attribute *msi_wmi_platform_hwmon_attrs[] = {
 };
 ATTRIBUTE_GROUPS(msi_wmi_platform_hwmon);
 
+static int msi_wmi_platform_curves_save(struct msi_wmi_platform_data *data)
+{
+	int ret;
+
+	data->factory_curves.cpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_FAN,
+		data->factory_curves.cpu_fan_table,
+		sizeof(data->factory_curves.cpu_fan_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.cpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_FAN_TABLE;
+
+	data->factory_curves.gpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_FAN,
+		data->factory_curves.gpu_fan_table,
+		sizeof(data->factory_curves.gpu_fan_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.gpu_fan_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_FAN_TABLE;
+
+	data->factory_curves.cpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_TEMPERATURE,
+		data->factory_curves.cpu_temp_table,
+		sizeof(data->factory_curves.cpu_temp_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.cpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_CPU_TEMP_TABLE;
+
+	data->factory_curves.gpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE;
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_GET_TEMPERATURE,
+		data->factory_curves.gpu_temp_table,
+		sizeof(data->factory_curves.gpu_temp_table));
+	if (ret < 0)
+		return ret;
+	data->factory_curves.gpu_temp_table[0] =
+		MSI_PLATFORM_FAN_SUBFEATURE_GPU_TEMP_TABLE;
+
+	return 0;
+}
+
+static int msi_wmi_platform_curves_load(struct msi_wmi_platform_data *data)
+{
+	u8 buffer[32] = { };
+	int ret;
+
+	memcpy(buffer, data->factory_curves.cpu_fan_table,
+	       sizeof(data->factory_curves.cpu_fan_table));
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.gpu_fan_table,
+	       sizeof(data->factory_curves.gpu_fan_table));
+	ret = msi_wmi_platform_query_unlocked(data, MSI_PLATFORM_SET_FAN,
+					      buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.cpu_temp_table,
+	       sizeof(data->factory_curves.cpu_temp_table));
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_SET_TEMPERATURE, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	memcpy(buffer, data->factory_curves.gpu_temp_table,
+	       sizeof(data->factory_curves.gpu_temp_table));
+	ret = msi_wmi_platform_query_unlocked(
+		data, MSI_PLATFORM_SET_TEMPERATURE, buffer, sizeof(buffer));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+
 static umode_t msi_wmi_platform_is_visible(const void *drvdata, enum hwmon_sensor_types type,
 					   u32 attr, int channel)
 {
@@ -625,9 +725,19 @@ static int msi_wmi_platform_write(struct device *dev, enum hwmon_sensor_types ty
 				return -EINVAL;
 			}
 
-			return msi_wmi_platform_query_unlocked(
+			ret = msi_wmi_platform_query_unlocked(
 				data, MSI_PLATFORM_SET_AP, buffer,
 				sizeof(buffer));
+			if (ret < 0)
+				return ret;
+
+			if (val == 2 && data->quirks->restore_curves) {
+				ret = msi_wmi_platform_curves_load(data);
+				if (ret < 0)
+					return ret;
+			}
+
+			return 0;
 		default:
 			return -EOPNOTSUPP;
 		}
@@ -1402,6 +1512,13 @@ static int msi_wmi_platform_probe(struct wmi_device *wdev, const void *context)
 
 	msi_wmi_platform_profile_setup(data);
 
+	if (data->quirks->restore_curves) {
+		guard(mutex)(&data->wmi_lock);
+		ret = msi_wmi_platform_curves_save(data);
+		if (ret < 0)
+			return ret;
+	}
+
 	return msi_wmi_platform_hwmon_init(data);
 }
 
@@ -1411,6 +1528,11 @@ static void msi_wmi_platform_remove(struct wmi_device *wdev)
 
 	if (data->quirks->charge_threshold)
 		battery_hook_unregister(&data->battery_hook);
+
+	if (data->quirks->restore_curves) {
+		guard(mutex)(&data->wmi_lock);
+		msi_wmi_platform_curves_load(data);
+	}
 }
 
 static const struct wmi_device_id msi_wmi_platform_id_table[] = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cryolitia PukNgae <cryolitia@uniontech.com>
Date: Mon, 8 Sep 2025 10:25:44 +0800
Subject: hwmon: add GPD devices sensor driver
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Sensors driver for GPD Handhelds that expose fan reading and control via
hwmon sysfs.

Shenzhen GPD Technology Co., Ltd. manufactures a series of handheld
devices. This driver implements these functions through x86 port-mapped
IO.

Tested-by: Marcin Strgowski <marcin@stragowski.com>
Tested-by: someone5678 <someone5678.dev@gmail.com>
Tested-by: Justin Weiss <justin@justinweiss.com>
Tested-by: Antheas Kapenekakis <lkml@antheas.dev>
Tested-by: command_block <mtf@ik.me>
Tested-by: derjohn <himself@derjohn.de>
Tested-by: Crashdummyy <crashdummy1337@proton.me>
Signed-off-by: Cryolitia PukNgae <cryolitia@uniontech.com>
Link: https://lore.kernel.org/r/20250908-gpd_fan-v9-1-7b4506c03953@uniontech.com
Signed-off-by: Guenter Roeck <linux@roeck-us.net>
---
 MAINTAINERS             |   6 +
 drivers/hwmon/Kconfig   |  10 +
 drivers/hwmon/Makefile  |   1 +
 drivers/hwmon/gpd-fan.c | 715 ++++++++++++++++++++++++++++++++++++++++
 4 files changed, 732 insertions(+)
 create mode 100644 drivers/hwmon/gpd-fan.c

diff --git a/MAINTAINERS b/MAINTAINERS
index c7e27e2edfe4..c7ad37d90cbb 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -10427,6 +10427,12 @@ F:	drivers/phy/samsung/phy-gs101-ufs.c
 F:	include/dt-bindings/clock/google,gs101.h
 K:	[gG]oogle.?[tT]ensor
 
+GPD FAN DRIVER
+M:	Cryolitia PukNgae <cryolitia@uniontech.com>
+L:	linux-hwmon@vger.kernel.org
+S:	Maintained
+F:	drivers/hwmon/gpd-fan.c
+
 GPD POCKET FAN DRIVER
 M:	Hans de Goede <hansg@kernel.org>
 L:	platform-driver-x86@vger.kernel.org
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 48341d5652ac..a137e908ee4a 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -769,6 +769,16 @@ config SENSORS_GL520SM
 	  This driver can also be built as a module. If so, the module
 	  will be called gl520sm.
 
+config SENSORS_GPD
+	tristate "GPD handhelds"
+	depends on X86
+	help
+	  If you say yes here you get support for fan readings and
+	  control over GPD handheld devices.
+
+	  Can also be built as a module. In that case it will be
+	  called gpd-fan.
+
 config SENSORS_G760A
 	tristate "GMT G760A"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index f3e1422a68f9..99023929efea 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -88,6 +88,7 @@ obj-$(CONFIG_SENSORS_GIGABYTE_WATERFORCE) += gigabyte_waterforce.o
 obj-$(CONFIG_SENSORS_GL518SM)	+= gl518sm.o
 obj-$(CONFIG_SENSORS_GL520SM)	+= gl520sm.o
 obj-$(CONFIG_SENSORS_GSC)	+= gsc-hwmon.o
+obj-$(CONFIG_SENSORS_GPD)	+= gpd-fan.o
 obj-$(CONFIG_SENSORS_GPIO_FAN)	+= gpio-fan.o
 obj-$(CONFIG_SENSORS_GXP_FAN_CTRL) += gxp-fan-ctrl.o
 obj-$(CONFIG_SENSORS_HIH6130)	+= hih6130.o
diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
new file mode 100644
index 000000000000..e0b3b46e1bf1
--- /dev/null
+++ b/drivers/hwmon/gpd-fan.c
@@ -0,0 +1,715 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/* Platform driver for GPD devices that expose fan control via hwmon sysfs.
+ *
+ * Fan control is provided via pwm interface in the range [0-255].
+ * Each model has a different range in the EC, the written value is scaled to
+ * accommodate for that.
+ *
+ * Based on this repo:
+ * https://github.com/Cryolitia/gpd-fan-driver
+ *
+ * Copyright (c) 2024 Cryolitia PukNgae
+ */
+
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/hwmon.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "gpdfan"
+#define GPD_PWM_CTR_OFFSET 0x1841
+
+static char *gpd_fan_board = "";
+module_param(gpd_fan_board, charp, 0444);
+
+// EC read/write locker, protecting a sequence of EC operations
+static DEFINE_MUTEX(gpd_fan_sequence_lock);
+
+enum gpd_board {
+	win_mini,
+	win4_6800u,
+	win_max_2,
+	duo,
+};
+
+enum FAN_PWM_ENABLE {
+	DISABLE		= 0,
+	MANUAL		= 1,
+	AUTOMATIC	= 2,
+};
+
+static struct {
+	enum FAN_PWM_ENABLE pwm_enable;
+	u8 pwm_value;
+
+	const struct gpd_fan_drvdata *drvdata;
+} gpd_driver_priv;
+
+struct gpd_fan_drvdata {
+	const char *board_name; // Board name for module param comparison
+	const enum gpd_board board;
+
+	const u8 addr_port;
+	const u8 data_port;
+	const u16 manual_control_enable;
+	const u16 rpm_read;
+	const u16 pwm_write;
+	const u16 pwm_max;
+};
+
+static struct gpd_fan_drvdata gpd_win_mini_drvdata = {
+	.board_name		= "win_mini",
+	.board			= win_mini,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x047A,
+	.rpm_read		= 0x0478,
+	.pwm_write		= 0x047A,
+	.pwm_max		= 244,
+};
+
+static struct gpd_fan_drvdata gpd_duo_drvdata = {
+	.board_name		= "duo",
+	.board			= duo,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x047A,
+	.rpm_read		= 0x0478,
+	.pwm_write		= 0x047A,
+	.pwm_max		= 244,
+};
+
+static struct gpd_fan_drvdata gpd_win4_drvdata = {
+	.board_name		= "win4",
+	.board			= win4_6800u,
+
+	.addr_port		= 0x2E,
+	.data_port		= 0x2F,
+	.manual_control_enable	= 0xC311,
+	.rpm_read		= 0xC880,
+	.pwm_write		= 0xC311,
+	.pwm_max		= 127,
+};
+
+static struct gpd_fan_drvdata gpd_wm2_drvdata = {
+	.board_name		= "wm2",
+	.board			= win_max_2,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x0275,
+	.rpm_read		= 0x0218,
+	.pwm_write		= 0x1809,
+	.pwm_max		= 184,
+};
+
+static const struct dmi_system_id dmi_table[] = {
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen 8840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-01")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-02")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-02-L")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win 4 with AMD Ryzen 6800U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Default string"),
+		},
+		.driver_data = &gpd_win4_drvdata,
+	},
+	{
+		// GPD Win 4 with Ryzen 7840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Ver. 1.0"),
+		},
+		// Since 7840U, win4 uses the same drvdata as wm2
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win 4 with Ryzen 7840U (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Ver.1.0"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win Max 2 with Ryzen 6800U
+		// GPD Win Max 2 2023 with Ryzen 7840U
+		// GPD Win Max 2 2024 with Ryzen 8840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-04"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win Max 2 with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-05"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Duo
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1622-01"),
+		},
+		.driver_data = &gpd_duo_drvdata,
+	},
+	{
+		// GPD Duo (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1622-01-L"),
+		},
+		.driver_data = &gpd_duo_drvdata,
+	},
+	{
+		// GPD Pocket 4
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1628-04"),
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Pocket 4 (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1628-04-L"),
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{}
+};
+
+static const struct gpd_fan_drvdata *gpd_module_drvdata[] = {
+	&gpd_win_mini_drvdata, &gpd_win4_drvdata, &gpd_wm2_drvdata, NULL
+};
+
+// Helper functions to handle EC read/write
+static void gpd_ecram_read(u16 offset, u8 *val)
+{
+	u16 addr_port = gpd_driver_priv.drvdata->addr_port;
+	u16 data_port = gpd_driver_priv.drvdata->data_port;
+
+	outb(0x2E, addr_port);
+	outb(0x11, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)((offset >> 8) & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x10, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)(offset & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x12, data_port);
+	outb(0x2F, addr_port);
+	*val = inb(data_port);
+}
+
+static void gpd_ecram_write(u16 offset, u8 value)
+{
+	u16 addr_port = gpd_driver_priv.drvdata->addr_port;
+	u16 data_port = gpd_driver_priv.drvdata->data_port;
+
+	outb(0x2E, addr_port);
+	outb(0x11, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)((offset >> 8) & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x10, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)(offset & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x12, data_port);
+	outb(0x2F, addr_port);
+	outb(value, data_port);
+}
+
+static int gpd_generic_read_rpm(void)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 high, low;
+
+	gpd_ecram_read(drvdata->rpm_read, &high);
+	gpd_ecram_read(drvdata->rpm_read + 1, &low);
+
+	return (u16)high << 8 | low;
+}
+
+static void gpd_win4_init_ec(void)
+{
+	u8 chip_id, chip_ver;
+
+	gpd_ecram_read(0x2000, &chip_id);
+
+	if (chip_id == 0x55) {
+		gpd_ecram_read(0x1060, &chip_ver);
+		gpd_ecram_write(0x1060, chip_ver | 0x80);
+	}
+}
+
+static int gpd_win4_read_rpm(void)
+{
+	int ret;
+
+	ret = gpd_generic_read_rpm();
+
+	if (ret == 0)
+		// Re-init EC when speed is 0
+		gpd_win4_init_ec();
+
+	return ret;
+}
+
+static int gpd_wm2_read_rpm(void)
+{
+	for (u16 pwm_ctr_offset = GPD_PWM_CTR_OFFSET;
+	     pwm_ctr_offset <= GPD_PWM_CTR_OFFSET + 2; pwm_ctr_offset++) {
+		u8 PWMCTR;
+
+		gpd_ecram_read(pwm_ctr_offset, &PWMCTR);
+
+		if (PWMCTR != 0xB8)
+			gpd_ecram_write(pwm_ctr_offset, 0xB8);
+	}
+
+	return gpd_generic_read_rpm();
+}
+
+// Read value for fan1_input
+static int gpd_read_rpm(void)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case duo:
+		return gpd_generic_read_rpm();
+	case win4_6800u:
+		return gpd_win4_read_rpm();
+	case win_max_2:
+		return gpd_wm2_read_rpm();
+	}
+
+	return 0;
+}
+
+static int gpd_wm2_read_pwm(void)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 var;
+
+	gpd_ecram_read(drvdata->pwm_write, &var);
+
+	// Match gpd_generic_write_pwm(u8) below
+	return DIV_ROUND_CLOSEST((var - 1) * 255, (drvdata->pwm_max - 1));
+}
+
+// Read value for pwm1
+static int gpd_read_pwm(void)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case duo:
+	case win4_6800u:
+		switch (gpd_driver_priv.pwm_enable) {
+		case DISABLE:
+			return 255;
+		case MANUAL:
+			return gpd_driver_priv.pwm_value;
+		case AUTOMATIC:
+			return -EOPNOTSUPP;
+		}
+		break;
+	case win_max_2:
+		return gpd_wm2_read_pwm();
+	}
+	return 0;
+}
+
+// PWM value's range in EC is 1 - pwm_max, cast 0 - 255 to it.
+static inline u8 gpd_cast_pwm_range(u8 val)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+
+	return DIV_ROUND_CLOSEST(val * (drvdata->pwm_max - 1), 255) + 1;
+}
+
+static void gpd_generic_write_pwm(u8 val)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 pwm_reg;
+
+	pwm_reg = gpd_cast_pwm_range(val);
+	gpd_ecram_write(drvdata->pwm_write, pwm_reg);
+}
+
+static void gpd_duo_write_pwm(u8 val)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 pwm_reg;
+
+	pwm_reg = gpd_cast_pwm_range(val);
+	gpd_ecram_write(drvdata->pwm_write, pwm_reg);
+	gpd_ecram_write(drvdata->pwm_write + 1, pwm_reg);
+}
+
+// Write value for pwm1
+static int gpd_write_pwm(u8 val)
+{
+	if (gpd_driver_priv.pwm_enable != MANUAL)
+		return -EPERM;
+
+	switch (gpd_driver_priv.drvdata->board) {
+	case duo:
+		gpd_duo_write_pwm(val);
+		break;
+	case win_mini:
+	case win4_6800u:
+	case win_max_2:
+		gpd_generic_write_pwm(val);
+		break;
+	}
+
+	return 0;
+}
+
+static void gpd_win_mini_set_pwm_enable(enum FAN_PWM_ENABLE pwm_enable)
+{
+	switch (pwm_enable) {
+	case DISABLE:
+		gpd_generic_write_pwm(255);
+		break;
+	case MANUAL:
+		gpd_generic_write_pwm(gpd_driver_priv.pwm_value);
+		break;
+	case AUTOMATIC:
+		gpd_ecram_write(gpd_driver_priv.drvdata->pwm_write, 0);
+		break;
+	}
+}
+
+static void gpd_duo_set_pwm_enable(enum FAN_PWM_ENABLE pwm_enable)
+{
+	switch (pwm_enable) {
+	case DISABLE:
+		gpd_duo_write_pwm(255);
+		break;
+	case MANUAL:
+		gpd_duo_write_pwm(gpd_driver_priv.pwm_value);
+		break;
+	case AUTOMATIC:
+		gpd_ecram_write(gpd_driver_priv.drvdata->pwm_write, 0);
+		break;
+	}
+}
+
+static void gpd_wm2_set_pwm_enable(enum FAN_PWM_ENABLE enable)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+
+	switch (enable) {
+	case DISABLE:
+		gpd_generic_write_pwm(255);
+		gpd_ecram_write(drvdata->manual_control_enable, 1);
+		break;
+	case MANUAL:
+		gpd_generic_write_pwm(gpd_driver_priv.pwm_value);
+		gpd_ecram_write(drvdata->manual_control_enable, 1);
+		break;
+	case AUTOMATIC:
+		gpd_ecram_write(drvdata->manual_control_enable, 0);
+		break;
+	}
+}
+
+// Write value for pwm1_enable
+static void gpd_set_pwm_enable(enum FAN_PWM_ENABLE enable)
+{
+	if (enable == MANUAL)
+		// Set pwm_value to max firstly when switching to manual mode, in
+		// consideration of device safety.
+		gpd_driver_priv.pwm_value = 255;
+
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case win4_6800u:
+		gpd_win_mini_set_pwm_enable(enable);
+		break;
+	case duo:
+		gpd_duo_set_pwm_enable(enable);
+		break;
+	case win_max_2:
+		gpd_wm2_set_pwm_enable(enable);
+		break;
+	}
+}
+
+static umode_t gpd_fan_hwmon_is_visible(__always_unused const void *drvdata,
+					enum hwmon_sensor_types type, u32 attr,
+					__always_unused int channel)
+{
+	if (type == hwmon_fan && attr == hwmon_fan_input) {
+		return 0444;
+	} else if (type == hwmon_pwm) {
+		switch (attr) {
+		case hwmon_pwm_enable:
+		case hwmon_pwm_input:
+			return 0644;
+		default:
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static int gpd_fan_hwmon_read(__always_unused struct device *dev,
+			      enum hwmon_sensor_types type, u32 attr,
+			      __always_unused int channel, long *val)
+{
+	int ret;
+
+	ret = mutex_lock_interruptible(&gpd_fan_sequence_lock);
+	if (ret)
+		return ret;
+
+	if (type == hwmon_fan) {
+		if (attr == hwmon_fan_input) {
+			ret = gpd_read_rpm();
+
+			if (ret < 0)
+				goto OUT;
+
+			*val = ret;
+			ret = 0;
+			goto OUT;
+		}
+	} else if (type == hwmon_pwm) {
+		switch (attr) {
+		case hwmon_pwm_enable:
+			*val = gpd_driver_priv.pwm_enable;
+			ret = 0;
+			goto OUT;
+		case hwmon_pwm_input:
+			ret = gpd_read_pwm();
+
+			if (ret < 0)
+				goto OUT;
+
+			*val = ret;
+			ret = 0;
+			goto OUT;
+		}
+	}
+
+	ret = -EOPNOTSUPP;
+
+OUT:
+	mutex_unlock(&gpd_fan_sequence_lock);
+	return ret;
+}
+
+static int gpd_fan_hwmon_write(__always_unused struct device *dev,
+			       enum hwmon_sensor_types type, u32 attr,
+			       __always_unused int channel, long val)
+{
+	int ret;
+
+	ret = mutex_lock_interruptible(&gpd_fan_sequence_lock);
+	if (ret)
+		return ret;
+
+	if (type == hwmon_pwm) {
+		switch (attr) {
+		case hwmon_pwm_enable:
+			if (!in_range(val, 0, 3)) {
+				ret = -EINVAL;
+				goto OUT;
+			}
+
+			gpd_driver_priv.pwm_enable = val;
+
+			gpd_set_pwm_enable(gpd_driver_priv.pwm_enable);
+			ret = 0;
+			goto OUT;
+		case hwmon_pwm_input:
+			if (!in_range(val, 0, 255)) {
+				ret = -ERANGE;
+				goto OUT;
+			}
+
+			gpd_driver_priv.pwm_value = val;
+
+			ret = gpd_write_pwm(val);
+			goto OUT;
+		}
+	}
+
+	ret = -EOPNOTSUPP;
+
+OUT:
+	mutex_unlock(&gpd_fan_sequence_lock);
+	return ret;
+}
+
+static const struct hwmon_ops gpd_fan_ops = {
+	.is_visible = gpd_fan_hwmon_is_visible,
+	.read = gpd_fan_hwmon_read,
+	.write = gpd_fan_hwmon_write,
+};
+
+static const struct hwmon_channel_info *gpd_fan_hwmon_channel_info[] = {
+	HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),
+	HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE),
+	NULL
+};
+
+static struct hwmon_chip_info gpd_fan_chip_info = {
+	.ops = &gpd_fan_ops,
+	.info = gpd_fan_hwmon_channel_info
+};
+
+static int gpd_fan_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct resource *region;
+	const struct resource *res;
+	const struct device *hwdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (IS_ERR(res))
+		return dev_err_probe(dev, PTR_ERR(res),
+				     "Failed to get platform resource\n");
+
+	region = devm_request_region(dev, res->start,
+				     resource_size(res), DRIVER_NAME);
+	if (IS_ERR(region))
+		return dev_err_probe(dev, PTR_ERR(region),
+				     "Failed to request region\n");
+
+	hwdev = devm_hwmon_device_register_with_info(dev,
+						     DRIVER_NAME,
+						     NULL,
+						     &gpd_fan_chip_info,
+						     NULL);
+	if (IS_ERR(hwdev))
+		return dev_err_probe(dev, PTR_ERR(region),
+				     "Failed to register hwmon device\n");
+
+	return 0;
+}
+
+static void gpd_fan_remove(__always_unused struct platform_device *pdev)
+{
+	gpd_driver_priv.pwm_enable = AUTOMATIC;
+	gpd_set_pwm_enable(AUTOMATIC);
+}
+
+static struct platform_driver gpd_fan_driver = {
+	.probe = gpd_fan_probe,
+	.remove = gpd_fan_remove,
+	.driver = {
+		.name = KBUILD_MODNAME,
+	},
+};
+
+static struct platform_device *gpd_fan_platform_device;
+
+static int __init gpd_fan_init(void)
+{
+	const struct gpd_fan_drvdata *match = NULL;
+
+	for (const struct gpd_fan_drvdata **p = gpd_module_drvdata; *p; p++) {
+		if (strcmp(gpd_fan_board, (*p)->board_name) == 0) {
+			match = *p;
+			break;
+		}
+	}
+
+	if (!match) {
+		const struct dmi_system_id *dmi_match =
+			dmi_first_match(dmi_table);
+		if (dmi_match)
+			match = dmi_match->driver_data;
+	}
+
+	if (!match)
+		return -ENODEV;
+
+	gpd_driver_priv.pwm_enable = AUTOMATIC;
+	gpd_driver_priv.pwm_value = 255;
+	gpd_driver_priv.drvdata = match;
+
+	struct resource gpd_fan_resources[] = {
+		{
+			.start = match->addr_port,
+			.end = match->data_port,
+			.flags = IORESOURCE_IO,
+		},
+	};
+
+	gpd_fan_platform_device = platform_create_bundle(&gpd_fan_driver,
+							 gpd_fan_probe,
+							 gpd_fan_resources,
+							 1, NULL, 0);
+
+	if (IS_ERR(gpd_fan_platform_device)) {
+		pr_warn("Failed to create platform device\n");
+		return PTR_ERR(gpd_fan_platform_device);
+	}
+
+	return 0;
+}
+
+static void __exit gpd_fan_exit(void)
+{
+	platform_device_unregister(gpd_fan_platform_device);
+	platform_driver_unregister(&gpd_fan_driver);
+}
+
+MODULE_DEVICE_TABLE(dmi, dmi_table);
+
+module_init(gpd_fan_init);
+module_exit(gpd_fan_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cryolitia PukNgae <cryolitia@uniontech.com>");
+MODULE_DESCRIPTION("GPD Devices fan control driver");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Cryolitia PukNgae <cryolitia@uniontech.com>
Date: Fri, 19 Sep 2025 16:38:49 +0800
Subject: hwmon: (gpd-fan) Fix range check for pwm input

Fixed the maximum value in the PWM input range check, allowing the
input to be set to 255.

Fixes: 0ab88e239439 ("hwmon: add GPD devices sensor driver")
Reported-by: Chenx Dust <chenx_dust@outlook.com>
Link: https://github.com/Cryolitia/gpd-fan-driver/pull/18
Co-developed-by: Chenx Dust <chenx_dust@outlook.com>
Signed-off-by: Chenx Dust <chenx_dust@outlook.com>
Signed-off-by: Cryolitia PukNgae <cryolitia@uniontech.com>
Link: https://lore.kernel.org/r/20250919-hwmon-v1-1-2b69c8b9c062@uniontech.com
Signed-off-by: Guenter Roeck <linux@roeck-us.net>
---
 drivers/hwmon/gpd-fan.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
index e0b3b46e1bf1..644dc3ca9df7 100644
--- a/drivers/hwmon/gpd-fan.c
+++ b/drivers/hwmon/gpd-fan.c
@@ -571,7 +571,7 @@ static int gpd_fan_hwmon_write(__always_unused struct device *dev,
 			ret = 0;
 			goto OUT;
 		case hwmon_pwm_input:
-			if (!in_range(val, 0, 255)) {
+			if (!in_range(val, 0, 256)) {
 				ret = -ERANGE;
 				goto OUT;
 			}
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
Date: Fri, 10 Oct 2025 13:43:59 -0700
Subject: hwmon: (gpd-fan) Fix return value when platform_get_resource() fails

When platform_get_resource() fails it returns NULL and not an error
pointer, accordingly change the error handling.

Fixes: 0ab88e239439 ("hwmon: add GPD devices sensor driver")
Signed-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
Link: https://lore.kernel.org/r/20251010204359.94300-1-harshit.m.mogalapalli@oracle.com
Signed-off-by: Guenter Roeck <linux@roeck-us.net>
---
 drivers/hwmon/gpd-fan.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
index 644dc3ca9df7..eebe39ef9677 100644
--- a/drivers/hwmon/gpd-fan.c
+++ b/drivers/hwmon/gpd-fan.c
@@ -615,8 +615,8 @@ static int gpd_fan_probe(struct platform_device *pdev)
 	const struct device *hwdev;
 
 	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
-	if (IS_ERR(res))
-		return dev_err_probe(dev, PTR_ERR(res),
+	if (!res)
+		return dev_err_probe(dev, -EINVAL,
 				     "Failed to get platform resource\n");
 
 	region = devm_request_region(dev, res->start,
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
Date: Fri, 10 Oct 2025 13:44:46 -0700
Subject: hwmon: (gpd-fan) Fix error handling in gpd_fan_probe()

devm_request_region() returns a NULL pointer on error, not an ERR_PTR().
Handle it accordingly.

Also fix error return from the call to devm_hwmon_device_register_with_info().

Fixes: 0ab88e239439 ("hwmon: add GPD devices sensor driver")
Signed-off-by: Harshit Mogalapalli <harshit.m.mogalapalli@oracle.com>
Reviewed-by: Cryolitia PukNgae <cryolitia@uniontech.com>
Link: https://lore.kernel.org/r/20251010204447.94343-1-harshit.m.mogalapalli@oracle.com
[groeck: Updated subject to improve readability]
Signed-off-by: Guenter Roeck <linux@roeck-us.net>
---
 drivers/hwmon/gpd-fan.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
index eebe39ef9677..321794807e8d 100644
--- a/drivers/hwmon/gpd-fan.c
+++ b/drivers/hwmon/gpd-fan.c
@@ -621,8 +621,8 @@ static int gpd_fan_probe(struct platform_device *pdev)
 
 	region = devm_request_region(dev, res->start,
 				     resource_size(res), DRIVER_NAME);
-	if (IS_ERR(region))
-		return dev_err_probe(dev, PTR_ERR(region),
+	if (!region)
+		return dev_err_probe(dev, -EBUSY,
 				     "Failed to request region\n");
 
 	hwdev = devm_hwmon_device_register_with_info(dev,
@@ -631,7 +631,7 @@ static int gpd_fan_probe(struct platform_device *pdev)
 						     &gpd_fan_chip_info,
 						     NULL);
 	if (IS_ERR(hwdev))
-		return dev_err_probe(dev, PTR_ERR(region),
+		return dev_err_probe(dev, PTR_ERR(hwdev),
 				     "Failed to register hwmon device\n");
 
 	return 0;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 24 Oct 2025 22:46:08 +0200
Subject: hwmon: (gpd-fan) Add GPD Win 5

The GPD Win 5 is a new device by GPD with an AMD AI MAX 395 chip.
It uses the same fan control registers as the GPD Win 4.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hwmon/gpd-fan.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/hwmon/gpd-fan.c b/drivers/hwmon/gpd-fan.c
index 321794807e8d..d8a9e2cb4b61 100644
--- a/drivers/hwmon/gpd-fan.c
+++ b/drivers/hwmon/gpd-fan.c
@@ -146,6 +146,14 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = &gpd_win4_drvdata,
 	},
+	{
+		// GPD Win 5 with AMD AI MAX 395
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-05"),
+		},
+		.driver_data = &gpd_win4_drvdata,
+	},
 	{
 		// GPD Win 4 with Ryzen 7840U
 		.matches = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 23 Feb 2025 22:39:04 +0100
Subject: drm/amd: Lower logging level of overdrive warning to err

Using a crit message breaks seamless boot by making the kernel
wipe the framebuffer. This leads to an unfavorable user experience.

Therefore, lower to err.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 7be62b9619f9..9380a29ac67d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -3143,7 +3143,7 @@ static int __init amdgpu_init(void)
 
 	if (amdgpu_pp_feature_mask & PP_OVERDRIVE_MASK) {
 		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
-		pr_crit("Overdrive is enabled, please disable it before "
+		pr_err("Overdrive is enabled, please disable it before "
 			"reporting any bugs unrelated to overdrive.\n");
 	}
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mario Limonciello <mario.limonciello@amd.com>
Date: Thu, 1 May 2025 16:17:32 -0500
Subject: PM: Add suspend and hibernate notifications for after freeze

Suspend and hibernate notifications are available specifically when
the sequence starts and finishes.  However there are no notifications
during the process when tasks have been frozen.

Introduce two new events `PM_SUSPEND_POST_FREEZE` and
`PM_HIBERNATE_POST_FREEZE` that drivers can subscribe to and take
different actions specifically knowing userspace is frozen.

Suggested-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
---
 Documentation/driver-api/pm/notifiers.rst | 19 ++++++++++++++++---
 include/linux/suspend.h                   | 14 ++++++++------
 kernel/power/hibernate.c                  |  9 +++++++--
 kernel/power/suspend.c                    | 10 ++++++++--
 4 files changed, 39 insertions(+), 13 deletions(-)

diff --git a/Documentation/driver-api/pm/notifiers.rst b/Documentation/driver-api/pm/notifiers.rst
index 186435c43b77..6a1912fbee21 100644
--- a/Documentation/driver-api/pm/notifiers.rst
+++ b/Documentation/driver-api/pm/notifiers.rst
@@ -32,6 +32,18 @@ will be called upon the following events by the PM core:
 	additional work is done between the notifiers and the invocation of PM
 	callbacks for the "freeze" transition.
 
+``PM_HIBERNATION_POST_FREEZE``
+	The system is going to hibernate and tasks have just been frozen.
+
+``PM_SUSPEND_PREPARE``
+	The system is going to suspend, tasks will be frozen immediately.  This
+	is different from ``PM_HIBERNATION_PREPARE`` above, because in this case
+	additional work is done between the notifiers and the invocation of PM
+	callbacks for the "freeze" transition.
+
+``PM_SUSPEND_POST_FREEZE``
+	The system is going to suspend and tasks have just been frozen.
+
 ``PM_POST_HIBERNATION``
 	The system memory state has been restored from a hibernation image or an
 	error occurred during hibernation.  Device restore callbacks have been
@@ -54,9 +66,10 @@ will be called upon the following events by the PM core:
 	resume callbacks have been executed and tasks have been thawed.
 
 It is generally assumed that whatever the notifiers do for
-``PM_HIBERNATION_PREPARE``, should be undone for ``PM_POST_HIBERNATION``.
-Analogously, operations carried out for ``PM_SUSPEND_PREPARE`` should be
-reversed for ``PM_POST_SUSPEND``.
+``PM_HIBERNATION_PREPARE`` and ``PM_HIBERNATION_POST_FREEZE``, should be undone
+for ``PM_POST_HIBERNATION``.
+Analogously, operations carried out for ``PM_SUSPEND_PREPARE`` and ``PM_SUSPEND_POST_FREEZE``
+should be reversed for ``PM_POST_SUSPEND``.
 
 Moreover, if one of the notifiers fails for the ``PM_HIBERNATION_PREPARE`` or
 ``PM_SUSPEND_PREPARE`` event, the notifiers that have already succeeded for that
diff --git a/include/linux/suspend.h b/include/linux/suspend.h
index a9d4a9c88115..4a6ad1b22e54 100644
--- a/include/linux/suspend.h
+++ b/include/linux/suspend.h
@@ -443,12 +443,14 @@ static inline int is_hibernate_resume_dev(dev_t dev) { return 0; }
 #endif
 
 /* Hibernation and suspend events */
-#define PM_HIBERNATION_PREPARE	0x0001 /* Going to hibernate */
-#define PM_POST_HIBERNATION	0x0002 /* Hibernation finished */
-#define PM_SUSPEND_PREPARE	0x0003 /* Going to suspend the system */
-#define PM_POST_SUSPEND		0x0004 /* Suspend finished */
-#define PM_RESTORE_PREPARE	0x0005 /* Going to restore a saved image */
-#define PM_POST_RESTORE		0x0006 /* Restore failed */
+#define PM_HIBERNATION_PREPARE		0x0001 /* Going to hibernate */
+#define PM_HIBERNATION_POST_FREEZE	0x0002 /* Prepared for hibernation and tasks have been frozen */
+#define PM_POST_HIBERNATION		0x0003 /* Hibernation finished */
+#define PM_SUSPEND_PREPARE		0x0004 /* Going to suspend the system */
+#define PM_SUSPEND_POST_FREEZE		0x0005 /* Prepared and tasks have been frozen */
+#define PM_POST_SUSPEND			0x0006 /* Suspend finished */
+#define PM_RESTORE_PREPARE		0x0007 /* Going to restore a saved image */
+#define PM_POST_RESTORE			0x0008 /* Restore failed */
 
 extern struct mutex system_transition_mutex;
 
diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c
index 433b50555f35..b64c3d638ef4 100644
--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -836,11 +836,15 @@ int hibernate(void)
 	if (error)
 		goto Exit;
 
+	error = pm_notifier_call_chain_robust(PM_HIBERNATION_POST_FREEZE, PM_POST_HIBERNATION);
+	if (error)
+		goto Thaw;
+
 	lock_device_hotplug();
 	/* Allocate memory management structures */
 	error = create_basic_memory_bitmaps();
 	if (error)
-		goto Thaw;
+		goto Unlock_hotplug;
 
 	error = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);
 	if (error || freezer_test_done)
@@ -888,8 +892,9 @@ int hibernate(void)
 
  Free_bitmaps:
 	free_basic_memory_bitmaps();
- Thaw:
+ Unlock_hotplug:
 	unlock_device_hotplug();
+ Thaw:
 	if (snapshot_test) {
 		pm_pr_dbg("Checking hibernation image\n");
 		error = swsusp_check(false);
diff --git a/kernel/power/suspend.c b/kernel/power/suspend.c
index 72f1c63900a9..2f8a81abf2f8 100644
--- a/kernel/power/suspend.c
+++ b/kernel/power/suspend.c
@@ -540,14 +540,20 @@ static int suspend_prepare(suspend_state_t state)
 	trace_suspend_resume(TPS("freeze_processes"), 0, true);
 	error = suspend_freeze_processes();
 	trace_suspend_resume(TPS("freeze_processes"), 0, false);
-	if (!error)
-		return 0;
+	if (error)
+		goto Unfreeze;
+	error = pm_notifier_call_chain_robust(PM_SUSPEND_POST_FREEZE, PM_POST_SUSPEND);
+	if (error)
+		goto Unfreeze;
+	return 0;
 
+Unfreeze:
 	dpm_save_failed_step(SUSPEND_FREEZE);
 	filesystems_thaw();
 	pm_notifier_call_chain(PM_POST_SUSPEND);
  Restore:
 	pm_restore_console();
+	dpm_save_failed_step(SUSPEND_FREEZE);
 	return error;
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mario Limonciello <mario.limonciello@amd.com>
Date: Thu, 1 May 2025 16:17:33 -0500
Subject: drm/amd: Use suspend and hibernate post freeze notifications

commit 2965e6355dcd ("drm/amd: Add Suspend/Hibernate notification
callback support") introduced a VRAM eviction earlier in the PM
sequences when swap was still available for evicting to. This helped
to fix a number of memory pressure related bugs but also exposed a
new one.

If a userspace process is actively using the GPU when suspend starts
then a deadlock could occur.

Instead of going off the prepare notifier, use the PM notifiers that
occur after processes have been frozen to do evictions.

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4178
Fixes: 2965e6355dcd ("drm/amd: Add Suspend/Hibernate notification callback support")
Signed-off-by: Mario Limonciello <mario.limonciello@amd.com>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index c8459337fcb8..d9e4b3cb230d 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -5043,10 +5043,21 @@ static int amdgpu_device_pm_notifier(struct notifier_block *nb, unsigned long mo
 				     void *data)
 {
 	struct amdgpu_device *adev = container_of(nb, struct amdgpu_device, pm_nb);
+	int r = 0;
 
 	switch (mode) {
-	case PM_HIBERNATION_PREPARE:
+	case PM_HIBERNATION_POST_FREEZE:
 		adev->in_s4 = true;
+		fallthrough;
+	case PM_SUSPEND_POST_FREEZE:
+		r = amdgpu_device_evict_resources(adev);
+		/*
+		 * This is considered non-fatal at this time because
+		 * amdgpu_device_prepare() will also fatally evict resources.
+		 * See https://gitlab.freedesktop.org/drm/amd/-/issues/3781
+		 */
+		if (r)
+			drm_warn(adev_to_drm(adev), "Failed to evict resources, freeze active processes if problems occur: %d\n", r);
 		break;
 	case PM_POST_HIBERNATION:
 		adev->in_s4 = false;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 15 Jul 2025 17:36:53 +0200
Subject: Input: xpad - add new ID for Lenovo Legion Go controllers

The newest firmware update for the Lenovo Legion Go controllers changes
their PID (presumably to match the Go 2 due to backward compatibility).
Add the new PID to the xpad driver to ensure compatibility.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/input/joystick/xpad.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index d72e89c25e50..d2483ce93099 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -319,6 +319,7 @@ static const struct xpad_device {
 	{ 0x1689, 0xfd01, "Razer Onza Classic Edition", 0, XTYPE_XBOX360 },
 	{ 0x1689, 0xfe00, "Razer Sabertooth", 0, XTYPE_XBOX360 },
 	{ 0x17ef, 0x6182, "Lenovo Legion Controller for Windows", 0, XTYPE_XBOX360 },
+	{ 0x17ef, 0x61eb, "Lenovo Legion Controller for Windows", 0, XTYPE_XBOX360 },
 	{ 0x1949, 0x041a, "Amazon Game Controller", 0, XTYPE_XBOX360 },
 	{ 0x1a86, 0xe310, "Legion Go S", 0, XTYPE_XBOX360 },
 	{ 0x1bad, 0x0002, "Harmonix Rock Band Guitar", 0, XTYPE_XBOX360 },
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 16 Jul 2025 19:01:47 +0200
Subject: Input: evdev - allow releasing keys on grab

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/input/evdev.c            | 10 +++---
 drivers/input/input.c            | 52 ++++++++++++++++++--------------
 drivers/input/tests/input_test.c |  6 ++--
 include/linux/input.h            |  2 +-
 4 files changed, 39 insertions(+), 31 deletions(-)

diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c
index 90ff6be85cf4..6e28086165cf 100644
--- a/drivers/input/evdev.c
+++ b/drivers/input/evdev.c
@@ -329,14 +329,14 @@ static void evdev_free(struct device *dev)
  * Grabs an event device (along with underlying input device).
  * This function is called with evdev->mutex taken.
  */
-static int evdev_grab(struct evdev *evdev, struct evdev_client *client)
+static int evdev_grab(struct evdev *evdev, struct evdev_client *client, bool clean)
 {
 	int error;
 
 	if (evdev->grab)
 		return -EBUSY;
 
-	error = input_grab_device(&evdev->handle);
+	error = input_grab_device(&evdev->handle, clean);
 	if (error)
 		return error;
 
@@ -1082,8 +1082,10 @@ static long evdev_do_ioctl(struct file *file, unsigned int cmd,
 		return 0;
 
 	case EVIOCGRAB:
-		if (p)
-			return evdev_grab(evdev, client);
+		if (p == (void *)2)
+			return evdev_grab(evdev, client, true);
+		else if (p)
+			return evdev_grab(evdev, client, false);
 		else
 			return evdev_ungrab(evdev, client);
 
diff --git a/drivers/input/input.c b/drivers/input/input.c
index 1da41324362b..a943d9d9b95d 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -508,29 +508,6 @@ void input_copy_abs(struct input_dev *dst, unsigned int dst_axis,
 }
 EXPORT_SYMBOL(input_copy_abs);
 
-/**
- * input_grab_device - grabs device for exclusive use
- * @handle: input handle that wants to own the device
- *
- * When a device is grabbed by an input handle all events generated by
- * the device are delivered only to this handle. Also events injected
- * by other input handles are ignored while device is grabbed.
- */
-int input_grab_device(struct input_handle *handle)
-{
-	struct input_dev *dev = handle->dev;
-
-	scoped_cond_guard(mutex_intr, return -EINTR, &dev->mutex) {
-		if (dev->grab)
-			return -EBUSY;
-
-		rcu_assign_pointer(dev->grab, handle);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(input_grab_device);
-
 static void __input_release_device(struct input_handle *handle)
 {
 	struct input_dev *dev = handle->dev;
@@ -1769,6 +1746,35 @@ void input_reset_device(struct input_dev *dev)
 }
 EXPORT_SYMBOL(input_reset_device);
 
+/**
+ * input_grab_device - grabs device for exclusive use
+ * @handle: input handle that wants to own the device
+ * @release_keys: whether to release pressed keys before grabbing
+ *
+ * When a device is grabbed by an input handle all events generated by
+ * the device are delivered only to this handle. Also events injected
+ * by other input handles are ignored while device is grabbed.
+ */
+int input_grab_device(struct input_handle *handle, bool release_keys)
+{
+	struct input_dev *dev = handle->dev;
+
+	scoped_cond_guard(mutex_intr, return -EINTR, &dev->mutex) {
+		guard(spinlock_irqsave)(&dev->event_lock);
+
+		if (dev->grab)
+			return -EBUSY;
+
+		if (release_keys && input_dev_release_keys(dev))
+			input_handle_event(dev, EV_SYN, SYN_REPORT, 1);
+
+		rcu_assign_pointer(dev->grab, handle);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(input_grab_device);
+
 static int input_inhibit_device(struct input_dev *dev)
 {
 	guard(mutex)(&dev->mutex);
diff --git a/drivers/input/tests/input_test.c b/drivers/input/tests/input_test.c
index e105ce71a920..ff6d195baf13 100644
--- a/drivers/input/tests/input_test.c
+++ b/drivers/input/tests/input_test.c
@@ -145,18 +145,18 @@ static void input_test_grab(struct kunit *test)
 	handle.dev = input_get_device(input_dev);
 	handle.name = dev_name(&input_dev->dev);
 	handle.handler = &handler;
-	res = input_grab_device(&handle);
+	res = input_grab_device(&handle, false);
 	KUNIT_ASSERT_TRUE(test, res == 0);
 
 	test_handle.dev = input_get_device(input_dev);
 	test_handle.name = dev_name(&input_dev->dev);
 	test_handle.handler = &handler;
-	res = input_grab_device(&test_handle);
+	res = input_grab_device(&test_handle, false);
 	KUNIT_ASSERT_EQ(test, res, -EBUSY);
 
 	input_release_device(&handle);
 	input_put_device(input_dev);
-	res = input_grab_device(&test_handle);
+	res = input_grab_device(&test_handle, false);
 	KUNIT_ASSERT_TRUE(test, res == 0);
 	input_put_device(input_dev);
 }
diff --git a/include/linux/input.h b/include/linux/input.h
index 7d7cb0593a63..ef4dd65d15af 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -420,7 +420,7 @@ int input_handler_for_each_handle(struct input_handler *, void *data,
 int input_register_handle(struct input_handle *);
 void input_unregister_handle(struct input_handle *);
 
-int input_grab_device(struct input_handle *);
+int input_grab_device(struct input_handle *, bool release_keys);
 void input_release_device(struct input_handle *);
 
 int input_open_device(struct input_handle *);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Jul 2025 13:28:12 +0200
Subject: watchdog: reduce error message level to maintain plymouth

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/watchdog/watchdog_dev.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/watchdog/watchdog_dev.c b/drivers/watchdog/watchdog_dev.c
index 8369fd94fc1a..be8d00e0d171 100644
--- a/drivers/watchdog/watchdog_dev.c
+++ b/drivers/watchdog/watchdog_dev.c
@@ -965,7 +965,7 @@ static int watchdog_release(struct inode *inode, struct file *file)
 
 	/* If the watchdog was not stopped, send a keepalive ping */
 	if (err < 0) {
-		pr_crit("watchdog%d: watchdog did not stop!\n", wdd->id);
+		pr_err("watchdog%d: watchdog did not stop!\n", wdd->id);
 		watchdog_ping(wdd);
 	}
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 17 Jul 2025 23:12:32 +0200
Subject: HID: hid-steam: keep evdev connected while steam is active

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hid/hid-steam.c | 18 +++++-------------
 1 file changed, 5 insertions(+), 13 deletions(-)

diff --git a/drivers/hid/hid-steam.c b/drivers/hid/hid-steam.c
index 197126d6e081..09abb62f7f0f 100644
--- a/drivers/hid/hid-steam.c
+++ b/drivers/hid/hid-steam.c
@@ -983,11 +983,11 @@ static int steam_register(struct steam_device *steam)
 	client_opened = steam->client_opened;
 	spin_unlock_irqrestore(&steam->lock, flags);
 
+	ret = steam_input_register(steam);
+	if (ret != 0)
+		goto steam_register_input_fail;
 	if (!client_opened) {
 		steam_set_lizard_mode(steam, lizard_mode);
-		ret = steam_input_register(steam);
-		if (ret != 0)
-			goto steam_register_input_fail;
 		ret = steam_sensors_register(steam);
 		if (ret != 0)
 			goto steam_register_sensors_fail;
@@ -1081,12 +1081,11 @@ static void steam_work_unregister_cb(struct work_struct *work)
 	spin_unlock_irqrestore(&steam->lock, flags);
 
 	if (connected) {
+		steam_input_register(steam);
 		if (opened) {
 			steam_sensors_unregister(steam);
-			steam_input_unregister(steam);
 		} else {
 			steam_set_lizard_mode(steam, lizard_mode);
-			steam_input_register(steam);
 			steam_sensors_register(steam);
 		}
 	}
@@ -1615,9 +1614,6 @@ static void steam_do_deck_input_event(struct steam_device *steam,
 		schedule_delayed_work(&steam->mode_switch, 45 * HZ / 100);
 	}
 
-	if (!steam->gamepad_mode && lizard_mode)
-		return;
-
 	lpad_touched = b10 & BIT(3);
 	rpad_touched = b10 & BIT(4);
 
@@ -1767,8 +1763,6 @@ static int steam_raw_event(struct hid_device *hdev,
 
 	switch (data[2]) {
 	case ID_CONTROLLER_STATE:
-		if (steam->client_opened)
-			return 0;
 		rcu_read_lock();
 		input = rcu_dereference(steam->input);
 		if (likely(input))
@@ -1776,14 +1770,12 @@ static int steam_raw_event(struct hid_device *hdev,
 		rcu_read_unlock();
 		break;
 	case ID_CONTROLLER_DECK_STATE:
-		if (steam->client_opened)
-			return 0;
 		rcu_read_lock();
 		input = rcu_dereference(steam->input);
 		if (likely(input))
 			steam_do_deck_input_event(steam, input, data);
 		sensors = rcu_dereference(steam->sensors);
-		if (likely(sensors))
+		if (!steam->client_opened && likely(sensors))
 			steam_do_deck_sensors_event(steam, sensors, data);
 		rcu_read_unlock();
 		break;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 09:15:05 +0200
Subject: platform/x86: ayaneo-ec: Add Ayaneo Embedded Controller platform
 driver

Recent Ayaneo devices feature an ACPI mapped Embedded Controller (EC)
with standard addresses across models that provides access to fan
speed, fan control, battery charge limits, and controller power
controls. Introduce a new driver stub that will handle these driver
features.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 MAINTAINERS                      |  6 +++
 drivers/platform/x86/Kconfig     |  8 +++
 drivers/platform/x86/Makefile    |  3 ++
 drivers/platform/x86/ayaneo-ec.c | 89 ++++++++++++++++++++++++++++++++
 4 files changed, 106 insertions(+)
 create mode 100644 drivers/platform/x86/ayaneo-ec.c

diff --git a/MAINTAINERS b/MAINTAINERS
index c7ad37d90cbb..3d7056f2886b 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -4129,6 +4129,12 @@ W:	https://ez.analog.com/linux-software-drivers
 F:	Documentation/devicetree/bindings/pwm/adi,axi-pwmgen.yaml
 F:	drivers/pwm/pwm-axi-pwmgen.c
 
+AYANEO PLATFORM EC DRIVER
+M:	Antheas Kapenekakis <lkml@antheas.dev>
+L:	platform-driver-x86@vger.kernel.org
+S:	Maintained
+F:	drivers/platform/x86/ayaneo-ec.c
+
 AZ6007 DVB DRIVER
 M:	Mauro Carvalho Chehab <mchehab@kernel.org>
 L:	linux-media@vger.kernel.org
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 940ae9b9e380..8d42ac9bbc01 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -321,6 +321,14 @@ config ASUS_TF103C_DOCK
 	  If you have an Asus TF103C tablet say Y or M here, for a generic x86
 	  distro config say M here.
 
+config AYANEO_EC
+	tristate "Ayaneo EC platform control"
+	depends on X86
+	help
+		Enables support for the platform EC of Ayaneo devices. This
+		includes fan control, fan speed, charge limit, and magic
+		module support.
+
 config MERAKI_MX100
 	tristate "Cisco Meraki MX100 Platform Driver"
 	depends on GPIOLIB
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 62a763bec617..73bf6fe0934a 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -43,6 +43,9 @@ obj-$(CONFIG_ASUS_TF103C_DOCK)	+= asus-tf103c-dock.o
 obj-$(CONFIG_EEEPC_LAPTOP)	+= eeepc-laptop.o
 obj-$(CONFIG_EEEPC_WMI)		+= eeepc-wmi.o
 
+# Ayaneo
+obj-$(CONFIG_AYANEO_EC)		+= ayaneo-ec.o
+
 # Cisco/Meraki
 obj-$(CONFIG_MERAKI_MX100)	+= meraki-mx100.o
 
diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
new file mode 100644
index 000000000000..55ae9a5cbd47
--- /dev/null
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Platform driver for the Embedded Controller (EC) of Ayaneo devices. Handles
+ * hwmon (fan speed, fan control), battery charge limits, and magic module
+ * control (connected modules, controller disconnection).
+ * 
+ * Copyright (C) 2025 Antheas Kapenekakis <lkml@antheas.dev>
+ */
+
+#include <linux/dmi.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+struct ayaneo_ec_quirk {
+};
+
+struct ayaneo_ec_platform_data {
+	struct platform_device *pdev;
+	struct ayaneo_ec_quirk *quirks;
+};
+
+static const struct ayaneo_ec_quirk ayaneo3 = {
+};
+
+static const struct dmi_system_id dmi_table[] = {
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AYANEO 3"),
+		},
+		.driver_data = (void *)&ayaneo3,
+	},
+	{},
+};
+
+static int ayaneo_ec_probe(struct platform_device *pdev)
+{
+	const struct dmi_system_id *dmi_entry;
+	struct ayaneo_ec_platform_data *data;
+
+	dmi_entry = dmi_first_match(dmi_table);
+	if (!dmi_entry)
+		return -ENODEV;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->pdev = pdev;
+	data->quirks = dmi_entry->driver_data;
+	platform_set_drvdata(pdev, data);
+
+	return 0;
+}
+
+static struct platform_driver ayaneo_platform_driver = {
+	.driver = {
+		.name = "ayaneo-ec",
+	},
+	.probe = ayaneo_ec_probe,
+};
+
+static struct platform_device *ayaneo_platform_device;
+
+static int __init ayaneo_ec_init(void)
+{
+	ayaneo_platform_device =
+		platform_create_bundle(&ayaneo_platform_driver,
+				       ayaneo_ec_probe, NULL, 0, NULL, 0);
+
+	return PTR_ERR_OR_ZERO(ayaneo_platform_device);
+}
+
+static void __exit ayaneo_ec_exit(void)
+{
+	platform_device_unregister(ayaneo_platform_device);
+	platform_driver_unregister(&ayaneo_platform_driver);
+}
+
+MODULE_DEVICE_TABLE(dmi, dmi_table);
+
+module_init(ayaneo_ec_init);
+module_exit(ayaneo_ec_exit);
+
+MODULE_AUTHOR("Antheas Kapenekakis <lkml@antheas.dev>");
+MODULE_DESCRIPTION("Ayaneo Embedded Controller (EC) platform features");
+MODULE_LICENSE("GPL");
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 02:39:41 +0200
Subject: platform/x86: ayaneo-ec: Add hwmon support

Add hwmon single fan sensor reads and control for Ayaneo devices.
The register and method of access is the same for all devices.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig     |   2 +
 drivers/platform/x86/ayaneo-ec.c | 132 +++++++++++++++++++++++++++++++
 2 files changed, 134 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 8d42ac9bbc01..d7110698be46 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -324,6 +324,8 @@ config ASUS_TF103C_DOCK
 config AYANEO_EC
 	tristate "Ayaneo EC platform control"
 	depends on X86
+	depends on ACPI_EC
+	depends on HWMON
 	help
 		Enables support for the platform EC of Ayaneo devices. This
 		includes fan control, fan speed, charge limit, and magic
diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index 55ae9a5cbd47..ede8fa063ef4 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -7,13 +7,23 @@
  * Copyright (C) 2025 Antheas Kapenekakis <lkml@antheas.dev>
  */
 
+#include <linux/acpi.h>
 #include <linux/dmi.h>
+#include <linux/hwmon.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 
+#define AYANEO_PWM_ENABLE_REG	 0x4A
+#define AYANEO_PWM_REG		 0x4B
+#define AYANEO_PWM_MODE_AUTO	 0x00
+#define AYANEO_PWM_MODE_MANUAL	 0x01
+
+#define AYANEO_FAN_REG		 0x76
+
 struct ayaneo_ec_quirk {
+	bool has_fan_control;
 };
 
 struct ayaneo_ec_platform_data {
@@ -22,6 +32,7 @@ struct ayaneo_ec_platform_data {
 };
 
 static const struct ayaneo_ec_quirk ayaneo3 = {
+	.has_fan_control = true,
 };
 
 static const struct dmi_system_id dmi_table[] = {
@@ -35,10 +46,124 @@ static const struct dmi_system_id dmi_table[] = {
 	{},
 };
 
+/* Callbacks for hwmon interface */
+static umode_t ayaneo_ec_hwmon_is_visible(const void *drvdata,
+				       enum hwmon_sensor_types type, u32 attr,
+				       int channel)
+{
+	switch (type) {
+	case hwmon_fan:
+		return 0444;
+	case hwmon_pwm:
+		return 0644;
+	default:
+		return 0;
+	}
+}
+
+static int ayaneo_ec_read(struct device *dev, enum hwmon_sensor_types type,
+			     u32 attr, int channel, long *val)
+{
+	u8 tmp;
+	int ret;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			ret = ec_read(AYANEO_FAN_REG, &tmp);
+			if (ret)
+				return ret;
+			*val = tmp << 8;
+			ret = ec_read(AYANEO_FAN_REG + 1, &tmp);
+			if (ret)
+				return ret;
+			*val += tmp;
+			return 0;
+		default:
+			break;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			ret = ec_read(AYANEO_PWM_REG, &tmp);
+			if (ret)
+				return ret;
+			*val = (255 * tmp) / 100;
+			if (*val < 0 || *val > 255)
+				return -EINVAL;
+			return 0;
+		case hwmon_pwm_enable:
+			ret = ec_read(AYANEO_PWM_ENABLE_REG, &tmp);
+			if (ret)
+				return ret;
+			if (tmp == AYANEO_PWM_MODE_MANUAL)
+				*val = 1;
+			else
+				*val = 2;
+			return 0;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+
+static int ayaneo_ec_write(struct device *dev, enum hwmon_sensor_types type,
+			      u32 attr, int channel, long val)
+{
+	switch (type) {
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_enable:
+			if (val == 1)
+				return ec_write(AYANEO_PWM_ENABLE_REG,
+						AYANEO_PWM_MODE_MANUAL);
+			else if (val == 2)
+				return ec_write(AYANEO_PWM_ENABLE_REG,
+						AYANEO_PWM_MODE_AUTO);
+			else
+				return -EINVAL;
+		case hwmon_pwm_input:
+			if (val < 0 || val > 255)
+				return -EINVAL;
+			return ec_write(AYANEO_PWM_REG, (val * 100) / 255);
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops ayaneo_ec_hwmon_ops = {
+	.is_visible = ayaneo_ec_hwmon_is_visible,
+	.read = ayaneo_ec_read,
+	.write = ayaneo_ec_write,
+};
+
+static const struct hwmon_channel_info *const ayaneo_ec_sensors[] = {
+	HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),
+	HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE),
+	NULL,
+};
+
+static const struct hwmon_chip_info ayaneo_ec_chip_info = {
+	.ops = &ayaneo_ec_hwmon_ops,
+	.info = ayaneo_ec_sensors,
+};
+
 static int ayaneo_ec_probe(struct platform_device *pdev)
 {
 	const struct dmi_system_id *dmi_entry;
 	struct ayaneo_ec_platform_data *data;
+	struct device *hwdev;
 
 	dmi_entry = dmi_first_match(dmi_table);
 	if (!dmi_entry)
@@ -52,6 +177,13 @@ static int ayaneo_ec_probe(struct platform_device *pdev)
 	data->quirks = dmi_entry->driver_data;
 	platform_set_drvdata(pdev, data);
 
+	if (data->quirks->has_fan_control) {
+		hwdev = devm_hwmon_device_register_with_info(
+			&pdev->dev, "ayaneo_ec", NULL, &ayaneo_ec_chip_info, NULL);
+		if (IS_ERR(hwdev))
+			return PTR_ERR(hwdev);
+	}
+
 	return 0;
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 03:01:30 +0200
Subject: platform/x86: ayaneo-ec: Add charge control support

Ayaneo devices support charge inhibition via the EC. This inhibition
only works while the device is powered on, and resets between restarts.
However, it is maintained across suspend/resume cycles.

The EC does not support charge threshold control. Instead, userspace
software on Windows manually toggles charge inhibition depending on
battery level.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig     |   1 +
 drivers/platform/x86/ayaneo-ec.c | 110 +++++++++++++++++++++++++++++++
 2 files changed, 111 insertions(+)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index d7110698be46..5fef6a0df688 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -325,6 +325,7 @@ config AYANEO_EC
 	tristate "Ayaneo EC platform control"
 	depends on X86
 	depends on ACPI_EC
+	depends on ACPI_BATTERY
 	depends on HWMON
 	help
 		Enables support for the platform EC of Ayaneo devices. This
diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index ede8fa063ef4..ec3583e94b99 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <acpi/battery.h>
 
 #define AYANEO_PWM_ENABLE_REG	 0x4A
 #define AYANEO_PWM_REG		 0x4B
@@ -22,17 +23,27 @@
 
 #define AYANEO_FAN_REG		 0x76
 
+#define EC_CHARGE_CONTROL_BEHAVIOURS                         \
+	(BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO) |           \
+	 BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE))
+#define AYANEO_CHARGE_REG		0x1e
+#define AYANEO_CHARGE_VAL_AUTO		0xaa
+#define AYANEO_CHARGE_VAL_INHIBIT	0x55
+
 struct ayaneo_ec_quirk {
 	bool has_fan_control;
+	bool has_charge_control;
 };
 
 struct ayaneo_ec_platform_data {
 	struct platform_device *pdev;
 	struct ayaneo_ec_quirk *quirks;
+	struct acpi_battery_hook battery_hook;
 };
 
 static const struct ayaneo_ec_quirk ayaneo3 = {
 	.has_fan_control = true,
+	.has_charge_control = true,
 };
 
 static const struct dmi_system_id dmi_table[] = {
@@ -159,6 +170,96 @@ static const struct hwmon_chip_info ayaneo_ec_chip_info = {
 	.info = ayaneo_ec_sensors,
 };
 
+static int ayaneo_psy_ext_get_prop(struct power_supply *psy,
+				const struct power_supply_ext *ext,
+				void *data,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	int ret;
+	u8 tmp;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR:
+		ret = ec_read(AYANEO_CHARGE_REG, &tmp);
+		if (ret)
+			return ret;
+
+		if (tmp == AYANEO_CHARGE_VAL_INHIBIT)
+			val->intval = POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE;
+		else
+			val->intval = POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ayaneo_psy_ext_set_prop(struct power_supply *psy,
+				const struct power_supply_ext *ext,
+				void *data,
+				enum power_supply_property psp,
+				const union power_supply_propval *val)
+{
+	u8 raw_val;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR:
+		switch (val->intval) {
+		case POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO:
+			raw_val = AYANEO_CHARGE_VAL_AUTO;
+			break;
+		case POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE:
+			raw_val = AYANEO_CHARGE_VAL_INHIBIT;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return ec_write(AYANEO_CHARGE_REG, raw_val);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ayaneo_psy_prop_is_writeable(struct power_supply *psy,
+				     const struct power_supply_ext *ext,
+				     void *data,
+				     enum power_supply_property psp)
+{
+	return true;
+}
+
+static const enum power_supply_property ayaneo_psy_ext_props[] = {
+	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR,
+};
+
+static const struct power_supply_ext ayaneo_psy_ext = {
+	.name			= "ayaneo-charge-control",
+	.properties		= ayaneo_psy_ext_props,
+	.num_properties		= ARRAY_SIZE(ayaneo_psy_ext_props),
+	.charge_behaviours	= EC_CHARGE_CONTROL_BEHAVIOURS,
+	.get_property		= ayaneo_psy_ext_get_prop,
+	.set_property		= ayaneo_psy_ext_set_prop,
+	.property_is_writeable	= ayaneo_psy_prop_is_writeable,
+};
+
+static int ayaneo_add_battery(struct power_supply *battery,
+			   struct acpi_battery_hook *hook)
+{
+	struct ayaneo_ec_platform_data *data =
+		container_of(hook, struct ayaneo_ec_platform_data, battery_hook);
+
+	return power_supply_register_extension(battery, &ayaneo_psy_ext,
+					       &data->pdev->dev, NULL);
+}
+
+static int ayaneo_remove_battery(struct power_supply *battery,
+			      struct acpi_battery_hook *hook)
+{
+	power_supply_unregister_extension(battery, &ayaneo_psy_ext);
+	return 0;
+}
+
 static int ayaneo_ec_probe(struct platform_device *pdev)
 {
 	const struct dmi_system_id *dmi_entry;
@@ -184,6 +285,15 @@ static int ayaneo_ec_probe(struct platform_device *pdev)
 			return PTR_ERR(hwdev);
 	}
 
+	if (data->quirks->has_charge_control) {
+		data->battery_hook.add_battery = ayaneo_add_battery;
+		data->battery_hook.remove_battery = ayaneo_remove_battery;
+		data->battery_hook.name = "Ayaneo Battery";
+		int ret = devm_battery_hook_register(&pdev->dev, &data->battery_hook);
+		if (ret)
+			return ret;
+	}
+
 	return 0;
 }
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 10:17:30 +0200
Subject: platform/x86: ayaneo-ec: Add controller power and modules attributes

The Ayaneo 3 features hot-swappable controller modules. The ejection
and management is done through HID. However, after ejecting the modules,
the controller needs to be power cycled via the EC to re-initialize.

For this, the EC provides a variable that holds whether the left or
right modules are connected, and a power control register to turn
the controller on or off. After ejecting the modules, the controller
should be turned off. Then, after both modules are reinserted,
the controller may be powered on again to re-initialize.

This patch introduces two new firmware attributes:
 - `controller_modules`: a read-only attribute that indicates whether
   the left and right modules are connected (none, left, right, both).
 - `controller_power`: a read-write attribute that allows the user
   to turn the controller on or off (with 'on'/'off').

Therefore, after ejection is complete, userspace can power off the
controller, then wait until both modules have been reinserted
(`controller_modules` will return 'both') to turn on the controller.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/ayaneo-ec.c | 238 ++++++++++++++++++++++++++++++-
 1 file changed, 236 insertions(+), 2 deletions(-)

diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index ec3583e94b99..eb19307e5818 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -16,6 +16,10 @@
 #include <linux/platform_device.h>
 #include <acpi/battery.h>
 
+#include "firmware_attributes_class.h"
+
+#define DRIVER_NAME "ayaneo-ec" 
+
 #define AYANEO_PWM_ENABLE_REG	 0x4A
 #define AYANEO_PWM_REG		 0x4B
 #define AYANEO_PWM_MODE_AUTO	 0x00
@@ -30,20 +34,60 @@
 #define AYANEO_CHARGE_VAL_AUTO		0xaa
 #define AYANEO_CHARGE_VAL_INHIBIT	0x55
 
+#define AYANEO_POWER_REG	0x2d
+#define AYANEO_POWER_OFF	0xfe
+#define AYANEO_POWER_ON		0xff
+#define AYANEO_MODULE_REG	0x2f
+#define AYANEO_MODULE_LEFT	BIT(0)
+#define AYANEO_MODULE_RIGHT	BIT(1)
+
+enum ayaneo_fw_attr_id {
+	AYANEO_ATTR_CONTROLLER_MODULES,
+	AYANEO_ATTR_CONTROLLER_POWER,
+};
+
+static const char *const ayaneo_fw_attr_name[] = {
+	[AYANEO_ATTR_CONTROLLER_MODULES] = "controller_modules",
+	[AYANEO_ATTR_CONTROLLER_POWER] = "controller_power",
+};
+
+static const char *const ayaneo_fw_attr_desc[] = {
+	[AYANEO_ATTR_CONTROLLER_MODULES] =
+		"Which controller Magic Modules are connected (none, left, right, both)",
+	[AYANEO_ATTR_CONTROLLER_POWER] = "Controller power state (on, off)",
+};
+
+#define AYANEO_ATTR_ENUM_MAX_ATTRS 7
+#define AYANEO_ATTR_LANGUAGE_CODE "en_US.UTF-8"
+
 struct ayaneo_ec_quirk {
 	bool has_fan_control;
 	bool has_charge_control;
+	bool has_magic_modules;
+	bool has_controller_power;
 };
 
 struct ayaneo_ec_platform_data {
 	struct platform_device *pdev;
 	struct ayaneo_ec_quirk *quirks;
 	struct acpi_battery_hook battery_hook;
+	struct device *fw_attrs_dev;
+	struct kset *fw_attrs_kset;
+};
+
+struct ayaneo_fw_attr {
+	struct ayaneo_ec_platform_data *data;
+	enum ayaneo_fw_attr_id fw_attr_id;
+	struct attribute_group attr_group;
+	struct kobj_attribute display_name;
+	struct kobj_attribute current_value;
 };
 
 static const struct ayaneo_ec_quirk ayaneo3 = {
 	.has_fan_control = true,
 	.has_charge_control = true,
+	.has_magic_modules = true,
+	.has_controller_power = true,
 };
 
 static const struct dmi_system_id dmi_table[] = {
@@ -260,11 +304,165 @@ static int ayaneo_remove_battery(struct power_supply *battery,
 	return 0;
 }
 
+static void ayaneo_kset_unregister(void *data)
+{
+	struct kset *kset = data;
+
+	kset_unregister(kset);
+}
+
+static void ayaneo_fw_attrs_dev_unregister(void *data)
+{
+	struct device *fw_attrs_dev = data;
+
+	device_unregister(fw_attrs_dev);
+}
+
+static ssize_t display_name_language_code_show(struct kobject *kobj,
+					       struct kobj_attribute *attr,
+					       char *buf)
+{
+	return sysfs_emit(buf, "%s\n", AYANEO_ATTR_LANGUAGE_CODE);
+}
+
+static struct kobj_attribute fw_attr_display_name_language_code =
+	__ATTR_RO(display_name_language_code);
+
+static ssize_t display_name_show(struct kobject *kobj,
+				 struct kobj_attribute *attr, char *buf)
+{
+	struct ayaneo_fw_attr *fw_attr =
+		container_of(attr, struct ayaneo_fw_attr, display_name);
+
+	return sysfs_emit(buf, "%s\n", ayaneo_fw_attr_desc[fw_attr->fw_attr_id]);
+}
+
+static ssize_t current_value_show(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	struct ayaneo_fw_attr *fw_attr =
+		container_of(attr, struct ayaneo_fw_attr, current_value);
+	bool left, right;
+	char *out;
+	int ret;
+	u8 tmp;
+
+	switch (fw_attr->fw_attr_id) {
+	case AYANEO_ATTR_CONTROLLER_MODULES:
+		ret = ec_read(AYANEO_MODULE_REG, &tmp);
+		if (ret)
+			return ret;
+		left = !(tmp & AYANEO_MODULE_LEFT);
+		right = !(tmp & AYANEO_MODULE_RIGHT);
+
+		if (left && right)
+			out = "both";
+		else if (left)
+			out = "left";
+		else if (right)
+			out = "right";
+		else
+			out = "none";
+
+		return sysfs_emit(buf, "%s\n", out);
+	case AYANEO_ATTR_CONTROLLER_POWER:
+		ret = ec_read(AYANEO_POWER_REG, &tmp);
+		if (ret)
+			return ret;
+
+		if (tmp == AYANEO_POWER_OFF)
+			out = "off";
+		else
+			out = "on";
+
+		return sysfs_emit(buf, "%s\n", out);
+	}
+	return -EINVAL;
+}
+
+static ssize_t current_value_store(struct kobject *kobj,
+				   struct kobj_attribute *attr, const char *buf,
+				   size_t count)
+{
+	struct ayaneo_fw_attr *fw_attr =
+		container_of(attr, struct ayaneo_fw_attr, current_value);
+	int ret;
+
+	switch (fw_attr->fw_attr_id) {
+	case AYANEO_ATTR_CONTROLLER_POWER:
+		if (sysfs_streq(buf, "on"))
+			ret = ec_write(AYANEO_POWER_REG, AYANEO_POWER_ON);
+		else if (sysfs_streq(buf, "off"))
+			ret = ec_write(AYANEO_POWER_REG, AYANEO_POWER_OFF);
+		if (ret)
+			return ret;
+		return count;
+	case AYANEO_ATTR_CONTROLLER_MODULES:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static ssize_t type_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	return sysfs_emit(buf, "string\n");
+}
+
+static struct kobj_attribute fw_attr_type_string = {
+	.attr = { .name = "type", .mode = 0444 },
+	.show = type_show,
+};
+
+static int ayaneo_fw_attr_init(struct ayaneo_ec_platform_data *data,
+			       const enum ayaneo_fw_attr_id fw_attr_id,
+			       bool read_only)
+{
+	struct ayaneo_fw_attr *fw_attr;
+	struct attribute **attrs;
+	int idx = 0;
+
+	fw_attr = devm_kzalloc(&data->pdev->dev, sizeof(*fw_attr), GFP_KERNEL);
+	if (!fw_attr)
+		return -ENOMEM;
+
+	attrs = devm_kcalloc(&data->pdev->dev, AYANEO_ATTR_ENUM_MAX_ATTRS + 1,
+			     sizeof(*attrs), GFP_KERNEL);
+	if (!attrs)
+		return -ENOMEM;
+
+	fw_attr->data = data;
+	fw_attr->fw_attr_id = fw_attr_id;
+	fw_attr->attr_group.name = ayaneo_fw_attr_name[fw_attr_id];
+	fw_attr->attr_group.attrs = attrs;
+
+	attrs[idx++] = &fw_attr_type_string.attr;
+	attrs[idx++] = &fw_attr_display_name_language_code.attr;
+
+	sysfs_attr_init(&fw_attr->display_name.attr);
+	fw_attr->display_name.attr.name = "display_name";
+	fw_attr->display_name.attr.mode = 0444;
+	fw_attr->display_name.show = display_name_show;
+	attrs[idx++] = &fw_attr->display_name.attr;
+
+	sysfs_attr_init(&fw_attr->current_value.attr);
+	fw_attr->current_value.attr.name = "current_value";
+	fw_attr->current_value.attr.mode = read_only ? 0444 : 0644;
+	fw_attr->current_value.show = current_value_show;
+	fw_attr->current_value.store = current_value_store;
+	attrs[idx++] = &fw_attr->current_value.attr;
+
+	attrs[idx] = NULL;
+	return sysfs_create_group(&data->fw_attrs_kset->kobj,
+				  &fw_attr->attr_group);
+}
+
 static int ayaneo_ec_probe(struct platform_device *pdev)
 {
 	const struct dmi_system_id *dmi_entry;
 	struct ayaneo_ec_platform_data *data;
 	struct device *hwdev;
+	int ret;
 
 	dmi_entry = dmi_first_match(dmi_table);
 	if (!dmi_entry)
@@ -289,9 +487,45 @@ static int ayaneo_ec_probe(struct platform_device *pdev)
 		data->battery_hook.add_battery = ayaneo_add_battery;
 		data->battery_hook.remove_battery = ayaneo_remove_battery;
 		data->battery_hook.name = "Ayaneo Battery";
-		int ret = devm_battery_hook_register(&pdev->dev, &data->battery_hook);
+		ret = devm_battery_hook_register(&pdev->dev, &data->battery_hook);
+		if (ret)
+			return ret;
+	}
+
+	if (data->quirks->has_magic_modules || data->quirks->has_controller_power) {
+		data->fw_attrs_dev = device_create(&firmware_attributes_class, NULL,
+						MKDEV(0, 0), NULL, "%s",
+						DRIVER_NAME);
+		if (IS_ERR(data->fw_attrs_dev))
+			return PTR_ERR(data->fw_attrs_dev);
+
+		ret = devm_add_action_or_reset(&data->pdev->dev,
+					ayaneo_fw_attrs_dev_unregister,
+					data->fw_attrs_dev);
 		if (ret)
 			return ret;
+
+		data->fw_attrs_kset = kset_create_and_add("attributes", NULL,
+							&data->fw_attrs_dev->kobj);
+		if (!data->fw_attrs_kset)
+			return -ENOMEM;
+
+		ret = devm_add_action_or_reset(&data->pdev->dev, ayaneo_kset_unregister,
+					data->fw_attrs_kset);
+
+		if (data->quirks->has_magic_modules) {
+			ret = ayaneo_fw_attr_init(
+				data, AYANEO_ATTR_CONTROLLER_MODULES, true);
+			if (ret)
+				return ret;
+		}
+
+		if (data->quirks->has_controller_power) {
+			ret = ayaneo_fw_attr_init(
+				data, AYANEO_ATTR_CONTROLLER_POWER, false);
+			if (ret)
+				return ret;
+		}
 	}
 
 	return 0;
@@ -299,7 +533,7 @@ static int ayaneo_ec_probe(struct platform_device *pdev)
 
 static struct platform_driver ayaneo_platform_driver = {
 	.driver = {
-		.name = "ayaneo-ec",
+		.name = DRIVER_NAME,
 	},
 	.probe = ayaneo_ec_probe,
 };
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 16:43:53 +0200
Subject: platform/x86: ayaneo-ec: Move Ayaneo devices from oxpec to ayaneo-ec

Currently, the oxpec driver contains Ayaneo devices. Move them to the
new ayaneo-ec driver, which is dedicated to them.

As this driver supports charge inhibition for Ayaneo, add support for it
for the AIR, AIR 1S, AB05-Medoncino, AIR Pro, and Kun, referenced from the
out-of-tree ayaneo-platform driver.

Link: https://github.com/ShadowBlip/ayaneo-platform
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/Kconfig     |   4 +-
 drivers/platform/x86/ayaneo-ec.c |  66 ++++++++++++++++++
 drivers/platform/x86/oxpec.c     | 115 +------------------------------
 3 files changed, 68 insertions(+), 117 deletions(-)

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 5fef6a0df688..afd7e68395a2 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -1049,9 +1049,7 @@ config OXP_EC
 	help
 		Enables support for the platform EC of OneXPlayer and AOKZOE
 		handheld devices. This includes fan speed, fan controls, and
-		disabling the default TDP behavior of the device. Due to legacy
-		reasons, this driver also provides hwmon functionality to Ayaneo
-		devices and the OrangePi Neo.
+		disabling the default TDP behavior of the device.
 
 source "drivers/platform/x86/tuxedo/Kconfig"
 
diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index eb19307e5818..189748ae338c 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -83,6 +83,15 @@ struct ayaneo_fw_attr {
 	struct kobj_attribute current_value;
 };
 
+static const struct ayaneo_ec_quirk quirk_fan = {
+	.has_fan_control = true,
+};
+
+static const struct ayaneo_ec_quirk quirk_charge_limit = {
+	.has_fan_control = true,
+	.has_charge_control = true,
+};
+
 static const struct ayaneo_ec_quirk ayaneo3 = {
 	.has_fan_control = true,
 	.has_charge_control = true,
@@ -91,6 +100,63 @@ static const struct ayaneo_ec_quirk ayaneo3 = {
 };
 
 static const struct dmi_system_id dmi_table[] = {
+
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_MATCH(DMI_BOARD_NAME, "AYANEO 2"),
+		},
+		.driver_data = (void *)&quirk_fan,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_MATCH(DMI_BOARD_NAME, "FLIP"),
+		},
+		.driver_data = (void *)&quirk_fan,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_MATCH(DMI_BOARD_NAME, "GEEK"),
+		},
+		.driver_data = (void *)&quirk_fan,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR"),
+		},
+		.driver_data = (void *)&quirk_charge_limit,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR 1S"),
+		},
+		.driver_data = (void *)&quirk_charge_limit,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AB05-Mendocino"),
+		},
+		.driver_data = (void *)&quirk_charge_limit,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR Pro"),
+		},
+		.driver_data = (void *)&quirk_charge_limit,
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "KUN"),
+		},
+		.driver_data = (void *)&quirk_charge_limit,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index 54377b282ff8..144a454103b9 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -1,8 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * Platform driver for OneXPlayer and AOKZOE devices. For the time being,
- * it also exposes fan controls for AYANEO, and OrangePi Handhelds via
- * hwmon sysfs.
+ * Platform driver for OneXPlayer and AOKZOE devices.
  *
  * Fan control is provided via pwm interface in the range [0-255].
  * Old AMD boards use [0-100] as range in the EC, the written value is
@@ -43,14 +41,6 @@ static bool unlock_global_acpi_lock(void)
 
 enum oxp_board {
 	aok_zoe_a1 = 1,
-	aya_neo_2,
-	aya_neo_air,
-	aya_neo_air_1s,
-	aya_neo_air_plus_mendo,
-	aya_neo_air_pro,
-	aya_neo_flip,
-	aya_neo_geek,
-	aya_neo_kun,
 	orange_pi_neo,
 	oxp_2,
 	oxp_fly,
@@ -131,62 +121,6 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)oxp_fly,
 	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_MATCH(DMI_BOARD_NAME, "AYANEO 2"),
-		},
-		.driver_data = (void *)aya_neo_2,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR"),
-		},
-		.driver_data = (void *)aya_neo_air,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR 1S"),
-		},
-		.driver_data = (void *)aya_neo_air_1s,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AB05-Mendocino"),
-		},
-		.driver_data = (void *)aya_neo_air_plus_mendo,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR Pro"),
-		},
-		.driver_data = (void *)aya_neo_air_pro,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_MATCH(DMI_BOARD_NAME, "FLIP"),
-		},
-		.driver_data = (void *)aya_neo_flip,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_MATCH(DMI_BOARD_NAME, "GEEK"),
-		},
-		.driver_data = (void *)aya_neo_geek,
-	},
-	{
-		.matches = {
-			DMI_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
-			DMI_EXACT_MATCH(DMI_BOARD_NAME, "KUN"),
-		},
-		.driver_data = (void *)aya_neo_kun,
-	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "OrangePi"),
@@ -672,13 +606,6 @@ static int oxp_pwm_enable(void)
 	case orange_pi_neo:
 		return write_to_ec(ORANGEPI_SENSOR_PWM_ENABLE_REG, PWM_MODE_MANUAL);
 	case aok_zoe_a1:
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_2:
 	case oxp_fly:
 	case oxp_mini_amd:
@@ -699,14 +626,6 @@ static int oxp_pwm_disable(void)
 	case orange_pi_neo:
 		return write_to_ec(ORANGEPI_SENSOR_PWM_ENABLE_REG, PWM_MODE_AUTO);
 	case aok_zoe_a1:
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_1s:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_2:
 	case oxp_fly:
 	case oxp_mini_amd:
@@ -727,14 +646,6 @@ static int oxp_pwm_read(long *val)
 	case orange_pi_neo:
 		return read_from_ec(ORANGEPI_SENSOR_PWM_ENABLE_REG, 1, val);
 	case aok_zoe_a1:
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_1s:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_2:
 	case oxp_fly:
 	case oxp_mini_amd:
@@ -774,14 +685,6 @@ static int oxp_pwm_fan_speed(long *val)
 	case oxp_g1_i:
 		return read_from_ec(OXP_2_SENSOR_FAN_REG, 2, val);
 	case aok_zoe_a1:
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_1s:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_fly:
 	case oxp_mini_amd:
 	case oxp_mini_amd_a07:
@@ -810,14 +713,6 @@ static int oxp_pwm_input_write(long val)
 		/* scale to range [0-184] */
 		val = (val * 184) / 255;
 		return write_to_ec(OXP_SENSOR_PWM_REG, val);
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_1s:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_mini_amd:
 	case oxp_mini_amd_a07:
 		/* scale to range [0-100] */
@@ -854,14 +749,6 @@ static int oxp_pwm_input_read(long *val)
 		/* scale from range [0-184] */
 		*val = (*val * 255) / 184;
 		break;
-	case aya_neo_2:
-	case aya_neo_air:
-	case aya_neo_air_1s:
-	case aya_neo_air_plus_mendo:
-	case aya_neo_air_pro:
-	case aya_neo_flip:
-	case aya_neo_geek:
-	case aya_neo_kun:
 	case oxp_mini_amd:
 	case oxp_mini_amd_a07:
 		ret = read_from_ec(OXP_SENSOR_PWM_REG, 1, val);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 20 Aug 2025 16:49:11 +0200
Subject: [TMP] platform/x86: ayaneo-ec: Remove charge inhibition for other
 devices

On Bazzite, charge inhibition is currently provided by the oot
ayaneo-platform driver. To avoid stacking modules, remove the support
from the ayaneo-ec driver.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/ayaneo-ec.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index 189748ae338c..dd62f1f38132 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -89,7 +89,6 @@ static const struct ayaneo_ec_quirk quirk_fan = {
 
 static const struct ayaneo_ec_quirk quirk_charge_limit = {
 	.has_fan_control = true,
-	.has_charge_control = true,
 };
 
 static const struct ayaneo_ec_quirk ayaneo3 = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 3 Aug 2025 05:16:39 +0200
Subject: ACPI: EC: Set ec_no_wakeup for MSI Claw A8

Same panel as the Legion Go S, and is an AMD variant.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/ec.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c
index 7855bbf752b1..ad39393cddf9 100644
--- a/drivers/acpi/ec.c
+++ b/drivers/acpi/ec.c
@@ -2350,6 +2350,15 @@ static const struct dmi_system_id acpi_ec_no_wakeup[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "83Q3"),
 		}
 	},
+	/*
+	 * MSI Claw A8. Similar issue to Legion Go S (and same screen)
+	 */
+	{
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Micro-Star International Co., Ltd."),
+			DMI_MATCH(DMI_BOARD_NAME, "MS-1T8K"),
+		}
+	},
 	{
 		// TUXEDO InfinityBook Pro AMD Gen9
 		.matches = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Mon, 11 Aug 2025 17:43:46 +0200
Subject: drm/amdgpu/vpe: increase VPE_IDLE_TIMEOUT to fix hang on Strix Halo

On the Asus Z13 2025, which uses a Strix Halo platform, around 8% of the
suspend resumes result in a soft lock around 1 second after the screen
turns on (it freezes). This happens due to power gating VPE when it is
not used, which happens 1 second after inactivity.

Specifically, the VPE gating after resume is as follows: an initial
ungate, followed by a gate in the resume process. Then,
amdgpu_device_delayed_init_work_handler with a delay of 2s is scheduled
to run tests, one of which is testing VPE in vpe_ring_test_ib. This
causes an ungate, After that test, vpe_idle_work_handler is scheduled
with VPE_IDLE_TIMEOUT (1s).

When vpe_idle_work_handler runs and tries to gate VPE, it causes the
SMU to hang and partially freezes half of the GPU IPs, with the thread
that called the command being stuck processing it.

Specifically, after that SMU command tries to run, we get the following:

snd_hda_intel 0000:c4:00.1: Refused to change power state from D0 to D3hot
...
xhci_hcd 0000:c4:00.4: Refused to change power state from D0 to D3hot
...
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VPE!
[drm:vpe_set_powergating_state [amdgpu]] *ERROR* Dpm disable vpe failed, ret = -62.
amdgpu 0000:c4:00.0: [drm] *ERROR* [CRTC:93:crtc-0] flip_done timed out
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate JPEG!
[drm:jpeg_v4_0_5_set_powergating_state [amdgpu]] *ERROR* Dpm disable jpeg failed, ret = -62.
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VCN instance 0!
[drm:vcn_v4_0_5_stop [amdgpu]] *ERROR* Dpm disable uvd failed, ret = -62.
thunderbolt 0000:c6:00.5: 0: timeout reading config space 1 from 0xd3
thunderbolt 0000:c6:00.5: 0: timeout reading config space 2 from 0x5
thunderbolt 0000:c6:00.5: Refused to change power state from D0 to D3hot
amdgpu 0000:c4:00.0: [drm] *ERROR* [CRTC:97:crtc-1] flip_done timed out
amdgpu 0000:c4:00.0: amdgpu: SMU: I'm not done with your previous command: SMN_C2PMSG_66:0x00000032 SMN_C2PMSG_82:0x00000000
amdgpu 0000:c4:00.0: amdgpu: Failed to power gate VCN instance 1!

In addition to e.g., kwin errors in journalctl. 0000:c4.00.0 is the GPU.
Interestingly, 0000:c4.00.6, which is another HDA block, 0000:c4.00.5,
a PCI controller, and 0000:c4.00.2, resume normally. 0x00000032 is the
PowerDownVpe(50) command which is the common failure point in all
failed resumes.

On a normal resume, we should get the following power gates:
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVpe(50) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownJpeg0(33) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownJpeg1(38) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVcn1(4) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerDownVcn0(6) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpVcn0(7) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpVcn1(5) param: 0x00010000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpJpeg0(34) param: 0x00000000, resp: 0x00000001
amdgpu 0000:c4:00.0: amdgpu: smu send message: PowerUpJpeg1(39) param: 0x00010000, resp: 0x00000001

To fix this, increase VPE_IDLE_TIMEOUT to 2 seconds. This increases
reliability from 4-25 suspends to 200+ (tested) suspends with a cycle
time of 12s sleep, 8s resume. The suspected reason here is that 1s
was a borderline delay before, and it does not give enough time for
VPE to be ready to be gated on Strix Halo.

Fixes: 5f82a0c90cca ("drm/amdgpu/vpe: enable vpe dpm")
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
index 121ee17b522b..24f09e457352 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vpe.c
@@ -34,8 +34,8 @@
 /* VPE CSA resides in the 4th page of CSA */
 #define AMDGPU_CSA_VPE_OFFSET 	(4096 * 3)
 
-/* 1 second timeout */
-#define VPE_IDLE_TIMEOUT	msecs_to_jiffies(1000)
+/* 2 second timeout */
+#define VPE_IDLE_TIMEOUT	msecs_to_jiffies(2000)
 
 #define VPE_MAX_DPM_LEVEL			4
 #define FIXED1_8_BITS_PER_FRACTIONAL_PART	8
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 22:01:58 +0200
Subject: drm: panel-backlight-quirks: Make ident optional

Currently, having a valid panel_id match is required to use the quirk
system. For certain devices, we know that all SKUs need a certain quirk.
Therefore, allow not specifying ident by only checking for a match
if panel_id is non-zero.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index 598f812b7cb3..b38b33e26ea5 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -50,7 +50,7 @@ static bool drm_panel_min_backlight_quirk_matches(const struct drm_panel_min_bac
 	if (!dmi_match(quirk->dmi_match.field, quirk->dmi_match.value))
 		return false;
 
-	if (!drm_edid_match(edid, &quirk->ident))
+	if (quirk->ident.panel_id && !drm_edid_match(edid, &quirk->ident))
 		return false;
 
 	return true;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 27 Aug 2025 19:17:48 +0200
Subject: drm: panel-backlight-quirks: Convert brightness quirk to generic
 structure
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, the brightness quirk is limited to minimum brightness only.
Refactor it to a structure, so that more quirks can be added in the
future. Reserve 0 value for "no quirk", and use u16 to allow minimum
brightness up to 255.

Tested-by: Philip Mller <philm@manjaro.org>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 12 ++++--
 drivers/gpu/drm/drm_panel_backlight_quirks.c  | 41 ++++++++++---------
 include/drm/drm_utils.h                       |  7 +++-
 3 files changed, 35 insertions(+), 25 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index bb2443f49e84..81f08136e191 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -3609,11 +3609,11 @@ static struct drm_mode_config_helper_funcs amdgpu_dm_mode_config_helperfuncs = {
 
 static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)
 {
+	const struct drm_panel_backlight_quirk *panel_backlight_quirk;
 	struct amdgpu_dm_backlight_caps *caps;
 	struct drm_connector *conn_base;
 	struct amdgpu_device *adev;
 	struct drm_luminance_range_info *luminance_range;
-	int min_input_signal_override;
 
 	if (aconnector->bl_idx == -1 ||
 	    aconnector->dc_link->connector_signal != SIGNAL_TYPE_EDP)
@@ -3653,9 +3653,13 @@ static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)
 	else
 		caps->aux_min_input_signal = 1;
 
-	min_input_signal_override = drm_get_panel_min_brightness_quirk(aconnector->drm_edid);
-	if (min_input_signal_override >= 0)
-		caps->min_input_signal = min_input_signal_override;
+	panel_backlight_quirk =
+		drm_get_panel_backlight_quirk(aconnector->drm_edid);
+	if (!IS_ERR_OR_NULL(panel_backlight_quirk)) {
+		if (panel_backlight_quirk->min_brightness)
+			caps->min_input_signal =
+				panel_backlight_quirk->min_brightness - 1;
+	}
 }
 
 DEFINE_FREE(sink_release, struct dc_sink *, if (_T) dc_sink_release(_T))
diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index b38b33e26ea5..702726c20ccc 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -8,23 +8,23 @@
 #include <drm/drm_edid.h>
 #include <drm/drm_utils.h>
 
-struct drm_panel_min_backlight_quirk {
+struct drm_get_panel_backlight_quirk {
 	struct {
 		enum dmi_field field;
 		const char * const value;
 	} dmi_match;
 	struct drm_edid_ident ident;
-	u8 min_brightness;
+	struct drm_panel_backlight_quirk quirk;
 };
 
-static const struct drm_panel_min_backlight_quirk drm_panel_min_backlight_quirks[] = {
+static const struct drm_get_panel_backlight_quirk drm_panel_min_backlight_quirks[] = {
 	/* 13 inch matte panel */
 	{
 		.dmi_match.field = DMI_BOARD_VENDOR,
 		.dmi_match.value = "Framework",
 		.ident.panel_id = drm_edid_encode_panel_id('B', 'O', 'E', 0x0bca),
 		.ident.name = "NE135FBM-N41",
-		.min_brightness = 0,
+		.quirk = { .min_brightness = 1, },
 	},
 	/* 13 inch glossy panel */
 	{
@@ -32,7 +32,7 @@ static const struct drm_panel_min_backlight_quirk drm_panel_min_backlight_quirks
 		.dmi_match.value = "Framework",
 		.ident.panel_id = drm_edid_encode_panel_id('B', 'O', 'E', 0x095f),
 		.ident.name = "NE135FBM-N41",
-		.min_brightness = 0,
+		.quirk = { .min_brightness = 1, },
 	},
 	/* 13 inch 2.8k panel */
 	{
@@ -40,12 +40,13 @@ static const struct drm_panel_min_backlight_quirk drm_panel_min_backlight_quirks
 		.dmi_match.value = "Framework",
 		.ident.panel_id = drm_edid_encode_panel_id('B', 'O', 'E', 0x0cb4),
 		.ident.name = "NE135A1M-NY1",
-		.min_brightness = 0,
+		.quirk = { .min_brightness = 1, },
 	},
 };
 
-static bool drm_panel_min_backlight_quirk_matches(const struct drm_panel_min_backlight_quirk *quirk,
-						  const struct drm_edid *edid)
+static bool drm_panel_min_backlight_quirk_matches(
+	const struct drm_get_panel_backlight_quirk *quirk,
+	const struct drm_edid *edid)
 {
 	if (!dmi_match(quirk->dmi_match.field, quirk->dmi_match.value))
 		return false;
@@ -57,39 +58,39 @@ static bool drm_panel_min_backlight_quirk_matches(const struct drm_panel_min_bac
 }
 
 /**
- * drm_get_panel_min_brightness_quirk - Get minimum supported brightness level for a panel.
+ * drm_get_panel_backlight_quirk - Get backlight quirks for a panel
  * @edid: EDID of the panel to check
  *
  * This function checks for platform specific (e.g. DMI based) quirks
  * providing info on the minimum backlight brightness for systems where this
- * cannot be probed correctly from the hard-/firm-ware.
+ * cannot be probed correctly from the hard-/firm-ware and other sources.
  *
  * Returns:
- * A negative error value or
- * an override value in the range [0, 255] representing 0-100% to be scaled to
- * the drivers target range.
+ * a drm_panel_backlight_quirk struct if a quirk was found, otherwise an
+ * error pointer.
  */
-int drm_get_panel_min_brightness_quirk(const struct drm_edid *edid)
+const struct drm_panel_backlight_quirk *
+drm_get_panel_backlight_quirk(const struct drm_edid *edid)
 {
-	const struct drm_panel_min_backlight_quirk *quirk;
+	const struct drm_get_panel_backlight_quirk *quirk;
 	size_t i;
 
 	if (!IS_ENABLED(CONFIG_DMI))
-		return -ENODATA;
+		return ERR_PTR(-ENODATA);
 
 	if (!edid)
-		return -EINVAL;
+		return ERR_PTR(-EINVAL);
 
 	for (i = 0; i < ARRAY_SIZE(drm_panel_min_backlight_quirks); i++) {
 		quirk = &drm_panel_min_backlight_quirks[i];
 
 		if (drm_panel_min_backlight_quirk_matches(quirk, edid))
-			return quirk->min_brightness;
+			return &quirk->quirk;
 	}
 
-	return -ENODATA;
+	return ERR_PTR(-ENODATA);
 }
-EXPORT_SYMBOL(drm_get_panel_min_brightness_quirk);
+EXPORT_SYMBOL(drm_get_panel_backlight_quirk);
 
 MODULE_DESCRIPTION("Quirks for panel backlight overrides");
 MODULE_LICENSE("GPL");
diff --git a/include/drm/drm_utils.h b/include/drm/drm_utils.h
index 15fa9b6865f4..82eeee4a58ab 100644
--- a/include/drm/drm_utils.h
+++ b/include/drm/drm_utils.h
@@ -16,7 +16,12 @@ struct drm_edid;
 
 int drm_get_panel_orientation_quirk(int width, int height);
 
-int drm_get_panel_min_brightness_quirk(const struct drm_edid *edid);
+struct drm_panel_backlight_quirk {
+	u16 min_brightness;
+};
+
+const struct drm_panel_backlight_quirk *
+drm_get_panel_backlight_quirk(const struct drm_edid *edid);
 
 signed long drm_timeout_abs_to_jiffies(int64_t timeout_nsec);
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 22:02:00 +0200
Subject: drm: panel-backlight-quirks: Add secondary DMI match
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Using a single DMI match only allows matching per manufacturer.
Introduce a second optional match to allow matching make/model.
In addition, make DMI optional to allow matching only by EDID.

Tested-by: Philip Mller <philm@manjaro.org>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index 702726c20ccc..3d386a96e50e 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -8,11 +8,14 @@
 #include <drm/drm_edid.h>
 #include <drm/drm_utils.h>
 
+struct drm_panel_match {
+	enum dmi_field field;
+	const char * const value;
+};
+
 struct drm_get_panel_backlight_quirk {
-	struct {
-		enum dmi_field field;
-		const char * const value;
-	} dmi_match;
+	struct drm_panel_match dmi_match;
+	struct drm_panel_match dmi_match_other;
 	struct drm_edid_ident ident;
 	struct drm_panel_backlight_quirk quirk;
 };
@@ -48,7 +51,13 @@ static bool drm_panel_min_backlight_quirk_matches(
 	const struct drm_get_panel_backlight_quirk *quirk,
 	const struct drm_edid *edid)
 {
-	if (!dmi_match(quirk->dmi_match.field, quirk->dmi_match.value))
+	if (quirk->dmi_match.field &&
+	    !dmi_match(quirk->dmi_match.field, quirk->dmi_match.value))
+		return false;
+
+	if (quirk->dmi_match_other.field &&
+	    !dmi_match(quirk->dmi_match_other.field,
+		       quirk->dmi_match_other.value))
 		return false;
 
 	if (quirk->ident.panel_id && !drm_edid_match(edid, &quirk->ident))
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 22:02:01 +0200
Subject: drm: panel-backlight-quirks: Add brightness mask quirk
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Certain OLED devices malfunction on specific brightness levels.
Specifically, when DP_SOURCE_BACKLIGHT_LEVEL is written to with
the first byte being 0x00 and sometimes 0x01, the panel forcibly
turns off until the device sleeps again.

Below are some examples. This was found by iterating over brighness
ranges while printing DP_SOURCE_BACKLIGHT_LEVEL. It was found that
the screen would malfunction on specific values, and some of them
were collected. Summary examples are found below.

This quirk was tested by removing the workarounds and iterating
from 0 to 50_000 value ranges with a cadence of 0.2s/it. The
range of the panel is 1000...400_000, so the values were slightly
interpolated during testing. The custom brightness curve added on
6.15 was disabled.

 86016:  10101000000000000
 86272:  10101000100000000
 87808:  10101011100000000
251648: 111101011100000000
251649: 111101011100000001

 86144:  10101000010000000
 87809:  10101011100000001
251650: 111101011100000010

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/3803
Tested-by: Philip Mller <philm@manjaro.org>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c |  7 ++++
 .../gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h |  6 ++++
 drivers/gpu/drm/drm_panel_backlight_quirks.c  | 36 +++++++++++++++++++
 include/drm/drm_utils.h                       |  1 +
 4 files changed, 50 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 81f08136e191..011b90fad0f5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -3659,6 +3659,9 @@ static void update_connector_ext_caps(struct amdgpu_dm_connector *aconnector)
 		if (panel_backlight_quirk->min_brightness)
 			caps->min_input_signal =
 				panel_backlight_quirk->min_brightness - 1;
+		if (panel_backlight_quirk->brightness_mask)
+			caps->brightness_mask =
+				panel_backlight_quirk->brightness_mask;
 	}
 }
 
@@ -4859,6 +4862,10 @@ static void amdgpu_dm_backlight_set_level(struct amdgpu_display_manager *dm,
 	brightness = convert_brightness_from_user(caps, dm->brightness[bl_idx]);
 	link = (struct dc_link *)dm->backlight_link[bl_idx];
 
+	/* Apply brightness quirk */
+	if (caps->brightness_mask)
+		brightness |= caps->brightness_mask;
+
 	/* Change brightness based on AUX property */
 	mutex_lock(&dm->dc_lock);
 	if (dm->dc->caps.ips_support && dm->dc->ctx->dmub_srv->idle_allowed) {
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
index 6aae51c1beb3..85f5aa2a957c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.h
@@ -200,6 +200,12 @@ struct amdgpu_dm_backlight_caps {
 	 * @aux_support: Describes if the display supports AUX backlight.
 	 */
 	bool aux_support;
+	/**
+	 * @brightness_mask: After deriving brightness, or it with this mask.
+	 * This is used to workaround panels that have issues with certain
+	 * brightness values.
+	 */
+	u32 brightness_mask;
 	/**
 	 * @ac_level: the default brightness if booted on AC
 	 */
diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index 3d386a96e50e..2bdbd5583d32 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -45,6 +45,42 @@ static const struct drm_get_panel_backlight_quirk drm_panel_min_backlight_quirks
 		.ident.name = "NE135A1M-NY1",
 		.quirk = { .min_brightness = 1, },
 	},
+	/* Have OLED Panels with brightness issue when last byte is 0/1 */
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "AYANEO",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "AYANEO 3",
+		.quirk = { .brightness_mask = 3, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "ZOTAC",
+		.dmi_match_other.field = DMI_BOARD_NAME,
+		.dmi_match_other.value = "G0A1W",
+		.quirk = { .brightness_mask = 3, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "ZOTAC",
+		.dmi_match_other.field = DMI_BOARD_NAME,
+		.dmi_match_other.value = "G1A1W",
+		.quirk = { .brightness_mask = 3, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "ONE-NETBOOK",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "ONEXPLAYER F1Pro",
+		.quirk = { .brightness_mask = 3, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "ONE-NETBOOK",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "ONEXPLAYER F1 EVA-02",
+		.quirk = { .brightness_mask = 3, },
+	},
 };
 
 static bool drm_panel_min_backlight_quirk_matches(
diff --git a/include/drm/drm_utils.h b/include/drm/drm_utils.h
index 82eeee4a58ab..6a46f755daba 100644
--- a/include/drm/drm_utils.h
+++ b/include/drm/drm_utils.h
@@ -18,6 +18,7 @@ int drm_get_panel_orientation_quirk(int width, int height);
 
 struct drm_panel_backlight_quirk {
 	u16 min_brightness;
+	u32 brightness_mask;
 };
 
 const struct drm_panel_backlight_quirk *
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 24 Aug 2025 22:02:02 +0200
Subject: drm: panel-backlight-quirks: Add Steam Decks

On the SteamOS kernel, Valve universally makes minimum brightness 0
for all devices. SteamOS is (was?) meant for the Steam Deck, so
enabling it universally is reasonable. However, it causes issues in
certain devices. Therefore, introduce it just for the Steam Deck here.

SteamOS kernel does not have a public mirror, but this replaces commit
806dd74bb225 ("amd/drm: override backlight min value from 12 -> 0")
in the latest, as of this writing, SteamOS kernel (6.11.11-valve24).
See unofficial mirror reconstructed from sources below.

Link: https://gitlab.com/evlaV/linux-integration/-/commit/806dd74bb225
Reviewed-by: Robert Beckett <bob.beckett@collabora.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_backlight_quirks.c | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_backlight_quirks.c b/drivers/gpu/drm/drm_panel_backlight_quirks.c
index 2bdbd5583d32..69d38c248a0a 100644
--- a/drivers/gpu/drm/drm_panel_backlight_quirks.c
+++ b/drivers/gpu/drm/drm_panel_backlight_quirks.c
@@ -81,6 +81,21 @@ static const struct drm_get_panel_backlight_quirk drm_panel_min_backlight_quirks
 		.dmi_match_other.value = "ONEXPLAYER F1 EVA-02",
 		.quirk = { .brightness_mask = 3, },
 	},
+	/* Steam Deck models */
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "Valve",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "Jupiter",
+		.quirk = { .min_brightness = 1, },
+	},
+	{
+		.dmi_match.field = DMI_SYS_VENDOR,
+		.dmi_match.value = "Valve",
+		.dmi_match_other.field = DMI_PRODUCT_NAME,
+		.dmi_match_other.value = "Galileo",
+		.quirk = { .min_brightness = 1, },
+	},
 };
 
 static bool drm_panel_min_backlight_quirk_matches(
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 28 Aug 2025 11:21:41 +0200
Subject: drm/amdgpu: tweak min and max clocks of cyan_skillfish

Certain aftermarket cyan_skillfish boards that are
used for gaming have an expanded clock range that
is limited by this driver. Update it to reflect
the actual min and max clocks of the board.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
index 9548bd3c624b..14086e3e56ef 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c
@@ -45,8 +45,8 @@
 #undef pr_debug
 
 /* unit: MHz */
-#define CYAN_SKILLFISH_SCLK_MIN			1000
-#define CYAN_SKILLFISH_SCLK_MAX			2000
+#define CYAN_SKILLFISH_SCLK_MIN			350
+#define CYAN_SKILLFISH_SCLK_MAX			2230
 
 /* unit: mV */
 #define CYAN_SKILLFISH_VDDC_MIN			700
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sat, 30 Aug 2025 13:20:41 +0200
Subject: drm/amd/display: enable private color API universally

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c       | 2 +-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c | 2 +-
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c  | 6 +++---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c | 6 +++---
 4 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 011b90fad0f5..b8ca3d635dea 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -4679,7 +4679,7 @@ static int amdgpu_dm_mode_config_init(struct amdgpu_device *adev)
 		return r;
 	}
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 	if (amdgpu_dm_create_color_properties(adev)) {
 		dc_state_release(state->context);
 		kfree(state);
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
index c0dfe2d8b3be..5b338ebb7672 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c
@@ -97,7 +97,7 @@ static inline struct fixed31_32 amdgpu_dm_fixpt_from_s3132(__u64 x)
 	return val;
 }
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 /* Pre-defined Transfer Functions (TF)
  *
  * AMD driver supports pre-defined mathematical functions for transferring
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
index 45feb404b097..645c0b5020c5 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_crtc.c
@@ -491,7 +491,7 @@ static int amdgpu_dm_crtc_late_register(struct drm_crtc *crtc)
 }
 #endif
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 /**
  * dm_crtc_additional_color_mgmt - enable additional color properties
  * @crtc: DRM CRTC
@@ -573,7 +573,7 @@ static const struct drm_crtc_funcs amdgpu_dm_crtc_funcs = {
 #if defined(CONFIG_DEBUG_FS)
 	.late_register = amdgpu_dm_crtc_late_register,
 #endif
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 	.atomic_set_property = amdgpu_dm_atomic_crtc_set_property,
 	.atomic_get_property = amdgpu_dm_atomic_crtc_get_property,
 #endif
@@ -770,7 +770,7 @@ int amdgpu_dm_crtc_init(struct amdgpu_display_manager *dm,
 
 	drm_mode_crtc_set_gamma_size(&acrtc->base, MAX_COLOR_LEGACY_LUT_ENTRIES);
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 	dm_crtc_additional_color_mgmt(&acrtc->base);
 #endif
 	return 0;
diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
index 3d2f8eedeef2..1cda0153cd52 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c
@@ -1601,7 +1601,7 @@ static void amdgpu_dm_plane_drm_plane_destroy_state(struct drm_plane *plane,
 	drm_atomic_helper_plane_destroy_state(plane, state);
 }
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 static void
 dm_atomic_plane_attach_color_mgmt_properties(struct amdgpu_display_manager *dm,
 					     struct drm_plane *plane)
@@ -1792,7 +1792,7 @@ static const struct drm_plane_funcs dm_plane_funcs = {
 	.atomic_duplicate_state = amdgpu_dm_plane_drm_plane_duplicate_state,
 	.atomic_destroy_state = amdgpu_dm_plane_drm_plane_destroy_state,
 	.format_mod_supported = amdgpu_dm_plane_format_mod_supported,
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 	.atomic_set_property = dm_atomic_plane_set_property,
 	.atomic_get_property = dm_atomic_plane_get_property,
 #endif
@@ -1888,7 +1888,7 @@ int amdgpu_dm_plane_init(struct amdgpu_display_manager *dm,
 	else
 		drm_plane_helper_add(plane, &dm_plane_helper_funcs);
 
-#ifdef AMD_PRIVATE_COLOR
+#if 1 //#ifdef AMD_PRIVATE_COLOR
 	dm_atomic_plane_attach_color_mgmt_properties(dm, plane);
 #endif
 	/* Create (reset) the plane state */
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 5 Sep 2025 12:54:46 +0200
Subject: disable custom brightness curve for now

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index b8ca3d635dea..f65fb9a6c789 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@ -4780,6 +4780,8 @@ static void convert_custom_brightness(const struct amdgpu_dm_backlight_caps *cap
 	u8 prev_signal = 0, prev_lum = 0;
 	int i = 0;
 
+	return;
+
 	if (amdgpu_dc_debug_mask & DC_DISABLE_CUSTOM_BRIGHTNESS_CURVE)
 		return;
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 10 Sep 2025 17:43:17 +0200
Subject: drm: panel-orientation-quirks: add SuiPlay0X1

Very similar to the AYANEO 2S, the Mysten SuiPlay0X1 is a handheld
gaming device with a 1200x1920 display that is mounted in a
right-side-up orientation. Add a quirk for it.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index ed1901de4a8e..15820d1ecab3 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -503,6 +503,12 @@ static const struct dmi_system_id orientation_data[] = {
 		 DMI_MATCH(DMI_PRODUCT_VERSION, "Blade3-10A-001"),
 		},
 		.driver_data = (void *)&lcd1600x2560_rightside_up,
+	}, {	/* Mysten SuiPlay0X1 */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Mysten Labs, Inc."),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "SuiPlay0X1"),
+		},
+		.driver_data = (void *)&lcd1200x1920_rightside_up,
 	}, {	/* Nanote UMPC-01 */
 		.matches = {
 		 DMI_MATCH(DMI_SYS_VENDOR, "RWC CO.,LTD"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 10 Sep 2025 17:45:42 +0200
Subject: add suiplay

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/ayaneo-ec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/ayaneo-ec.c b/drivers/platform/x86/ayaneo-ec.c
index dd62f1f38132..52a129b74d58 100644
--- a/drivers/platform/x86/ayaneo-ec.c
+++ b/drivers/platform/x86/ayaneo-ec.c
@@ -163,6 +163,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)&ayaneo3,
 	},
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Mysten Labs, Inc."),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "SuiPlay0X1"),
+		},
+		.driver_data = (void *)&quirk_fan,
+	},
 	{},
 };
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 18 Sep 2025 21:10:04 +0200
Subject: platform/x86: oxpec: Add support for OneXPlayer X1z

This is a variant of OneXPlayer X1 A with 8840U. It seems that only one
user has this one.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index 144a454103b9..adb8a1a9b658 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -212,6 +212,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)oxp_mini_amd_pro,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1z"),
+		},
+		.driver_data = (void *)oxp_x1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 18 Sep 2025 21:12:24 +0200
Subject: add orientation for x1z

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 15820d1ecab3..24741dfc594a 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -540,6 +540,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 A"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 AMD second variant */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1z"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 AMD Strix Point */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 15:47:29 +0200
Subject: tmp: add MSI Center button event to msi-wmi

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/msi-wmi.c | 18 +++++++++++++++---
 1 file changed, 15 insertions(+), 3 deletions(-)

diff --git a/drivers/platform/x86/msi-wmi.c b/drivers/platform/x86/msi-wmi.c
index 4a7ac85c4db4..20de3173ecca 100644
--- a/drivers/platform/x86/msi-wmi.c
+++ b/drivers/platform/x86/msi-wmi.c
@@ -41,6 +41,7 @@ enum msi_scancodes {
 	MSI_KEY_MUTE,
 	/* MSI Wind keys */
 	WIND_KEY_TOUCHPAD	= 0x08,	/* Fn+F3 touchpad toggle */
+	WIND_KEY_MSI_CENTER	= 0x29,
 	WIND_KEY_BLUETOOTH	= 0x56,	/* Fn+F11 Bluetooth toggle */
 	WIND_KEY_CAMERA,		/* Fn+F6 webcam toggle */
 	WIND_KEY_WLAN		= 0x5f,	/* Fn+F11 Wi-Fi toggle */
@@ -68,6 +69,7 @@ static struct key_entry msi_wmi_keymap[] = {
 	/* These are MSI Wind keys that should be handled via WMI */
 	{ KE_KEY, WIND_KEY_TURBO,		{KEY_PROG1} },
 	{ KE_KEY, WIND_KEY_ECO,			{KEY_PROG2} },
+	{ KE_KEY, WIND_KEY_MSI_CENTER,		{KEY_F15}},
 
 	{ KE_END, 0 }
 };
@@ -173,14 +175,24 @@ static const struct backlight_ops msi_backlight_ops = {
 static void msi_wmi_notify(union acpi_object *obj, void *context)
 {
 	struct key_entry *key;
+	int eventcode;
+
+	if (obj) {
+		if (obj->type == ACPI_TYPE_INTEGER)
+			eventcode = obj->integer.value;
+		else if (obj->type == ACPI_TYPE_BUFFER && obj->buffer.length)
+			eventcode = obj->buffer.pointer[0];
+		else {
+			pr_info("Unknown event received\n");
+			return;
+		}
 
-	if (obj && obj->type == ACPI_TYPE_INTEGER) {
-		int eventcode = obj->integer.value;
 		pr_debug("Eventcode: 0x%x\n", eventcode);
 		key = sparse_keymap_entry_from_scancode(msi_wmi_input_dev,
 				eventcode);
 		if (!key) {
-			pr_info("Unknown key pressed - %x\n", eventcode);
+			pr_info("Unknown key pressed - %x (ACPI type: %d)\n",
+				eventcode, obj->type);
 			return;
 		}
 
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 19:41:37 +0200
Subject: oxpec: add a2 pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index adb8a1a9b658..924d698b7105 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -114,6 +114,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)aok_zoe_a1,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "AOKZOE"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "AOKZOE A2 Pro"),
+		},
+		.driver_data = (void *)aok_zoe_a1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "AOKZOE"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 21 Sep 2025 19:41:46 +0200
Subject: panel quirks: add a2 pro

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 24741dfc594a..7deff55b076c 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -185,6 +185,12 @@ static const struct dmi_system_id orientation_data[] = {
 		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A1 Pro"),
 		},
 		.driver_data = (void *)&lcd1200x1920_leftside_up,
+	}, {	/* AOKZOE A2 Pro */
+		.matches = {
+		 DMI_EXACT_MATCH(DMI_SYS_VENDOR, "AOKZOE"),
+		 DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "AOKZOE A2 Pro"),
+		},
+		.driver_data = (void *)&lcd1200x1920_leftside_up,
 	}, {	/* Asus T100HA */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ASUSTeK COMPUTER INC."),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 28 Sep 2025 17:05:22 +0200
Subject: lower sleep interval to avoid waking up too long

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/amd/pmc/pmc.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/platform/x86/amd/pmc/pmc.c b/drivers/platform/x86/amd/pmc/pmc.c
index bd318fd02ccf..ae70fc71ab42 100644
--- a/drivers/platform/x86/amd/pmc/pmc.c
+++ b/drivers/platform/x86/amd/pmc/pmc.c
@@ -635,7 +635,7 @@ static void amd_pmc_s2idle_check(void)
 
 	/* Avoid triggering OVP */
 	if (!get_metrics_table(pdev, &table) && table.s0i3_last_entry_status)
-		msleep(2500);
+		msleep(500);
 
 	/* Dump the IdleMask before we add to the STB */
 	amd_pmc_idlemask_read(pdev, pdev->dev, NULL);
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 28 Sep 2025 21:37:07 +0200
Subject: drm/amdgpu: enable override by default for APUs

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index d9e4b3cb230d..907ae2f5a981 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -2774,6 +2774,9 @@ static int amdgpu_device_ip_early_init(struct amdgpu_device *adev)
 	}
 
 	adev->pm.pp_feature = amdgpu_pp_feature_mask;
+
+	if (adev->flags & AMD_IS_APU)
+		adev->pm.pp_feature |= PP_OVERDRIVE_MASK;
 	if (amdgpu_sriov_vf(adev) || sched_policy == KFD_SCHED_POLICY_NO_HWS)
 		adev->pm.pp_feature &= ~PP_GFXOFF_MASK;
 	if (amdgpu_sriov_vf(adev) && adev->asic_type == CHIP_SIENNA_CICHLID)
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Sun, 28 Sep 2025 22:23:11 +0200
Subject: drm/amdgpu: defer overdrive taint until used

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c                 | 1 -
 drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c    | 6 ++++++
 drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c     | 6 ++++++
 drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c   | 6 ++++++
 drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h            | 1 +
 drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h           | 1 +
 drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c         | 7 +++++++
 drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c | 7 +++++++
 drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c    | 7 +++++++
 drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c    | 7 +++++++
 drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c    | 7 +++++++
 11 files changed, 55 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 9380a29ac67d..c0f04e495892 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -3142,7 +3142,6 @@ static int __init amdgpu_init(void)
 	amdgpu_amdkfd_init();
 
 	if (amdgpu_pp_feature_mask & PP_OVERDRIVE_MASK) {
-		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
 		pr_err("Overdrive is enabled, please disable it before "
 			"reporting any bugs unrelated to overdrive.\n");
 	}
diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c
index 9a821563bc8e..e7ef9e5aff39 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu10_hwmgr.c
@@ -1551,6 +1551,12 @@ static int smu10_set_fine_grain_clk_vol(struct pp_hwmgr *hwmgr,
 		return -EINVAL;
 	}
 
+	if (!hwmgr->od_tainted) {
+		pr_err("OverDrive setting changed. Tainting kernel.\n");
+		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+		hwmgr->od_tainted = true;
+	}
+
 	if (type == PP_OD_EDIT_SCLK_VDDC_TABLE) {
 		if (size != 2) {
 			pr_err("Input parameter number not correct\n");
diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
index 8da882c51856..50aea23f49c1 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
@@ -5510,6 +5510,12 @@ static int smu7_odn_edit_dpm_table(struct pp_hwmgr *hwmgr,
 		return -EINVAL;
 	}
 
+	if (!hwmgr->od_tainted) {
+		pr_err("OverDrive setting changed. Tainting kernel.\n");
+		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+		hwmgr->od_tainted = true;
+	}
+
 	if (PP_OD_EDIT_SCLK_VDDC_TABLE == type) {
 		podn_dpm_table_in_backend = &data->odn_dpm_table.odn_core_clock_dpm_levels;
 		podn_vdd_dep_in_backend = &data->odn_dpm_table.vdd_dependency_on_sclk;
diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c
index 9ace863792d4..b38e49125332 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c
@@ -5609,6 +5609,12 @@ static int vega10_odn_edit_dpm_table(struct pp_hwmgr *hwmgr,
 		return -EINVAL;
 	}
 
+	if (!hwmgr->od_tainted) {
+		pr_err("OverDrive setting changed. Tainting kernel.\n");
+		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+		hwmgr->od_tainted = true;
+	}
+
 	if (PP_OD_EDIT_SCLK_VDDC_TABLE == type) {
 		dpm_table = &data->dpm_table.gfx_table;
 		podn_vdd_dep_table = &data->odn_dpm_table.vdd_dep_on_sclk;
diff --git a/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h b/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
index c661185753b4..a6d129582d83 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
+++ b/drivers/gpu/drm/amd/pm/powerplay/inc/hwmgr.h
@@ -800,6 +800,7 @@ struct pp_hwmgr {
 	uint32_t pstate_sclk;
 	uint32_t pstate_mclk;
 	bool od_enabled;
+	bool od_tainted;
 	uint32_t power_limit;
 	uint32_t default_power_limit;
 	uint32_t workload_mask;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h b/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
index b52e194397e2..95a90771a480 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
+++ b/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h
@@ -540,6 +540,7 @@ struct smu_context {
 	uint32_t pstate_mclk;
 
 	bool od_enabled;
+	bool od_tainted;
 	uint32_t current_power_limit;
 	uint32_t default_power_limit;
 	uint32_t max_power_limit;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
index aac202d0c30e..103843241937 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c
@@ -2646,6 +2646,13 @@ static int navi10_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TABL
 		return -ENOENT;
 	}
 
+	if (!smu->od_tainted) {
+		dev_err(smu->adev->dev,
+			"OverDrive setting changed. Tainting kernel.\n");
+		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+		smu->od_tainted = true;
+	}
+
 	od_settings = smu->od_settings;
 
 	switch (type) {
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
index d57591509aed..4432c08a10da 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c
@@ -2301,6 +2301,13 @@ static int sienna_cichlid_od_edit_dpm_table(struct smu_context *smu,
 		return -EINVAL;
 	}
 
+	if (!smu->od_tainted) {
+		dev_err(smu->adev->dev,
+			"OverDrive setting changed. Tainting kernel.\n");
+		add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+		smu->od_tainted = true;
+	}
+
 	switch (type) {
 	case PP_OD_EDIT_SCLK_VDDC_TABLE:
 		if (!sienna_cichlid_is_od_feature_supported(od_settings,
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
index e084ed99ec0e..075b1ee8065e 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c
@@ -3109,6 +3109,13 @@ static int smu_v13_0_0_set_power_limit(struct smu_context *smu,
 		}
 		return smu_v13_0_set_power_limit(smu, limit_type, limit);
 	} else if (smu->od_enabled) {
+		if (!smu->od_tainted) {
+			dev_err(smu->adev->dev,
+				"OverDrive setting changed. Tainting kernel.\n");
+			add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+			smu->od_tainted = true;
+		}
+
 		ret = smu_v13_0_set_power_limit(smu, limit_type, msg_limit);
 		if (ret)
 			return ret;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
index c96fa5e49ed6..f77a5c4022d5 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_7_ppt.c
@@ -2698,6 +2698,13 @@ static int smu_v13_0_7_set_power_limit(struct smu_context *smu,
 		}
 		return smu_v13_0_set_power_limit(smu, limit_type, limit);
 	} else if (smu->od_enabled) {
+		if (!smu->od_tainted) {
+			dev_err(smu->adev->dev,
+				"OverDrive setting changed. Tainting kernel.\n");
+			add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+			smu->od_tainted = true;
+		}
+
 		ret = smu_v13_0_set_power_limit(smu, limit_type, msg_limit);
 		if (ret)
 			return ret;
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
index f32474af90b3..478b9b846a13 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu14/smu_v14_0_2_ppt.c
@@ -2840,6 +2840,13 @@ static int smu_v14_0_2_set_power_limit(struct smu_context *smu,
 		}
 		return smu_v14_0_set_power_limit(smu, limit_type, limit);
 	} else if (smu->od_enabled) {
+		if (!smu->od_tainted) {
+			dev_err(smu->adev->dev,
+				"OverDrive setting changed. Tainting kernel.\n");
+			add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);
+			smu->od_tainted = true;
+		}
+
 		ret = smu_v14_0_set_power_limit(smu, limit_type, msg_limit);
 		if (ret)
 			return ret;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Oct 2025 22:11:29 +0200
Subject: platform/x86/amd: pmc: Add Lenovo Legion Go 2 to pmc quirk list

The Lenovo Legion Go 2 takes a long time to resume from suspend.
Adding it to the pmc quirk list fixes this issue.

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4618
Suggested-by: Mario Limonciello <mario.limonciello@amd.com>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/amd/pmc/pmc-quirks.c | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/drivers/platform/x86/amd/pmc/pmc-quirks.c b/drivers/platform/x86/amd/pmc/pmc-quirks.c
index d63aaad7ef59..0fadcf5f288a 100644
--- a/drivers/platform/x86/amd/pmc/pmc-quirks.c
+++ b/drivers/platform/x86/amd/pmc/pmc-quirks.c
@@ -204,6 +204,23 @@ static const struct dmi_system_id fwbug_list[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "82ND"),
 		}
 	},
+	/* https://gitlab.freedesktop.org/drm/amd/-/issues/4618 */
+	{
+		.ident = "Lenovo Legion Go 2",
+		.driver_data = &quirk_s2idle_bug,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "83N0"),
+		}
+	},
+	{
+		.ident = "Lenovo Legion Go 2",
+		.driver_data = &quirk_s2idle_bug,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "83N1"),
+		}
+	},
 	/* https://gitlab.freedesktop.org/drm/amd/-/issues/2684 */
 	{
 		.ident = "HP Laptop 15s-eq2xxx",
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Oct 2025 22:06:32 +0200
Subject: oxpec: add x1 air

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/oxpec.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/drivers/platform/x86/oxpec.c b/drivers/platform/x86/oxpec.c
index 924d698b7105..64a778ebb6dc 100644
--- a/drivers/platform/x86/oxpec.c
+++ b/drivers/platform/x86/oxpec.c
@@ -240,6 +240,13 @@ static const struct dmi_system_id dmi_table[] = {
 		},
 		.driver_data = (void *)oxp_x1,
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
+			DMI_EXACT_MATCH(DMI_BOARD_NAME, "ONEXPLAYER X1Air"),
+		},
+		.driver_data = (void *)oxp_x1,
+	},
 	{
 		.matches = {
 			DMI_MATCH(DMI_BOARD_VENDOR, "ONE-NETBOOK"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Tue, 7 Oct 2025 22:07:28 +0200
Subject: orientation: add x1 air

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/drm_panel_orientation_quirks.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/gpu/drm/drm_panel_orientation_quirks.c b/drivers/gpu/drm/drm_panel_orientation_quirks.c
index 7deff55b076c..6e7dac6f8e70 100644
--- a/drivers/gpu/drm/drm_panel_orientation_quirks.c
+++ b/drivers/gpu/drm/drm_panel_orientation_quirks.c
@@ -570,6 +570,12 @@ static const struct dmi_system_id orientation_data[] = {
 		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1 i"),
 		},
 		.driver_data = (void *)&lcd1600x2560_leftside_up,
+	}, {	/* OneXPlayer X1 Intel */
+		.matches = {
+		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
+		  DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "ONEXPLAYER X1Air"),
+		},
+		.driver_data = (void *)&lcd1600x2560_leftside_up,
 	}, {	/* OneXPlayer X1 mini (AMD) */
 		.matches = {
 		  DMI_EXACT_MATCH(DMI_SYS_VENDOR, "ONE-NETBOOK"),
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 15 Oct 2025 22:28:37 +0200
Subject: add new ally units

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/acpi/x86/s2idle.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/acpi/x86/s2idle.c b/drivers/acpi/x86/s2idle.c
index 86adad4a7f25..dd2a8845f23c 100644
--- a/drivers/acpi/x86/s2idle.c
+++ b/drivers/acpi/x86/s2idle.c
@@ -137,6 +137,18 @@ static const struct dmi_system_id s2idle_delay_quirks[] = {
 		},
 		.driver_data = (void *)&rog_ally_quirks
 	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC73Y"), // non-x (YA)
+		},
+		.driver_data = (void *)&rog_ally_quirks
+	},
+	{
+		.matches = {
+			DMI_MATCH(DMI_BOARD_NAME, "RC73X"), // x (XA)
+		},
+		.driver_data = (void *)&rog_ally_quirks
+	},
 	/* Legion Go S */
 	{
 		.matches = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 15 Oct 2025 22:31:32 +0200
Subject: add legion go 2 mics

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 sound/soc/amd/yc/acp6x-mach.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/sound/soc/amd/yc/acp6x-mach.c b/sound/soc/amd/yc/acp6x-mach.c
index f210a253da9f..924d081437da 100644
--- a/sound/soc/amd/yc/acp6x-mach.c
+++ b/sound/soc/amd/yc/acp6x-mach.c
@@ -346,6 +346,20 @@ static const struct dmi_system_id yc_acp_quirk_table[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "83Q2"),
 		}
 	},
+	{
+		.driver_data = &acp6x_card,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "83N0"),
+		}
+	},
+	{
+		.driver_data = &acp6x_card,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "83N1"),
+		}
+	},
 	{
 		.driver_data = &acp6x_card,
 		.matches = {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Wed, 1 Oct 2025 03:34:27 +0200
Subject: CI: add akmod modules

We have to lobotomize objtool for broadcom-wl to compile. TODO: remove
when that module goes out the wayside.

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 .gitmodules                               |  60 ++++++
 drivers/Kconfig                           |   2 +
 drivers/Makefile                          |   2 +
 drivers/custom/.gitignore                 |   3 +
 drivers/custom/Kconfig                    | 115 ++++++++++
 drivers/custom/Makefile                   |  41 ++++
 drivers/custom/ayaneo_platform            |   1 +
 drivers/custom/ayn_platform               |   1 +
 drivers/custom/bmi260                     |   1 +
 drivers/custom/broadcom-wl                |   1 +
 drivers/custom/cdemu                      |   1 +
 drivers/custom/evdi                       |   1 +
 drivers/custom/facetimehd                 |   1 +
 drivers/custom/fanatecff                  |   1 +
 drivers/custom/framework                  |   1 +
 drivers/custom/gcadapter_oc               |   1 +
 drivers/custom/kvfm                       |   1 +
 drivers/custom/lg4ff                      |   1 +
 drivers/custom/modprobe.conf              |   1 +
 drivers/custom/modules-load.conf          |   4 +
 drivers/custom/nct6687d                   |   1 +
 drivers/custom/nvidia-separate-drivers.py | 248 ++++++++++++++++++++++
 drivers/custom/razer                      |   1 +
 drivers/custom/system76                   |   1 +
 drivers/custom/system76_io                |   1 +
 drivers/custom/v4l2loopback               |   1 +
 drivers/custom/xonedo                     |   1 +
 drivers/custom/xpadneo                    |   1 +
 drivers/custom/zenergy                    |   1 +
 scripts/mod/modpost.c                     |   4 +-
 tools/objtool/builtin-check.c             |   1 +
 tools/objtool/check.c                     |   3 +
 tools/objtool/include/objtool/builtin.h   |   1 +
 33 files changed, 503 insertions(+), 2 deletions(-)
 create mode 100644 .gitmodules
 create mode 100644 drivers/custom/.gitignore
 create mode 100644 drivers/custom/Kconfig
 create mode 100644 drivers/custom/Makefile
 create mode 160000 drivers/custom/ayaneo_platform
 create mode 160000 drivers/custom/ayn_platform
 create mode 160000 drivers/custom/bmi260
 create mode 160000 drivers/custom/broadcom-wl
 create mode 160000 drivers/custom/cdemu
 create mode 160000 drivers/custom/evdi
 create mode 160000 drivers/custom/facetimehd
 create mode 160000 drivers/custom/fanatecff
 create mode 160000 drivers/custom/framework
 create mode 160000 drivers/custom/gcadapter_oc
 create mode 160000 drivers/custom/kvfm
 create mode 160000 drivers/custom/lg4ff
 create mode 100644 drivers/custom/modprobe.conf
 create mode 100644 drivers/custom/modules-load.conf
 create mode 160000 drivers/custom/nct6687d
 create mode 100644 drivers/custom/nvidia-separate-drivers.py
 create mode 160000 drivers/custom/razer
 create mode 160000 drivers/custom/system76
 create mode 160000 drivers/custom/system76_io
 create mode 160000 drivers/custom/v4l2loopback
 create mode 160000 drivers/custom/xonedo
 create mode 160000 drivers/custom/xpadneo
 create mode 160000 drivers/custom/zenergy

diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 000000000000..f1177abe50bb
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,60 @@
+[submodule "drivers/custom/ayn_platform"]
+	path = drivers/custom/ayn_platform
+	url = https://github.com/bazzite-org/ayn-platform
+[submodule "drivers/custom/ayaneo_platform"]
+	path = drivers/custom/ayaneo_platform
+	url = https://github.com/bazzite-org/ayaneo-platform
+[submodule "drivers/custom/framework"]
+	path = drivers/custom/framework
+	url = https://github.com/bazzite-org/framework-laptop-kmod
+[submodule "drivers/custom/bmi260"]
+	path = drivers/custom/bmi260
+	url = https://github.com/hhd-dev/bmi260
+[submodule "drivers/custom/xonedo"]
+	path = drivers/custom/xonedo
+	url = https://github.com/bazzite-org/xonedo
+[submodule "drivers/custom/xpadneo"]
+	path = drivers/custom/xpadneo
+	url = https://github.com/atar-axis/xpadneo
+[submodule "drivers/custom/kvfm"]
+	path = drivers/custom/kvfm
+	url = https://github.com/gnif/LookingGlass
+[submodule "drivers/custom/razer"]
+	path = drivers/custom/razer
+	url = https://github.com/ublue-os/openrazer.git
+[submodule "drivers/custom/v4l2loopback"]
+	path = drivers/custom/v4l2loopback
+	url = https://github.com/umlaeute/v4l2loopback
+[submodule "drivers/custom/evdi"]
+	path = drivers/custom/evdi
+	url = https://github.com/DisplayLink/evdi
+[submodule "drivers/custom/gcadapter_oc"]
+	path = drivers/custom/gcadapter_oc
+	url = https://github.com/hannesmann/gcadapter-oc-kmod
+[submodule "drivers/custom/zenergy"]
+	path = drivers/custom/zenergy
+	url = https://github.com/bazzite-org/zenergy.git
+[submodule "drivers/custom/nct6687d"]
+	path = drivers/custom/nct6687d
+	url = https://github.com/ublue-os/nct6687d.git
+[submodule "drivers/custom/lg4ff"]
+	path = drivers/custom/lg4ff
+	url = https://github.com/berarma/new-lg4ff
+[submodule "drivers/custom/system76"]
+	path = drivers/custom/system76
+	url = https://github.com/pop-os/system76-dkms
+[submodule "drivers/custom/system76_io"]
+	path = drivers/custom/system76_io
+	url = https://github.com/pop-os/system76-io-dkms
+[submodule "drivers/custom/facetimehd"]
+	path = drivers/custom/facetimehd
+	url = https://github.com/patjak/facetimehd/
+[submodule "drivers/custom/cdemu"]
+	path = drivers/custom/cdemu
+	url = https://github.com/cdemu/cdemu
+[submodule "drivers/custom/broadcom-wl"]
+	path = drivers/custom/broadcom-wl
+	url = https://github.com/bazzite-org/broadcom-wl
+[submodule "drivers/custom/fanatecff"]
+	path = drivers/custom/fanatecff
+	url = https://github.com/gotzl/hid-fanatecff
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 4915a63866b0..f3796a10e278 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -17,6 +17,8 @@ config PC104
 	  selection and configuration. Enable this option if your target
 	  machine has a PC/104 bus.
 
+source "drivers/custom/Kconfig"
+
 source "drivers/base/Kconfig"
 
 source "drivers/bus/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index b5749cf67044..fdeefef6c11f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -6,6 +6,8 @@
 # Rewritten to use lists instead of if-statements.
 #
 
+obj-y				+= custom/
+
 obj-y				+= cache/
 obj-y				+= irqchip/
 obj-y				+= bus/
diff --git a/drivers/custom/.gitignore b/drivers/custom/.gitignore
new file mode 100644
index 000000000000..b9adbda1674e
--- /dev/null
+++ b/drivers/custom/.gitignore
@@ -0,0 +1,3 @@
+NVIDIA-Linux-*
+nvidia
+zfs
\ No newline at end of file
diff --git a/drivers/custom/Kconfig b/drivers/custom/Kconfig
new file mode 100644
index 000000000000..84a35902d070
--- /dev/null
+++ b/drivers/custom/Kconfig
@@ -0,0 +1,115 @@
+config AYN
+    tristate "AYN Platform Driver"
+    help
+        AYN platform driver for Linux. Link:
+        https://github.com/bazzite-org/ayn-platform
+
+config AYANEO
+    tristate "AYANEO Legacy Platform Driver"
+    help
+        AYANEO Legacy platform driver for Linux. Link:
+        https://github.com/bazzite-org/ayaneo-platform
+
+config BMI260
+    tristate "BMI260 Legacy Driver"
+    help
+        BMI260 driver for Linux. Link:
+        https://github.com/hhd-dev/bmi260
+
+config XONEDO
+    tristate "XONEDO Driver"
+    help
+        XONEDO driver for Linux. Link:
+        https://github.com/bazzite-org/xonedo
+
+config XPADNEO
+    tristate "Xpadneo Driver"
+    help
+        Xpadneo driver for Linux. Link:
+        https://github.com/atar-axis/xpadneo
+
+config FANATEC
+    tristate "Fanatec Driver"
+    help
+        Fanatec driver for Linux. Link:
+        https://github.com/gotzl/hid-fanatecff
+
+config LG4FF
+    tristate "New LG4FF Driver"
+    help
+        New LG4FF driver for Linux. Link:
+        https://github.com/berarma/new-lg4ff
+
+config GCAOC
+    tristate "GCAdapter OC Driver"
+    help
+        GCAdapter OC driver for Linux. Link:
+        https://github.com/hannesmann/gcadapter-oc-kmod
+
+config RAZER
+    tristate "OpenRazer Driver"
+    help
+        OpenRazer driver for Linux. Link:
+        https://openrazer.github.io/
+
+config NCT6687D
+    tristate "NCT6687D Driver"
+    help
+        NCT6687D driver for Linux. Link:
+        https://github.com/ublue-os/nct6687d.git
+
+config WL
+    tristate "Broadcom WL Driver"
+    help
+        Broadcom WL driver for Linux. Link:
+        https://github.com/bazzite-org/broadcom-wl
+
+
+config FWOOT
+    tristate "Framework Laptop Driver"
+    help
+        Framework Laptop driver for Linux. Link:
+        https://github.com/bazzite-org/framework-laptop-kmod
+
+config S76
+    tristate "System76 Driver"
+    help
+        System76 driver for Linux. Link:
+        https://github.com/pop-os/system76-dkms
+
+config S76IO
+    tristate "System76 IO Driver"
+    help
+        System76 IO driver for Linux. Link:
+        https://github.com/pop-os/system76-io-dkms
+
+config ZENERGY
+    tristate "Zenergy Driver"
+    help
+        Zenergy driver for Linux. Link:
+        https://github.com/bazzite-org/zenergy.git
+
+config KVFM
+    tristate "KVFM Driver"
+    help
+        KVFM driver for Linux. Link:
+
+source "drivers/custom/evdi/module/Kconfig"
+
+config V4L2LOOP
+    tristate "V4L2Loopback Driver"
+    help
+        V4L2Loopback driver for Linux. Link:
+        https://github.com/umlaeute/v4l2loopback
+
+config VHBA
+    tristate "CDEMU VHBA Driver"
+    help
+        CDEMU VHBA driver for Linux. Link:
+        https://github.com/cdemu/cdemu
+
+config FACETIMEHD
+    tristate "FacetimeHD Driver"
+    help
+        FacetimeHD driver for Linux. Link:
+        
\ No newline at end of file
diff --git a/drivers/custom/Makefile b/drivers/custom/Makefile
new file mode 100644
index 000000000000..eef3c34c6da7
--- /dev/null
+++ b/drivers/custom/Makefile
@@ -0,0 +1,41 @@
+obj-$(CONFIG_AYN) += ayn_platform/
+obj-$(CONFIG_AYANEO) += ayaneo_platform/
+obj-$(CONFIG_BMI260) += bmi260/
+
+obj-$(CONFIG_XONEDO) += xonedo/
+obj-$(CONFIG_XPADNEO) += xpadneo/hid-xpadneo/src/
+obj-$(CONFIG_FANATEC) += fanatecff/
+obj-$(CONFIG_LG4FF) += lg4ff/
+obj-$(CONFIG_GCAOC) += gcadapter_oc/
+obj-$(CONFIG_RAZER) += razer/driver/
+
+obj-$(CONFIG_WL) += broadcom-wl/
+obj-$(CONFIG_NCT6687D) += nct6687d/
+
+obj-$(CONFIG_FWOOT) += framework/
+obj-$(CONFIG_S76) += system76/
+obj-$(CONFIG_S76IO) += system76_io/
+
+obj-$(CONFIG_ZENERGY) += zenergy/
+obj-$(CONFIG_KVFM) += kvfm/module/
+# evdi incorrectly picks those variables up
+CFLAGS :=
+export CFLAGS
+obj-$(CONFIG_DRM_EVDI) += evdi/module/
+obj-$(CONFIG_V4L2LOOP) += v4l2loopback/
+obj-$(CONFIG_VHBA) += cdemu/vhba-module/
+obj-$(CONFIG_FACETIMEHD) += facetimehd/
+
+# Install common files from all modules
+install:
+	install -D modules-load.conf $(INSTALL_DIR)/usr/lib/modules-load.d/20-akmods.conf
+	install -D modprobe.conf $(INSTALL_DIR)/usr/lib/modprobe.d/20-akmods.conf
+
+	install -D razer/install_files/udev/99-razer.rules $(INSTALL_DIR)/usr/lib/udev/rules.d/70-razer.rules
+	install -D -m 0755 razer/install_files/udev/razer_mount $(INSTALL_DIR)/usr/lib/udev/razer_mount
+
+	install -D cdemu/vhba-module/debian/vhba-dkms.udev $(INSTALL_DIR)/usr/lib/udev/rules.d/70-vhba.rules
+	install -D xonedo/install/modprobe.conf $(INSTALL_DIR)/usr/lib/modprobe.d/xone.conf
+
+	make -C v4l2loopback/utils/
+	install -D -m 0755 v4l2loopback/utils/v4l2loopback-ctl $(INSTALL_DIR)/usr/bin/v4l2loopback-ctl
\ No newline at end of file
diff --git a/drivers/custom/ayaneo_platform b/drivers/custom/ayaneo_platform
new file mode 160000
index 000000000000..bccb4ad32269
--- /dev/null
+++ b/drivers/custom/ayaneo_platform
@@ -0,0 +1 @@
+Subproject commit bccb4ad322695557d6a1bbfffd2f175304dd8f14
diff --git a/drivers/custom/ayn_platform b/drivers/custom/ayn_platform
new file mode 160000
index 000000000000..fee1bab81d4e
--- /dev/null
+++ b/drivers/custom/ayn_platform
@@ -0,0 +1 @@
+Subproject commit fee1bab81d4ef7dc8f9c5695f5081ace26a58ea0
diff --git a/drivers/custom/bmi260 b/drivers/custom/bmi260
new file mode 160000
index 000000000000..2d764db2bd69
--- /dev/null
+++ b/drivers/custom/bmi260
@@ -0,0 +1 @@
+Subproject commit 2d764db2bd69f2922d7fad6cb162136e32f357a2
diff --git a/drivers/custom/broadcom-wl b/drivers/custom/broadcom-wl
new file mode 160000
index 000000000000..2eb8d6d0bc06
--- /dev/null
+++ b/drivers/custom/broadcom-wl
@@ -0,0 +1 @@
+Subproject commit 2eb8d6d0bc064501177e7528834f80166987b538
diff --git a/drivers/custom/cdemu b/drivers/custom/cdemu
new file mode 160000
index 000000000000..d00300615639
--- /dev/null
+++ b/drivers/custom/cdemu
@@ -0,0 +1 @@
+Subproject commit d00300615639d7e973ae51a6c922b89e527d5735
diff --git a/drivers/custom/evdi b/drivers/custom/evdi
new file mode 160000
index 000000000000..34da6e302a44
--- /dev/null
+++ b/drivers/custom/evdi
@@ -0,0 +1 @@
+Subproject commit 34da6e302a44e569e3fb7692fa1fb796b7146606
diff --git a/drivers/custom/facetimehd b/drivers/custom/facetimehd
new file mode 160000
index 000000000000..1bd87461d3d1
--- /dev/null
+++ b/drivers/custom/facetimehd
@@ -0,0 +1 @@
+Subproject commit 1bd87461d3d1a59e89ace855dcaabb7c96750335
diff --git a/drivers/custom/fanatecff b/drivers/custom/fanatecff
new file mode 160000
index 000000000000..0f1922f9cd3c
--- /dev/null
+++ b/drivers/custom/fanatecff
@@ -0,0 +1 @@
+Subproject commit 0f1922f9cd3c56205b00855d386edd3bee87c904
diff --git a/drivers/custom/framework b/drivers/custom/framework
new file mode 160000
index 000000000000..6164bc3dec24
--- /dev/null
+++ b/drivers/custom/framework
@@ -0,0 +1 @@
+Subproject commit 6164bc3dec24b6bb2806eedd269df6a170bcc930
diff --git a/drivers/custom/gcadapter_oc b/drivers/custom/gcadapter_oc
new file mode 160000
index 000000000000..0a7d7027d0dc
--- /dev/null
+++ b/drivers/custom/gcadapter_oc
@@ -0,0 +1 @@
+Subproject commit 0a7d7027d0dc5c0701b5c6f8664dfcb020e4a1cf
diff --git a/drivers/custom/kvfm b/drivers/custom/kvfm
new file mode 160000
index 000000000000..fddcb7f2d43e
--- /dev/null
+++ b/drivers/custom/kvfm
@@ -0,0 +1 @@
+Subproject commit fddcb7f2d43ef752804af759f2c2194da8c8e9c5
diff --git a/drivers/custom/lg4ff b/drivers/custom/lg4ff
new file mode 160000
index 000000000000..2092db19f7b4
--- /dev/null
+++ b/drivers/custom/lg4ff
@@ -0,0 +1 @@
+Subproject commit 2092db19f7b40854e0427a1b2e39eda9f8d0c3cd
diff --git a/drivers/custom/modprobe.conf b/drivers/custom/modprobe.conf
new file mode 100644
index 000000000000..de440a13a784
--- /dev/null
+++ b/drivers/custom/modprobe.conf
@@ -0,0 +1 @@
+options v4l2loopback exclusive_caps=1 card_label="OBS Virtual Camera"
diff --git a/drivers/custom/modules-load.conf b/drivers/custom/modules-load.conf
new file mode 100644
index 000000000000..4a6df9065371
--- /dev/null
+++ b/drivers/custom/modules-load.conf
@@ -0,0 +1,4 @@
+gcadapter_oc
+kvmfr
+nct6687
+vhba
\ No newline at end of file
diff --git a/drivers/custom/nct6687d b/drivers/custom/nct6687d
new file mode 160000
index 000000000000..80dc037bb5e1
--- /dev/null
+++ b/drivers/custom/nct6687d
@@ -0,0 +1 @@
+Subproject commit 80dc037bb5e1c354ec05040f69d6144f79725ef4
diff --git a/drivers/custom/nvidia-separate-drivers.py b/drivers/custom/nvidia-separate-drivers.py
new file mode 100644
index 000000000000..a3c0253d2408
--- /dev/null
+++ b/drivers/custom/nvidia-separate-drivers.py
@@ -0,0 +1,248 @@
+#!/usr/bin/python3
+# -*- coding: utf-8 -*-
+#
+# Copyright (C) 2025 Simone Caronni <negativo17@gmail.com>
+# Copyright (C) 2025 Antheas Kapenekakis <negativo17@gmail.com>
+# Licensed under the GNU General Public License Version or later
+
+import argparse
+import json
+import re
+import os
+import shutil
+import sys
+
+
+def generate_pci_entries(gpu_list, open: bool = False):
+    entries = []
+    # Add GPU entries
+    for gpu in gpu_list:
+        for cls in ["PCI_CLASS_DISPLAY_VGA", "PCI_CLASS_DISPLAY_3D"]:
+            # VGA controller entry
+            entries.append(
+                f"""    {{
+            .vendor      = PCI_VENDOR_ID_NVIDIA,
+            .device      = 0x{gpu},
+            .subvendor   = PCI_ANY_ID,
+            .subdevice   = PCI_ANY_ID,
+            .class       = ({cls} << 8),
+            .class_mask  = ~0
+        }},"""
+            )
+
+    # Add NVSwitch entries
+    for switch in devids_nvswitch:
+        entries.append(
+            f"""    {{
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = 0x{switch},
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_BRIDGE << 8),
+        .class_mask  = ~0
+    }},"""
+        )
+
+    # Add terminating empty entry
+    entries.append("    { }")
+    return entries
+
+
+def patch_pci_table_file(header, filepath, gpu_list):
+    with open(filepath, "r") as f:
+        content = f.read()
+
+    # Find and patch nv_pci_table
+    table_pattern = r"struct pci_device_id nv_pci_table\[\] = \{(.*?)\};"
+    match = re.search(table_pattern, content, re.DOTALL)
+    if not match:
+        print(f"Warning: Could not find nv_pci_table in {filepath}")
+        return False
+
+    # Generate new table entries
+    new_entries = generate_pci_entries(gpu_list)
+    new_table = (
+        "struct pci_device_id nv_pci_table[] = {\n" + "\n".join(new_entries) + "\n};"
+    )
+
+    # Replace the old table with the new one
+    content = re.sub(table_pattern, new_table, content, flags=re.DOTALL)
+
+    # Find and patch nv_module_device_table
+    module_table_pattern = (
+        r"struct pci_device_id nv_module_device_table\[\d+\] = \{(.*?)\};"
+    )
+    module_header_pattern = (
+        r"extern struct pci_device_id nv_module_device_table\[\d+\];"
+    )
+    match = re.search(module_table_pattern, content, re.DOTALL)
+    if not match:
+        print(f"Warning: Could not find nv_module_device_table in {filepath}")
+        return False
+
+    # Check if PCI_CLASS_BRIDGE_OTHER entry exists in the original
+    bridge_other_pattern = r"{\s*\.vendor\s*=\s*PCI_VENDOR_ID_NVIDIA,\s*\.device\s*=\s*PCI_ANY_ID,\s*\.subvendor\s*=\s*PCI_ANY_ID,\s*\.subdevice\s*=\s*PCI_ANY_ID,\s*\.class\s*=\s*\(PCI_CLASS_BRIDGE_OTHER\s*<<\s*8\),\s*\.class_mask\s*=\s*~0\s*},"
+    bridge_other_match = re.search(bridge_other_pattern, match.group(1), re.DOTALL)
+    has_bridge_other = bridge_other_match is not None
+
+    # Create the new module table entries
+    module_entries = new_entries[:-1]  # Remove the terminator
+
+    # Add properly formatted PCI_CLASS_BRIDGE_OTHER entry if it existed in original
+    if has_bridge_other:
+        bridge_other_entry = """    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_BRIDGE_OTHER << 8),
+        .class_mask  = ~0
+    },"""
+        module_entries.append(bridge_other_entry)
+
+    module_entries.append("    { }")  # Add back the terminator
+
+    # Calculate the size needed for the module table
+    table_size = len(module_entries)
+    new_module_table = (
+        f"struct pci_device_id nv_module_device_table[{table_size}] = {{\n"
+        + "\n".join(module_entries)
+        + "\n};"
+    )
+    new_module_header = (
+        f"extern struct pci_device_id nv_module_device_table[{table_size}];"
+    )
+
+    # Replace the old module table with the new one
+    content = re.sub(module_table_pattern, new_module_table, content, flags=re.DOTALL)
+
+    # Write the modified content back to the file
+    with open(filepath, "w") as f:
+        f.write(content)
+
+    # Ensure the header file has the extern declaration
+    with open(header, "r") as f:
+        header_content = f.read()
+
+    header_content = re.sub(
+        module_header_pattern, new_module_header, header_content, flags=re.DOTALL
+    )
+
+    with open(header, "w") as f:
+        f.write(header_content)
+
+    return True
+
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(
+        description="Parse a supported-gpus.json file and patch PCI device table files."
+    )
+    parser.add_argument(
+        "--json",
+        dest="INPUT_JSON",
+        help="The JSON file to be parsed (default: supported-gpus/supported-gpus.json)",
+        type=str,
+        default="supported-gpus/supported-gpus.json",
+    )
+    parser.add_argument(
+        "--nvswitch",
+        dest="NVSWITCH_C",
+        help="The src/common/nvswitch/kernel/nvswitch.c file from the Open GPU kernel modules to parse for additional IDs",
+        type=str,
+    )
+    parser.add_argument(
+        "basedir",
+        help="The base directory where the kernel and kernel-open folders are located",
+        type=str,
+        default=".",
+    )
+    args = parser.parse_args()
+
+    b = args.basedir
+    with open(os.path.join(b, args.INPUT_JSON), "r") as f:
+        gpus_raw = json.load(f)
+
+    devids_gpu_closed = []
+    devids_gpu_open = []
+    devids_nvswitch = []
+    names = {}
+    nvswitch_ids = {}
+
+    for product in gpus_raw["chips"]:
+        gpu = product["devid"].replace("0x", "")
+
+        # For closed modules: exclude legacy branch and kernelopen GPUs
+        if not ("legacybranch" in product or "kernelopen" in product["features"]):
+            if not gpu in devids_gpu_closed:
+                devids_gpu_closed.append(gpu)
+                names[gpu] = product["name"]  # Store the GPU name
+
+        # For open modules: include only kernelopen GPUs
+        if "kernelopen" in product["features"]:
+            if not gpu in devids_gpu_open:
+                devids_gpu_open.append(gpu)
+                names[gpu] = product["name"]  # Store the GPU name
+
+    # Read and parse nvswitch.c for device IDs if provided
+    if args.NVSWITCH_C:
+        with open(os.path.join(b, args.NVSWITCH_C), "r") as f:
+            nvswitch_content = f.read()
+
+        # Pattern to match device ID arrays like: nvswitch_lr10_device_ids[] = { 0x1AE8, ... };
+        id_patterns = re.finditer(
+            r"nvswitch_(\w+)_device_ids\[\]\s*=\s*{([^}]+)}", nvswitch_content
+        )
+        for match in id_patterns:
+            gen_name = match.group(1).upper()  # lr10 -> LR10
+            # Extract hex numbers and convert to lowercase without 0x prefix
+            ids = re.findall(r"0x([0-9A-Fa-f]+)", match.group(2))
+            for device_id in ids:
+                device_id = device_id.lower()
+                devids_nvswitch.append(device_id)
+                names[device_id] = f"NVIDIA NVSwitch {gen_name}"
+                nvswitch_ids[device_id] = True
+
+    # Patch kernel files with closed module GPUs
+    driver_type = ["kernel", "kernel-open"]
+
+    header_paths = [
+        "nvidia/nv-pci-table.h",
+        "nvidia-drm/nv-pci-table.h",
+    ]
+    list_paths = [
+        "nvidia/nv-pci-table.c",
+        "nvidia-drm/nv-pci-table.c",
+    ]
+
+    print(
+        f"Found {len(devids_gpu_closed)} closed module GPUs and {len(devids_gpu_open)} open module GPUs"
+    )
+
+    for ktype in driver_type:
+        for hname, cname in zip(header_paths, list_paths):
+            hname = os.path.join(b, ktype, hname)
+            cname = os.path.join(b, ktype, cname)
+
+            for n in [hname, cname]:
+                if os.path.exists(n + ".orig"):
+                    shutil.copyfile(n + ".orig", n)
+                elif os.path.exists(n):
+                    shutil.copyfile(n, n + ".orig")
+                else:
+                    print(f"Error: Could not find {n}")
+                    sys.exit(1)
+
+            if ktype == "kernel":
+                devs = devids_gpu_closed
+                type_desc = "closed module"
+            else:
+                devs = devids_gpu_open
+                type_desc = "open module"
+            if patch_pci_table_file(hname, cname, devs):
+                print(
+                    f"-> Successfully patched {cname} with {len(devs)} {type_desc} GPUs"
+                )
+            else:
+                print(f"Failed to patch {cname}")
+                sys.exit(1)
diff --git a/drivers/custom/razer b/drivers/custom/razer
new file mode 160000
index 000000000000..0663c556e527
--- /dev/null
+++ b/drivers/custom/razer
@@ -0,0 +1 @@
+Subproject commit 0663c556e5272062d2d76c68b11e496c821b8731
diff --git a/drivers/custom/system76 b/drivers/custom/system76
new file mode 160000
index 000000000000..d3d9ce28c65c
--- /dev/null
+++ b/drivers/custom/system76
@@ -0,0 +1 @@
+Subproject commit d3d9ce28c65c315e123ff72d552776d1495f02e6
diff --git a/drivers/custom/system76_io b/drivers/custom/system76_io
new file mode 160000
index 000000000000..fc71f154ab8d
--- /dev/null
+++ b/drivers/custom/system76_io
@@ -0,0 +1 @@
+Subproject commit fc71f154ab8d9810f960ba171479c68c44737649
diff --git a/drivers/custom/v4l2loopback b/drivers/custom/v4l2loopback
new file mode 160000
index 000000000000..c394f8fb2c16
--- /dev/null
+++ b/drivers/custom/v4l2loopback
@@ -0,0 +1 @@
+Subproject commit c394f8fb2c168932055c2577247c42390198d7c9
diff --git a/drivers/custom/xonedo b/drivers/custom/xonedo
new file mode 160000
index 000000000000..b1cd46868954
--- /dev/null
+++ b/drivers/custom/xonedo
@@ -0,0 +1 @@
+Subproject commit b1cd46868954d2b1331611890322d54e5fcb0c49
diff --git a/drivers/custom/xpadneo b/drivers/custom/xpadneo
new file mode 160000
index 000000000000..a16acb03e7be
--- /dev/null
+++ b/drivers/custom/xpadneo
@@ -0,0 +1 @@
+Subproject commit a16acb03e7be191d47ebfbc8ca1d5223422dac3e
diff --git a/drivers/custom/zenergy b/drivers/custom/zenergy
new file mode 160000
index 000000000000..310ed88b13c6
--- /dev/null
+++ b/drivers/custom/zenergy
@@ -0,0 +1 @@
+Subproject commit 310ed88b13c6c46ea8b4e89c120690eb319816a9
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index c7e3c64bc803..5bbcf6d4057c 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1608,8 +1608,8 @@ static void read_symbols(const char *modname)
 			add_namespace(&mod->imported_namespaces, namespace);
 		}
 
-		if (!get_modinfo(&info, "description"))
-			warn("missing MODULE_DESCRIPTION() in %s\n", modname);
+		// if (!get_modinfo(&info, "description"))
+		// 	warn("missing MODULE_DESCRIPTION() in %s\n", modname);
 	}
 
 	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
diff --git a/tools/objtool/builtin-check.c b/tools/objtool/builtin-check.c
index 80239843e9f0..ec97ba30fed5 100644
--- a/tools/objtool/builtin-check.c
+++ b/tools/objtool/builtin-check.c
@@ -101,6 +101,7 @@ static const struct option check_options[] = {
 	OPT_BOOLEAN(0,   "stats", &opts.stats, "print statistics"),
 	OPT_BOOLEAN('v', "verbose", &opts.verbose, "verbose warnings"),
 	OPT_BOOLEAN(0,   "Werror", &opts.werror, "return error on warnings"),
+	OPT_BOOLEAN(0,   "skip-check", &opts.skipcheck, "return error on warnings"),
 
 	OPT_END(),
 };
diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index d14f20ef1db1..c586cd225207 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -4806,5 +4806,8 @@ int check(struct objtool_file *file)
 		disas_warned_funcs(file);
 	}
 
+	if (opts.skipcheck)
+		ret = 0;
+
 	return ret;
 }
diff --git a/tools/objtool/include/objtool/builtin.h b/tools/objtool/include/objtool/builtin.h
index 6b08666fa69d..a128c357bf45 100644
--- a/tools/objtool/include/objtool/builtin.h
+++ b/tools/objtool/include/objtool/builtin.h
@@ -39,6 +39,7 @@ struct opts {
 	bool stats;
 	bool verbose;
 	bool werror;
+	bool skipcheck;
 };
 
 extern struct opts opts;
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 23 Oct 2025 17:19:57 +0200
Subject: platform/x86/amd/pmc: Add support for Van Gogh SoC

The ROG Xbox Ally (non-X) SoC features a similar architecture to the
Steam Deck. While the Steam Deck supports S3 (s2idle causes a crash),
this support was dropped by the Xbox Ally which only S0ix suspend.

Since the handler is missing here, this causes the device to not suspend
and the AMD GPU driver to crash while trying to resume afterwards due to
a power hang.

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4659
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/amd/pmc/pmc.c | 3 +++
 drivers/platform/x86/amd/pmc/pmc.h | 1 +
 2 files changed, 4 insertions(+)

diff --git a/drivers/platform/x86/amd/pmc/pmc.c b/drivers/platform/x86/amd/pmc/pmc.c
index ae70fc71ab42..79870f371beb 100644
--- a/drivers/platform/x86/amd/pmc/pmc.c
+++ b/drivers/platform/x86/amd/pmc/pmc.c
@@ -106,6 +106,7 @@ static void amd_pmc_get_ip_info(struct amd_pmc_dev *dev)
 	switch (dev->cpu_id) {
 	case AMD_CPU_ID_PCO:
 	case AMD_CPU_ID_RN:
+	case AMD_CPU_ID_VG:
 	case AMD_CPU_ID_YC:
 	case AMD_CPU_ID_CB:
 		dev->num_ips = 12;
@@ -517,6 +518,7 @@ static int amd_pmc_get_os_hint(struct amd_pmc_dev *dev)
 	case AMD_CPU_ID_PCO:
 		return MSG_OS_HINT_PCO;
 	case AMD_CPU_ID_RN:
+	case AMD_CPU_ID_VG:
 	case AMD_CPU_ID_YC:
 	case AMD_CPU_ID_CB:
 	case AMD_CPU_ID_PS:
@@ -717,6 +719,7 @@ static const struct pci_device_id pmc_pci_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_RV) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_SP) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_SHP) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, AMD_CPU_ID_VG) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M20H_ROOT) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_1AH_M60H_ROOT) },
 	{ }
diff --git a/drivers/platform/x86/amd/pmc/pmc.h b/drivers/platform/x86/amd/pmc/pmc.h
index 62f3e51020fd..fe3f53eb5955 100644
--- a/drivers/platform/x86/amd/pmc/pmc.h
+++ b/drivers/platform/x86/amd/pmc/pmc.h
@@ -156,6 +156,7 @@ void amd_mp2_stb_deinit(struct amd_pmc_dev *dev);
 #define AMD_CPU_ID_RN			0x1630
 #define AMD_CPU_ID_PCO			AMD_CPU_ID_RV
 #define AMD_CPU_ID_CZN			AMD_CPU_ID_RN
+#define AMD_CPU_ID_VG			0x1645
 #define AMD_CPU_ID_YC			0x14B5
 #define AMD_CPU_ID_CB			0x14D8
 #define AMD_CPU_ID_PS			0x14E8
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Thu, 23 Oct 2025 20:40:56 +0200
Subject: platform/x86/amd/pmc: Add spurious_8042 to Xbox Ally

The Xbox Ally features a Van Gogh SoC that has spurious interrupts
during resume. We get the following logs:

atkbd_receive_byte: 20 callbacks suppressed
atkbd serio0: Spurious ACK on isa0060/serio0. Some program might be trying to access hardware directly.

So, add the spurious_8042 quirk for it. It does not have a keyboard, so
this does not result in any functional loss.

Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4659
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/platform/x86/amd/pmc/pmc-quirks.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/platform/x86/amd/pmc/pmc-quirks.c b/drivers/platform/x86/amd/pmc/pmc-quirks.c
index 0fadcf5f288a..404e62ad293a 100644
--- a/drivers/platform/x86/amd/pmc/pmc-quirks.c
+++ b/drivers/platform/x86/amd/pmc/pmc-quirks.c
@@ -122,6 +122,14 @@ static const struct dmi_system_id fwbug_list[] = {
 			DMI_MATCH(DMI_PRODUCT_NAME, "21A1"),
 		}
 	},
+	{
+		.ident = "ROG Xbox Ally RC73YA",
+		.driver_data = &quirk_spurious_8042,
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK COMPUTER INC."),
+			DMI_MATCH(DMI_BOARD_NAME, "RC73YA"),
+		}
+	},
 	/* https://bugzilla.kernel.org/show_bug.cgi?id=218024 */
 	{
 		.ident = "V14 G4 AMN",
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alex Deucher <alexander.deucher@amd.com>
Date: Thu, 23 Oct 2025 16:24:25 -0400
Subject: drm/amdgpu: only send the SMU RLC notification on S3

For S0ix, the RLC is not powered down. Rework the Van Gogh logic to
skip powering it down and skip part of post-init.

Fixes: 8c4e9105b2a8 ("drm/amdgpu: optimize RLC powerdown notification on Vangogh")
Closes: https://gitlab.freedesktop.org/drm/amd/-/issues/4659
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Tested-by: Antheas Kapenekakis <lkml@antheas.dev>
Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c       | 8 +++++---
 drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c        | 6 ++++++
 drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c | 3 +++
 3 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 907ae2f5a981..ea90b315b5bd 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -5186,9 +5186,11 @@ int amdgpu_device_suspend(struct drm_device *dev, bool notify_clients)
 	if (amdgpu_sriov_vf(adev))
 		amdgpu_virt_release_full_gpu(adev, false);
 
-	r = amdgpu_dpm_notify_rlc_state(adev, false);
-	if (r)
-		return r;
+	if (!adev->in_s0ix) {
+		r = amdgpu_dpm_notify_rlc_state(adev, false);
+		if (r)
+			return r;
+	}
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
index 4eb99b74a04f..3758eee890dc 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/amdgpu_smu.c
@@ -2012,6 +2012,12 @@ static int smu_disable_dpms(struct smu_context *smu)
 	    smu->is_apu && (amdgpu_in_reset(adev) || adev->in_s0ix))
 		return 0;
 
+	/* vangogh s0ix */
+	if ((amdgpu_ip_version(adev, MP1_HWIP, 0) == IP_VERSION(11, 5, 0) ||
+	     amdgpu_ip_version(adev, MP1_HWIP, 0) == IP_VERSION(11, 5, 2)) &&
+	    adev->in_s0ix)
+		return 0;
+
 	/*
 	 * For gpu reset, runpm and hibernation through BACO,
 	 * BACO feature has to be kept enabled.
diff --git a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
index 2c9869feba61..0708d0f0938b 100644
--- a/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
+++ b/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c
@@ -2217,6 +2217,9 @@ static int vangogh_post_smu_init(struct smu_context *smu)
 	uint32_t total_cu = adev->gfx.config.max_cu_per_sh *
 		adev->gfx.config.max_sh_per_se * adev->gfx.config.max_shader_engines;
 
+	if (adev->in_s0ix)
+		return 0;
+
 	/* allow message will be sent after enable message on Vangogh*/
 	if (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT) &&
 			(adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)) {
-- 
2.51.0


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <lkml@antheas.dev>
Date: Fri, 24 Oct 2025 22:29:15 +0200
Subject: patch it87 using frankcrawford/it87#60d9de

Signed-off-by: Antheas Kapenekakis <lkml@antheas.dev>
---
 drivers/hwmon/it87.c | 1695 ++++++++++++++++++++++++++++++++----------
 1 file changed, 1310 insertions(+), 385 deletions(-)

diff --git a/drivers/hwmon/it87.c b/drivers/hwmon/it87.c
index e233aafa8856..a7d8da0ca8bb 100644
--- a/drivers/hwmon/it87.c
+++ b/drivers/hwmon/it87.c
@@ -12,10 +12,19 @@
  *  similar parts.  The other devices are supported by different drivers.
  *
  *  Supports: IT8603E  Super I/O chip w/LPC interface
+ *            IT8606E  Super I/O chip w/LPC interface
+ *            IT8607E  Super I/O chip w/LPC interface
+ *            IT8613E  Super I/O chip w/LPC interface
  *            IT8620E  Super I/O chip w/LPC interface
  *            IT8622E  Super I/O chip w/LPC interface
  *            IT8623E  Super I/O chip w/LPC interface
+ *            IT8625E  Super I/O chip w/LPC interface
  *            IT8628E  Super I/O chip w/LPC interface
+ *            IT8655E  Super I/O chip w/LPC interface
+ *            IT8665E  Super I/O chip w/LPC interface
+ *            IT8686E  Super I/O chip w/LPC interface
+ *            IT8688E  Super I/O chip w/LPC interface
+ *            IT8689E  Super I/O chip w/LPC interface
  *            IT8705F  Super I/O chip w/LPC interface
  *            IT8712F  Super I/O chip w/LPC interface
  *            IT8716F  Super I/O chip w/LPC interface
@@ -25,12 +34,15 @@
  *            IT8726F  Super I/O chip w/LPC interface
  *            IT8728F  Super I/O chip w/LPC interface
  *            IT8732F  Super I/O chip w/LPC interface
+ *            IT8736F  Super I/O chip w/LPC interface
+ *            IT8738E  Super I/O chip w/LPC interface
  *            IT8758E  Super I/O chip w/LPC interface
  *            IT8771E  Super I/O chip w/LPC interface
  *            IT8772E  Super I/O chip w/LPC interface
  *            IT8781F  Super I/O chip w/LPC interface
  *            IT8782F  Super I/O chip w/LPC interface
  *            IT8783E/F Super I/O chip w/LPC interface
+ *            IT8785E  Super I/O chip w/LPC interface
  *            IT8786E  Super I/O chip w/LPC interface
  *            IT8790E  Super I/O chip w/LPC interface
  *            IT8792E  Super I/O chip w/LPC interface
@@ -63,8 +75,10 @@
 #define DRVNAME "it87"
 
 enum chips { it87, it8712, it8716, it8718, it8720, it8721, it8728, it8732,
-	     it8771, it8772, it8781, it8782, it8783, it8786, it8790,
-	     it8792, it8603, it8620, it8622, it8628, it87952 };
+	     it8736, it8738,
+	     it8771, it8772, it8781, it8782, it8783, it8785, it8786, it8790,
+	     it8792, it8603, it8606, it8607, it8613, it8620, it8622, it8625,
+	     it8628, it8655, it8665, it8686, it8688, it8689, it87952, it8696 };
 
 static struct platform_device *it87_pdev[2];
 
@@ -72,10 +86,10 @@ static struct platform_device *it87_pdev[2];
 #define	REG_4E	0x4e	/* Secondary register to read/write */
 
 #define	DEV	0x07	/* Register: Logical device select */
-#define PME	0x04	/* The device with the fan registers in it */
+#define	PME	0x04	/* The device with the fan registers in it */
 
 /* The device with the IT8718F/IT8720F VID value in it */
-#define GPIO	0x07
+#define	GPIO	0x07
 
 #define	DEVID	0x20	/* Register: Device ID */
 #define	DEVREV	0x22	/* Register: Device Revision */
@@ -90,8 +104,12 @@ static inline void __superio_enter(int ioreg)
 
 static inline int superio_inb(int ioreg, int reg)
 {
+	int val;
+
 	outb(reg, ioreg);
-	return inb(ioreg + 1);
+	val = inb(ioreg + 1);
+
+	return val;
 }
 
 static inline void superio_outb(int ioreg, int reg, int val)
@@ -102,13 +120,7 @@ static inline void superio_outb(int ioreg, int reg, int val)
 
 static int superio_inw(int ioreg, int reg)
 {
-	int val;
-
-	outb(reg++, ioreg);
-	val = inb(ioreg + 1) << 8;
-	outb(reg, ioreg);
-	val |= inb(ioreg + 1);
-	return val;
+	return (superio_inb(ioreg, reg) << 8) | superio_inb(ioreg, reg + 1);
 }
 
 static inline void superio_select(int ioreg, int ldn)
@@ -149,34 +161,52 @@ static inline void superio_exit(int ioreg, bool noexit)
 #define IT8726F_DEVID 0x8726
 #define IT8728F_DEVID 0x8728
 #define IT8732F_DEVID 0x8732
+#define IT8736F_DEVID 0x8736
+#define IT8738E_DEVID 0x8738
 #define IT8792E_DEVID 0x8733
 #define IT8771E_DEVID 0x8771
 #define IT8772E_DEVID 0x8772
 #define IT8781F_DEVID 0x8781
 #define IT8782F_DEVID 0x8782
 #define IT8783E_DEVID 0x8783
+#define IT8785E_DEVID 0x8785
 #define IT8786E_DEVID 0x8786
 #define IT8790E_DEVID 0x8790
 #define IT8603E_DEVID 0x8603
+#define IT8606E_DEVID 0x8606
+#define IT8607E_DEVID 0x8607
+#define IT8613E_DEVID 0x8613
 #define IT8620E_DEVID 0x8620
 #define IT8622E_DEVID 0x8622
 #define IT8623E_DEVID 0x8623
+#define IT8625E_DEVID 0x8625
 #define IT8628E_DEVID 0x8628
+#define IT8655E_DEVID 0x8655
+#define IT8665E_DEVID 0x8665
+#define IT8686E_DEVID 0x8686
+#define IT8688E_DEVID 0x8688
+#define IT8689E_DEVID 0x8689
 #define IT87952E_DEVID 0x8695
+#define IT8696E_DEVID 0x8696
 
 /* Logical device 4 (Environmental Monitor) registers */
-#define IT87_ACT_REG	0x30
-#define IT87_BASE_REG	0x60
+#define IT87_ACT_REG  0x30
+#define IT87_BASE_REG 0x60
 #define IT87_SPECIAL_CFG_REG	0xf3	/* special configuration register */
 
-/* Logical device 7 registers (IT8712F and later) */
+/* Global configuration registers (IT8712F and later) */
+#define IT87_EC_HWM_MIO_REG	0x24	/* MMIO configuration register */
 #define IT87_SIO_GPIO1_REG	0x25
 #define IT87_SIO_GPIO2_REG	0x26
 #define IT87_SIO_GPIO3_REG	0x27
 #define IT87_SIO_GPIO4_REG	0x28
 #define IT87_SIO_GPIO5_REG	0x29
+#define IT87_SIO_GPIO9_REG	0xd3
 #define IT87_SIO_PINX1_REG	0x2a	/* Pin selection */
 #define IT87_SIO_PINX2_REG	0x2c	/* Pin selection */
+#define IT87_SIO_PINX4_REG	0x2d	/* Pin selection */
+
+/* Logical device 7 (GPIO) registers (IT8712F and later) */
 #define IT87_SIO_SPI_REG	0xef	/* SPI function pin select */
 #define IT87_SIO_VID_REG	0xfc	/* VID value */
 #define IT87_SIO_BEEP_PIN_REG	0xf6	/* Beep pin mapping */
@@ -188,6 +218,9 @@ static unsigned int force_id_cnt;
 /* ACPI resource conflicts are ignored if this parameter is set to 1 */
 static bool ignore_resource_conflict;
 
+/* If set the driver uses MMIO to access the chip if supported */
+static bool mmio;
+
 /* Update battery voltage after every reading if true */
 static bool update_vbat;
 
@@ -217,6 +250,8 @@ static bool fix_pwm_polarity;
 #define IT87_REG_ALARM2        0x02
 #define IT87_REG_ALARM3        0x03
 
+#define IT87_REG_BANK          0x06
+
 /*
  * The IT8718F and IT8720F have the VID value in a different register, in
  * Super-I/O configuration space.
@@ -245,11 +280,25 @@ static const u8 IT87_REG_FAN[]         = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x4c };
 static const u8 IT87_REG_FAN_MIN[]     = { 0x10, 0x11, 0x12, 0x84, 0x86, 0x4e };
 static const u8 IT87_REG_FANX[]        = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
 static const u8 IT87_REG_FANX_MIN[]    = { 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0x4f };
-static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59 };
+
+static const u8 IT87_REG_FAN_8665[]    = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x93 };
+static const u8 IT87_REG_FAN_MIN_8665[] = {
+					   0x10, 0x11, 0x12, 0x84, 0x86, 0xb2 };
+static const u8 IT87_REG_FANX_8665[]   = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x94 };
+static const u8 IT87_REG_FANX_MIN_8665[] = {
+					   0x1b, 0x1c, 0x1d, 0x85, 0x87, 0xb3 };
+
+static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59, 0x5a, 0x90, 0x91 };
+
+static const u8 IT87_REG_TEMP_OFFSET_8686[] = {
+					   0x56, 0x57, 0x59, 0x90, 0x91, 0x92 };
 
 #define IT87_REG_FAN_MAIN_CTRL 0x13
 #define IT87_REG_FAN_CTL       0x14
+
 static const u8 IT87_REG_PWM[]         = { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };
+static const u8 IT87_REG_PWM_8665[]    = { 0x15, 0x16, 0x17, 0x1e, 0x1f, 0x92 };
+
 static const u8 IT87_REG_PWM_DUTY[]    = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
 
 static const u8 IT87_REG_VIN[]	= { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
@@ -259,15 +308,21 @@ static const u8 IT87_REG_VIN[]	= { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
 
 #define IT87_REG_VIN_MAX(nr)   (0x30 + (nr) * 2)
 #define IT87_REG_VIN_MIN(nr)   (0x31 + (nr) * 2)
-#define IT87_REG_TEMP_HIGH(nr) (0x40 + (nr) * 2)
-#define IT87_REG_TEMP_LOW(nr)  (0x41 + (nr) * 2)
 
-#define IT87_REG_VIN_ENABLE    0x50
-#define IT87_REG_TEMP_ENABLE   0x51
-#define IT87_REG_TEMP_EXTRA    0x55
-#define IT87_REG_BEEP_ENABLE   0x5c
+static const u8 IT87_REG_TEMP_HIGH[]   = { 0x40, 0x42, 0x44, 0x46, 0xb4, 0xb6 };
+static const u8 IT87_REG_TEMP_LOW[]    = { 0x41, 0x43, 0x45, 0x47, 0xb5, 0xb7 };
+
+static const u8 IT87_REG_TEMP_HIGH_8686[] = {
+					   0x40, 0x42, 0x44, 0xb4, 0xb6, 0xb8 };
+static const u8 IT87_REG_TEMP_LOW_8686[] = {
+					   0x41, 0x43, 0x45, 0xb5, 0xb7, 0xb9 };
+
+#define IT87_REG_VIN_ENABLE   0x50
+#define IT87_REG_TEMP_ENABLE  0x51
+#define IT87_REG_TEMP_EXTRA   0x55
+#define IT87_REG_BEEP_ENABLE  0x5c
 
-#define IT87_REG_CHIPID        0x58
+#define IT87_REG_CHIPID       0x58
 
 static const u8 IT87_REG_AUTO_BASE[] = { 0x60, 0x68, 0x70, 0x78, 0xa0, 0xa8 };
 
@@ -276,11 +331,12 @@ static const u8 IT87_REG_AUTO_BASE[] = { 0x60, 0x68, 0x70, 0x78, 0xa0, 0xa8 };
 
 #define IT87_REG_TEMP456_ENABLE	0x77
 
+static const u16 IT87_REG_TEMP_SRC1[] = { 0x21d, 0x21e, 0x21f };
+#define IT87_REG_TEMP_SRC2	0x23d
+
 #define NUM_VIN			ARRAY_SIZE(IT87_REG_VIN)
 #define NUM_VIN_LIMIT		8
 #define NUM_TEMP		6
-#define NUM_TEMP_OFFSET		ARRAY_SIZE(IT87_REG_TEMP_OFFSET)
-#define NUM_TEMP_LIMIT		3
 #define NUM_FAN			ARRAY_SIZE(IT87_REG_FAN)
 #define NUM_FAN_DIV		3
 #define NUM_PWM			ARRAY_SIZE(IT87_REG_PWM)
@@ -290,6 +346,9 @@ struct it87_devices {
 	const char *name;
 	const char * const model;
 	u32 features;
+	u8 num_temp_limit;
+	u8 num_temp_offset;
+	u8 num_temp_map;	/* Number of temperature sources for pwm */
 	u8 peci_mask;
 	u8 old_peci_mask;
 	u8 smbus_bitmap;	/* SMBus enable bits in extra config register */
@@ -300,7 +359,6 @@ struct it87_devices {
 #define FEAT_NEWER_AUTOPWM	BIT(1)
 #define FEAT_OLD_AUTOPWM	BIT(2)
 #define FEAT_16BIT_FANS		BIT(3)
-#define FEAT_TEMP_OFFSET	BIT(4)
 #define FEAT_TEMP_PECI		BIT(5)
 #define FEAT_TEMP_OLD_PECI	BIT(6)
 #define FEAT_FAN16_CONFIG	BIT(7)	/* Need to enable 16-bit fans */
@@ -326,6 +384,10 @@ struct it87_devices {
 #define FEAT_FOUR_PWM		BIT(21)	/* Supports four fan controls */
 #define FEAT_FOUR_TEMP		BIT(22)
 #define FEAT_FANCTL_ONOFF	BIT(23)	/* chip has FAN_CTL ON/OFF */
+#define FEAT_NEW_TEMPMAP	BIT(24)	/* new temp input selection */
+#define FEAT_BANK_SEL		BIT(25)	/* Chip has multi-bank support */
+#define FEAT_11MV_ADC		BIT(26)
+#define FEAT_MMIO		BIT(27)	/* Chip supports MMIO */
 
 static const struct it87_devices it87_devices[] = {
 	[it87] = {
@@ -333,193 +395,413 @@ static const struct it87_devices it87_devices[] = {
 		.model = "IT87F",
 		.features = FEAT_OLD_AUTOPWM | FEAT_FANCTL_ONOFF,
 		/* may need to overwrite */
+		.num_temp_limit = 3,
+		.num_temp_offset = 0,
+		.num_temp_map = 3,
 	},
 	[it8712] = {
 		.name = "it8712",
 		.model = "IT8712F",
 		.features = FEAT_OLD_AUTOPWM | FEAT_VID | FEAT_FANCTL_ONOFF,
 		/* may need to overwrite */
+		.num_temp_limit = 3,
+		.num_temp_offset = 0,
+		.num_temp_map = 3,
 	},
 	[it8716] = {
 		.name = "it8716",
 		.model = "IT8716F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
+		.features = FEAT_16BIT_FANS | FEAT_VID
 		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 	},
 	[it8718] = {
 		.name = "it8718",
 		.model = "IT8718F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
+		.features = FEAT_16BIT_FANS | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8720] = {
 		.name = "it8720",
 		.model = "IT8720F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
+		.features = FEAT_16BIT_FANS | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8721] = {
 		.name = "it8721",
 		.model = "IT8721F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
+		  | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x05,
-		.old_peci_mask = 0x02,	/* Actually reports PCH */
+		.old_peci_mask = 0x02,  /* Actually reports PCH */
 	},
 	[it8728] = {
 		.name = "it8728",
 		.model = "IT8728F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
+		  | FEAT_TEMP_PECI | FEAT_FIVE_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 6,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8732] = {
 		.name = "it8732",
 		.model = "IT8732F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
+		  | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FOUR_FANS
 		  | FEAT_FOUR_PWM | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
+		.peci_mask = 0x07,
+		.old_peci_mask = 0x02,  /* Actually reports PCH */
+	},
+	[it8736] = {
+		.name = "it8736",
+		.model = "IT8736F",
+		.features = FEAT_16BIT_FANS
+		  | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FOUR_FANS
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
-		.old_peci_mask = 0x02,	/* Actually reports PCH */
+		.old_peci_mask = 0x02,  /* Actually reports PCH */
+	},
+	[it8738] = {
+		.name = "it8738",
+		.model = "IT8738E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL
+		  | FEAT_FANCTL_ONOFF
+		  | FEAT_AVCC3,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
+		.peci_mask = 0x07,
+		.old_peci_mask = 0x02,
 	},
 	[it8771] = {
 		.name = "it8771",
 		.model = "IT8771E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
 				/* PECI: guesswork */
 				/* 12mV ADC (OHM) */
 				/* 16 bit fans (OHM) */
 				/* three fans, always 16 bit (guesswork) */
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8772] = {
 		.name = "it8772",
 		.model = "IT8772E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
 				/* PECI (coreboot) */
 				/* 12mV ADC (HWSensors4, OHM) */
 				/* 16 bit fans (HWSensors4, OHM) */
 				/* three fans, always 16 bit (datasheet) */
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8781] = {
 		.name = "it8781",
 		.model = "IT8781F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
+		.features = FEAT_16BIT_FANS
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8782] = {
 		.name = "it8782",
 		.model = "IT8782F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
+		.features = FEAT_16BIT_FANS
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8783] = {
 		.name = "it8783",
 		.model = "IT8783E/F",
-		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
+		.features = FEAT_16BIT_FANS
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.old_peci_mask = 0x4,
 	},
+	[it8785] = {
+		.name = "it8785",
+		.model = "IT8785E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
+		.peci_mask = 0x07,
+	},
 	[it8786] = {
 		.name = "it8786",
 		.model = "IT8786E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8790] = {
 		.name = "it8790",
 		.model = "IT8790E",
-		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_NOCONF,
+		.features = FEAT_NEWER_AUTOPWM | FEAT_10_9MV_ADC
+		  | FEAT_16BIT_FANS | FEAT_TEMP_PECI
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF
+		  | FEAT_NOCONF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8792] = {
 		.name = "it8792",
 		.model = "IT8792E/IT8795E",
-		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
-		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF
+		.features = FEAT_NEWER_AUTOPWM | FEAT_11MV_ADC
+		  | FEAT_16BIT_FANS | FEAT_TEMP_PECI
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF
 		  | FEAT_NOCONF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
-		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
 	[it8603] = {
 		.name = "it8603",
 		.model = "IT8603E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_AVCC3 | FEAT_PWM_FREQ2,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 4,
+		.peci_mask = 0x07,
+	},
+	[it8606] = {
+		.name = "it8606",
+		.model = "IT8606E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_AVCC3 | FEAT_PWM_FREQ2,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
+		.peci_mask = 0x07,
+	},
+	[it8607] = {
+		.name = "it8607",
+		.model = "IT8607E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL | FEAT_NEW_TEMPMAP
+		  | FEAT_AVCC3 | FEAT_PWM_FREQ2
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 6,
+		.peci_mask = 0x07,
+	},
+	[it8613] = {
+		.name = "it8613",
+		.model = "IT8613E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_11MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_PECI | FEAT_FIVE_FANS
+		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
+		  | FEAT_AVCC3 | FEAT_NEW_TEMPMAP,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 6,
 		.peci_mask = 0x07,
 	},
 	[it8620] = {
 		.name = "it8620",
 		.model = "IT8620E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
+		  | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
 		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
 	[it8622] = {
 		.name = "it8622",
 		.model = "IT8622E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
+		  | FEAT_TEMP_PECI | FEAT_FIVE_FANS | FEAT_FOUR_TEMP
 		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
-		  | FEAT_AVCC3 | FEAT_VIN3_5V | FEAT_FOUR_TEMP,
-		.peci_mask = 0x07,
+		  | FEAT_AVCC3 | FEAT_VIN3_5V,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 4,
+		.peci_mask = 0x0f,
+		.smbus_bitmap = BIT(1) | BIT(2),
+	},
+	[it8625] = {
+		.name = "it8625",
+		.model = "IT8625E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_11MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 6,
 		.smbus_bitmap = BIT(1) | BIT(2),
 	},
 	[it8628] = {
 		.name = "it8628",
 		.model = "IT8628E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
+		  | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
-		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,
+		  | FEAT_SIX_TEMP | FEAT_AVCC3
+		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 6,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
 	},
+	[it8655] = {
+		.name = "it8655",
+		.model = "IT8655E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_BANK_SEL
+		  | FEAT_SIX_TEMP | FEAT_MMIO,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 6,
+		.smbus_bitmap = BIT(2),
+	},
+	[it8665] = {
+		.name = "it8665",
+		.model = "IT8665E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL | FEAT_MMIO | FEAT_SIX_TEMP,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 6,
+		.smbus_bitmap = BIT(2),
+	},
+	[it8686] = {
+		.name = "it8686",
+		.model = "IT8686E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC
+		  | FEAT_16BIT_FANS | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_AVCC3,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 7,
+		.smbus_bitmap = BIT(1) | BIT(2),
+	},
+	[it8688] = {
+		.name = "it8688",
+		.model = "IT8688E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_AVCC3,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 7,
+		.smbus_bitmap = BIT(1) | BIT(2),
+	},
+	[it8689] = {
+		.name = "it8689",
+		.model = "IT8689E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_AVCC3,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 7,
+		.smbus_bitmap = BIT(1) | BIT(2),
+	},
 	[it87952] = {
 		.name = "it87952",
 		.model = "IT87952E",
-		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
-		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
-		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF
+		.features = FEAT_NEWER_AUTOPWM | FEAT_11MV_ADC
+		  | FEAT_16BIT_FANS | FEAT_TEMP_PECI
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF
 		  | FEAT_NOCONF,
+		.num_temp_limit = 3,
+		.num_temp_offset = 3,
+		.num_temp_map = 3,
 		.peci_mask = 0x07,
-		.old_peci_mask = 0x02,	/* Actually reports PCH */
+	},
+		[it8696] = {
+		.name = "it8696",
+		.model = "IT8696E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_AVCC3,
+		.num_temp_limit = 6,
+		.num_temp_offset = 6,
+		.num_temp_map = 7,
+		.smbus_bitmap = BIT(1) | BIT(2),
 	},
 };
 
 #define has_16bit_fans(data)	((data)->features & FEAT_16BIT_FANS)
 #define has_12mv_adc(data)	((data)->features & FEAT_12MV_ADC)
+#define has_11mv_adc(data)	((data)->features & FEAT_11MV_ADC)
 #define has_10_9mv_adc(data)	((data)->features & FEAT_10_9MV_ADC)
 #define has_newer_autopwm(data)	((data)->features & FEAT_NEWER_AUTOPWM)
 #define has_old_autopwm(data)	((data)->features & FEAT_OLD_AUTOPWM)
-#define has_temp_offset(data)	((data)->features & FEAT_TEMP_OFFSET)
 #define has_temp_peci(data, nr)	(((data)->features & FEAT_TEMP_PECI) && \
 				 ((data)->peci_mask & BIT(nr)))
 #define has_temp_old_peci(data, nr) \
@@ -547,12 +829,16 @@ static const struct it87_devices it87_devices[] = {
 #define has_vin3_5v(data)	((data)->features & FEAT_VIN3_5V)
 #define has_noconf(data)	((data)->features & FEAT_NOCONF)
 #define has_scaling(data)	((data)->features & (FEAT_12MV_ADC | \
-						     FEAT_10_9MV_ADC))
+						     FEAT_10_9MV_ADC | \
+						     FEAT_11MV_ADC))
 #define has_fanctl_onoff(data)	((data)->features & FEAT_FANCTL_ONOFF)
+#define has_new_tempmap(data)	((data)->features & FEAT_NEW_TEMPMAP)
+#define has_bank_sel(data)	((data)->features & FEAT_BANK_SEL)
+#define has_mmio(data)		((data)->features & FEAT_MMIO)
 
 struct it87_sio_data {
-	int sioaddr;
 	enum chips type;
+	u8 sioaddr;
 	/* Values read from Super-I/O config space */
 	u8 revision;
 	u8 vid_value;
@@ -575,17 +861,32 @@ struct it87_sio_data {
  */
 struct it87_data {
 	const struct attribute_group *groups[7];
-	int sioaddr;
 	enum chips type;
 	u32 features;
 	u8 peci_mask;
 	u8 old_peci_mask;
 
 	u8 smbus_bitmap;	/* !=0 if SMBus needs to be disabled */
+	u8 saved_bank;		/* saved bank register value */
 	u8 ec_special_config;	/* EC special config register restore value */
+	u8 sioaddr;		/* SIO port address */
+
+	void __iomem *mmio;	/* Remapped MMIO address if available */
+	int (*read)(struct it87_data *, u16);
+	void (*write)(struct it87_data *, u16, u8);
+
+	const u8 *REG_FAN;
+	const u8 *REG_FANX;
+	const u8 *REG_FAN_MIN;
+	const u8 *REG_FANX_MIN;
+
+	const u8 *REG_PWM;
+
+	const u8 *REG_TEMP_OFFSET;
+	const u8 *REG_TEMP_LOW;
+	const u8 *REG_TEMP_HIGH;
 
 	unsigned short addr;
-	const char *name;
 	struct mutex update_lock;
 	bool valid;		/* true if following fields are valid */
 	unsigned long last_updated;	/* In jiffies */
@@ -593,12 +894,15 @@ struct it87_data {
 	u16 in_scaled;		/* Internal voltage sensors are scaled */
 	u16 in_internal;	/* Bitfield, internal sensors (for labels) */
 	u16 has_in;		/* Bitfield, voltage sensors enabled */
-	u8 in[NUM_VIN][3];		/* [nr][0]=in, [1]=min, [2]=max */
+	u8 in[NUM_VIN][3];	/* [nr][0]=in, [1]=min, [2]=max */
 	bool need_in7_reroute;
 	u8 has_fan;		/* Bitfield, fans enabled */
 	u16 fan[NUM_FAN][2];	/* Register values, [nr][0]=fan, [1]=min */
 	u8 has_temp;		/* Bitfield, temp sensors enabled */
 	s8 temp[NUM_TEMP][4];	/* [nr][0]=temp, [1]=min, [2]=max, [3]=offset */
+	u8 num_temp_limit;	/* Number of temperature limit registers */
+	u8 num_temp_offset;	/* Number of temperature offset registers */
+	u8 temp_src[4];		/* Up to 4 temperature source registers */
 	u8 sensor;		/* Register value (IT87_REG_TEMP_ENABLE) */
 	u8 extra;		/* Register value (IT87_REG_TEMP_EXTRA) */
 	u8 fan_div[NUM_FAN_DIV];/* Register encoding, shifted right */
@@ -625,6 +929,9 @@ struct it87_data {
 	u8 pwm_ctrl[NUM_PWM];	/* Register value */
 	u8 pwm_duty[NUM_PWM];	/* Manual PWM value set by user */
 	u8 pwm_temp_map[NUM_PWM];/* PWM to temp. chan. mapping (bits 1-0) */
+	u8 pwm_temp_map_mask;	/* 0x03 for old, 0x07 for new temp map */
+	u8 pwm_temp_map_shift;	/* 0 for old, 3 for new temp map */
+	u8 pwm_num_temp_map;	/* from config data, 3..7 depending on chip */
 
 	/* Automatic fan speed control registers */
 	u8 auto_pwm[NUM_AUTO_PWM][4];	/* [nr][3] is hard-coded */
@@ -634,6 +941,7 @@ struct it87_data {
 /* Board specific settings from DMI matching */
 struct it87_dmi_data {
 	u8 skip_pwm;		/* pwm channels to skip for this board  */
+	bool skip_acpi_res;	/* ignore acpi failures on this board */
 };
 
 /* Global for results from DMI matching, if needed */
@@ -647,6 +955,8 @@ static int adc_lsb(const struct it87_data *data, int nr)
 		lsb = 120;
 	else if (has_10_9mv_adc(data))
 		lsb = 109;
+	else if (has_11mv_adc(data))
+		lsb = 110;
 	else
 		lsb = 160;
 	if (data->in_scaled & BIT(nr))
@@ -717,6 +1027,25 @@ static int DIV_TO_REG(int val)
 
 #define DIV_FROM_REG(val) BIT(val)
 
+static u8 temp_map_from_reg(const struct it87_data *data, u8 reg)
+{
+	u8 map;
+
+	map = (reg >> data->pwm_temp_map_shift) & data->pwm_temp_map_mask;
+	if (map >= data->pwm_num_temp_map)  /* map is 0-based */
+		map = 0;
+
+	return map;
+}
+
+static u8 temp_map_to_reg(const struct it87_data *data, int nr, u8 map)
+{
+	u8 ctrl = data->pwm_ctrl[nr];
+
+	return (ctrl & ~(data->pwm_temp_map_mask << data->pwm_temp_map_shift)) |
+		(map << data->pwm_temp_map_shift);
+}
+
 /*
  * PWM base frequencies. The frequency has to be divided by either 128 or 256,
  * depending on the chip type, to calculate the actual PWM frequency.
@@ -738,6 +1067,18 @@ static const unsigned int pwm_freq[8] = {
 	750000,
 };
 
+static int _it87_io_read(struct it87_data *data, u16 reg)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+}
+
+static void _it87_io_write(struct it87_data *data, u16 reg, u8 value)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+}
+
 static int smbus_disable(struct it87_data *data)
 {
 	int err;
@@ -750,6 +1091,8 @@ static int smbus_disable(struct it87_data *data)
 		superio_outb(data->sioaddr, IT87_SPECIAL_CFG_REG,
 			     data->ec_special_config & ~data->smbus_bitmap);
 		superio_exit(data->sioaddr, has_noconf(data));
+		if (has_bank_sel(data) && !data->mmio)
+			data->saved_bank = _it87_io_read(data, IT87_REG_BANK);
 	}
 	return 0;
 }
@@ -759,6 +1102,8 @@ static int smbus_enable(struct it87_data *data)
 	int err;
 
 	if (data->smbus_bitmap) {
+		if (has_bank_sel(data) && !data->mmio)
+			_it87_io_write(data, IT87_REG_BANK, data->saved_bank);
 		err = superio_enter(data->sioaddr, has_noconf(data));
 		if (err)
 			return err;
@@ -771,16 +1116,39 @@ static int smbus_enable(struct it87_data *data)
 	return 0;
 }
 
+static u8 it87_io_set_bank(struct it87_data *data, u8 bank)
+{
+	u8 _bank = bank;
+
+	if (has_bank_sel(data)) {
+		u8 breg = _it87_io_read(data, IT87_REG_BANK);
+
+		_bank = breg >> 5;
+		if (bank != _bank) {
+			breg &= 0x1f;
+			breg |= (bank << 5);
+			_it87_io_write(data, IT87_REG_BANK, breg);
+		}
+	}
+	return _bank;
+}
+
 /*
  * Must be called with data->update_lock held, except during initialization.
  * Must be called with SMBus accesses disabled.
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static int it87_read_value(struct it87_data *data, u8 reg)
+static int it87_io_read(struct it87_data *data, u16 reg)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+	u8 bank;
+	int val;
+
+	bank = it87_io_set_bank(data, reg >> 8);
+	val = _it87_io_read(data, reg & 0xff);
+	it87_io_set_bank(data, bank);
+
+	return val;
 }
 
 /*
@@ -789,34 +1157,49 @@ static int it87_read_value(struct it87_data *data, u8 reg)
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static void it87_write_value(struct it87_data *data, u8 reg, u8 value)
+static void it87_io_write(struct it87_data *data, u16 reg, u8 value)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+	u8 bank;
+
+	bank = it87_io_set_bank(data, reg >> 8);
+	_it87_io_write(data, reg & 0xff, value);
+	it87_io_set_bank(data, bank);
+}
+
+static int it87_mmio_read(struct it87_data *data, u16 reg)
+{
+	return readb(data->mmio + reg);
+}
+
+static void it87_mmio_write(struct it87_data *data, u16 reg, u8 value)
+{
+	writeb(value, data->mmio + reg);
 }
 
 static void it87_update_pwm_ctrl(struct it87_data *data, int nr)
 {
-	data->pwm_ctrl[nr] = it87_read_value(data, IT87_REG_PWM[nr]);
+	u8 ctrl;
+
+	ctrl = data->read(data, data->REG_PWM[nr]);
+	data->pwm_ctrl[nr] = ctrl;
 	if (has_newer_autopwm(data)) {
-		data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
-		data->pwm_duty[nr] = it87_read_value(data,
-						     IT87_REG_PWM_DUTY[nr]);
+		data->pwm_temp_map[nr] = temp_map_from_reg(data, ctrl);
+		data->pwm_duty[nr] = data->read(data, IT87_REG_PWM_DUTY[nr]);
 	} else {
-		if (data->pwm_ctrl[nr] & 0x80)	/* Automatic mode */
-			data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
+		if (ctrl & 0x80)	/* Automatic mode */
+			data->pwm_temp_map[nr] = temp_map_from_reg(data, ctrl);
 		else				/* Manual mode */
-			data->pwm_duty[nr] = data->pwm_ctrl[nr] & 0x7f;
+			data->pwm_duty[nr] = ctrl & 0x7f;
 	}
 
 	if (has_old_autopwm(data)) {
 		int i;
 
 		for (i = 0; i < 5 ; i++)
-			data->auto_temp[nr][i] = it87_read_value(data,
+			data->auto_temp[nr][i] = data->read(data,
 						IT87_REG_AUTO_TEMP(nr, i));
 		for (i = 0; i < 3 ; i++)
-			data->auto_pwm[nr][i] = it87_read_value(data,
+			data->auto_pwm[nr][i] = data->read(data,
 						IT87_REG_AUTO_PWM(nr, i));
 	} else if (has_newer_autopwm(data)) {
 		int i;
@@ -828,20 +1211,19 @@ static void it87_update_pwm_ctrl(struct it87_data *data, int nr)
 		 * 3: fan max temperature (base + 2)
 		 */
 		data->auto_temp[nr][0] =
-			it87_read_value(data, IT87_REG_AUTO_TEMP(nr, 5));
+			data->read(data, IT87_REG_AUTO_TEMP(nr, 5));
 
 		for (i = 0; i < 3 ; i++)
 			data->auto_temp[nr][i + 1] =
-				it87_read_value(data,
-						IT87_REG_AUTO_TEMP(nr, i));
+				data->read(data, IT87_REG_AUTO_TEMP(nr, i));
 		/*
 		 * 0: start pwm value (base + 3)
 		 * 1: pwm slope (base + 4, 1/8th pwm)
 		 */
 		data->auto_pwm[nr][0] =
-			it87_read_value(data, IT87_REG_AUTO_TEMP(nr, 3));
+			data->read(data, IT87_REG_AUTO_TEMP(nr, 3));
 		data->auto_pwm[nr][1] =
-			it87_read_value(data, IT87_REG_AUTO_TEMP(nr, 4));
+			data->read(data, IT87_REG_AUTO_TEMP(nr, 4));
 	}
 }
 
@@ -883,24 +1265,21 @@ static struct it87_data *it87_update_device(struct device *dev)
 			 * Cleared after each update, so reenable.  Value
 			 * returned by this read will be previous value
 			 */
-			it87_write_value(data, IT87_REG_CONFIG,
-				it87_read_value(data, IT87_REG_CONFIG) | 0x40);
+			data->write(data, IT87_REG_CONFIG,
+				    data->read(data, IT87_REG_CONFIG) | 0x40);
 		}
 		for (i = 0; i < NUM_VIN; i++) {
 			if (!(data->has_in & BIT(i)))
 				continue;
 
-			data->in[i][0] =
-				it87_read_value(data, IT87_REG_VIN[i]);
+			data->in[i][0] = data->read(data, IT87_REG_VIN[i]);
 
 			/* VBAT and AVCC don't have limit registers */
 			if (i >= NUM_VIN_LIMIT)
 				continue;
 
-			data->in[i][1] =
-				it87_read_value(data, IT87_REG_VIN_MIN(i));
-			data->in[i][2] =
-				it87_read_value(data, IT87_REG_VIN_MAX(i));
+			data->in[i][1] = data->read(data, IT87_REG_VIN_MIN(i));
+			data->in[i][2] = data->read(data, IT87_REG_VIN_MAX(i));
 		}
 
 		for (i = 0; i < NUM_FAN; i++) {
@@ -908,70 +1287,67 @@ static struct it87_data *it87_update_device(struct device *dev)
 			if (!(data->has_fan & BIT(i)))
 				continue;
 
-			data->fan[i][1] =
-				it87_read_value(data, IT87_REG_FAN_MIN[i]);
-			data->fan[i][0] = it87_read_value(data,
-				       IT87_REG_FAN[i]);
+			data->fan[i][1] = data->read(data,
+					data->REG_FAN_MIN[i]);
+			data->fan[i][0] = data->read(data, data->REG_FAN[i]);
 			/* Add high byte if in 16-bit mode */
 			if (has_16bit_fans(data)) {
-				data->fan[i][0] |= it87_read_value(data,
-						IT87_REG_FANX[i]) << 8;
-				data->fan[i][1] |= it87_read_value(data,
-						IT87_REG_FANX_MIN[i]) << 8;
+				data->fan[i][0] |= data->read(data,
+						data->REG_FANX[i]) << 8;
+				data->fan[i][1] |= data->read(data,
+						data->REG_FANX_MIN[i]) << 8;
 			}
 		}
 		for (i = 0; i < NUM_TEMP; i++) {
 			if (!(data->has_temp & BIT(i)))
 				continue;
 			data->temp[i][0] =
-				it87_read_value(data, IT87_REG_TEMP(i));
+				data->read(data, IT87_REG_TEMP(i));
 
-			if (has_temp_offset(data) && i < NUM_TEMP_OFFSET)
-				data->temp[i][3] =
-				  it87_read_value(data,
-						  IT87_REG_TEMP_OFFSET[i]);
-
-			if (i >= NUM_TEMP_LIMIT)
+			if (i >= data->num_temp_limit)
 				continue;
 
+			if (i < data->num_temp_offset)
+				data->temp[i][3] =
+				  data->read(data, data->REG_TEMP_OFFSET[i]);
+
 			data->temp[i][1] =
-				it87_read_value(data, IT87_REG_TEMP_LOW(i));
+				data->read(data, data->REG_TEMP_LOW[i]);
 			data->temp[i][2] =
-				it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+				data->read(data, data->REG_TEMP_HIGH[i]);
 		}
 
 		/* Newer chips don't have clock dividers */
 		if ((data->has_fan & 0x07) && !has_16bit_fans(data)) {
-			i = it87_read_value(data, IT87_REG_FAN_DIV);
+			i = data->read(data, IT87_REG_FAN_DIV);
 			data->fan_div[0] = i & 0x07;
 			data->fan_div[1] = (i >> 3) & 0x07;
 			data->fan_div[2] = (i & 0x40) ? 3 : 1;
 		}
 
 		data->alarms =
-			it87_read_value(data, IT87_REG_ALARM1) |
-			(it87_read_value(data, IT87_REG_ALARM2) << 8) |
-			(it87_read_value(data, IT87_REG_ALARM3) << 16);
-		data->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);
-
-		data->fan_main_ctrl = it87_read_value(data,
-				IT87_REG_FAN_MAIN_CTRL);
-		data->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL);
+			data->read(data, IT87_REG_ALARM1) |
+			(data->read(data, IT87_REG_ALARM2) << 8) |
+			(data->read(data, IT87_REG_ALARM3) << 16);
+		data->beeps = data->read(data, IT87_REG_BEEP_ENABLE);
+
+		data->fan_main_ctrl = data->read(data, IT87_REG_FAN_MAIN_CTRL);
+		data->fan_ctl = data->read(data, IT87_REG_FAN_CTL);
 		for (i = 0; i < NUM_PWM; i++) {
 			if (!(data->has_pwm & BIT(i)))
 				continue;
 			it87_update_pwm_ctrl(data, i);
 		}
 
-		data->sensor = it87_read_value(data, IT87_REG_TEMP_ENABLE);
-		data->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);
+		data->sensor = data->read(data, IT87_REG_TEMP_ENABLE);
+		data->extra = data->read(data, IT87_REG_TEMP_EXTRA);
 		/*
 		 * The IT8705F does not have VID capability.
 		 * The IT8718F and later don't use IT87_REG_VID for the
 		 * same purpose.
 		 */
 		if (data->type == it8712 || data->type == it8716) {
-			data->vid = it87_read_value(data, IT87_REG_VID);
+			data->vid = data->read(data, IT87_REG_VID);
 			/*
 			 * The older IT8712F revisions had only 5 VID pins,
 			 * but we assume it is always safe to read 6 bits.
@@ -1019,61 +1395,44 @@ static ssize_t set_in(struct device *dev, struct device_attribute *attr,
 		return err;
 
 	data->in[nr][index] = in_to_reg(data, nr, val);
-	it87_write_value(data,
-			 index == 1 ? IT87_REG_VIN_MIN(nr)
-				    : IT87_REG_VIN_MAX(nr),
-			 data->in[nr][index]);
+	data->write(data, index == 1 ? IT87_REG_VIN_MIN(nr)
+				     : IT87_REG_VIN_MAX(nr),
+		    data->in[nr][index]);
 	it87_unlock(data);
 	return count;
 }
 
 static SENSOR_DEVICE_ATTR_2(in0_input, S_IRUGO, show_in, NULL, 0, 0);
-static SENSOR_DEVICE_ATTR_2(in0_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    0, 1);
-static SENSOR_DEVICE_ATTR_2(in0_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    0, 2);
+static SENSOR_DEVICE_ATTR_2(in0_min, S_IRUGO | S_IWUSR, show_in, set_in, 0, 1);
+static SENSOR_DEVICE_ATTR_2(in0_max, S_IRUGO | S_IWUSR, show_in, set_in, 0, 2);
 
 static SENSOR_DEVICE_ATTR_2(in1_input, S_IRUGO, show_in, NULL, 1, 0);
-static SENSOR_DEVICE_ATTR_2(in1_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    1, 1);
-static SENSOR_DEVICE_ATTR_2(in1_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    1, 2);
+static SENSOR_DEVICE_ATTR_2(in1_min, S_IRUGO | S_IWUSR, show_in, set_in, 1, 1);
+static SENSOR_DEVICE_ATTR_2(in1_max, S_IRUGO | S_IWUSR, show_in, set_in, 1, 2);
 
 static SENSOR_DEVICE_ATTR_2(in2_input, S_IRUGO, show_in, NULL, 2, 0);
-static SENSOR_DEVICE_ATTR_2(in2_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    2, 1);
-static SENSOR_DEVICE_ATTR_2(in2_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    2, 2);
+static SENSOR_DEVICE_ATTR_2(in2_min, S_IRUGO | S_IWUSR, show_in, set_in, 2, 1);
+static SENSOR_DEVICE_ATTR_2(in2_max, S_IRUGO | S_IWUSR, show_in, set_in, 2, 2);
 
 static SENSOR_DEVICE_ATTR_2(in3_input, S_IRUGO, show_in, NULL, 3, 0);
-static SENSOR_DEVICE_ATTR_2(in3_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    3, 1);
-static SENSOR_DEVICE_ATTR_2(in3_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    3, 2);
+static SENSOR_DEVICE_ATTR_2(in3_min, S_IRUGO | S_IWUSR, show_in, set_in, 3, 1);
+static SENSOR_DEVICE_ATTR_2(in3_max, S_IRUGO | S_IWUSR, show_in, set_in, 3, 2);
 
 static SENSOR_DEVICE_ATTR_2(in4_input, S_IRUGO, show_in, NULL, 4, 0);
-static SENSOR_DEVICE_ATTR_2(in4_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    4, 1);
-static SENSOR_DEVICE_ATTR_2(in4_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    4, 2);
+static SENSOR_DEVICE_ATTR_2(in4_min, S_IRUGO | S_IWUSR, show_in, set_in, 4, 1);
+static SENSOR_DEVICE_ATTR_2(in4_max, S_IRUGO | S_IWUSR, show_in, set_in, 4, 2);
 
 static SENSOR_DEVICE_ATTR_2(in5_input, S_IRUGO, show_in, NULL, 5, 0);
-static SENSOR_DEVICE_ATTR_2(in5_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    5, 1);
-static SENSOR_DEVICE_ATTR_2(in5_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    5, 2);
+static SENSOR_DEVICE_ATTR_2(in5_min, S_IRUGO | S_IWUSR, show_in, set_in, 5, 1);
+static SENSOR_DEVICE_ATTR_2(in5_max, S_IRUGO | S_IWUSR, show_in, set_in, 5, 2);
 
 static SENSOR_DEVICE_ATTR_2(in6_input, S_IRUGO, show_in, NULL, 6, 0);
-static SENSOR_DEVICE_ATTR_2(in6_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    6, 1);
-static SENSOR_DEVICE_ATTR_2(in6_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    6, 2);
+static SENSOR_DEVICE_ATTR_2(in6_min, S_IRUGO | S_IWUSR, show_in, set_in, 6, 1);
+static SENSOR_DEVICE_ATTR_2(in6_max, S_IRUGO | S_IWUSR, show_in, set_in, 6, 2);
 
 static SENSOR_DEVICE_ATTR_2(in7_input, S_IRUGO, show_in, NULL, 7, 0);
-static SENSOR_DEVICE_ATTR_2(in7_min, S_IRUGO | S_IWUSR, show_in, set_in,
-			    7, 1);
-static SENSOR_DEVICE_ATTR_2(in7_max, S_IRUGO | S_IWUSR, show_in, set_in,
-			    7, 2);
+static SENSOR_DEVICE_ATTR_2(in7_min, S_IRUGO | S_IWUSR, show_in, set_in, 7, 1);
+static SENSOR_DEVICE_ATTR_2(in7_max, S_IRUGO | S_IWUSR, show_in, set_in, 7, 2);
 
 static SENSOR_DEVICE_ATTR_2(in8_input, S_IRUGO, show_in, NULL, 8, 0);
 static SENSOR_DEVICE_ATTR_2(in9_input, S_IRUGO, show_in, NULL, 9, 0);
@@ -1117,24 +1476,24 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *attr,
 	switch (index) {
 	default:
 	case 1:
-		reg = IT87_REG_TEMP_LOW(nr);
+		reg = data->REG_TEMP_LOW[nr];
 		break;
 	case 2:
-		reg = IT87_REG_TEMP_HIGH(nr);
+		reg = data->REG_TEMP_HIGH[nr];
 		break;
 	case 3:
-		regval = it87_read_value(data, IT87_REG_BEEP_ENABLE);
+		regval = data->read(data, IT87_REG_BEEP_ENABLE);
 		if (!(regval & 0x80)) {
 			regval |= 0x80;
-			it87_write_value(data, IT87_REG_BEEP_ENABLE, regval);
+			data->write(data, IT87_REG_BEEP_ENABLE, regval);
 		}
 		data->valid = false;
-		reg = IT87_REG_TEMP_OFFSET[nr];
+		reg = data->REG_TEMP_OFFSET[nr];
 		break;
 	}
 
 	data->temp[nr][index] = TEMP_TO_REG(val);
-	it87_write_value(data, reg, data->temp[nr][index]);
+	data->write(data, reg, data->temp[nr][index]);
 	it87_unlock(data);
 	return count;
 }
@@ -1161,32 +1520,95 @@ static SENSOR_DEVICE_ATTR_2(temp3_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
 static SENSOR_DEVICE_ATTR_2(temp3_offset, S_IRUGO | S_IWUSR, show_temp,
 			    set_temp, 2, 3);
 static SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 3, 0);
+static SENSOR_DEVICE_ATTR_2(temp4_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    3, 1);
+static SENSOR_DEVICE_ATTR_2(temp4_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    3, 2);
+static SENSOR_DEVICE_ATTR_2(temp4_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 3, 3);
 static SENSOR_DEVICE_ATTR_2(temp5_input, S_IRUGO, show_temp, NULL, 4, 0);
+static SENSOR_DEVICE_ATTR_2(temp5_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    4, 1);
+static SENSOR_DEVICE_ATTR_2(temp5_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    4, 2);
+static SENSOR_DEVICE_ATTR_2(temp5_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 4, 3);
 static SENSOR_DEVICE_ATTR_2(temp6_input, S_IRUGO, show_temp, NULL, 5, 0);
+static SENSOR_DEVICE_ATTR_2(temp6_min, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    5, 1);
+static SENSOR_DEVICE_ATTR_2(temp6_max, S_IRUGO | S_IWUSR, show_temp, set_temp,
+			    5, 2);
+static SENSOR_DEVICE_ATTR_2(temp6_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 5, 3);
+
+static const u8 temp_types_8686[NUM_TEMP][9] = {
+	{ 0, 8, 8, 8, 8, 8, 8, 8, 7 },
+	{ 0, 6, 8, 8, 6, 0, 0, 0, 7 },
+	{ 0, 6, 5, 8, 6, 0, 0, 0, 7 },
+	{ 4, 8, 8, 8, 8, 8, 8, 8, 7 },
+	{ 4, 6, 8, 8, 6, 0, 0, 0, 7 },
+	{ 4, 6, 5, 8, 6, 0, 0, 0, 7 },
+};
 
 static int get_temp_type(struct it87_data *data, int index)
 {
-	/*
-	 * 2 is deprecated;
-	 * 3 = thermal diode;
-	 * 4 = thermistor;
-	 * 5 = AMDTSI;
-	 * 6 = Intel PECI;
-	 * 0 = disabled
-	 */
 	u8 reg, extra;
 	int ttype, type = 0;
 
-	/* Detect PECI vs. AMDTSI */
+	if (has_bank_sel(data)) {
+		u8 src1, src2;
+
+		src1 = (data->temp_src[index / 2] >> ((index % 2) * 4)) & 0x0f;
+
+		switch (data->type) {
+		case it8686:
+		case it8688:
+		case it8689:
+			if (src1 < 9)
+				type = temp_types_8686[index][src1];
+			break;
+		case it8625:
+			if (index < 3)
+				break;
+			fallthrough; /* special Linux kernel function */
+		case it8655:
+		case it8665:
+			if (src1 < 3) {
+				index = src1;
+				break;
+			}
+			src2 = data->temp_src[3];
+			switch (src1) {
+			case 3:
+				type = (src2 & BIT(index)) ? 6 : 5;
+				break;
+			case 4 ... 8:
+				type = (src2 & BIT(index)) ? 4 : 6;
+				break;
+			case 9:
+				type = (src2 & BIT(index)) ? 5 : 0;
+				break;
+			default:
+				break;
+			}
+			return type;
+		default:
+			return 0;
+		}
+	}
+	if (type)
+		return type;
+
+	/* Dectect PECI vs. AMDTSI */
 	ttype = 6;
 	if ((has_temp_peci(data, index)) || data->type == it8721 ||
-	    data->type == it8720) {
-		extra = it87_read_value(data, IT87_REG_IFSEL);
+			data->type == it8720) {
+		extra = data->read(data, IT87_REG_IFSEL);
 		if ((extra & 0x70) == 0x40)
 			ttype = 5;
 	}
 
-	reg = it87_read_value(data, IT87_REG_TEMP_ENABLE);
+	reg = data->read(data, IT87_REG_TEMP_ENABLE);
 
 	/* Per chip special detection */
 	switch (data->type) {
@@ -1201,10 +1623,10 @@ static int get_temp_type(struct it87_data *data, int index)
 	if (type || index >= 3)
 		return type;
 
-	extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);
+	extra = data->read(data, IT87_REG_TEMP_EXTRA);
 
 	if ((has_temp_peci(data, index) && (reg >> 6 == index + 1)) ||
-	    (has_temp_old_peci(data, index) && (extra & 0x80)))
+			(has_temp_old_peci(data, index) && (extra & 0x80)))
 		type = ttype;	/* Intel PECI or AMDTSI */
 	else if (reg & BIT(index))
 		type = 3;	/* thermal diode */
@@ -1244,12 +1666,12 @@ static ssize_t set_temp_type(struct device *dev, struct device_attribute *attr,
 	if (err)
 		return err;
 
-	reg = it87_read_value(data, IT87_REG_TEMP_ENABLE);
+	reg = data->read(data, IT87_REG_TEMP_ENABLE);
 	reg &= ~(1 << nr);
 	reg &= ~(8 << nr);
 	if (has_temp_peci(data, nr) && (reg >> 6 == nr + 1 || val == 6))
 		reg &= 0x3f;
-	extra = it87_read_value(data, IT87_REG_TEMP_EXTRA);
+	extra = data->read(data, IT87_REG_TEMP_EXTRA);
 	if (has_temp_old_peci(data, nr) && ((extra & 0x80) || val == 6))
 		extra &= 0x7f;
 	if (val == 2) {	/* backwards compatibility */
@@ -1273,9 +1695,9 @@ static ssize_t set_temp_type(struct device *dev, struct device_attribute *attr,
 
 	data->sensor = reg;
 	data->extra = extra;
-	it87_write_value(data, IT87_REG_TEMP_ENABLE, data->sensor);
+	data->write(data, IT87_REG_TEMP_ENABLE, data->sensor);
 	if (has_temp_old_peci(data, nr))
-		it87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);
+		data->write(data, IT87_REG_TEMP_EXTRA, data->extra);
 	data->valid = false;	/* Force cache refresh */
 unlock:
 	it87_unlock(data);
@@ -1288,6 +1710,12 @@ static SENSOR_DEVICE_ATTR(temp2_type, S_IRUGO | S_IWUSR, show_temp_type,
 			  set_temp_type, 1);
 static SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO | S_IWUSR, show_temp_type,
 			  set_temp_type, 2);
+static SENSOR_DEVICE_ATTR(temp4_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 3);
+static SENSOR_DEVICE_ATTR(temp5_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 4);
+static SENSOR_DEVICE_ATTR(temp6_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 5);
 
 /* 6 Fans */
 
@@ -1407,12 +1835,12 @@ static ssize_t set_fan(struct device *dev, struct device_attribute *attr,
 
 	if (has_16bit_fans(data)) {
 		data->fan[nr][index] = FAN16_TO_REG(val);
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
-				 data->fan[nr][index] & 0xff);
-		it87_write_value(data, IT87_REG_FANX_MIN[nr],
-				 data->fan[nr][index] >> 8);
+		data->write(data, data->REG_FAN_MIN[nr],
+			    data->fan[nr][index] & 0xff);
+		data->write(data, data->REG_FANX_MIN[nr],
+			    data->fan[nr][index] >> 8);
 	} else {
-		reg = it87_read_value(data, IT87_REG_FAN_DIV);
+		reg = data->read(data, IT87_REG_FAN_DIV);
 		switch (nr) {
 		case 0:
 			data->fan_div[nr] = reg & 0x07;
@@ -1426,10 +1854,8 @@ static ssize_t set_fan(struct device *dev, struct device_attribute *attr,
 		}
 		data->fan[nr][index] =
 		  FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
-				 data->fan[nr][index]);
+		data->write(data, data->REG_FAN_MIN[nr], data->fan[nr][index]);
 	}
-
 	it87_unlock(data);
 	return count;
 }
@@ -1451,7 +1877,7 @@ static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 	if (err)
 		return err;
 
-	old = it87_read_value(data, IT87_REG_FAN_DIV);
+	old = data->read(data, IT87_REG_FAN_DIV);
 
 	/* Save fan min limit */
 	min = FAN_FROM_REG(data->fan[nr][1], DIV_FROM_REG(data->fan_div[nr]));
@@ -1472,12 +1898,11 @@ static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 	val |= (data->fan_div[1] & 0x07) << 3;
 	if (data->fan_div[2] == 3)
 		val |= 0x1 << 6;
-	it87_write_value(data, IT87_REG_FAN_DIV, val);
+	data->write(data, IT87_REG_FAN_DIV, val);
 
 	/* Restore fan min limit */
 	data->fan[nr][1] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));
-	it87_write_value(data, IT87_REG_FAN_MIN[nr], data->fan[nr][1]);
-
+	data->write(data, data->REG_FAN_MIN[nr], data->fan[nr][1]);
 	it87_unlock(data);
 	return count;
 }
@@ -1534,52 +1959,57 @@ static ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,
 	if (err)
 		return err;
 
+	it87_update_pwm_ctrl(data, nr);
+
 	if (val == 0) {
 		if (nr < 3 && has_fanctl_onoff(data)) {
 			int tmp;
 			/* make sure the fan is on when in on/off mode */
-			tmp = it87_read_value(data, IT87_REG_FAN_CTL);
-			it87_write_value(data, IT87_REG_FAN_CTL, tmp | BIT(nr));
+			tmp = data->read(data, IT87_REG_FAN_CTL);
+			data->write(data, IT87_REG_FAN_CTL, tmp | BIT(nr));
 			/* set on/off mode */
 			data->fan_main_ctrl &= ~BIT(nr);
-			it87_write_value(data, IT87_REG_FAN_MAIN_CTRL,
-					 data->fan_main_ctrl);
+			data->write(data, IT87_REG_FAN_MAIN_CTRL,
+				    data->fan_main_ctrl);
 		} else {
 			u8 ctrl;
 
 			/* No on/off mode, set maximum pwm value */
 			data->pwm_duty[nr] = pwm_to_reg(data, 0xff);
-			it87_write_value(data, IT87_REG_PWM_DUTY[nr],
-					 data->pwm_duty[nr]);
+			data->write(data, IT87_REG_PWM_DUTY[nr],
+				    data->pwm_duty[nr]);
 			/* and set manual mode */
 			if (has_newer_autopwm(data)) {
-				ctrl = (data->pwm_ctrl[nr] & 0x7c) |
-					data->pwm_temp_map[nr];
+				ctrl = temp_map_to_reg(data, nr,
+						       data->pwm_temp_map[nr]);
+				ctrl &= 0x7f;
 			} else {
 				ctrl = data->pwm_duty[nr];
 			}
 			data->pwm_ctrl[nr] = ctrl;
-			it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+			data->write(data, data->REG_PWM[nr], ctrl);
 		}
 	} else {
 		u8 ctrl;
 
 		if (has_newer_autopwm(data)) {
-			ctrl = (data->pwm_ctrl[nr] & 0x7c) |
-				data->pwm_temp_map[nr];
-			if (val != 1)
+			ctrl = temp_map_to_reg(data, nr,
+					       data->pwm_temp_map[nr]);
+			if (val == 1)
+				ctrl &= 0x7f;
+			else
 				ctrl |= 0x80;
 		} else {
 			ctrl = (val == 1 ? data->pwm_duty[nr] : 0x80);
 		}
 		data->pwm_ctrl[nr] = ctrl;
-		it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+		data->write(data, data->REG_PWM[nr], ctrl);
 
 		if (has_fanctl_onoff(data) && nr < 3) {
 			/* set SmartGuardian mode */
 			data->fan_main_ctrl |= BIT(nr);
-			it87_write_value(data, IT87_REG_FAN_MAIN_CTRL,
-					 data->fan_main_ctrl);
+			data->write(data, IT87_REG_FAN_MAIN_CTRL,
+				    data->fan_main_ctrl);
 		}
 	}
 
@@ -1614,8 +2044,8 @@ static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
 			goto unlock;
 		}
 		data->pwm_duty[nr] = pwm_to_reg(data, val);
-		it87_write_value(data, IT87_REG_PWM_DUTY[nr],
-				 data->pwm_duty[nr]);
+		data->write(data, IT87_REG_PWM_DUTY[nr],
+			    data->pwm_duty[nr]);
 	} else {
 		data->pwm_duty[nr] = pwm_to_reg(data, val);
 		/*
@@ -1624,8 +2054,8 @@ static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
 		 */
 		if (!(data->pwm_ctrl[nr] & 0x80)) {
 			data->pwm_ctrl[nr] = data->pwm_duty[nr];
-			it87_write_value(data, IT87_REG_PWM[nr],
-					 data->pwm_ctrl[nr]);
+			data->write(data, data->REG_PWM[nr],
+				    data->pwm_ctrl[nr]);
 		}
 	}
 unlock:
@@ -1650,7 +2080,7 @@ static ssize_t set_pwm_freq(struct device *dev, struct device_attribute *attr,
 	val *= has_newer_autopwm(data) ? 256 : 128;
 
 	/* Search for the nearest available frequency */
-	for (i = 0; i < 7; i++) {
+	for (i = 0; i < ARRAY_SIZE(pwm_freq) - 1; i++) {
 		if (val > (pwm_freq[i] + pwm_freq[i + 1]) / 2)
 			break;
 	}
@@ -1660,16 +2090,15 @@ static ssize_t set_pwm_freq(struct device *dev, struct device_attribute *attr,
 		return err;
 
 	if (nr == 0) {
-		data->fan_ctl = it87_read_value(data, IT87_REG_FAN_CTL) & 0x8f;
+		data->fan_ctl = data->read(data, IT87_REG_FAN_CTL) & 0x8f;
 		data->fan_ctl |= i << 4;
-		it87_write_value(data, IT87_REG_FAN_CTL, data->fan_ctl);
+		data->write(data, IT87_REG_FAN_CTL, data->fan_ctl);
 	} else {
-		data->extra = it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x8f;
+		data->extra = data->read(data, IT87_REG_TEMP_EXTRA) & 0x8f;
 		data->extra |= i << 4;
-		it87_write_value(data, IT87_REG_TEMP_EXTRA, data->extra);
+		data->write(data, IT87_REG_TEMP_EXTRA, data->extra);
 	}
 	it87_unlock(data);
-
 	return count;
 }
 
@@ -1679,18 +2108,11 @@ static ssize_t show_pwm_temp_map(struct device *dev,
 	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
 	struct it87_data *data = it87_update_device(dev);
 	int nr = sensor_attr->index;
-	int map;
 
 	if (IS_ERR(data))
 		return PTR_ERR(data);
 
-	map = data->pwm_temp_map[nr];
-	if (map >= 3)
-		map = 0;	/* Should never happen */
-	if (nr >= 3)		/* pwm channels 3..6 map to temp4..6 */
-		map += 3;
-
-	return sprintf(buf, "%d\n", (int)BIT(map));
+	return sprintf(buf, "%d\n", data->pwm_temp_map[nr] + 1);
 }
 
 static ssize_t set_pwm_temp_map(struct device *dev,
@@ -1700,44 +2122,31 @@ static ssize_t set_pwm_temp_map(struct device *dev,
 	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
 	struct it87_data *data = dev_get_drvdata(dev);
 	int nr = sensor_attr->index;
-	long val;
+	unsigned long val;
 	int err;
-	u8 reg;
+	u8 map;
 
-	if (kstrtol(buf, 10, &val) < 0)
+	if (kstrtoul(buf, 10, &val) < 0)
 		return -EINVAL;
 
-	if (nr >= 3)
-		val -= 3;
-
-	switch (val) {
-	case BIT(0):
-		reg = 0x00;
-		break;
-	case BIT(1):
-		reg = 0x01;
-		break;
-	case BIT(2):
-		reg = 0x02;
-		break;
-	default:
+	if (!val || val > data->pwm_num_temp_map)
 		return -EINVAL;
-	}
+
+	map = val - 1;
 
 	err = it87_lock(data);
 	if (err)
 		return err;
 
 	it87_update_pwm_ctrl(data, nr);
-	data->pwm_temp_map[nr] = reg;
+	data->pwm_temp_map[nr] = map;
 	/*
 	 * If we are in automatic mode, write the temp mapping immediately;
 	 * otherwise, just store it for later use.
 	 */
 	if (data->pwm_ctrl[nr] & 0x80) {
-		data->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & 0xfc) |
-						data->pwm_temp_map[nr];
-		it87_write_value(data, IT87_REG_PWM[nr], data->pwm_ctrl[nr]);
+		data->pwm_ctrl[nr] = temp_map_to_reg(data, nr, map);
+		data->write(data, data->REG_PWM[nr], data->pwm_ctrl[nr]);
 	}
 	it87_unlock(data);
 	return count;
@@ -1783,7 +2192,7 @@ static ssize_t set_auto_pwm(struct device *dev, struct device_attribute *attr,
 		regaddr = IT87_REG_AUTO_TEMP(nr, 3);
 	else
 		regaddr = IT87_REG_AUTO_PWM(nr, point);
-	it87_write_value(data, regaddr, data->auto_pwm[nr][point]);
+	data->write(data, regaddr, data->auto_pwm[nr][point]);
 	it87_unlock(data);
 	return count;
 }
@@ -1819,8 +2228,7 @@ static ssize_t set_auto_pwm_slope(struct device *dev,
 		return err;
 
 	data->auto_pwm[nr][1] = (data->auto_pwm[nr][1] & 0x80) | val;
-	it87_write_value(data, IT87_REG_AUTO_TEMP(nr, 4),
-			 data->auto_pwm[nr][1]);
+	data->write(data, IT87_REG_AUTO_TEMP(nr, 4), data->auto_pwm[nr][1]);
 	it87_unlock(data);
 	return count;
 }
@@ -1869,13 +2277,13 @@ static ssize_t set_auto_temp(struct device *dev, struct device_attribute *attr,
 		reg = data->auto_temp[nr][1] - TEMP_TO_REG(val);
 		reg = clamp_val(reg, 0, 0x1f) | (data->auto_temp[nr][0] & 0xe0);
 		data->auto_temp[nr][0] = reg;
-		it87_write_value(data, IT87_REG_AUTO_TEMP(nr, 5), reg);
+		data->write(data, IT87_REG_AUTO_TEMP(nr, 5), reg);
 	} else {
 		reg = TEMP_TO_REG(val);
 		data->auto_temp[nr][point] = reg;
 		if (has_newer_autopwm(data))
 			point--;
-		it87_write_value(data, IT87_REG_AUTO_TEMP(nr, point), reg);
+		data->write(data, IT87_REG_AUTO_TEMP(nr, point), reg);
 	}
 	it87_unlock(data);
 	return count;
@@ -2057,7 +2465,7 @@ static SENSOR_DEVICE_ATTR(pwm6_auto_slope, S_IRUGO | S_IWUSR,
 			  show_auto_pwm_slope, set_auto_pwm_slope, 5);
 
 /* Alarms */
-static ssize_t alarms_show(struct device *dev, struct device_attribute *attr,
+static ssize_t show_alarms(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct it87_data *data = it87_update_device(dev);
@@ -2067,7 +2475,7 @@ static ssize_t alarms_show(struct device *dev, struct device_attribute *attr,
 
 	return sprintf(buf, "%u\n", data->alarms);
 }
-static DEVICE_ATTR_RO(alarms);
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
 
 static ssize_t show_alarm(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -2096,15 +2504,11 @@ static ssize_t clear_intrusion(struct device *dev,
 	if (err)
 		return err;
 
-	config = it87_read_value(data, IT87_REG_CONFIG);
-	if (config < 0) {
-		count = config;
-	} else {
-		config |= BIT(5);
-		it87_write_value(data, IT87_REG_CONFIG, config);
-		/* Invalidate cache to force re-read */
-		data->valid = false;
-	}
+	config = data->read(data, IT87_REG_CONFIG);
+	config |= BIT(5);
+	data->write(data, IT87_REG_CONFIG, config);
+	/* Invalidate cache to force re-read */
+	data->valid = false;
 	it87_unlock(data);
 	return count;
 }
@@ -2126,6 +2530,9 @@ static SENSOR_DEVICE_ATTR(fan6_alarm, S_IRUGO, show_alarm, NULL, 7);
 static SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 16);
 static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 17);
 static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 18);
+static SENSOR_DEVICE_ATTR(temp4_alarm, S_IRUGO, show_alarm, NULL, 19);
+static SENSOR_DEVICE_ATTR(temp5_alarm, S_IRUGO, show_alarm, NULL, 20);
+static SENSOR_DEVICE_ATTR(temp6_alarm, S_IRUGO, show_alarm, NULL, 21);
 static SENSOR_DEVICE_ATTR(intrusion0_alarm, S_IRUGO | S_IWUSR,
 			  show_alarm, clear_intrusion, 4);
 
@@ -2156,12 +2563,12 @@ static ssize_t set_beep(struct device *dev, struct device_attribute *attr,
 	if (err)
 		return err;
 
-	data->beeps = it87_read_value(data, IT87_REG_BEEP_ENABLE);
+	data->beeps = data->read(data, IT87_REG_BEEP_ENABLE);
 	if (val)
 		data->beeps |= BIT(bitnr);
 	else
 		data->beeps &= ~BIT(bitnr);
-	it87_write_value(data, IT87_REG_BEEP_ENABLE, data->beeps);
+	data->write(data, IT87_REG_BEEP_ENABLE, data->beeps);
 	it87_unlock(data);
 	return count;
 }
@@ -2186,17 +2593,20 @@ static SENSOR_DEVICE_ATTR(temp1_beep, S_IRUGO | S_IWUSR,
 			  show_beep, set_beep, 2);
 static SENSOR_DEVICE_ATTR(temp2_beep, S_IRUGO, show_beep, NULL, 2);
 static SENSOR_DEVICE_ATTR(temp3_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp5_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp6_beep, S_IRUGO, show_beep, NULL, 2);
 
-static ssize_t vrm_show(struct device *dev, struct device_attribute *attr,
-			char *buf)
+static ssize_t show_vrm_reg(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct it87_data *data = dev_get_drvdata(dev);
 
 	return sprintf(buf, "%u\n", data->vrm);
 }
 
-static ssize_t vrm_store(struct device *dev, struct device_attribute *attr,
-			 const char *buf, size_t count)
+static ssize_t store_vrm_reg(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
 {
 	struct it87_data *data = dev_get_drvdata(dev);
 	unsigned long val;
@@ -2208,10 +2618,10 @@ static ssize_t vrm_store(struct device *dev, struct device_attribute *attr,
 
 	return count;
 }
-static DEVICE_ATTR_RW(vrm);
+static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm_reg, store_vrm_reg);
 
-static ssize_t cpu0_vid_show(struct device *dev,
-			     struct device_attribute *attr, char *buf)
+static ssize_t show_vid_reg(struct device *dev, struct device_attribute *attr,
+			    char *buf)
 {
 	struct it87_data *data = it87_update_device(dev);
 
@@ -2220,7 +2630,7 @@ static ssize_t cpu0_vid_show(struct device *dev,
 
 	return sprintf(buf, "%ld\n", (long)vid_from_reg(data->vid, data->vrm));
 }
-static DEVICE_ATTR_RO(cpu0_vid);
+static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid_reg, NULL);
 
 static ssize_t show_label(struct device *dev, struct device_attribute *attr,
 			  char *buf)
@@ -2328,10 +2738,10 @@ static struct attribute *it87_attributes_in[] = {
 	&sensor_dev_attr_in7_beep.dev_attr.attr,	/* 39 */
 
 	&sensor_dev_attr_in8_input.dev_attr.attr,	/* 40 */
-	&sensor_dev_attr_in9_input.dev_attr.attr,
-	&sensor_dev_attr_in10_input.dev_attr.attr,
-	&sensor_dev_attr_in11_input.dev_attr.attr,
-	&sensor_dev_attr_in12_input.dev_attr.attr,
+	&sensor_dev_attr_in9_input.dev_attr.attr,	/* 41 */
+	&sensor_dev_attr_in10_input.dev_attr.attr,	/* 42 */
+	&sensor_dev_attr_in11_input.dev_attr.attr,	/* 43 */
+	&sensor_dev_attr_in12_input.dev_attr.attr,	/* 44 */
 	NULL
 };
 
@@ -2348,21 +2758,21 @@ static umode_t it87_temp_is_visible(struct kobject *kobj,
 	int i = index / 7;	/* temperature index */
 	int a = index % 7;	/* attribute index */
 
-	if (index >= 21) {
-		i = index - 21 + 3;
-		a = 0;
-	}
-
 	if (!(data->has_temp & BIT(i)))
 		return 0;
 
+	if (a && i >= data->num_temp_limit)
+		return 0;
+
 	if (a == 3) {
 		if (get_temp_type(data, i) == 0)
 			return 0;
+		if (has_bank_sel(data))
+			return 0444;
 		return attr->mode;
 	}
 
-	if (a == 5 && !has_temp_offset(data))
+	if (a == 5 && i >= data->num_temp_offset)
 		return 0;
 
 	if (a == 6 && !data->has_beep)
@@ -2375,7 +2785,7 @@ static struct attribute *it87_attributes_temp[] = {
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_temp1_max.dev_attr.attr,
 	&sensor_dev_attr_temp1_min.dev_attr.attr,
-	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,	/* 3 */
 	&sensor_dev_attr_temp1_alarm.dev_attr.attr,
 	&sensor_dev_attr_temp1_offset.dev_attr.attr,	/* 5 */
 	&sensor_dev_attr_temp1_beep.dev_attr.attr,	/* 6 */
@@ -2397,8 +2807,28 @@ static struct attribute *it87_attributes_temp[] = {
 	&sensor_dev_attr_temp3_beep.dev_attr.attr,
 
 	&sensor_dev_attr_temp4_input.dev_attr.attr,	/* 21 */
+	&sensor_dev_attr_temp4_max.dev_attr.attr,
+	&sensor_dev_attr_temp4_min.dev_attr.attr,
+	&sensor_dev_attr_temp4_type.dev_attr.attr,
+	&sensor_dev_attr_temp4_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp4_offset.dev_attr.attr,
+	&sensor_dev_attr_temp4_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp5_input.dev_attr.attr,
+	&sensor_dev_attr_temp5_max.dev_attr.attr,
+	&sensor_dev_attr_temp5_min.dev_attr.attr,
+	&sensor_dev_attr_temp5_type.dev_attr.attr,
+	&sensor_dev_attr_temp5_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp5_offset.dev_attr.attr,
+	&sensor_dev_attr_temp5_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp6_input.dev_attr.attr,
+	&sensor_dev_attr_temp6_max.dev_attr.attr,
+	&sensor_dev_attr_temp6_min.dev_attr.attr,
+	&sensor_dev_attr_temp6_type.dev_attr.attr,
+	&sensor_dev_attr_temp6_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp6_offset.dev_attr.attr,
+	&sensor_dev_attr_temp6_beep.dev_attr.attr,
 	NULL
 };
 
@@ -2681,7 +3111,7 @@ static const struct attribute_group it87_group_auto_pwm = {
  * Z87X-OC.
  *
  * From other information supplied:
- * ChipIDs 0x8733, 0x8695 (early ID for IT87952E) and 0x8790 are initialized
+ * ChipIDs 0x8733, 0x8695 (early ID for IT87952E) and 0x8790 are intialised
  * and left in configuration mode, and entering and/or exiting configuration
  * mode is what causes the crash.
  *
@@ -2690,11 +3120,15 @@ static const struct attribute_group it87_group_auto_pwm = {
  */
 /* SuperIO detection - will change isa_address if a chip is found */
 static int __init it87_find(int sioaddr, unsigned short *address,
-			    struct it87_sio_data *sio_data, int chip_cnt)
+			    phys_addr_t *mmio_address,
+			    struct it87_sio_data *sio_data,
+			    int chip_cnt)
 {
-	int err;
-	u16 chip_type;
 	const struct it87_devices *config = NULL;
+	phys_addr_t base = 0;
+	char mmio_str[32];
+	u16 chip_type;
+	int err;
 	bool enabled = false;
 
 	/* First step, lock memory but don't enter configuration mode */
@@ -2702,6 +3136,8 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	if (err)
 		return err;
 
+	sio_data->sioaddr = sioaddr;
+
 	err = -ENODEV;
 	chip_type = superio_inw(sioaddr, DEVID);
 	/* Check for a valid chip before forcing chip id */
@@ -2748,6 +3184,12 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	case IT8732F_DEVID:
 		sio_data->type = it8732;
 		break;
+	case IT8736F_DEVID:
+		sio_data->type = it8736;
+		break;
+	case IT8738E_DEVID:
+		sio_data->type = it8738;
+		break;
 	case IT8792E_DEVID:
 		sio_data->type = it8792;
 		break;
@@ -2766,6 +3208,9 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	case IT8783E_DEVID:
 		sio_data->type = it8783;
 		break;
+	case IT8785E_DEVID:
+		sio_data->type = it8785;
+		break;
 	case IT8786E_DEVID:
 		sio_data->type = it8786;
 		break;
@@ -2776,18 +3221,48 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	case IT8623E_DEVID:
 		sio_data->type = it8603;
 		break;
+	case IT8606E_DEVID:
+		sio_data->type = it8606;
+		break;
+	case IT8607E_DEVID:
+		sio_data->type = it8607;
+		break;
+	case IT8613E_DEVID:
+		sio_data->type = it8613;
+		break;
 	case IT8620E_DEVID:
 		sio_data->type = it8620;
 		break;
 	case IT8622E_DEVID:
 		sio_data->type = it8622;
 		break;
+	case IT8625E_DEVID:
+		sio_data->type = it8625;
+		break;
 	case IT8628E_DEVID:
 		sio_data->type = it8628;
 		break;
+	case IT8655E_DEVID:
+		sio_data->type = it8655;
+		break;
+	case IT8665E_DEVID:
+		sio_data->type = it8665;
+		break;
+	case IT8686E_DEVID:
+		sio_data->type = it8686;
+		break;
+	case IT8688E_DEVID:
+		sio_data->type = it8688;
+		break;
+	case IT8689E_DEVID:
+		sio_data->type = it8689;
+		break;
 	case IT87952E_DEVID:
 		sio_data->type = it87952;
 		break;
+	case IT8696E_DEVID:
+		sio_data->type = it8696;
+		break;
 	case 0xffff:	/* No device at all */
 		goto exit;
 	default:
@@ -2824,11 +3299,26 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	}
 
 	err = 0;
-	sio_data->sioaddr = sioaddr;
 	sio_data->revision = superio_inb(sioaddr, DEVREV) & 0x0f;
-	pr_info("Found %s chip at 0x%x, revision %d\n",
-		it87_devices[sio_data->type].model,
-		*address, sio_data->revision);
+
+	if (has_mmio(config) && mmio) {
+		u8 reg;
+
+		reg = superio_inb(sioaddr, IT87_EC_HWM_MIO_REG);
+		if (reg & BIT(5)) {
+			base = 0xf0000000 + ((reg & 0x0f) << 24);
+			base += (reg & 0xc0) << 14;
+		}
+	}
+	*mmio_address = base;
+
+	mmio_str[0] = '\0';
+	if (base)
+		snprintf(mmio_str, sizeof(mmio_str), " [MMIO at %pa]", &base);
+
+	pr_info("Found %s chip at 0x%x%s, revision %d\n",
+			it87_devices[sio_data->type].model,
+			*address, mmio_str, sio_data->revision);
 
 	/* in7 (VSB or VCCH5V) is always internal on some chips */
 	if (has_in7_internal(config))
@@ -2927,7 +3417,8 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8603) {
+	} else if (sio_data->type == it8603 || sio_data->type == it8606 ||
+		   sio_data->type == it8607) {
 		int reg27, reg29;
 
 		superio_select(sioaddr, GPIO);
@@ -2947,12 +3438,62 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 		if (reg29 & BIT(2))
 			sio_data->skip_fan |= BIT(1);
 
-		sio_data->skip_in |= BIT(5); /* No VIN5 */
-		sio_data->skip_in |= BIT(6); /* No VIN6 */
+		switch (sio_data->type) {
+		case it8603:
+			sio_data->skip_in |= BIT(5); /* No VIN5 */
+			sio_data->skip_in |= BIT(6); /* No VIN6 */
+			break;
+		case it8607:
+			sio_data->skip_pwm |= BIT(0);/* No fan1 */
+			sio_data->skip_fan |= BIT(0);
+		default:
+			break;
+		}
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+				IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8613) {
+		int reg27, reg29, reg2a;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm3, fan3, pwm5, fan5 */
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (!(reg27 & BIT(1)))
+			sio_data->skip_fan |= BIT(4);
+		if (reg27 & BIT(3))
+			sio_data->skip_pwm |= BIT(4);
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for pwm2, fan2 */
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg29 & BIT(2))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm4, fan4 */
+		reg2a = superio_inb(sioaddr, IT87_SIO_PINX1_REG);
+		if (!(reg2a & BIT(0)) || (reg29 & BIT(7))) {
+			sio_data->skip_fan |= BIT(3);
+			sio_data->skip_pwm |= BIT(3);
+		}
+
+		sio_data->skip_pwm |= BIT(0); /* No pwm1 */
+		sio_data->skip_fan |= BIT(0); /* No fan1 */
+		sio_data->skip_in |= BIT(3);  /* No VIN3 */
+		sio_data->skip_in |= BIT(6);  /* No VIN6 */
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8620 || sio_data->type == it8628) {
+
+	}
+	else if (sio_data->type == it8620 || sio_data->type == it8628 ||
+		 sio_data->type == it8686 ||
+		 sio_data->type == it8688 || sio_data->type == it8689) {
 		int reg;
 
 		superio_select(sioaddr, GPIO);
@@ -2995,10 +3536,16 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 
 		/* Check if AVCC is on VIN3 */
 		reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
-		if (reg & BIT(0))
-			sio_data->internal |= BIT(0);
-		else
+		if (reg & BIT(0)) {
+			/* For it8686, the bit just enables AVCC3 */
+			if (sio_data->type != it8686 &&
+			    sio_data->type != it8688 &&
+			    sio_data->type != it8689)
+				sio_data->internal |= BIT(0);
+		} else {
+			sio_data->internal &= ~BIT(3);
 			sio_data->skip_in |= BIT(9);
+		}
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
@@ -3039,7 +3586,8 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8732) {
+	} else if (sio_data->type == it8732 || sio_data->type == it8736 ||
+		   sio_data->type == it8738) {
 		int reg;
 
 		superio_select(sioaddr, GPIO);
@@ -3061,9 +3609,98 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 			sio_data->skip_fan |= BIT(3);
 
 		/* Check if AVCC is on VIN3 */
-		reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
-		if (reg & BIT(0))
-			sio_data->internal |= BIT(0);
+		if (sio_data->type != it8738) {
+			reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
+			if (reg & BIT(0))
+				sio_data->internal |= BIT(0);
+		}
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8655) {
+		int reg;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm2 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+
+		/* Check for fan2 */
+		reg = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		if (reg & BIT(4))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8665 || sio_data->type == it8625) {
+		int reg27, reg29, reg2d, regd3;
+
+		superio_select(sioaddr, GPIO);
+
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		reg2d = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		regd3 = superio_inb(sioaddr, IT87_SIO_GPIO9_REG);
+
+		/* Check for pwm2 */
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for fan2, pwm4, fan4, pwm5, fan5 */
+		if (sio_data->type == it8625) {
+			int reg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);
+
+			if (reg29 & BIT(2))
+				sio_data->skip_fan |= BIT(1);
+			if (reg25 & BIT(6))
+				sio_data->skip_fan |= BIT(3);
+			if (reg25 & BIT(5))
+				sio_data->skip_pwm |= BIT(3);
+			if (reg27 & BIT(3))
+				sio_data->skip_pwm |= BIT(4);
+			if (!(reg27 & BIT(1)))
+				sio_data->skip_fan |= BIT(4);
+		} else {
+			int reg26 = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);
+
+			if (reg2d & BIT(4))
+				sio_data->skip_fan |= BIT(1);
+			if (regd3 & BIT(2))
+				sio_data->skip_pwm |= BIT(3);
+			if (regd3 & BIT(3))
+				sio_data->skip_fan |= BIT(3);
+			if (reg26 & BIT(5))
+				sio_data->skip_pwm |= BIT(4);
+			/*
+			 * Table 6-1 in datasheet claims that FAN_TAC5 would
+			 * be enabled with 26h[4]=0. This contradicts with the
+			 * information in section 8.3.9 and with feedback from
+			 * users.
+			 */
+			if (!(reg26 & BIT(4)))
+				sio_data->skip_fan |= BIT(4);
+		}
+
+		/* Check for pwm6, fan6 */
+		if (regd3 & BIT(0))
+			sio_data->skip_pwm |= BIT(5);
+		if (regd3 & BIT(1))
+			sio_data->skip_fan |= BIT(5);
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
@@ -3112,7 +3749,10 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 			sio_data->skip_fan |= BIT(2);
 
 		/* Check if fan2 is there or not */
-		reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (sio_data->type == it8785)
+			reg = superio_inb(sioaddr, IT87_SIO_GPIO4_REG);
+		else
+			reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
 		if (reg & BIT(1))
 			sio_data->skip_pwm |= BIT(1);
 		if (reg & BIT(2))
@@ -3176,7 +3816,7 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	if (dmi_data)
 		sio_data->skip_pwm |= dmi_data->skip_pwm;
 
-	if (config->smbus_bitmap) {
+	if (config->smbus_bitmap && !base) {
 		u8 reg;
 
 		superio_select(sioaddr, PME);
@@ -3190,6 +3830,82 @@ static int __init it87_find(int sioaddr, unsigned short *address,
 	return err;
 }
 
+static void it87_init_regs(struct platform_device *pdev)
+{
+	struct it87_data *data = platform_get_drvdata(pdev);
+
+	/* Initialize chip specific register pointers */
+	switch (data->type) {
+	case it8628:
+	case it8686:
+	case it8688:
+	case it8689:
+	case it8696:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET_8686;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW_8686;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH_8686;
+		break;
+	case it8625:
+	case it8655:
+	case it8665:
+		data->REG_FAN = IT87_REG_FAN_8665;
+		data->REG_FANX = IT87_REG_FANX_8665;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN_8665;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN_8665;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8622:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8613:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	default:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	}
+
+	if (data->mmio) {
+		data->read = it87_mmio_read;
+		data->write = it87_mmio_write;
+	} else if (has_bank_sel(data)) {
+		data->read = it87_io_read;
+		data->write = it87_io_write;
+	} else {
+		data->read = _it87_io_read;
+		data->write = _it87_io_write;
+	}
+}
+
 /*
  * Some chips seem to have default value 0xff for all limit
  * registers. For low voltage limits it makes no sense and triggers
@@ -3202,26 +3918,27 @@ static void it87_check_limit_regs(struct it87_data *data)
 	int i, reg;
 
 	for (i = 0; i < NUM_VIN_LIMIT; i++) {
-		reg = it87_read_value(data, IT87_REG_VIN_MIN(i));
+		reg = data->read(data, IT87_REG_VIN_MIN(i));
 		if (reg == 0xff)
-			it87_write_value(data, IT87_REG_VIN_MIN(i), 0);
+			data->write(data, IT87_REG_VIN_MIN(i), 0);
 	}
-	for (i = 0; i < NUM_TEMP_LIMIT; i++) {
-		reg = it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+	for (i = 0; i < data->num_temp_limit; i++) {
+		reg = data->read(data, data->REG_TEMP_HIGH[i]);
 		if (reg == 0xff)
-			it87_write_value(data, IT87_REG_TEMP_HIGH(i), 127);
+			data->write(data, data->REG_TEMP_HIGH[i], 127);
 	}
 }
 
+
 /* Check if voltage monitors are reset manually or by some reason */
 static void it87_check_voltage_monitors_reset(struct it87_data *data)
 {
 	int reg;
 
-	reg = it87_read_value(data, IT87_REG_VIN_ENABLE);
+	reg = data->read(data, IT87_REG_VIN_ENABLE);
 	if ((reg & 0xff) == 0) {
 		/* Enable all voltage monitors */
-		it87_write_value(data, IT87_REG_VIN_ENABLE, 0xff);
+		data->write(data, IT87_REG_VIN_ENABLE, 0xff);
 	}
 }
 
@@ -3233,12 +3950,11 @@ static void it87_check_tachometers_reset(struct platform_device *pdev)
 	u8 mask, fan_main_ctrl;
 
 	mask = 0x70 & ~(sio_data->skip_fan << 4);
-	fan_main_ctrl = it87_read_value(data, IT87_REG_FAN_MAIN_CTRL);
+	fan_main_ctrl = data->read(data, IT87_REG_FAN_MAIN_CTRL);
 	if ((fan_main_ctrl & mask) == 0) {
 		/* Enable all fan tachometers */
 		fan_main_ctrl |= mask;
-		it87_write_value(data, IT87_REG_FAN_MAIN_CTRL,
-				 fan_main_ctrl);
+		data->write(data, IT87_REG_FAN_MAIN_CTRL, data->fan_main_ctrl);
 	}
 }
 
@@ -3251,20 +3967,19 @@ static void it87_check_tachometers_16bit_mode(struct platform_device *pdev)
 	if (!has_fan16_config(data))
 		return;
 
-	reg = it87_read_value(data, IT87_REG_FAN_16BIT);
+	reg = data->read(data, IT87_REG_FAN_16BIT);
 	if (~reg & 0x07 & data->has_fan) {
 		dev_dbg(&pdev->dev,
 			"Setting fan1-3 to 16-bit mode\n");
-		it87_write_value(data, IT87_REG_FAN_16BIT,
-				 reg | 0x07);
+		data->write(data, IT87_REG_FAN_16BIT, reg | 0x07);
 	}
 }
 
 static void it87_start_monitoring(struct it87_data *data)
 {
-	it87_write_value(data, IT87_REG_CONFIG,
-			 (it87_read_value(data, IT87_REG_CONFIG) & 0x3e)
-			 | (update_vbat ? 0x41 : 0x01));
+	data->write(data, IT87_REG_CONFIG,
+		    (data->read(data, IT87_REG_CONFIG) & 0x3e)
+		    | (update_vbat ? 0x41 : 0x01));
 }
 
 /* Called when we have found a new IT87. */
@@ -3274,13 +3989,21 @@ static void it87_init_device(struct platform_device *pdev)
 	struct it87_data *data = platform_get_drvdata(pdev);
 	int tmp, i;
 
+	if (has_new_tempmap(data)) {
+		data->pwm_temp_map_shift = 3;
+		data->pwm_temp_map_mask = 0x07;
+	} else {
+		data->pwm_temp_map_shift = 0;
+		data->pwm_temp_map_mask = 0x03;
+	}
+
 	/*
 	 * For each PWM channel:
 	 * - If it is in automatic mode, setting to manual mode should set
 	 *   the fan to full speed by default.
 	 * - If it is in manual mode, we need a mapping to temperature
 	 *   channels to use when later setting to automatic mode later.
-	 *   Use a 1:1 mapping by default (we are clueless.)
+	 *   Map to the first sensor by default (we are clueless.)
 	 * In both cases, the value can (and should) be changed by the user
 	 * prior to switching to a different mode.
 	 * Note that this is no longer needed for the IT8721F and later, as
@@ -3288,7 +4011,7 @@ static void it87_init_device(struct platform_device *pdev)
 	 * manual duty cycle.
 	 */
 	for (i = 0; i < NUM_AUTO_PWM; i++) {
-		data->pwm_temp_map[i] = i;
+		data->pwm_temp_map[i] = 0;
 		data->pwm_duty[i] = 0x7f;	/* Full speed */
 		data->auto_pwm[i][3] = 0x7f;	/* Full speed, hard-coded */
 	}
@@ -3306,32 +4029,65 @@ static void it87_init_device(struct platform_device *pdev)
 
 	it87_check_tachometers_reset(pdev);
 
-	data->fan_main_ctrl = it87_read_value(data, IT87_REG_FAN_MAIN_CTRL);
+	data->fan_main_ctrl = data->read(data, IT87_REG_FAN_MAIN_CTRL);
 	data->has_fan = (data->fan_main_ctrl >> 4) & 0x07;
 
 	it87_check_tachometers_16bit_mode(pdev);
 
 	/* Check for additional fans */
-	tmp = it87_read_value(data, IT87_REG_FAN_16BIT);
+	tmp = data->read(data, IT87_REG_FAN_16BIT);
 
 	if (has_four_fans(data) && (tmp & BIT(4)))
 		data->has_fan |= BIT(3); /* fan4 enabled */
 	if (has_five_fans(data) && (tmp & BIT(5)))
 		data->has_fan |= BIT(4); /* fan5 enabled */
-	if (has_six_fans(data) && (tmp & BIT(2)))
-		data->has_fan |= BIT(5); /* fan6 enabled */
+	if (has_six_fans(data)) {
+		switch (data->type) {
+		case it8620:
+		case it8628:
+		case it8686:
+		case it8688:
+		case it8689:
+		case it8696:
+			if (tmp & BIT(2))
+				data->has_fan |= BIT(5); /* fan6 enabled */
+			break;
+		case it8625:
+		case it8665:
+			tmp = data->read(data, IT87_REG_FAN_DIV);
+			if (tmp & BIT(3))
+				data->has_fan |= BIT(5); /* fan6 enabled */
+			break;
+		default:
+			break;
+		}
+	}
 
 	/* Fan input pins may be used for alternative functions */
 	data->has_fan &= ~sio_data->skip_fan;
 
-	/* Check if pwm5, pwm6 are enabled */
+	/* Check if pwm6 is enabled */
 	if (has_six_pwm(data)) {
-		/* The following code may be IT8620E specific */
-		tmp = it87_read_value(data, IT87_REG_FAN_DIV);
-		if ((tmp & 0xc0) == 0xc0)
-			sio_data->skip_pwm |= BIT(4);
-		if (!(tmp & BIT(3)))
-			sio_data->skip_pwm |= BIT(5);
+		switch (data->type) {
+		case it8620:
+		case it8686:
+		case it8688:
+		case it8689:
+		case it8696:
+			tmp = data->read(data, IT87_REG_FAN_DIV);
+			if (!(tmp & BIT(3)))
+				sio_data->skip_pwm |= BIT(5);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (has_bank_sel(data)) {
+		for (i = 0; i < 3; i++)
+			data->temp_src[i] =
+				data->read(data, IT87_REG_TEMP_SRC1[i]);
+		data->temp_src[3] = data->read(data, IT87_REG_TEMP_SRC2);
 	}
 
 	it87_start_monitoring(data);
@@ -3346,7 +4102,7 @@ static int it87_check_pwm(struct device *dev)
 	 * and polarity set to active low is sign that this is the case so we
 	 * disable pwm control to protect the user.
 	 */
-	int tmp = it87_read_value(data, IT87_REG_FAN_CTL);
+	int tmp = data->read(data, IT87_REG_FAN_CTL);
 
 	if ((tmp & 0x87) == 0) {
 		if (fix_pwm_polarity) {
@@ -3359,8 +4115,8 @@ static int it87_check_pwm(struct device *dev)
 			u8 pwm[3];
 
 			for (i = 0; i < ARRAY_SIZE(pwm); i++)
-				pwm[i] = it87_read_value(data,
-							 IT87_REG_PWM[i]);
+				pwm[i] = data->read(data,
+						    data->REG_PWM[i]);
 
 			/*
 			 * If any fan is in automatic pwm mode, the polarity
@@ -3371,12 +4127,10 @@ static int it87_check_pwm(struct device *dev)
 			if (!((pwm[0] | pwm[1] | pwm[2]) & 0x80)) {
 				dev_info(dev,
 					 "Reconfiguring PWM to active high polarity\n");
-				it87_write_value(data, IT87_REG_FAN_CTL,
-						 tmp | 0x87);
+				data->write(data, IT87_REG_FAN_CTL, tmp | 0x87);
 				for (i = 0; i < 3; i++)
-					it87_write_value(data,
-							 IT87_REG_PWM[i],
-							 0x7f & ~pwm[i]);
+					data->write(data, data->REG_PWM[i],
+						    0x7f & ~pwm[i]);
 				return 1;
 			}
 
@@ -3403,25 +4157,33 @@ static int it87_probe(struct platform_device *pdev)
 	struct device *hwmon_dev;
 	int err;
 
-	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
-	if (!devm_request_region(&pdev->dev, res->start, IT87_EC_EXTENT,
-				 DRVNAME)) {
-		dev_err(dev, "Failed to request region 0x%lx-0x%lx\n",
-			(unsigned long)res->start,
-			(unsigned long)(res->start + IT87_EC_EXTENT - 1));
-		return -EBUSY;
-	}
-
-	data = devm_kzalloc(&pdev->dev, sizeof(struct it87_data), GFP_KERNEL);
+	data = devm_kzalloc(dev, sizeof(struct it87_data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (res) {
+		if (!devm_request_region(dev, res->start, IT87_EC_EXTENT,
+					 DRVNAME)) {
+			dev_err(dev, "Failed to request region %pR\n", res);
+			return -EBUSY;
+		}
+	} else {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		data->mmio = devm_ioremap_resource(dev, res);
+		if (IS_ERR(data->mmio))
+			return PTR_ERR(data->mmio);
+	}
+
 	data->addr = res->start;
-	data->sioaddr = sio_data->sioaddr;
 	data->type = sio_data->type;
+	data->sioaddr = sio_data->sioaddr;
 	data->smbus_bitmap = sio_data->smbus_bitmap;
 	data->ec_special_config = sio_data->ec_special_config;
 	data->features = it87_devices[sio_data->type].features;
+	data->num_temp_limit = it87_devices[sio_data->type].num_temp_limit;
+	data->num_temp_offset = it87_devices[sio_data->type].num_temp_offset;
+	data->pwm_num_temp_map = it87_devices[sio_data->type].num_temp_map;
 	data->peci_mask = it87_devices[sio_data->type].peci_mask;
 	data->old_peci_mask = it87_devices[sio_data->type].old_peci_mask;
 	/*
@@ -3451,13 +4213,27 @@ static int it87_probe(struct platform_device *pdev)
 
 	mutex_init(&data->update_lock);
 
+	/* Initialize register pointers */
+	it87_init_regs(pdev);
+
+	/*
+	 * We need to disable SMBus before we can read any registers in
+	 * the envmon address space, even if it is for chip identification
+	 * purposes. If the chip has SMBus client support, it likely also has
+	 * multi-page envmon registers, so we have to set the page anyway
+	 * before accessing those registers. Kind of a chicken-and-egg
+	 * problem.
+	 * Fortunately, the chip was already identified through the SIO
+	 * address space, only recent chips are affected, and this is just
+	 * an additional safeguard.
+	 */
 	err = smbus_disable(data);
 	if (err)
 		return err;
 
 	/* Now, we do the remaining detection. */
-	if ((it87_read_value(data, IT87_REG_CONFIG) & 0x80) ||
-	    it87_read_value(data, IT87_REG_CHIPID) != 0x90) {
+	if ((data->read(data, IT87_REG_CONFIG) & 0x80) ||
+			data->read(data, IT87_REG_CHIPID) != 0x90) {
 		smbus_enable(data);
 		return -ENODEV;
 	}
@@ -3489,7 +4265,7 @@ static int it87_probe(struct platform_device *pdev)
 	data->has_temp = 0x07;
 	if (sio_data->skip_temp & BIT(2)) {
 		if (sio_data->type == it8782 &&
-		    !(it87_read_value(data, IT87_REG_TEMP_EXTRA) & 0x80))
+		    !(data->read(data, IT87_REG_TEMP_EXTRA) & 0x80))
 			data->has_temp &= ~BIT(2);
 	}
 
@@ -3500,23 +4276,27 @@ static int it87_probe(struct platform_device *pdev)
 	if (has_four_temp(data)) {
 		data->has_temp |= BIT(3);
 	} else if (has_six_temp(data)) {
-		u8 reg = it87_read_value(data, IT87_REG_TEMP456_ENABLE);
-
-		/* Check for additional temperature sensors */
-		if ((reg & 0x03) >= 0x02)
-			data->has_temp |= BIT(3);
-		if (((reg >> 2) & 0x03) >= 0x02)
-			data->has_temp |= BIT(4);
-		if (((reg >> 4) & 0x03) >= 0x02)
-			data->has_temp |= BIT(5);
-
-		/* Check for additional voltage sensors */
-		if ((reg & 0x03) == 0x01)
-			data->has_in |= BIT(10);
-		if (((reg >> 2) & 0x03) == 0x01)
-			data->has_in |= BIT(11);
-		if (((reg >> 4) & 0x03) == 0x01)
-			data->has_in |= BIT(12);
+		if (sio_data->type == it8655 || sio_data->type == it8665) {
+			data->has_temp |= BIT(3) | BIT(4) | BIT(5);
+		} else {
+			u8 reg = data->read(data, IT87_REG_TEMP456_ENABLE);
+
+			/* Check for additional temperature sensors */
+			if ((reg & 0x03) >= 0x02)
+				data->has_temp |= BIT(3);
+			if (((reg >> 2) & 0x03) >= 0x02)
+				data->has_temp |= BIT(4);
+			if (((reg >> 4) & 0x03) >= 0x02)
+				data->has_temp |= BIT(5);
+
+			/* Check for additional voltage sensors */
+			if ((reg & 0x03) == 0x01)
+				data->has_in |= BIT(10);
+			if (((reg >> 2) & 0x03) == 0x01)
+				data->has_in |= BIT(11);
+			if (((reg >> 4) & 0x03) == 0x01)
+				data->has_in |= BIT(12);
+		}
 	}
 
 	data->has_beep = !!sio_data->beep_pin;
@@ -3590,10 +4370,13 @@ static int it87_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct it87_data *data = dev_get_drvdata(dev);
+	int err;
 
 	it87_resume_sio(pdev);
 
-	it87_lock(data);
+	err = it87_lock(data);
+	if (err)
+		return err;
 
 	it87_check_pwm(dev);
 	it87_check_limit_regs(data);
@@ -3618,30 +4401,40 @@ static DEFINE_SIMPLE_DEV_PM_OPS(it87_dev_pm_ops, NULL, it87_resume);
 static struct platform_driver it87_driver = {
 	.driver = {
 		.name	= DRVNAME,
-		.pm     = pm_sleep_ptr(&it87_dev_pm_ops),
+		.pm	= pm_sleep_ptr(&it87_dev_pm_ops),
 	},
 	.probe	= it87_probe,
 };
 
-static int __init it87_device_add(int index, unsigned short address,
+static int __init it87_device_add(int index, unsigned short sio_address,
+				  phys_addr_t mmio_address,
 				  const struct it87_sio_data *sio_data)
 {
 	struct platform_device *pdev;
 	struct resource res = {
-		.start	= address + IT87_EC_OFFSET,
-		.end	= address + IT87_EC_OFFSET + IT87_EC_EXTENT - 1,
 		.name	= DRVNAME,
-		.flags	= IORESOURCE_IO,
 	};
 	int err;
 
+	if (mmio_address) {
+		res.start = mmio_address;
+		res.end  = mmio_address + 0x400 - 1;
+		res.flags = IORESOURCE_MEM;
+	} else {
+		res.start = sio_address + IT87_EC_OFFSET;
+		res.end  = sio_address + IT87_EC_OFFSET + IT87_EC_EXTENT - 1;
+		res.flags = IORESOURCE_IO;
+	}
+
 	err = acpi_check_resource_conflict(&res);
 	if (err) {
-		if (!ignore_resource_conflict)
+		if (dmi_data && dmi_data->skip_acpi_res)
+			pr_info("Ignoring expected ACPI resource conflict\n");
+		else if (!ignore_resource_conflict)
 			return err;
 	}
 
-	pdev = platform_device_alloc(DRVNAME, address);
+	pdev = platform_device_alloc(DRVNAME, sio_address);
 	if (!pdev)
 		return -ENOMEM;
 
@@ -3695,6 +4488,21 @@ static struct it87_dmi_data nvidia_fn68pt = {
 	.skip_pwm = BIT(1),
 };
 
+/*
+ * On some Gigabyte boards sensors are marked as ACPI regions but not
+ * really handled by ACPI calls, as they return no data.
+ * Most commonly this is seen on boards with multiple ITE chips.
+ * In this case we just ignore the failure and continue on.
+ * This is effectively the same as the use of either
+ *     acpi_enforce_resources=lax (kernel)
+ * or
+ *     ignore_resource_conflict=1 (it87)
+ * but set programatically.
+ */
+static struct it87_dmi_data it87_acpi_ignore = {
+	.skip_acpi_res = true,
+};
+
 #define IT87_DMI_MATCH_VND(vendor, name, cb, data) \
 	{ \
 		.callback = cb, \
@@ -3705,10 +4513,123 @@ static struct it87_dmi_data nvidia_fn68pt = {
 		.driver_data = data, \
 	}
 
+#define IT87_DMI_MATCH_GBT(name, cb, data) \
+	IT87_DMI_MATCH_VND("Gigabyte Technology Co., Ltd.", name, cb, data)
+
 static const struct dmi_system_id it87_dmi_table[] __initconst = {
+	IT87_DMI_MATCH_GBT("A320M-S2H V2-CF", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8686E */
+	IT87_DMI_MATCH_GBT("AB350", it87_dmi_cb, NULL),
+		/* ? + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("AX370", it87_dmi_cb, NULL),
+		/* ? + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("Q370M D3H GSM PLUS", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8686E */
+	IT87_DMI_MATCH_GBT("A520I AC", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E */
+	IT87_DMI_MATCH_GBT("Z97X-Gaming G1", it87_dmi_cb, NULL),
+		/* ? + IT8790E */
+	IT87_DMI_MATCH_GBT("TRX40 AORUS XTREME", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("Z390 AORUS ULTRA-CF", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("X399 DESIGNARE EX-CF", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8686E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("B450 AORUS PRO-CF", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8686E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("Z490 AORUS ELITE AC", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E */
+	IT87_DMI_MATCH_GBT("B550 AORUS PRO AC", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("B560I AORUS PRO AX", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("X570 AORUS ELITE", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E */
+	IT87_DMI_MATCH_GBT("X570 AORUS ELITE WIFI", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E */
+	IT87_DMI_MATCH_GBT("X570 AORUS MASTER", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("X570 AORUS PRO", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("X570 AORUS PRO WIFI", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("X570 AORUS ULTRA", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E + IT8792E/IT8795E */
+	IT87_DMI_MATCH_GBT("X570 I AORUS PRO WIFI", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8688E */
+	IT87_DMI_MATCH_GBT("X570S AERO G", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("B650M GAMING X AX", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("B660M DS3H DDR4", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("X670 AORUS ELITE AX", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87952E */
+	IT87_DMI_MATCH_GBT("X670E AORUS MASTER", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87922E */
+	IT87_DMI_MATCH_GBT("H610M H DDR4", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("H610M S2H V2", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E */
+	IT87_DMI_MATCH_GBT("Z690 AORUS PRO DDR4", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87952E */
+	IT87_DMI_MATCH_GBT("Z690 AORUS PRO", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87952E */
+	IT87_DMI_MATCH_GBT("Z790 AORUS ELITE AX", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87952E */
+	IT87_DMI_MATCH_GBT("Z790 AORUS MASTER", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8689E + IT87952E */
+	IT87_DMI_MATCH_GBT("X870I AORUS PRO ICE", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8696E */
+	IT87_DMI_MATCH_GBT("X870 AORUS ELITE WIFI7", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT87952E + IT8696E */
+	IT87_DMI_MATCH_GBT("X870 AORUS ELITE WIFI7 ICE", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8696E */
+	IT87_DMI_MATCH_GBT("X870 GAMING WIFI6", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8696E */
+	IT87_DMI_MATCH_GBT("X870E AORUS MASTER", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8696E */
+	IT87_DMI_MATCH_GBT("X870 EAGLE WIFI7", it87_dmi_cb,
+			   &it87_acpi_ignore),
+		/* IT8696E */
+	IT87_DMI_MATCH_VND("ASUSTeK COMPUTER INC.", "PRIME B350-PLUS",
+			   it87_dmi_cb, NULL),
+		/* IT8655E */
 	IT87_DMI_MATCH_VND("nVIDIA", "FN68PT", it87_dmi_cb, &nvidia_fn68pt),
 	{ }
-
 };
 MODULE_DEVICE_TABLE(dmi, it87_dmi_table);
 
@@ -3717,6 +4638,7 @@ static int __init sm_it87_init(void)
 	int sioaddr[2] = { REG_2E, REG_4E };
 	struct it87_sio_data sio_data;
 	unsigned short isa_address[2];
+	phys_addr_t mmio_address;
 	bool found = false;
 	int i, err;
 
@@ -3729,7 +4651,9 @@ static int __init sm_it87_init(void)
 	for (i = 0; i < ARRAY_SIZE(sioaddr); i++) {
 		memset(&sio_data, 0, sizeof(struct it87_sio_data));
 		isa_address[i] = 0;
-		err = it87_find(sioaddr[i], &isa_address[i], &sio_data, i);
+		mmio_address = 0;
+		err = it87_find(sioaddr[i], &isa_address[i], &mmio_address,
+				&sio_data, i);
 		if (err || isa_address[i] == 0)
 			continue;
 		/*
@@ -3739,7 +4663,8 @@ static int __init sm_it87_init(void)
 		if (i && isa_address[i] == isa_address[0])
 			break;
 
-		err = it87_device_add(i, isa_address[i], &sio_data);
+		err = it87_device_add(i, isa_address[i], mmio_address,
+				      &sio_data);
 		if (err)
 			goto exit_dev_unregister;
 
-- 
2.51.0

