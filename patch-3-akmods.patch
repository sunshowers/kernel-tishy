# ----------------------------------------
# Module: ayn_platform
# Version: fee1bab81d4e
# ----------------------------------------
diff --git a/drivers/custom/ayn_platform/Kconfig b/drivers/custom/ayn_platform/Kconfig
new file mode 100644
index 000000000000..b08b31733983
--- /dev/null
+++ b/drivers/custom/ayn_platform/Kconfig
@@ -0,0 +1,10 @@
+menuconfig AYN_PLATFORM
+	tristate "Ayn x86 PWM Control Support"
+	depends on HWMON
+	select LEDS_CLASS
+	select LEDS_CLASS_MULTICOLOR
+	help
+	  This driver provides support for Ayn x86 Handheld Consoles by
+	  providing a hwmon interface for pwm fan control and a BIOS
+	  controlled custom fan curve, as well as an RGB LED control 
+	  via a multicolor LED sysfs interface.
diff --git a/drivers/custom/ayn_platform/Makefile b/drivers/custom/ayn_platform/Makefile
new file mode 100644
index 000000000000..62a2fe123bfb
--- /dev/null
+++ b/drivers/custom/ayn_platform/Makefile
@@ -0,0 +1,108 @@
+# For building for the current running version of Linux
+ifndef TARGET
+TARGET = $(shell uname -r)
+endif
+# Or specific version
+#TARGET = 2.6.33.5
+
+KERNEL_MODULES = /lib/modules/$(TARGET)
+
+ifneq ("","$(wildcard /usr/src/linux-headers-$(TARGET)/*)")
+# Ubuntu
+KERNEL_BUILD = /usr/src/linux-headers-$(TARGET)
+else
+ifneq ("","$(wildcard /usr/src/kernels/$(TARGET)/*)")
+# Fedora
+KERNEL_BUILD = /usr/src/kernels/$(TARGET)
+else
+KERNEL_BUILD = $(KERNEL_MODULES)/build
+endif
+endif
+
+# SYSTEM_MAP = $(KERNEL_BUILD)/System.map
+ifneq ("","$(wildcard /boot/System.map-$(TARGET))")
+SYSTEM_MAP = /boot/System.map-$(TARGET)
+else
+# Arch
+SYSTEM_MAP = /proc/kallsyms
+endif
+
+DRIVER := ayn-platform
+ifneq ("","$(wildcard .git/*)")
+DRIVER_VERSION := $(shell git describe --long --tags | sed s/\-/\./g )
+else
+ifneq ("", "$(wildcard VERSION)")
+DRIVER_VERSION := $(shell cat VERSION)
+else
+DRIVER_VERSION := unknown
+endif
+endif
+
+# DKMS
+DKMS_ROOT_PATH=/usr/src/$(DRIVER)-$(DRIVER_VERSION)
+MODPROBE_OUTPUT=$(shell lsmod | grep ayn-platform)
+
+# Directory below /lib/modules/$(TARGET)/kernel into which to install
+# the module:
+MOD_SUBDIR = drivers/platform/x86
+MODDESTDIR=$(KERNEL_MODULES)/kernel/$(MOD_SUBDIR)
+
+obj-m = $(patsubst %,%.o,$(DRIVER))
+obj-ko  := $(patsubst %,%.ko,$(DRIVER))
+
+MAKEFLAGS += --no-print-directory
+
+ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.gz)")
+COMPRESS_GZIP := y
+endif
+ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.xz)")
+COMPRESS_XZ := y
+endif
+
+
+.PHONY: all install modules modules_install clean dkms dkms_clean
+
+all: modules
+
+
+# Targets for running make directly in the external module directory:
+
+OXP_PLATFORM_CFLAGS=-DOXP_PLATFORM_DRIVER_VERSION='\"$(DRIVER_VERSION)\"'
+
+modules:
+	@$(MAKE) EXTRA_CFLAGS="$(OXP_PLATFORM_CFLAGS)" -C $(KERNEL_BUILD) M=$(CURDIR) $@
+
+clean:
+	@$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) $@
+
+install: modules_install
+
+modules_install:
+	mkdir -p $(MODDESTDIR)
+	cp $(DRIVER).ko $(MODDESTDIR)/
+ifeq ($(COMPRESS_GZIP), y)
+	@gzip -f $(MODDESTDIR)/$(DRIVER).ko
+endif
+ifeq ($(COMPRESS_XZ), y)
+	@xz -f $(MODDESTDIR)/$(DRIVER).ko
+endif
+	depmod -a -F $(SYSTEM_MAP) $(TARGET)
+
+dkms:
+	@sed -i -e '/^PACKAGE_VERSION=/ s/=.*/=\"$(DRIVER_VERSION)\"/' dkms.conf
+	@echo "$(DRIVER_VERSION)" >VERSION
+	@mkdir -p $(DKMS_ROOT_PATH)
+	@cp `pwd`/dkms.conf $(DKMS_ROOT_PATH)
+	@cp `pwd`/VERSION $(DKMS_ROOT_PATH)
+	@cp `pwd`/Makefile $(DKMS_ROOT_PATH)
+	@cp `pwd`/ayn-platform.c $(DKMS_ROOT_PATH)
+	@dkms add -m $(DRIVER) -v $(DRIVER_VERSION)
+	@dkms build -m $(DRIVER) -v $(DRIVER_VERSION) --kernelsourcedir=$(KERNEL_BUILD)
+	@dkms install --force -m $(DRIVER) -v $(DRIVER_VERSION)
+
+dkms_clean:
+	@if [ ! -z "$(MODPROBE_OUTPUT)" ]; then \
+		rmmod $(DRIVER);\
+	fi
+	@dkms remove -m $(DRIVER) -v $(DRIVER_VERSION) --all
+	@rm -rf $(DKMS_ROOT_PATH)
diff --git a/drivers/custom/ayn_platform/ayn-platform.c b/drivers/custom/ayn_platform/ayn-platform.c
new file mode 100644
index 000000000000..ab50e5dcbc0b
--- /dev/null
+++ b/drivers/custom/ayn_platform/ayn-platform.c
@@ -0,0 +1,767 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Platform driver for Ayn x86 Handhelds that expose fan reading and
+ * control, as well as temperature sensor readings exposed by the EC
+ * via hwmon sysfs.
+ *
+ * Fan control is provided via pwm interface in the range [0-255].
+ * Ayn use [0-128] as the range in the EC, the written value is
+ * scaled to accommodate. The EC also provides a configurable fan
+ * curve with five set points that associate a temperature [0-100]
+ * in Celcius with a fan speed [0-128]. The auto_point fan speeds
+ * are scaled from the range [0-255]. Temperature readings are
+ * scaled from the hwmon expected millidegrees to degrees when read.
+ *
+ * Copyright (C) 2023-2024 Derek J. Clark <derekjohn.clark@gmail.com>
+ */
+
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/processor.h>
+
+/* Handle ACPI lock mechanism */
+static u32 ayn_mutex;
+
+#define ACPI_LOCK_DELAY_MS 500
+
+static bool lock_global_acpi_lock(void) {
+        return ACPI_SUCCESS(acpi_acquire_global_lock(ACPI_LOCK_DELAY_MS, &ayn_mutex));
+}
+
+static bool unlock_global_acpi_lock(void) {
+         return ACPI_SUCCESS(acpi_release_global_lock(ayn_mutex));
+}
+
+enum ayn_model {
+        ayn_loki_max = 1,
+        ayn_loki_minipro,
+        ayn_loki_zero,
+};
+
+static enum ayn_model model;
+
+/* EC Teperature Sensors */
+#define AYN_SENSOR_BAT_TEMP_REG         0x04  /* Battery */
+#define AYN_SENSOR_CHARGE_TEMP_REG      0x07  /* Charger IC */
+#define AYN_SENSOR_MB_TEMP_REG          0x05  /* Motherboard */
+#define AYN_SENSOR_PROC_TEMP_REG        0x09  /* CPU Core */
+#define AYN_SENSOR_VCORE_TEMP_REG       0x08  /* vCore */
+
+/* Fan reading and PWM */
+#define AYN_SENSOR_PWM_FAN_ENABLE_REG   0x10  /* PWM operating mode */
+#define AYN_SENSOR_PWM_FAN_SET_REG      0x11  /* PWM duty cycle */
+#define AYN_SENSOR_PWM_FAN_SPEED_REG    0x20  /* Fan speed */
+
+/* EC controlled fan curve registers */
+#define AYN_SENSOR_PWM_FAN_SPEED_1_REG  0x12
+#define AYN_SENSOR_PWM_FAN_SPEED_2_REG  0x14
+#define AYN_SENSOR_PWM_FAN_SPEED_3_REG  0x16
+#define AYN_SENSOR_PWM_FAN_SPEED_4_REG  0x18
+#define AYN_SENSOR_PWM_FAN_SPEED_5_REG  0x1A
+#define AYN_SENSOR_PWM_FAN_TEMP_1_REG   0x13
+#define AYN_SENSOR_PWM_FAN_TEMP_2_REG   0x15
+#define AYN_SENSOR_PWM_FAN_TEMP_3_REG   0x17
+#define AYN_SENSOR_PWM_FAN_TEMP_4_REG   0x19
+#define AYN_SENSOR_PWM_FAN_TEMP_5_REG   0x1B
+
+/* EC Controlled RGB registers */
+#define AYN_LED_MC_B_REG                0xB2 /* Blue, range 0x00-0xFF */
+#define AYN_LED_MC_G_REG                0xB1 /* Green, range 0x00-0xFF */
+#define AYN_LED_MC_R_REG                0xB0 /* Red, range 0x00-0xFF */
+#define AYN_LED_MODE_REG                0xB3 /* RGB Mode */
+
+/* RGB Mode values */
+#define AYN_LED_MODE_BREATH             0x00 /* Default breathing mode */
+#define AYN_LED_MODE_WRITE              0xAA /* User defined mode */
+#define AYN_LED_MODE_WRITE_ENABLED      0x55 /* Return value when probed */
+
+enum led_mode {
+        breath = 0,
+        write,
+};
+
+static const struct dmi_system_id dmi_table[] = {
+    {
+        .matches =
+            {
+                DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "ayn"),
+                DMI_EXACT_MATCH(DMI_BOARD_NAME, "Loki Max"),
+            },
+        .driver_data = (void *)ayn_loki_max,
+    },
+    {
+        .matches =
+            {
+                DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "ayn"),
+                DMI_EXACT_MATCH(DMI_BOARD_NAME, "Loki MiniPro"),
+            },
+        .driver_data = (void *)ayn_loki_minipro,
+    },
+    {
+        .matches =
+            {
+                DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "ayn"),
+                DMI_EXACT_MATCH(DMI_BOARD_NAME, "Loki Zero"),
+            },
+        .driver_data = (void *)ayn_loki_zero,
+    },
+    {},
+};
+
+/* Helper functions to handle EC read/write */
+static int read_from_ec(u8 reg, int size, long *val)
+{
+        int i;
+        int ret;
+        u8 buffer;
+
+        if (!lock_global_acpi_lock())
+                return -EBUSY;
+
+        *val = 0;
+        for (i = 0; i < size; i++) {
+                ret = ec_read(reg + i, &buffer);
+                if (ret)
+                        return ret;
+                *val <<= i * 8;
+                *val += buffer;
+        }
+
+        if (!unlock_global_acpi_lock())
+                return -EBUSY;
+
+        return 0;
+}
+
+static int write_to_ec(u8 reg, u8 val)
+{
+        int ret;
+
+        if (!lock_global_acpi_lock())
+                return -EBUSY;
+
+        ret = ec_write(reg, val);
+
+        if (!unlock_global_acpi_lock())
+                return -EBUSY;
+
+        return ret;
+}
+
+/* Thermal Sensor Functions*/
+struct thermal_sensor {
+        char *name;
+        int reg;
+};
+
+static struct thermal_sensor thermal_sensors[] = {
+        {"Battery", AYN_SENSOR_BAT_TEMP_REG},
+        {"Motherboard", AYN_SENSOR_MB_TEMP_REG},
+        {"Charger IC", AYN_SENSOR_CHARGE_TEMP_REG},
+        {"vCore", AYN_SENSOR_VCORE_TEMP_REG},
+        {"CPU Core", AYN_SENSOR_PROC_TEMP_REG},
+        {0,}
+};
+
+static long thermal_sensor_temp(u8 reg, long *val)
+{
+        long retval;
+        retval = read_from_ec(reg, 1, val);
+
+        if (retval)
+                return retval;
+
+        *val = *val * (long)1000; // convert from hwmon expected millidegree to degree
+        return retval;
+};
+
+static ssize_t thermal_sensor_show(struct device *dev,
+                                   struct device_attribute *attr, char *buf)
+{
+        int index;
+        long retval;
+        long val;
+        index = to_sensor_dev_attr(attr)->index;
+
+        retval = thermal_sensor_temp(thermal_sensors[index].reg, &val);
+        if (retval)
+                return retval;
+
+        return sprintf(buf, "%ld\n", val);
+}
+
+static ssize_t thermal_sensor_label(struct device *dev,
+                                    struct device_attribute *attr, char *buf)
+{
+        int index;
+        index = to_sensor_dev_attr(attr)->index;
+        return sprintf(buf, "%s\n", thermal_sensors[index].name);
+}
+
+/* PWM mode functions */
+/* Callbacks for pwm_auto_point attributes */
+static ssize_t pwm_curve_store(struct device *dev,
+                               struct device_attribute *attr, const char *buf,
+                               size_t count)
+{
+        int index;
+        int retval;
+        int val;
+        u8 reg;
+
+        retval = kstrtoint(buf, 0, &val);
+        if (retval)
+                return retval;
+
+        index = to_sensor_dev_attr(attr)->index;
+        switch (index) {
+        case 0:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_1_REG;
+                break;
+        case 1:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_2_REG;
+                break;
+        case 2:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_3_REG;
+                break;
+        case 3:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_4_REG;
+                break;
+        case 4:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_5_REG;
+                break;
+        case 5:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_1_REG;
+                break;
+        case 6:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_2_REG;
+                break;
+        case 7:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_3_REG;
+                break;
+        case 8:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_4_REG;
+                break;
+        case 9:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_5_REG;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        switch (index) {
+        case 0:
+        case 1:
+        case 2:
+        case 3:
+        case 4:
+                if (val < 0 || val > 255)
+                        return -EINVAL;
+                val = val >> 1;
+                break;
+        case 5:
+        case 6:
+        case 7:
+        case 8:
+        case 9:
+                if (val < 0 || val > 100)
+                        return -EINVAL;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        retval = write_to_ec(reg, val);
+        if (retval)
+                return retval;
+        return count;
+}
+
+static ssize_t pwm_curve_show(struct device *dev, struct device_attribute *attr,
+                              char *buf)
+{
+        int index;
+        int retval;
+        long val;
+        u8 reg;
+
+        index = to_sensor_dev_attr(attr)->index;
+        switch (index) {
+        case 0:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_1_REG;
+                break;
+        case 1:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_2_REG;
+                break;
+        case 2:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_3_REG;
+                break;
+        case 3:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_4_REG;
+                break;
+        case 4:
+                reg = AYN_SENSOR_PWM_FAN_SPEED_5_REG;
+                break;
+        case 5:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_1_REG;
+                break;
+        case 6:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_2_REG;
+                break;
+        case 7:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_3_REG;
+                break;
+        case 8:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_4_REG;
+                break;
+        case 9:
+                reg = AYN_SENSOR_PWM_FAN_TEMP_5_REG;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        retval = read_from_ec(reg, 1, &val);
+        if (retval)
+                return retval;
+
+        switch (index) {
+        case 0:
+        case 1:
+        case 2:
+        case 3:
+        case 4:
+                val = val << 1;
+                break;
+        default:
+                break;
+         }
+
+        return sysfs_emit(buf, "%ld\n", val);
+}
+
+/* Manual provides direct control of the PWM */
+static int ayn_pwm_manual(void)
+{
+        return write_to_ec(AYN_SENSOR_PWM_FAN_ENABLE_REG, 0x00);
+}
+
+/* Auto provides EC full control of the PWM */
+static int ayn_pwm_auto(void)
+{
+        return write_to_ec(AYN_SENSOR_PWM_FAN_ENABLE_REG, 0x01);
+}
+
+/* User defined mode allows users to set a custom 5 point
+ * fan curve in the EC which uses the CPU temperature. */
+static int ayn_pwm_user(void)
+{
+        return write_to_ec(AYN_SENSOR_PWM_FAN_ENABLE_REG, 0x02);
+}
+
+/* Temperature sensor and fan curve attributes */
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, thermal_sensor_show, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, thermal_sensor_label, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, thermal_sensor_show, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp2_label, S_IRUGO, thermal_sensor_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp3_input, S_IRUGO, thermal_sensor_show, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp3_label, S_IRUGO, thermal_sensor_label, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_input, S_IRUGO, thermal_sensor_show, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp4_label, S_IRUGO, thermal_sensor_label, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp5_input, S_IRUGO, thermal_sensor_show, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp5_label, S_IRUGO, thermal_sensor_label, NULL, 4);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_pwm, pwm_curve, 0);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_pwm, pwm_curve, 1);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_pwm, pwm_curve, 2);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_pwm, pwm_curve, 3);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point5_pwm, pwm_curve, 4);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point1_temp, pwm_curve, 5);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point2_temp, pwm_curve, 6);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point3_temp, pwm_curve, 7);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point4_temp, pwm_curve, 8);
+static SENSOR_DEVICE_ATTR_RW(pwm1_auto_point5_temp, pwm_curve, 9);
+
+static struct attribute *ayn_sensors_attrs[] = {
+        &sensor_dev_attr_temp1_input.dev_attr.attr,
+        &sensor_dev_attr_temp1_label.dev_attr.attr,
+        &sensor_dev_attr_temp2_input.dev_attr.attr,
+        &sensor_dev_attr_temp2_label.dev_attr.attr,
+        &sensor_dev_attr_temp3_input.dev_attr.attr,
+        &sensor_dev_attr_temp3_label.dev_attr.attr,
+        &sensor_dev_attr_temp4_input.dev_attr.attr,
+        &sensor_dev_attr_temp4_label.dev_attr.attr,
+        &sensor_dev_attr_temp5_input.dev_attr.attr,
+        &sensor_dev_attr_temp5_label.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point1_pwm.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point2_pwm.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point3_pwm.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point4_pwm.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point5_pwm.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point1_temp.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point2_temp.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point3_temp.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point4_temp.dev_attr.attr,
+        &sensor_dev_attr_pwm1_auto_point5_temp.dev_attr.attr,
+        NULL,
+};
+
+ATTRIBUTE_GROUPS(ayn_sensors);
+
+/* Callbacks for fan1/pwm attributes */
+static umode_t ayn_ec_hwmon_is_visible(const void *drvdata,
+                                       enum hwmon_sensor_types type, u32 attr,
+                                       int channel)
+{
+        switch (type) {
+        case hwmon_fan:
+                return 0444;
+        case hwmon_pwm:
+                return 0644;
+        default:
+                return 0;
+        }
+}
+
+static int ayn_platform_read(struct device *dev, enum hwmon_sensor_types type,
+                             u32 attr, int channel, long *val)
+{
+        int ret;
+
+        switch (type) {
+        case hwmon_fan:
+                switch (attr) {
+                case hwmon_fan_input:
+                        return read_from_ec(AYN_SENSOR_PWM_FAN_SPEED_REG, 2, val);
+                default:
+                        break;
+                }
+                break;
+        case hwmon_pwm:
+                switch (attr) {
+                case hwmon_pwm_enable:
+                        ret = read_from_ec(AYN_SENSOR_PWM_FAN_ENABLE_REG, 1, val);
+                        switch (*val) {
+                        /* EC uses 0 for manual and 1 for automatic,
+                           reflect hwmon usage instead */
+                        case 0:
+                                *val = 1;
+                                break;
+                        case 1:
+                                *val = 0;
+                                break;
+                        default:
+                                break;
+                        }
+                        return ret;
+                case hwmon_pwm_input:
+                        ret = read_from_ec(AYN_SENSOR_PWM_FAN_SET_REG, 1, val);
+                        if (ret)
+                                return ret;
+                        switch (model) {
+                        case ayn_loki_max:
+                        case ayn_loki_minipro:
+                        case ayn_loki_zero:
+                                *val = *val << 1; /* EC max value is 128 */
+                                break;
+                        default:
+                                break;
+                        }
+                        return 0;
+                default:
+                        break;
+                }
+                break;
+        default:
+                break;
+        }
+        return -EOPNOTSUPP;
+}
+
+static int ayn_platform_write(struct device *dev, enum hwmon_sensor_types type,
+                              u32 attr, int channel, long val)
+{
+        switch (type) {
+        case hwmon_pwm:
+                switch (attr) {
+                case hwmon_pwm_enable:
+                        if (val == 1)
+                                return ayn_pwm_manual();
+                        else if (val == 2)
+                                return ayn_pwm_user();
+                        else if (val == 0)
+                                return ayn_pwm_auto();
+                        return -EINVAL;
+                case hwmon_pwm_input:
+                        if (val < 0 || val > 255)
+                                return -EINVAL;
+                        switch (model) {
+                        case ayn_loki_max:
+                        case ayn_loki_minipro:
+                        case ayn_loki_zero:
+                                val = val >> 1; /* EC max value is 128 */
+                                break;
+                        default:
+                                break;
+                        }
+                        return write_to_ec(AYN_SENSOR_PWM_FAN_SET_REG, val);
+                default:
+                        break;
+                }
+                break;
+        default:
+                break;
+        }
+        return -EOPNOTSUPP;
+}
+
+/* RGB LED Logic */
+static int led_mode_write(int mode)
+{
+        return write_to_ec(AYN_LED_MODE_REG, mode);
+};
+
+static ssize_t led_mode_store(struct device *dev, struct device_attribute *attr,
+                              const char *buf, size_t count)
+{
+        int val;
+        int retval;
+        int mode;
+
+        retval = kstrtoint(buf, 0, &val);
+        if (retval)
+                return retval;
+
+        if (val) {
+                mode = AYN_LED_MODE_WRITE;
+        } else {
+                mode = AYN_LED_MODE_BREATH;
+        }
+
+        retval = led_mode_write(mode);
+        if (retval)
+                return retval;
+
+        return count;
+};
+
+static ssize_t led_mode_show(struct device *dev, struct device_attribute *attr,
+                             char *buf)
+{
+        long mode;
+        int val;
+        int retval;
+
+        retval = read_from_ec(AYN_LED_MODE_REG, 1, &mode);
+        if (retval)
+                return retval;
+        switch (mode) {
+        case AYN_LED_MODE_BREATH:
+                val = breath;
+                break;
+        case AYN_LED_MODE_WRITE:
+        case AYN_LED_MODE_WRITE_ENABLED:
+                val = write;
+                break;
+        default:
+                break;
+        }
+        return sysfs_emit(buf, "%d\n", val);
+};
+
+static DEVICE_ATTR_RW(led_mode);
+
+static int ayn_led_mc_brightness_write(struct led_classdev *led_cdev,
+                                       enum led_brightness brightness)
+{
+        struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(led_cdev);
+        struct mc_subled s_led;
+        int i;
+        int retval;
+        int val;
+
+        for (i = 0; i < mc_cdev->num_colors; i++) {
+                s_led = mc_cdev->subled_info[i];
+                val = brightness * s_led.intensity / led_cdev->max_brightness;
+                retval = write_to_ec(s_led.channel, val);
+                if (retval)
+                        return retval;
+        }
+
+        return write_to_ec(AYN_LED_MODE_REG, AYN_LED_MODE_WRITE);
+
+};
+
+static void ayn_led_mc_brightness_set(struct led_classdev *led_cdev,
+                                      enum led_brightness brightness)
+{
+        long mode;
+        int retval;
+
+        retval = read_from_ec(AYN_LED_MODE_REG, 1, &mode);
+        if (retval)
+                return;
+
+        switch (mode) {
+        case AYN_LED_MODE_WRITE:
+        case AYN_LED_MODE_WRITE_ENABLED:
+                break;
+        default:
+                return;
+        }
+
+        led_cdev->brightness = brightness;
+        ayn_led_mc_brightness_write(led_cdev, brightness);
+};
+
+static enum led_brightness
+ayn_led_mc_brightness_get(struct led_classdev *led_cdev)
+{
+        return led_cdev->brightness;
+};
+
+static struct attribute *ayn_led_mc_attrs[] = {
+        &dev_attr_led_mode.attr,
+        NULL,
+};
+
+static struct attribute_group ayn_led_mc_group = {
+      .attrs = ayn_led_mc_attrs,
+};
+
+/* Initialization logic */
+static const struct hwmon_channel_info *ayn_platform_sensors[] = {
+        HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),
+        HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE),
+        NULL,
+};
+
+static const struct hwmon_ops ayn_ec_hwmon_ops = {
+        .is_visible = ayn_ec_hwmon_is_visible,
+        .read = ayn_platform_read,
+        .write = ayn_platform_write,
+};
+
+static const struct hwmon_chip_info ayn_ec_chip_info = {
+        .ops = &ayn_ec_hwmon_ops,
+        .info = ayn_platform_sensors,
+};
+
+struct mc_subled ayn_led_mc_subled_info[] = {
+        {
+                .color_index = LED_COLOR_ID_RED,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = AYN_LED_MC_R_REG,
+        },
+        {
+                .color_index = LED_COLOR_ID_GREEN,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = AYN_LED_MC_G_REG,
+        },
+        {
+                .color_index = LED_COLOR_ID_BLUE,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = AYN_LED_MC_B_REG,
+        },
+};
+
+struct led_classdev_mc ayn_led_mc = {
+        .led_cdev = {
+                .name = "ayn:rgb:joystick_rings",
+                .brightness = 0,
+                .max_brightness = 255,
+                .brightness_set = ayn_led_mc_brightness_set,
+                .brightness_get = ayn_led_mc_brightness_get,
+        },
+        .num_colors = ARRAY_SIZE(ayn_led_mc_subled_info),
+        .subled_info = ayn_led_mc_subled_info,
+};
+
+static int ayn_platform_resume(struct platform_device *pdev)
+{
+        struct led_classdev *led_cdev = &ayn_led_mc.led_cdev;
+        int retval;
+ 
+        retval = led_mode_write(AYN_LED_MODE_WRITE);
+        if (retval)
+                return retval;
+
+        retval = ayn_led_mc_brightness_write(led_cdev, led_cdev->brightness);
+        if (retval)
+                return retval;
+
+        return 0;
+}
+
+static int ayn_platform_probe(struct platform_device *pdev)
+{
+        struct device *dev = &pdev->dev;
+        struct device *hwdev;
+        int retval;
+
+        retval = devm_led_classdev_multicolor_register(dev, &ayn_led_mc);
+        if (retval)
+                return retval;
+
+        struct led_classdev *led_cdev = &ayn_led_mc.led_cdev;
+
+        retval = devm_device_add_group(ayn_led_mc.led_cdev.dev, &ayn_led_mc_group);
+        if (retval)
+                return retval;
+
+        retval = led_mode_write(AYN_LED_MODE_WRITE);
+        if (retval)
+                return retval;
+
+        retval = ayn_led_mc_brightness_write(led_cdev, 0);
+        if (retval)
+                return retval;
+
+        hwdev = devm_hwmon_device_register_with_info(
+                dev, "aynec", NULL, &ayn_ec_chip_info, ayn_sensors_groups);
+        return PTR_ERR_OR_ZERO(hwdev);
+}
+
+static struct platform_driver ayn_platform_driver = {
+        .driver = {
+                .name = "ayn-platform",
+        },
+        .probe = ayn_platform_probe,
+        .resume = ayn_platform_resume,
+};
+
+static struct platform_device *ayn_platform_device;
+
+static int __init ayn_platform_init(void)
+{
+        ayn_platform_device = platform_create_bundle(
+                &ayn_platform_driver, ayn_platform_probe, NULL, 0, NULL, 0);
+
+        return PTR_ERR_OR_ZERO(ayn_platform_device);
+}
+
+static void __exit ayn_platform_exit(void)
+{
+        platform_device_unregister(ayn_platform_device);
+        platform_driver_unregister(&ayn_platform_driver);
+}
+
+MODULE_DEVICE_TABLE(dmi, dmi_table);
+
+module_init(ayn_platform_init);
+module_exit(ayn_platform_exit);
+
+MODULE_AUTHOR("Derek John Clark <derekjohn.clark@gmail.com>");
+MODULE_DESCRIPTION(
+        "Platform driver that handles EC sensors of Ayn x86 devices");
+MODULE_LICENSE("GPL");
# ----------------------------------------
# Module: ayaneo_platform
# Version: bccb4ad32269
# ----------------------------------------
diff --git a/drivers/custom/ayaneo_platform/Kconfig b/drivers/custom/ayaneo_platform/Kconfig
new file mode 100644
index 000000000000..ae06caf85090
--- /dev/null
+++ b/drivers/custom/ayaneo_platform/Kconfig
@@ -0,0 +1,8 @@
+menuconfig AYANEO_PLATFORM
+	tristate "Ayaneo x86 PWM Control Support"
+	select LEDS_CLASS
+	select LEDS_CLASS_MULTICOLOR
+	help
+	  This driver provides support for Ayaneo x86 Handheld
+	  Consoles by providing an RGB LED control via a
+	  multicolor LED sysfs interface.
diff --git a/drivers/custom/ayaneo_platform/Makefile b/drivers/custom/ayaneo_platform/Makefile
new file mode 100644
index 000000000000..2e9842d766c5
--- /dev/null
+++ b/drivers/custom/ayaneo_platform/Makefile
@@ -0,0 +1,108 @@
+# For building for the current running version of Linux
+ifndef TARGET
+TARGET = $(shell uname -r)
+endif
+# Or specific version
+#TARGET = 2.6.33.5
+
+KERNEL_MODULES = /lib/modules/$(TARGET)
+
+ifneq ("","$(wildcard /usr/src/linux-headers-$(TARGET)/*)")
+# Ubuntu
+KERNEL_BUILD = /usr/src/linux-headers-$(TARGET)
+else
+ifneq ("","$(wildcard /usr/src/kernels/$(TARGET)/*)")
+# Fedora
+KERNEL_BUILD = /usr/src/kernels/$(TARGET)
+else
+KERNEL_BUILD = $(KERNEL_MODULES)/build
+endif
+endif
+
+# SYSTEM_MAP = $(KERNEL_BUILD)/System.map
+ifneq ("","$(wildcard /boot/System.map-$(TARGET))")
+SYSTEM_MAP = /boot/System.map-$(TARGET)
+else
+# Arch
+SYSTEM_MAP = /proc/kallsyms
+endif
+
+DRIVER := ayaneo-platform
+ifneq ("","$(wildcard .git/*)")
+DRIVER_VERSION := $(shell git describe --long --tags | sed s/\-/\./g )
+else
+ifneq ("", "$(wildcard VERSION)")
+DRIVER_VERSION := $(shell cat VERSION)
+else
+DRIVER_VERSION := unknown
+endif
+endif
+
+# DKMS
+DKMS_ROOT_PATH=/usr/src/$(DRIVER)-$(DRIVER_VERSION)
+MODPROBE_OUTPUT=$(shell lsmod | grep ayaneo-platform)
+
+# Directory below /lib/modules/$(TARGET)/kernel into which to install
+# the module:
+MOD_SUBDIR = drivers/platform/x86
+MODDESTDIR=$(KERNEL_MODULES)/kernel/$(MOD_SUBDIR)
+
+obj-m = $(patsubst %,%.o,$(DRIVER))
+obj-ko  := $(patsubst %,%.ko,$(DRIVER))
+
+MAKEFLAGS += --no-print-directory
+
+ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.gz)")
+COMPRESS_GZIP := y
+endif
+ifneq ("","$(wildcard $(MODDESTDIR)/*.ko.xz)")
+COMPRESS_XZ := y
+endif
+
+
+.PHONY: all install modules modules_install clean dkms dkms_clean
+
+all: modules
+
+
+# Targets for running make directly in the external module directory:
+
+OXP_PLATFORM_CFLAGS=-DOXP_PLATFORM_DRIVER_VERSION='\"$(DRIVER_VERSION)\"'
+
+modules:
+	@$(MAKE) EXTRA_CFLAGS="$(OXP_PLATFORM_CFLAGS)" -C $(KERNEL_BUILD) M=$(CURDIR) $@
+
+clean:
+	@$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) $@
+
+install: modules_install
+
+modules_install:
+	mkdir -p $(MODDESTDIR)
+	cp $(DRIVER).ko $(MODDESTDIR)/
+ifeq ($(COMPRESS_GZIP), y)
+	@gzip -f $(MODDESTDIR)/$(DRIVER).ko
+endif
+ifeq ($(COMPRESS_XZ), y)
+	@xz -f $(MODDESTDIR)/$(DRIVER).ko
+endif
+	depmod -a -F $(SYSTEM_MAP) $(TARGET)
+
+dkms:
+	@sed -i -e '/^PACKAGE_VERSION=/ s/=.*/=\"$(DRIVER_VERSION)\"/' dkms.conf
+	@echo "$(DRIVER_VERSION)" >VERSION
+	@mkdir -p $(DKMS_ROOT_PATH)
+	@cp `pwd`/dkms.conf $(DKMS_ROOT_PATH)
+	@cp `pwd`/VERSION $(DKMS_ROOT_PATH)
+	@cp `pwd`/Makefile $(DKMS_ROOT_PATH)
+	@cp `pwd`/ayaneo-platform.c $(DKMS_ROOT_PATH)
+	@dkms add -m $(DRIVER) -v $(DRIVER_VERSION)
+	@dkms build -m $(DRIVER) -v $(DRIVER_VERSION) --kernelsourcedir=$(KERNEL_BUILD)
+	@dkms install --force -m $(DRIVER) -v $(DRIVER_VERSION)
+
+dkms_clean:
+	@if [ ! -z "$(MODPROBE_OUTPUT)" ]; then \
+		rmmod $(DRIVER);\
+	fi
+	@dkms remove -m $(DRIVER) -v $(DRIVER_VERSION) --all
+	@rm -rf $(DKMS_ROOT_PATH)
diff --git a/drivers/custom/ayaneo_platform/ayaneo-platform.c b/drivers/custom/ayaneo_platform/ayaneo-platform.c
new file mode 100644
index 000000000000..8bb04e97e347
--- /dev/null
+++ b/drivers/custom/ayaneo_platform/ayaneo-platform.c
@@ -0,0 +1,1418 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Platform driver for AYANEO x86 Handhelds that exposes RGB LED
+ * control via a sysfs led_class_multicolor interface.
+ *
+ * Copyright (C) 2023-2024 Derek J. Clark <derekjohn.clark@gmail.com>
+ * Copyright (C) 2023-2024 JELOS <https://github.com/JustEnoughLinuxOS>
+ * Copyright (C) 2024, 2025 Sebastian Kranz <https://github.com/Lightwars>
+ * Copyright (C) 2024 Trevor Heslop <https://github.com/SytheZN>
+ * Derived from ayaled originally developed by Maya Matuszczyk
+ * <https://github.com/Maccraft123/ayaled>
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/led-class-multicolor.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/processor.h>
+#include <acpi/battery.h>
+
+/* Handle ACPI lock mechanism */
+static u32 ayaneo_mutex;
+
+#define ACPI_LOCK_DELAY_MS        500
+
+static bool lock_global_acpi_lock(void)
+{
+        return ACPI_SUCCESS(acpi_acquire_global_lock(ACPI_LOCK_DELAY_MS, &ayaneo_mutex));
+}
+
+static bool unlock_global_acpi_lock(void)
+{
+        return ACPI_SUCCESS(acpi_release_global_lock(ayaneo_mutex));
+}
+
+/* Common ec ram port data */
+#define AYANEO_ADDR_PORT         0x4e
+#define AYANEO_DATA_PORT         0x4f
+#define AYANEO_HIGH_BYTE         0xd1
+
+/* RGB LED EC Ram Registers
+ * #define AYANEO_LED_MC_L_Q1_R     0xb3
+ * #define AYANEO_LED_MC_L_Q1_G     0xb4
+ * #define AYANEO_LED_MC_L_Q1_B     0xb5
+ * #define AYANEO_LED_MC_L_Q2_R     0xb6
+ * #define AYANEO_LED_MC_L_Q2_G     0xb7
+ * #define AYANEO_LED_MC_L_Q2_B     0xb8
+ * #define AYANEO_LED_MC_L_Q3_R     0xb9
+ * #define AYANEO_LED_MC_L_Q3_G     0xba
+ * #define AYANEO_LED_MC_L_Q3_B     0xbb
+ * #define AYANEO_LED_MC_L_Q4_R     0xbc
+ * #define AYANEO_LED_MC_L_Q4_G     0xbd
+ * #define AYANEO_LED_MC_L_Q4_B     0xbe
+ * #define AYANEO_LED_MC_R_Q1_R     0x73
+ * #define AYANEO_LED_MC_R_Q1_G     0x74
+ * #define AYANEO_LED_MC_R_Q1_B     0x75
+ * #define AYANEO_LED_MC_R_Q2_R     0x76
+ * #define AYANEO_LED_MC_R_Q2_G     0x77
+ * #define AYANEO_LED_MC_R_Q2_B     0x78
+ * #define AYANEO_LED_MC_R_Q3_R     0x79
+ * #define AYANEO_LED_MC_R_Q3_G     0x7a
+ * #define AYANEO_LED_MC_R_Q3_B     0x7b
+ * #define AYANEO_LED_MC_R_Q4_R     0x7c
+ * #define AYANEO_LED_MC_R_Q4_G     0x7d
+ * #define AYANEO_LED_MC_R_Q4_B     0x7e
+ */
+
+#define AYANEO_LED_MC_ADDR_L          0xb0
+#define AYANEO_LED_MC_ADDR_R          0x70
+
+#define AYANEO_LED_MC_ADDR_CLOSE_1    0x86
+#define AYANEO_LED_MC_ADDR_CLOSE_2    0xc6
+
+#define AYANEO_LED_MC_MODE_ADDR       0x87
+#define AYANEO_LED_MC_MODE_HOLD       0xa5
+#define AYANEO_LED_MC_MODE_RELEASE    0x00
+
+/* Bypass Charge EC Ram Registers */
+#define AYANEO_BYPASSCHARGE_CONTROL 0xd1
+#define AYANEO_BYPASSCHARGE_OPEN    0x01
+#define AYANEO_BYPASSCHARGE_CLOSE   0x65
+
+/* Schema:
+ *
+ * 0x6d - LED PWM control (0x03)
+ *
+ * 0xb1 - Support for 4 zones and RGB color
+ *   Colors: Red (1), Green (2), Blue (3)
+ *   Zones:  Right (2), Down (5), Left (8) , Up (11)
+ *   Off: Set 0xb1 to 02
+ *
+ * 0xb2 - Brightness [0-255]. Left/Right produce different brightness for
+ *   the same value on different models, must be scaled. Requires b1
+ *   to be set at the same time.
+ *
+ * 0xbf - Set Mode
+ *   Modes: Enable (0x10), Tint (0xe2), Close (0xff)
+ */
+
+/* EC Controlled RGB registers */
+#define AYANEO_LED_PWM_CONTROL        0x6d
+#define AYANEO_LED_POS                0xb1
+#define AYANEO_LED_BRIGHTNESS         0xb2
+#define AYANEO_LED_MODE_REG           0xbf
+
+#define AYANEO_LED_CMD_ENABLE_ADDR    0x02
+#define AYANEO_LED_CMD_ENABLE_ON      0xb1
+#define AYANEO_LED_CMD_ENABLE_OFF     0x31
+#define AYANEO_LED_CMD_ENABLE_RESET   0xc0
+
+#define AYANEO_LED_CMD_PATTERN_ADDR   0x0f
+#define AYANEO_LED_CMD_PATTERN_OFF    0x00
+
+#define AYANEO_LED_CMD_FADE_ADDR      0x10
+#define AYANEO_LED_CMD_FADE_OFF       0x00
+
+#define AYANEO_LED_CMD_WATCHDOG_ADDR  0x15
+#define AYANEO_LED_CMD_WATCHDOG_ON    0x07
+
+#define AYANEO_LED_CMD_ANIM_1_ADDR    0x11 /* Animation step 1 */
+#define AYANEO_LED_CMD_ANIM_2_ADDR    0x12 /* Animation step 2 */
+#define AYANEO_LED_CMD_ANIM_3_ADDR    0x13 /* Animation step 3 */
+#define AYANEO_LED_CMD_ANIM_4_ADDR    0x14 /* Animation step 4 */
+#define AYANEO_LED_CMD_ANIM_STATIC    0x05
+
+/* RGB Mode values */
+#define AYANEO_LED_MODE_RELEASE       0x00 /* close channel, release control */
+#define AYANEO_LED_MODE_WRITE         0x10 /* Default write mode */
+#define AYANEO_LED_MODE_HOLD          0xfe /* close channel, hold control */
+
+#define AYANEO_LED_GROUP_LEFT         0x01
+#define AYANEO_LED_GROUP_RIGHT        0x02
+#define AYANEO_LED_GROUP_LEFT_RIGHT   0x03 /* omit for aya flip when implemented */
+#define AYANEO_LED_GROUP_BUTTON       0x04
+
+#define AYANEO_LED_WRITE_DELAY_LEGACY_MS        2
+#define AYANEO_LED_WRITE_DELAY_MS               1
+#define AYANEO_LED_WRITER_DELAY_RANGE_US        10000, 20000
+#define AYANEO_LED_SUSPEND_RESUME_DELAY_MS      100
+
+/* EC Controlled Bypass Charge Register */
+#define AYANEO_BYPASS_CHARGE_CONTROL  0x1e
+#define AYANEO_BYPASS_CHARGE_OPEN     0x55
+#define AYANEO_BYPASS_CHARGE_CLOSE    0xaa
+#define AYANEO_BYPASS_WRITER_DELAY_MS 30000
+#define AYANEO_EC_VERSION_REG 0x00 /* until 0x04 */
+
+enum ayaneo_model {
+        air = 1,
+        air_1s,
+        air_1s_limited,
+        air_plus,
+        air_plus_mendo,
+        air_pro,
+        ayaneo_2,
+        ayaneo_2s,
+        geek,
+        geek_1s,
+        kun,
+        slide,
+};
+
+static enum ayaneo_model model;
+
+enum AYANEO_LED_SUSPEND_MODE {
+        AYANEO_LED_SUSPEND_MODE_OFF,
+        AYANEO_LED_SUSPEND_MODE_OEM,
+        AYANEO_LED_SUSPEND_MODE_KEEP
+};
+
+static const char * const AYANEO_LED_SUSPEND_MODE_TEXT[] = {
+        [AYANEO_LED_SUSPEND_MODE_OFF] = "off",
+        [AYANEO_LED_SUSPEND_MODE_OEM] = "oem",
+        [AYANEO_LED_SUSPEND_MODE_KEEP] ="keep"
+};
+
+static enum AYANEO_LED_SUSPEND_MODE suspend_mode;
+
+static const struct dmi_system_id dmi_table[] = {
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR"),
+                },
+                .driver_data = (void *)air,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR 1S"),
+                },
+                .driver_data = (void *)air_1s,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR 1S Limited"),
+                },
+                .driver_data = (void *)air_1s_limited,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AB05-AMD"),
+                },
+                .driver_data = (void *)air_plus,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AB05-Mendocino"),
+                },
+                .driver_data = (void *)air_plus_mendo,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AIR Pro"),
+                },
+                .driver_data = (void *)air_pro,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AYANEO 2"),
+                },
+                .driver_data = (void *)ayaneo_2,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AYANEO 2S"),
+                },
+                .driver_data = (void *)ayaneo_2s,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "GEEK"),
+                },
+                .driver_data = (void *)geek,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "GEEK 1S"),
+                },
+                .driver_data = (void *)geek_1s,
+        },
+        {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_MATCH(DMI_BOARD_NAME, "KUN"),
+                },
+                .driver_data = (void *)kun,
+        },
+    {
+                .matches = {
+                        DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "AYANEO"),
+                        DMI_EXACT_MATCH(DMI_BOARD_NAME, "AS01"),
+                },
+                .driver_data = (void *)slide,
+        },
+        {},
+};
+
+static int ec_write_ram(u8 index, u8 val)
+{
+        int ret;
+
+        if (!lock_global_acpi_lock())
+                return -EBUSY;
+
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x11, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        outb(AYANEO_HIGH_BYTE, AYANEO_DATA_PORT);
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x10, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        outb(index, AYANEO_DATA_PORT);
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x12, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        outb(val, AYANEO_DATA_PORT);
+
+        if (!unlock_global_acpi_lock())
+                return -EBUSY;
+
+        return ret;
+}
+
+static int ec_read_ram(u8 index, u8 *val)
+{
+        int ret;
+
+        if (!lock_global_acpi_lock())
+                return -EBUSY;
+
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x11, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        outb(AYANEO_HIGH_BYTE, AYANEO_DATA_PORT);
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x10, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        outb(index, AYANEO_DATA_PORT);
+        outb(0x2e, AYANEO_ADDR_PORT);
+        outb(0x12, AYANEO_DATA_PORT);
+        outb(0x2f, AYANEO_ADDR_PORT);
+        *val = inb(AYANEO_DATA_PORT);
+
+        if (!unlock_global_acpi_lock())
+                return -EBUSY;
+
+        return ret;
+}
+
+/* Function Summary
+ * AYANEO devices can be largely divided into 2 groups; modern and legacy.
+ *   - Legacy devices use a microcontroller either embedded into or controlled via
+ *     the system's ACPI controller.
+ *   - Modern devices use a dedicated microcontroller and communicate via shared
+ *     memory.
+ *
+ * The control scheme is largely shared between both device types and many of
+ * the command values are shared.
+ *
+ * ayaneo_led_mc_set / ayaneo_led_mc_legacy_set
+ *       Sets the value of a single address or subpixel
+ *
+ * ayaneo_led_mc_release / ayaneo_led_mc_legacy_release
+ *       Releases control of the LEDs back to the microcontroller.
+ *       This function is abstracted by ayaneo_led_mc_release_control.
+ *
+ * ayaneo_led_mc_hold / ayaneo_led_mc_legacy_hold
+ *       Takes and holds control of the LEDs from the microcontroller.
+ *       This function is abstracted by ayaneo_led_mc_take_control.
+ *
+ * ayaneo_led_mc_intensity / ayaneo_led_mc_legacy_intensity
+ *       Sets the values of all of the LEDs in the zones of a given group.
+ *
+ * ayaneo_led_mc_off / ayaneo_led_mc_legacy_off
+ *       Instructs the microcontroller to disable output for the given group.
+ *
+ * ayaneo_led_mc_on / ayaneo_led_mc_legacy_on
+ *       Instructs the microcontroller to enable output for the given group.
+ *
+ * ayaneo_led_mc_reset / ayaneo_led_mc_legacy_reset
+ *       Reverts all of the microcontroller internal registers to power on
+ *       defaults.
+ */
+
+/* Dedicated microcontroller methods */
+static void ayaneo_led_mc_set(u8 group, u8 pos, u8 brightness)
+{
+        u8 led_offset;
+        u8 close_cmd;
+
+        if (group < 2)
+        {
+                led_offset = AYANEO_LED_MC_ADDR_L;
+                close_cmd = AYANEO_LED_MC_ADDR_CLOSE_2;
+        }
+        else
+        {
+                led_offset = AYANEO_LED_MC_ADDR_R;
+                close_cmd = AYANEO_LED_MC_ADDR_CLOSE_1;
+        }
+
+        ec_write_ram(led_offset + pos, brightness);
+        ec_write_ram(close_cmd, 0x01);
+        mdelay(AYANEO_LED_WRITE_DELAY_MS);
+}
+
+static void ayaneo_led_mc_release(void)
+{
+        ec_write_ram(AYANEO_LED_MC_MODE_ADDR, AYANEO_LED_MC_MODE_RELEASE);
+}
+
+static void ayaneo_led_mc_hold(void)
+{
+        ec_write_ram(AYANEO_LED_MC_MODE_ADDR, AYANEO_LED_MC_MODE_HOLD);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_intensity(u8 group, u8 *color, u8 zones[])
+{
+        int zone;
+
+        for (zone = 0; zone < 4; zone++) {
+                ayaneo_led_mc_set(group, zones[zone], color[0]);
+                ayaneo_led_mc_set(group, zones[zone] + 1, color[1]);
+                ayaneo_led_mc_set(group, zones[zone] + 2, color[2]);
+        }
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_off(void)
+{
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_OFF);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_OFF);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_on(void)
+{
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_ON);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_ON);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_PATTERN_ADDR, AYANEO_LED_CMD_PATTERN_OFF);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_PATTERN_ADDR, AYANEO_LED_CMD_PATTERN_OFF);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_FADE_ADDR, AYANEO_LED_CMD_FADE_OFF);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_FADE_ADDR, AYANEO_LED_CMD_FADE_OFF);
+
+        /* Set static color animation */
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ANIM_1_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ANIM_1_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ANIM_2_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ANIM_2_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ANIM_3_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ANIM_3_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ANIM_4_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ANIM_4_ADDR, AYANEO_LED_CMD_ANIM_STATIC);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_WATCHDOG_ADDR, AYANEO_LED_CMD_WATCHDOG_ON);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_WATCHDOG_ADDR, AYANEO_LED_CMD_WATCHDOG_ON);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_reset(void)
+{
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_RESET);
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_RESET);
+
+        ayaneo_led_mc_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+/* ACPI controller methods */
+static void ayaneo_led_mc_legacy_set(u8 group, u8 pos, u8 brightness)
+{
+        if (!lock_global_acpi_lock())
+                return;
+
+        ec_write(AYANEO_LED_PWM_CONTROL, group);
+        ec_write(AYANEO_LED_POS, pos);
+        ec_write(AYANEO_LED_BRIGHTNESS, brightness);
+        ec_write(AYANEO_LED_MODE_REG, AYANEO_LED_MODE_WRITE);
+
+        if (!unlock_global_acpi_lock())
+                return;
+
+        mdelay(AYANEO_LED_WRITE_DELAY_LEGACY_MS);
+
+        if (!lock_global_acpi_lock())
+                return;
+
+        ec_write(AYANEO_LED_MODE_REG, AYANEO_LED_MODE_HOLD);
+
+        if (!unlock_global_acpi_lock())
+                return;
+}
+
+static void ayaneo_led_mc_legacy_release(void)
+{
+        if (!lock_global_acpi_lock())
+                return;
+
+        ec_write(AYANEO_LED_MODE_REG, AYANEO_LED_MODE_RELEASE);
+
+        if (!unlock_global_acpi_lock())
+                return;
+}
+
+static void ayaneo_led_mc_legacy_hold(void)
+{
+        if (!lock_global_acpi_lock())
+                return;
+
+        ec_write(AYANEO_LED_MODE_REG, AYANEO_LED_MODE_HOLD);
+
+        if (!unlock_global_acpi_lock())
+                return;
+}
+
+static void ayaneo_led_mc_legacy_intensity_single(u8 group, u8 *color, u8 zone)
+{
+        ayaneo_led_mc_legacy_set(group, zone, color[0]);
+        ayaneo_led_mc_legacy_set(group, zone + 1, color[1]);
+        ayaneo_led_mc_legacy_set(group, zone + 2, color[2]);
+}
+
+static void ayaneo_led_mc_legacy_intensity(u8 group, u8 *color, u8 zones[])
+{
+        int zone;
+
+        for (zone = 0; zone < 4; zone++) {
+                ayaneo_led_mc_legacy_intensity_single(group, color, zones[zone]);
+        }
+
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+/* KUN doesn't use consistant zone mapping for RGB, adjust */
+static void ayaneo_led_mc_legacy_intensity_kun(u8 group, u8 *color)
+{
+        u8 zone;
+        u8 remap_color[3];
+
+        if (group == AYANEO_LED_GROUP_BUTTON)
+        {
+                zone = 12;
+                remap_color[0] = color[2];
+                remap_color[1] = color[0];
+                remap_color[2] = color[1];
+                ayaneo_led_mc_legacy_intensity_single(AYANEO_LED_GROUP_BUTTON, remap_color, zone);
+                ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+                return;
+        }
+
+        zone = 3;
+        remap_color[0] = color[1];
+        remap_color[1] = color[0];
+        remap_color[2] = color[2];
+        ayaneo_led_mc_legacy_intensity_single(group, remap_color, zone);
+
+        zone = 6;
+        remap_color[0] = color[1];
+        remap_color[1] = color[2];
+        remap_color[2] = color[0];
+        ayaneo_led_mc_legacy_intensity_single(group, remap_color, zone);
+
+        zone = 9;
+        remap_color[0] = color[2];
+        remap_color[1] = color[0];
+        remap_color[2] = color[1];
+        ayaneo_led_mc_legacy_intensity_single(group, remap_color, zone);
+
+        zone = 12;
+        remap_color[0] = color[2];
+        remap_color[1] = color[1];
+        remap_color[2] = color[0];
+        ayaneo_led_mc_legacy_intensity_single(group, remap_color, zone);
+
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_legacy_off(void)
+{
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_OFF);
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_OFF);
+
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_legacy_on(void)
+{
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_ON);
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_ON);
+
+        // note: omit for aya flip when implemented, causes unexpected behavior
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+static void ayaneo_led_mc_legacy_reset(void)
+{
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_RESET);
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_RIGHT,
+                AYANEO_LED_CMD_ENABLE_ADDR, AYANEO_LED_CMD_ENABLE_RESET);
+
+        // note: omit for aya flip when implemented, causes unexpected behavior
+        ayaneo_led_mc_legacy_set(AYANEO_LED_GROUP_LEFT_RIGHT, 0x00, 0x00);
+}
+
+/* Device command abstractions */
+static void ayaneo_led_mc_take_control(void)
+{
+        switch (model) {
+                case air:
+                case air_1s:
+                case air_1s_limited:
+                case air_pro:
+                case air_plus_mendo:
+                case geek:
+                case geek_1s:
+                case ayaneo_2:
+                case ayaneo_2s:
+                case kun:
+                        ayaneo_led_mc_legacy_hold();
+                        ayaneo_led_mc_legacy_reset();
+                        ayaneo_led_mc_legacy_off();
+                        break;
+                case air_plus:
+                case slide:
+                        ayaneo_led_mc_hold();
+                        ayaneo_led_mc_reset();
+                        ayaneo_led_mc_off();
+                        break;
+                default:
+                        break;
+                }
+}
+
+static void ayaneo_led_mc_release_control(void)
+{
+        switch (model) {
+                case air:
+                case air_1s:
+                case air_1s_limited:
+                case air_pro:
+                case air_plus_mendo:
+                case geek:
+                case geek_1s:
+                case ayaneo_2:
+                case ayaneo_2s:
+                case kun:
+                        ayaneo_led_mc_legacy_reset();
+                        ayaneo_led_mc_legacy_release();
+                        break;
+                case air_plus:
+                case slide:
+                        ayaneo_led_mc_reset();
+                        ayaneo_led_mc_release();
+                        break;
+                default:
+                        break;
+                }
+}
+
+/* Threaded writes:
+ *  The writer thread's job is to push updates to the physical LEDs as fast as
+ *  possible while allowing updates to the LED multi_intensity/brightness sysfs
+ *  attributes to return quickly.
+ *
+ *  During multi_intensity/brightness set, the ayaneo_led_mc_update_color array
+ *  is updated with the target color and ayaneo_led_mc_update_required is
+ *  incremented by 1.
+ *
+ *  When the writer thread begins its next loop, it copies the current values of
+ *  ayaneo_led_mc_update_required, and ayaneo_led_mc_update_color, after which
+ *  the new color is pushed to the microcontroller. After the color has been
+ *  pushed the writer thread subtracts the starting value from
+ *  ayaneo_led_mc_update_required. If any updates were pushed to
+ *  ayaneo_led_mc_update_required during the writes then the following iteration
+ *  will immediately begin writing the new colors to the microcontroller,
+ *  otherwise it'll sleep for a short while.
+ *
+ *  Updates to ayaneo_led_mc_update_required and ayaneo_led_mc_update_color are
+ *  syncronised by ayaneo_led_mc_update_lock to prevent a race condition between
+ *  the writer thread and the brightness set function.
+ *
+ *  During suspend kthread_stop is called which causes the writer thread to
+ *  terminate after its current iteration. The writer thread is restarted during
+ *  resume to allow updates to continue.
+ */
+static struct task_struct *ayaneo_led_mc_writer_thread;
+static int ayaneo_led_mc_update_required;
+static u8 ayaneo_led_mc_update_color[3];
+DEFINE_RWLOCK(ayaneo_led_mc_update_lock);
+
+static void ayaneo_led_mc_scale_color(u8 *color, u8 max_value)
+{
+        for (int i = 0; i < 3; i++)
+        {
+                int c_color = (int)color[i] * (int)max_value / 255;
+
+                // prevents left-right discrepancy when brightness/color are low
+                if (c_color == 0 && color[i] > 0)
+                        c_color = 1;
+
+                color[i] = (u8)c_color;
+        }
+}
+
+static void ayaneo_led_mc_brightness_apply(u8 *color)
+{
+        u8 color_l[3]; /* Left joystick ring */
+        u8 color_r[3]; /* Right joystick ring */
+        u8 color_b[3]; /* AyaSpace Button (KUN Only) */
+
+        u8 zones[4] = {3, 6, 9, 12};
+
+        for (int i = 0; i < 3; i++)
+        {
+                color_l[i] = color[i];
+                color_r[i] = color[i];
+                color_b[i] = color[i];
+        }
+
+        ayaneo_led_mc_scale_color(color_l, 192);
+        ayaneo_led_mc_scale_color(color_r, 192);
+        ayaneo_led_mc_scale_color(color_b, 192);
+
+        switch (model) {
+                case air:
+                case air_pro:
+                case air_1s:
+                        ayaneo_led_mc_legacy_on();
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case air_1s_limited:
+                        ayaneo_led_mc_scale_color(color_r, 204);
+                        ayaneo_led_mc_legacy_on();
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case geek:
+                case geek_1s:
+                case ayaneo_2:
+                case ayaneo_2s:
+                        ayaneo_led_mc_legacy_on();
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case air_plus_mendo:
+                        ayaneo_led_mc_scale_color(color_l, 64);
+                        ayaneo_led_mc_scale_color(color_r, 32);
+                        ayaneo_led_mc_legacy_on();
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_legacy_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case air_plus:
+                        ayaneo_led_mc_scale_color(color_l, 64);
+                        ayaneo_led_mc_scale_color(color_r, 32);
+                        ayaneo_led_mc_on();
+                        ayaneo_led_mc_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case slide:
+                        ayaneo_led_mc_on();
+                        ayaneo_led_mc_intensity(AYANEO_LED_GROUP_LEFT, color_l, zones);
+                        ayaneo_led_mc_intensity(AYANEO_LED_GROUP_RIGHT, color_r, zones);
+                        break;
+                case kun:
+                        ayaneo_led_mc_legacy_on();
+                        ayaneo_led_mc_legacy_intensity_kun(AYANEO_LED_GROUP_LEFT, color_l);
+                        ayaneo_led_mc_legacy_intensity_kun(AYANEO_LED_GROUP_RIGHT, color_r);
+                        ayaneo_led_mc_legacy_intensity_kun(AYANEO_LED_GROUP_BUTTON, color_b);
+                        break;
+                default:
+                        break;
+        }
+}
+
+int ayaneo_led_mc_writer(void *pv);
+int ayaneo_led_mc_writer(void *pv)
+{
+        pr_info("Writer thread started.\n");
+        int count;
+        u8 color[3];
+
+        while (!kthread_should_stop())
+        {
+                read_lock(&ayaneo_led_mc_update_lock);
+                count = ayaneo_led_mc_update_required;
+
+                if (count)
+                {
+                        color[0] = ayaneo_led_mc_update_color[0];
+                        color[1] = ayaneo_led_mc_update_color[1];
+                        color[2] = ayaneo_led_mc_update_color[2];
+                }
+                read_unlock(&ayaneo_led_mc_update_lock);
+
+                if (count)
+                {
+                        ayaneo_led_mc_brightness_apply(color);
+
+                        write_lock(&ayaneo_led_mc_update_lock);
+                        ayaneo_led_mc_update_required -= count;
+                        write_unlock(&ayaneo_led_mc_update_lock);
+                }
+                else
+                        usleep_range(AYANEO_LED_WRITER_DELAY_RANGE_US);
+        }
+
+        pr_info("Writer thread stopped.\n");
+        return 0;
+}
+
+/* RGB LED Logic */
+static void ayaneo_led_mc_brightness_set(struct led_classdev *led_cdev,
+                                      enum led_brightness brightness)
+{
+        struct led_classdev_mc *mc_cdev = lcdev_to_mccdev(led_cdev);
+        int val;
+        int i;
+        struct mc_subled s_led;
+
+        if (brightness < 0 || brightness > 255)
+                return;
+
+        led_cdev->brightness = brightness;
+
+        write_lock(&ayaneo_led_mc_update_lock);
+        for (i = 0; i < mc_cdev->num_colors; i++) {
+                s_led = mc_cdev->subled_info[i];
+                if (s_led.intensity < 0 || s_led.intensity > 255)
+                        return;
+                val = brightness * s_led.intensity / led_cdev->max_brightness;
+                ayaneo_led_mc_update_color[s_led.channel] = val;
+        }
+        ayaneo_led_mc_update_required++;
+        write_unlock(&ayaneo_led_mc_update_lock);
+};
+
+static enum led_brightness ayaneo_led_mc_brightness_get(struct led_classdev *led_cdev)
+{
+        return led_cdev->brightness;
+};
+
+/* Suspend Mode
+# Multiple modes of operation are supported during suspend:
+#
+# OEM:  Retains the default behavior of the device by returning control to the
+#       microcontroller. On most devices the LEDs will flash periodically, and
+#       will turn red when charging.
+# Off:  The LEDs are turned off during suspend, and control of the LEDs is
+#       retained by the driver. On most devices, charging will not turn on the
+#       LEDs. During resume, the last color set is restored.
+# Keep: The color currently set on the LEDs remains unchanged, and control of
+#       the LEDs is retained by the driver. On most devices, charging will not
+#       change the color of the LEDs.
+*/
+static ssize_t suspend_mode_show(struct device *dev, struct device_attribute *attr,
+                                 char *buf)
+{
+        bool active;
+        ssize_t count = 0;
+        int i;
+
+        for (i = 0; i <  ARRAY_SIZE(AYANEO_LED_SUSPEND_MODE_TEXT); i++) {
+                active = i == suspend_mode;
+
+                if (active) {
+                        count += sysfs_emit_at(buf, count, "[%s] ",
+                                   AYANEO_LED_SUSPEND_MODE_TEXT[i]);
+                }
+                else {
+                        count += sysfs_emit_at(buf, count, "%s ",
+                                   AYANEO_LED_SUSPEND_MODE_TEXT[i]);
+                }
+        }
+
+        if (count)
+                buf[count - 1] = '\n';
+
+        return count;
+}
+
+static ssize_t suspend_mode_store(struct device *dev, struct device_attribute *attr,
+                               const char *buf, size_t count)
+{
+        int res = sysfs_match_string(AYANEO_LED_SUSPEND_MODE_TEXT, buf);
+
+        if (res < 0)
+                return -EINVAL;
+
+        suspend_mode = res;
+
+        return count;
+}
+
+static DEVICE_ATTR_RW(suspend_mode);
+
+static struct attribute *ayaneo_led_mc_attrs[] = {
+        NULL,
+};
+
+static struct attribute_group ayaneo_led_mc_group = {
+      .attrs = ayaneo_led_mc_attrs,
+};
+
+static void suspend_mode_register_attr(void)
+{
+        switch (model) {
+                case air:
+                case air_1s:
+                case air_1s_limited:
+                case air_pro:
+                case air_plus_mendo:
+                case geek:
+                case geek_1s:
+                case ayaneo_2:
+                case ayaneo_2s:
+                case kun:
+                case air_plus:
+                case slide:
+                        ayaneo_led_mc_attrs[0] = &dev_attr_suspend_mode.attr;
+                        break;
+                default:
+                        break;
+        }
+}
+
+struct mc_subled ayaneo_led_mc_subled_info[] = {
+        {
+                .color_index = LED_COLOR_ID_RED,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = 0,
+        },
+        {
+                .color_index = LED_COLOR_ID_GREEN,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = 1,
+        },
+        {
+                .color_index = LED_COLOR_ID_BLUE,
+                .brightness = 0,
+                .intensity = 0,
+                .channel = 2,
+        },
+};
+
+struct led_classdev_mc ayaneo_led_mc = {
+        .led_cdev = {
+                .name = "ayaneo:rgb:joystick_rings",
+                .brightness = 0,
+                .max_brightness = 255,
+                .brightness_set = ayaneo_led_mc_brightness_set,
+                .brightness_get = ayaneo_led_mc_brightness_get,
+        },
+        .num_colors = ARRAY_SIZE(ayaneo_led_mc_subled_info),
+        .subled_info = ayaneo_led_mc_subled_info,
+};
+
+/* Handling bypass charge */
+struct ayaneo_ps_priv {
+    u8 charge_behaviour;
+    u8 bypass_available;
+};
+static struct ayaneo_ps_priv ps_priv = { POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO, 0 };
+
+static int ayaneo_psy_ext_get_prop(struct power_supply *psy, const struct power_supply_ext *ext,
+                  void *data, enum power_supply_property psp, union power_supply_propval *val)
+{
+    if(psp == POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR) {
+        val->intval = ps_priv.charge_behaviour;
+        return 0;
+    }
+    return -EINVAL;
+}
+
+static int ayaneo_psy_ext_set_prop(struct power_supply *psy, const struct power_supply_ext *ext,
+                  void *data, enum power_supply_property psp, const union power_supply_propval *val)
+{
+    if((psp == POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR) && ((val->intval == POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO) || (val->intval == POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE))) {
+        ps_priv.charge_behaviour = val->intval;
+        return 0;
+    }
+    return -EINVAL;
+}
+
+static int ayaneo_psy_ext_is_writeable(struct power_supply *psy, const struct power_supply_ext *ext,
+                  void *data, enum power_supply_property psp)
+{
+    if(psp == POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR) {
+        return 1;
+    } else {
+        return -ENOENT;
+    }
+}
+
+/* Function Summary
+ * AYANEO devices can be largely divided into 2 groups; modern and legacy.
+ *   - Legacy devices use a microcontroller either embedded into or controlled via
+ *     the system's ACPI controller.
+ *   - Modern devices use a dedicated microcontroller and communicate via shared
+ *     memory.
+ *
+ * The control scheme is largely shared between both device types and many of
+ * the command values are shared.
+ *
+ * ayaneo_bypass_charge_open / ayaneo_bypass_charge_legacy_open
+ *       Bypasses the charging of the battery and supplies power directly to 
+ *       the hardware.
+ *
+ * ayaneo_bypass_charge_close / ayaneo_bypass_charge_legacy_close
+ *       Renable the charging of the battery.
+ */
+static void ayaneo_bypass_charge_open(void)
+{
+    u8 val;
+    ec_read_ram(AYANEO_BYPASSCHARGE_CONTROL, &val);
+    if(val != AYANEO_BYPASSCHARGE_OPEN) {
+        ec_write_ram(AYANEO_BYPASSCHARGE_CONTROL, AYANEO_BYPASSCHARGE_OPEN);
+    }
+}
+
+static void ayaneo_bypass_charge_close(void)
+{
+    u8 val;
+    ec_read_ram(AYANEO_BYPASSCHARGE_CONTROL, &val);
+    if(val != AYANEO_BYPASSCHARGE_CLOSE) {
+        ec_write_ram(AYANEO_BYPASSCHARGE_CONTROL, AYANEO_BYPASSCHARGE_CLOSE);
+    }
+}
+
+static void ayaneo_bypass_charge_legacy_open(void)
+{
+    u8 val;
+        if (!lock_global_acpi_lock())
+                return;
+
+    if(ec_read(AYANEO_BYPASS_CHARGE_CONTROL, &val) == 0) {
+            if(val != AYANEO_BYPASS_CHARGE_OPEN) {
+                ec_write(AYANEO_BYPASS_CHARGE_CONTROL, AYANEO_BYPASS_CHARGE_OPEN);
+        }
+    }
+
+        if (!unlock_global_acpi_lock())
+                return;
+}
+
+static void ayaneo_bypass_charge_legacy_close(void)
+{
+    u8 val;
+        if (!lock_global_acpi_lock())
+                return;
+
+    if(ec_read(AYANEO_BYPASS_CHARGE_CONTROL, &val) == 0) {
+            if(val != AYANEO_BYPASS_CHARGE_CLOSE) {
+                ec_write(AYANEO_BYPASS_CHARGE_CONTROL, AYANEO_BYPASS_CHARGE_CLOSE);
+            }
+    }
+
+        if (!unlock_global_acpi_lock())
+                return;
+}
+/* Threaded writes:
+ *  The writer thread's job is to enable or disable the bypass charge function
+ *  depending on the POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR.
+ *
+ *  When the writer thread begins its next loop, it checks if it should activate
+ *  the bypass charge if POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE is set. It
+ *  then saves the state of charge behaviour and sleeps for some seconds.
+ *
+ *  During suspend kthread_stop is called which causes the writer thread to
+ *  terminate after its current iteration. The writer thread is restarted during
+ *  resume to allow updates to continue.
+ */
+static struct task_struct *ayaneo_bypass_charge_writer_thread;
+int ayaneo_bypass_charge_writer(void *pv);
+int ayaneo_bypass_charge_writer(void *pv)
+{
+        u8 last_charge_behaviour = 0xff;
+        pr_info("Bypass-Writer thread started.\n");
+
+        while (!kthread_should_stop())
+        {
+            if(last_charge_behaviour != ps_priv.charge_behaviour) {
+                if (POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE == ps_priv.charge_behaviour){
+                    switch (model) {
+                        case air:
+                        case air_1s:
+                        case air_1s_limited:
+                        case air_pro:
+                        case air_plus_mendo:
+                        case geek_1s:
+                        case ayaneo_2s:
+                        case kun:
+                                ayaneo_bypass_charge_legacy_open();
+                                break;
+                        case air_plus:
+                        case slide:
+                                ayaneo_bypass_charge_open();
+                                break;
+                        default:
+                                break;
+                    }
+                } else if(POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO == ps_priv.charge_behaviour) {
+                    switch (model) {
+                        case air:
+                        case air_1s:
+                        case air_1s_limited:
+                        case air_pro:
+                        case air_plus_mendo:
+                        case geek_1s:
+                        case ayaneo_2s:
+                        case kun:
+                                ayaneo_bypass_charge_legacy_close();
+                                break;
+                        case air_plus:
+                        case slide:
+                                ayaneo_bypass_charge_close();
+                                break;
+                        default:
+                                break;
+                    }
+                }
+                last_charge_behaviour = ps_priv.charge_behaviour;
+            }
+            msleep(AYANEO_BYPASS_WRITER_DELAY_MS);
+        }
+
+        pr_info("Bypass-Writer thread stopped.\n");
+        return 0;
+}
+
+static enum power_supply_property ayaneo_psy_ext_props[] = {
+    POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR,
+};
+
+static struct power_supply_ext ayaneo_psy_ext = {
+    .name = "ayaneo-bypass-charge",
+    .charge_behaviours = BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO) | BIT(POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE),
+    .properties = ayaneo_psy_ext_props,
+    .num_properties = ARRAY_SIZE(ayaneo_psy_ext_props),
+    .get_property = ayaneo_psy_ext_get_prop,
+    .set_property = ayaneo_psy_ext_set_prop,
+    .property_is_writeable = ayaneo_psy_ext_is_writeable,
+};
+
+static int ayaneo_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)
+{
+    /* Ayaneo devices only have one battery. */
+    if (strcmp(battery->desc->name, "BAT0") != 0 &&
+        strcmp(battery->desc->name, "BAT1") != 0 &&
+        strcmp(battery->desc->name, "BATC") != 0 &&
+        strcmp(battery->desc->name, "BATT") != 0)
+        return -ENODEV;
+
+    return power_supply_register_extension(battery, &ayaneo_psy_ext, &battery->dev, NULL);
+}
+
+static int ayaneo_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)
+{
+    power_supply_unregister_extension(battery, &ayaneo_psy_ext);
+    return 0;
+}
+
+static struct acpi_battery_hook battery_hook = {
+    .add_battery = ayaneo_battery_add,
+    .remove_battery = ayaneo_battery_remove,
+    .name = "Ayaneo Battery",
+};
+
+/* check the ec version of devices which can handle the bypass charge function */
+static int ayaneo_check_charge_control(void)
+{
+#define VERSION_LENGTH 5
+        int ret;
+        u8 version[VERSION_LENGTH];
+        u8 version_needed[VERSION_LENGTH];
+        u8 version_length = VERSION_LENGTH;
+        int index;
+        for(index = 0; index < VERSION_LENGTH; index++) {
+            ec_read(AYANEO_EC_VERSION_REG + index, &version[index]);
+        }
+        switch (model) {
+            case air:
+            case air_pro:
+                    version_needed[0] = 3;
+                    version_needed[1] = 1;
+                    version_needed[2] = 0;
+                    version_needed[3] = 4;
+                    version_needed[4] = 78;
+                    break;
+            case air_1s:
+            case air_1s_limited:
+                    version_needed[0] = 8;
+                    version_needed[1] = 4;
+                    version_needed[2] = 0;
+                    version_needed[3] = 0;
+                    version_needed[4] = 27;
+                    break;
+            case air_plus_mendo:
+                    version_needed[0] = 7;
+                    version_needed[1] = 0;
+                    version_needed[2] = 0;
+                    version_needed[3] = 0;
+                    version_needed[4] = 13;
+                    break;
+            case ayaneo_2s:
+            case geek_1s:
+                    version_needed[0] = 8;
+                    version_needed[1] = 0;
+                    version_needed[2] = 0;
+                    version_needed[3] = 1;
+                    version_needed[4] = 10;
+                    break;
+            case kun:
+                    version_needed[0] = 8;
+                    version_needed[1] = 3;
+                    version_needed[2] = 0;
+                    version_needed[3] = 0;
+                    version_needed[4] = 63;
+                    break;
+            case air_plus:
+            case slide:
+                    version_needed[0] = 0;
+                    version_needed[1] = 0x1b;
+                    version_needed[2] = 0;
+                    version_needed[3] = 0;
+                    version_needed[4] = 0;
+                    version_length = 2;
+                    break;
+            default:
+                    return -1;
+                    break;
+        }
+        ret = memcmp(version, version_needed, version_length);
+        return ret;
+}
+
+static int ayaneo_platform_resume(struct platform_device *pdev)
+{
+        ayaneo_led_mc_take_control();
+
+        /* Re-apply last color */
+        write_lock(&ayaneo_led_mc_update_lock);
+        ayaneo_led_mc_update_required++;
+        write_unlock(&ayaneo_led_mc_update_lock);
+
+        /* Allow the MCU to sync with the new state */
+        msleep(AYANEO_LED_SUSPEND_RESUME_DELAY_MS);
+
+        ayaneo_led_mc_writer_thread = kthread_run(ayaneo_led_mc_writer,
+                                                  NULL,
+                                                  "ayaneo-platform led writer");
+        if(ps_priv.bypass_available) {
+            ayaneo_bypass_charge_writer_thread = kthread_run(ayaneo_bypass_charge_writer,
+                                                  NULL,
+                                                  "ayaneo-platform bypass charge writer");
+        }
+        return 0;
+}
+
+static int ayaneo_platform_suspend(struct platform_device *pdev, pm_message_t state)
+{
+        kthread_stop(ayaneo_led_mc_writer_thread);
+
+        switch (suspend_mode)
+        {
+        case AYANEO_LED_SUSPEND_MODE_OEM:
+                ayaneo_led_mc_release_control();
+                break;
+
+        case AYANEO_LED_SUSPEND_MODE_KEEP:
+                // Nothing to do.
+                break;
+
+        case AYANEO_LED_SUSPEND_MODE_OFF:
+                ayaneo_led_mc_take_control();
+                break;
+
+        default:
+                break;
+        }
+
+        /* Allow the MCU to sync with the new state */
+        msleep(AYANEO_LED_SUSPEND_RESUME_DELAY_MS);
+
+        if(ps_priv.bypass_available) {
+            kthread_stop(ayaneo_bypass_charge_writer_thread);
+        }
+
+        return 0;
+}
+
+static int ayaneo_platform_probe(struct platform_device *pdev)
+{
+        struct device *dev = &pdev->dev;
+        const struct dmi_system_id *match;
+        int ret;
+
+        match = dmi_first_match(dmi_table);
+        ret = PTR_ERR_OR_ZERO(match);
+        if (ret)
+                return ret;
+
+        model = (enum ayaneo_model)match->driver_data;
+        suspend_mode_register_attr();
+        ayaneo_led_mc_take_control();
+
+        ret = devm_led_classdev_multicolor_register(dev, &ayaneo_led_mc);
+        if (ret)
+                return ret;
+
+        ret = devm_device_add_group(ayaneo_led_mc.led_cdev.dev, &ayaneo_led_mc_group);
+        if (ret)
+                return ret;
+
+        if(ayaneo_check_charge_control() >= 0) {
+            ps_priv.bypass_available = 1;
+        }
+        return ret;
+}
+
+static void ayaneo_platform_shutdown(struct platform_device *pdev)
+{
+        kthread_stop(ayaneo_led_mc_writer_thread);
+        ayaneo_led_mc_release_control();
+        if(ps_priv.bypass_available) {
+            kthread_stop(ayaneo_bypass_charge_writer_thread);
+        }
+}
+
+static void ayaneo_platform_remove(struct platform_device *pdev)
+{
+        kthread_stop(ayaneo_led_mc_writer_thread);
+        ayaneo_led_mc_release_control();
+        if(ps_priv.bypass_available) {
+            kthread_stop(ayaneo_bypass_charge_writer_thread);
+        }
+}
+
+static struct platform_driver ayaneo_platform_driver = {
+        .driver = {
+                .name = "ayaneo-platform",
+        },
+        .probe = ayaneo_platform_probe,
+        .resume = ayaneo_platform_resume,
+        .suspend = ayaneo_platform_suspend,
+        .shutdown = ayaneo_platform_shutdown,
+        .remove = ayaneo_platform_remove,
+};
+
+static struct platform_device *ayaneo_platform_device;
+
+static int __init ayaneo_platform_init(void)
+{
+        int ret;
+        ayaneo_platform_device = platform_create_bundle(&ayaneo_platform_driver,
+                                        ayaneo_platform_probe, NULL, 0, NULL, 0);
+        ret = PTR_ERR_OR_ZERO(ayaneo_platform_device);
+        if (ret)
+                return ret;
+
+        ayaneo_led_mc_writer_thread = kthread_run(ayaneo_led_mc_writer,
+                                                  NULL,
+                                                  "ayaneo-platform led writer");
+
+        if (!ayaneo_led_mc_writer_thread)
+        {
+                pr_err("Failed to start writer thread.\n");
+                platform_device_unregister(ayaneo_platform_device);
+                return -1;
+        }
+
+        if(ps_priv.bypass_available) {
+            battery_hook_register(&battery_hook);
+            ayaneo_bypass_charge_writer_thread = kthread_run(ayaneo_bypass_charge_writer,
+                                                  NULL,
+                                                  "ayaneo-platform bypass charge writer");
+
+            if (!ayaneo_bypass_charge_writer_thread)
+            {
+                    pr_err("Failed to start ps writer thread.\n");
+                    platform_device_unregister(ayaneo_platform_device);
+                    return -1;
+            }
+        }
+
+        return 0;
+}
+
+static void __exit ayaneo_platform_exit(void)
+{
+        kthread_stop(ayaneo_led_mc_writer_thread);
+        if(ps_priv.bypass_available) {
+            kthread_stop(ayaneo_bypass_charge_writer_thread);
+            battery_hook_unregister(&battery_hook);
+        }
+        platform_device_unregister(ayaneo_platform_device);
+        platform_driver_unregister(&ayaneo_platform_driver);
+}
+
+MODULE_DEVICE_TABLE(dmi, dmi_table);
+
+module_init(ayaneo_platform_init);
+module_exit(ayaneo_platform_exit);
+
+MODULE_AUTHOR("Derek John Clark <derekjohn.clark@gmail.com>");
+MODULE_DESCRIPTION("Platform driver that handles EC sensors of AYANEO x86 devices");
+MODULE_LICENSE("GPL");
# ----------------------------------------
# Module: framework
# Version: 6164bc3dec24
# ----------------------------------------
diff --git a/drivers/custom/framework/Makefile b/drivers/custom/framework/Makefile
new file mode 100644
index 000000000000..968eb7877b2e
--- /dev/null
+++ b/drivers/custom/framework/Makefile
@@ -0,0 +1,15 @@
+ifneq ($(KERNELRELEASE),)
+# kbuild part of makefile
+obj-m  := framework_laptop.o
+
+else
+# normal makefile
+KDIR ?= /lib/modules/`uname -r`/build
+
+modules:
+
+%:
+	$(MAKE) -C $(KDIR) M=$$PWD $@
+
+endif
+
diff --git a/drivers/custom/framework/framework_laptop.c b/drivers/custom/framework/framework_laptop.c
new file mode 100644
index 000000000000..b13fa49388ab
--- /dev/null
+++ b/drivers/custom/framework/framework_laptop.c
@@ -0,0 +1,841 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Framework Laptop ACPI Driver
+ *
+ * Copyright (C) 2022 Dustin L. Howett
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/acpi.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/pci_ids.h>
+#include <linux/power_supply.h>
+#include <linux/sysfs.h>
+#include <linux/types.h>
+#include <linux/dmi.h>
+#include <linux/platform_device.h>
+#include <linux/platform_data/cros_ec_proto.h>
+#include <linux/platform_data/cros_ec_commands.h>
+#include <linux/version.h>
+
+#include <acpi/battery.h>
+
+#define DRV_NAME "framework_laptop"
+#define FRAMEWORK_LAPTOP_EC_DEVICE_NAME "cros-ec-dev"
+
+static struct platform_device *fwdevice;
+static struct device *ec_device;
+struct framework_data {
+	struct platform_device *pdev;
+	struct led_classdev kb_led;
+	struct device *hwmon_dev;
+};
+
+#define EC_CMD_CHARGE_LIMIT_CONTROL 0x3E03
+
+enum ec_chg_limit_control_modes {
+	/* Disable all setting, charge control by charge_manage */
+	CHG_LIMIT_DISABLE	= BIT(0),
+	/* Set maximum and minimum percentage */
+	CHG_LIMIT_SET_LIMIT	= BIT(1),
+	/* Host read current setting */
+	CHG_LIMIT_GET_LIMIT	= BIT(3),
+	/* Enable override mode, allow charge to full this time */
+	CHG_LIMIT_OVERRIDE	= BIT(7),
+};
+
+struct ec_params_ec_chg_limit_control {
+	/* See enum ec_chg_limit_control_modes */
+	uint8_t modes;
+	uint8_t max_percentage;
+	uint8_t min_percentage;
+} __ec_align1;
+
+struct ec_response_chg_limit_control {
+	uint8_t max_percentage;
+	uint8_t min_percentage;
+} __ec_align1;
+
+#define EC_CMD_PRIVACY_SWITCHES_CHECK_MODE 0x3E14
+
+struct ec_response_privacy_switches_check {
+	uint8_t microphone;
+	uint8_t camera;
+} __ec_align1;
+
+static int charge_limit_control(enum ec_chg_limit_control_modes modes, uint8_t max_percentage) {
+	struct {
+		struct cros_ec_command msg;
+		union {
+			struct ec_params_ec_chg_limit_control params;
+			struct ec_response_chg_limit_control resp;
+		};
+	} __packed buf;
+	struct ec_params_ec_chg_limit_control *params = &buf.params;
+	struct ec_response_chg_limit_control *resp = &buf.resp;
+	struct cros_ec_command *msg = &buf.msg;
+	struct cros_ec_device *ec;
+	int ret;
+
+	if (!ec_device)
+		return -ENODEV;
+
+	ec = dev_get_drvdata(ec_device);
+
+	memset(&buf, 0, sizeof(buf));
+
+	msg->version = 0;
+	msg->command = EC_CMD_CHARGE_LIMIT_CONTROL;
+	msg->outsize = sizeof(*params);
+	msg->insize = sizeof(*resp);
+
+	params->modes = modes;
+	params->max_percentage = max_percentage;
+
+	ret = cros_ec_cmd_xfer_status(ec, msg);
+	if (ret < 0) {
+		return -EIO;
+	}
+
+	return resp->max_percentage;
+}
+
+// Get the last set keyboard LED brightness
+static enum led_brightness kb_led_get(struct led_classdev *led)
+{
+	struct {
+		struct cros_ec_command msg;
+		union {
+			struct ec_params_pwm_get_duty p;
+			struct ec_response_pwm_get_duty resp;
+		};
+	} __packed buf;
+
+	struct ec_params_pwm_get_duty *p = &buf.p;
+	struct ec_response_pwm_get_duty *resp = &buf.resp;
+	struct cros_ec_command *msg = &buf.msg;
+	struct cros_ec_device *ec;
+	int ret;
+	if (!ec_device)
+		goto out;
+
+	ec = dev_get_drvdata(ec_device);
+
+	memset(&buf, 0, sizeof(buf));
+
+	p->pwm_type = EC_PWM_TYPE_KB_LIGHT;
+	
+	msg->version = 0;
+	msg->command = EC_CMD_PWM_GET_DUTY;
+	msg->insize = sizeof(*resp);
+	msg->outsize = sizeof(*p);
+
+	ret = cros_ec_cmd_xfer_status(ec, msg);
+	if (ret < 0) {
+		goto out;
+	}
+
+	return resp->duty * 100 / EC_PWM_MAX_DUTY;
+
+out:
+	return 0;
+}
+
+// Set the keyboard LED brightness
+static int kb_led_set(struct led_classdev *led, enum led_brightness value)
+{
+	struct {
+		struct cros_ec_command msg;
+		union {
+			struct ec_params_pwm_set_keyboard_backlight params;
+		};
+	} __packed buf;
+
+	struct ec_params_pwm_set_keyboard_backlight *params = &buf.params;
+	struct cros_ec_command *msg = &buf.msg;
+	struct cros_ec_device *ec;
+	int ret;
+
+	if (!ec_device)
+		return -EIO;
+
+	ec = dev_get_drvdata(ec_device);
+
+	memset(&buf, 0, sizeof(buf));
+	
+	msg->version = 0;
+	msg->command = EC_CMD_PWM_SET_KEYBOARD_BACKLIGHT;
+	msg->insize = 0;
+	msg->outsize = sizeof(*params);
+
+	params->percent = value;
+
+	ret = cros_ec_cmd_xfer_status(ec, msg);
+	if (ret < 0) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+static ssize_t battery_get_threshold(char *buf)
+{
+	int ret;
+
+	ret = charge_limit_control(CHG_LIMIT_GET_LIMIT, 0);
+	if (ret < 0)
+		return ret;
+
+	return sysfs_emit(buf, "%d\n", (int)ret);
+}
+
+static ssize_t battery_set_threshold(const char *buf, size_t count)
+{
+	int ret;
+	int value;
+
+	ret = kstrtouint(buf, 10, &value);
+	if (ret)
+		return ret;
+
+	if (value > 100)
+		return -EINVAL;
+
+	ret = charge_limit_control(CHG_LIMIT_SET_LIMIT, (uint8_t)value);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t charge_control_end_threshold_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return battery_get_threshold(buf);
+}
+
+static ssize_t charge_control_end_threshold_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	return battery_set_threshold(buf, count);
+}
+
+static DEVICE_ATTR_RW(charge_control_end_threshold);
+
+static struct attribute *framework_laptop_battery_attrs[] = {
+	&dev_attr_charge_control_end_threshold.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(framework_laptop_battery);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+static int framework_laptop_battery_add(struct power_supply *battery, struct acpi_battery_hook *hook)
+#else
+static int framework_laptop_battery_add(struct power_supply *battery)
+#endif
+{
+	// Framework EC only supports 1 battery
+	if (strcmp(battery->desc->name, "BAT1") != 0)
+		return -ENODEV;
+
+	if (device_add_groups(&battery->dev, framework_laptop_battery_groups))
+		return -ENODEV;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+static int framework_laptop_battery_remove(struct power_supply *battery, struct acpi_battery_hook *hook)
+#else
+static int framework_laptop_battery_remove(struct power_supply *battery)
+#endif
+{
+	device_remove_groups(&battery->dev, framework_laptop_battery_groups);
+	return 0;
+}
+
+// --- fanN_input ---
+// Read the current fan speed from the EC's memory
+static ssize_t ec_get_fan_speed(u8 idx, u16 *val)
+{
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	const u8 offset = EC_MEMMAP_FAN + 2 * idx;
+
+	return ec->cmd_readmem(ec, offset, sizeof(*val), val);
+}
+
+static ssize_t fw_fan_speed_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+
+	u16 val;
+	if (ec_get_fan_speed(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	if (val == EC_FAN_SPEED_NOT_PRESENT || val == EC_FAN_SPEED_STALLED) {
+		return sysfs_emit(buf, "%u\n", 0);
+	}
+
+	// Format as string for sysfs
+	return sysfs_emit(buf, "%u\n", val);
+}
+
+// --- fanN_target ---
+static ssize_t ec_set_target_rpm(u8 idx, u32 *val)
+{
+	int ret;
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	struct ec_params_pwm_set_fan_target_rpm_v1 params = {
+		.rpm = *val,
+		.fan_idx = idx,
+	};
+
+	ret = cros_ec_cmd(ec, 1, EC_CMD_PWM_SET_FAN_TARGET_RPM, &params,
+			  sizeof(params), NULL, 0);
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static ssize_t ec_get_target_rpm(u8 idx, u32 *val)
+{
+	int ret;
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	struct ec_response_pwm_get_fan_rpm resp;
+
+	// index isn't supported, it should only return fan 0's target
+
+	ret = cros_ec_cmd(ec, 0, EC_CMD_PWM_GET_FAN_TARGET_RPM, NULL, 0, &resp,
+			  sizeof(resp));
+	if (ret < 0)
+		return -EIO;
+
+	*val = resp.rpm;
+
+	return 0;
+}
+
+static ssize_t fw_fan_target_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+	u32 val;
+
+	int err;
+	err = kstrtou32(buf, 10, &val);
+	if (err < 0)
+		return err;
+
+	if (ec_set_target_rpm(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	return count;
+}
+
+static ssize_t fw_fan_target_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+
+	// Only fan 0 is supported
+	if (sen_attr->index != 0) {
+		return -EINVAL;
+	}
+
+	u32 val;
+	if (ec_get_target_rpm(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	// Format as string for sysfs
+	return sysfs_emit(buf, "%u\n", val);
+}
+
+// --- fanN_fault ---
+static ssize_t fw_fan_fault_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+
+	u16 val;
+	if (ec_get_fan_speed(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	// Format as string for sysfs
+	return sysfs_emit(buf, "%u\n", val == EC_FAN_SPEED_NOT_PRESENT);
+}
+
+// --- fanN_alarm ---
+static ssize_t fw_fan_alarm_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+
+	u16 val;
+	if (ec_get_fan_speed(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	// Format as string for sysfs
+	return sysfs_emit(buf, "%u\n", val == EC_FAN_SPEED_STALLED);
+}
+
+// --- pwmN_enable ---
+static ssize_t ec_set_auto_fan_ctrl(u8 idx)
+{
+	int ret;
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	struct ec_params_auto_fan_ctrl_v1 params = {
+		.fan_idx = idx,
+	};
+
+	ret = cros_ec_cmd(ec, 1, EC_CMD_THERMAL_AUTO_FAN_CTRL, &params,
+			  sizeof(params), NULL, 0);
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static ssize_t fw_pwm_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+
+	// The EC doesn't take any arguments for this command,
+	// so we don't need to parse the buffer
+	// u32 val;
+
+	// int err;
+	// err = kstrtou32(buf, 10, &val);
+	// if (err < 0)
+	// 	return err;
+
+	if (ec_set_auto_fan_ctrl(sen_attr->index) < 0) {
+		return -EIO;
+	}
+
+	return count;
+}
+
+// --- pwmN ---
+static ssize_t ec_set_fan_duty(u8 idx, u32 *val)
+{
+	int ret;
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	struct ec_params_pwm_set_fan_duty_v1 params = {
+		.percent = *val,
+		.fan_idx = idx,
+	};
+
+	ret = cros_ec_cmd(ec, 1, EC_CMD_PWM_SET_FAN_DUTY, &params,
+			  sizeof(params), NULL, 0);
+	if (ret < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static ssize_t fw_pwm_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sen_attr = to_sensor_dev_attr(attr);
+	u32 val;
+
+	int err;
+	err = kstrtou32(buf, 10, &val);
+	if (err < 0)
+		return err;
+
+	if (ec_set_fan_duty(sen_attr->index, &val) < 0) {
+		return -EIO;
+	}
+
+	return count;
+}
+
+static ssize_t fw_pwm_min_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "%i\n", 0);
+}
+
+static ssize_t fw_pwm_max_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "%i\n", 100);
+}
+
+static ssize_t ec_count_fans(size_t *val)
+{
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	u16 fans[EC_FAN_SPEED_ENTRIES];
+
+	int ret = ec->cmd_readmem(ec, EC_MEMMAP_FAN, sizeof(fans), fans);
+	if (ret < 0)
+		return -EIO;
+
+	for (size_t i = 0; i < EC_FAN_SPEED_ENTRIES; i++) {
+		if (fans[i] == EC_FAN_SPEED_NOT_PRESENT) {
+			*val = i;
+			return 0;
+		}
+	}
+
+	*val = EC_FAN_SPEED_ENTRIES;
+	return 0;
+}
+
+// --- framework_privacy ---
+static ssize_t framework_privacy_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int ret;
+	if (!ec_device)
+		return -ENODEV;
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+
+	struct ec_response_privacy_switches_check resp;
+
+	ret = cros_ec_cmd(ec, 0, EC_CMD_PRIVACY_SWITCHES_CHECK_MODE, NULL, 0,
+			  &resp, sizeof(resp));
+	if (ret < 0)
+		return -EIO;
+
+	// Output following dell-privacy's format
+	return sysfs_emit(buf, "[Microphone] [%s]\n[Camera] [%s]\n",
+			  resp.microphone ? "unmuted" : "muted",
+			  resp.camera ? "unmuted" : "muted");
+}
+
+#define FW_ATTRS_PER_FAN 8
+
+// --- hwmon sysfs attributes ---
+// clang-format off
+static SENSOR_DEVICE_ATTR_RO(fan1_input, fw_fan_speed, 0); // Fan Reading
+static SENSOR_DEVICE_ATTR_RW(fan1_target, fw_fan_target, 0); // Target RPM (RW on fan 0 only)
+static SENSOR_DEVICE_ATTR_RO(fan1_fault, fw_fan_fault, 0); // Fan Not Present
+static SENSOR_DEVICE_ATTR_RO(fan1_alarm, fw_fan_alarm, 0); // Fan Stalled
+static SENSOR_DEVICE_ATTR_WO(pwm1_enable, fw_pwm_enable, 0); // Set Fan Control Mode
+static SENSOR_DEVICE_ATTR_WO(pwm1, fw_pwm, 0); // Set Fan Speed
+static SENSOR_DEVICE_ATTR_RO(pwm1_min, fw_pwm_min, 0); // Min Fan Speed
+static SENSOR_DEVICE_ATTR_RO(pwm1_max, fw_pwm_max, 0); // Max Fan Speed
+// clang-format on
+
+static SENSOR_DEVICE_ATTR_RO(fan2_input, fw_fan_speed, 1);
+static SENSOR_DEVICE_ATTR_WO(fan2_target, fw_fan_target, 1);
+static SENSOR_DEVICE_ATTR_RO(fan2_fault, fw_fan_fault, 1);
+static SENSOR_DEVICE_ATTR_RO(fan2_alarm, fw_fan_alarm, 1);
+static SENSOR_DEVICE_ATTR_WO(pwm2_enable, fw_pwm_enable, 1);
+static SENSOR_DEVICE_ATTR_WO(pwm2, fw_pwm, 1);
+static SENSOR_DEVICE_ATTR_RO(pwm2_min, fw_pwm_min, 1);
+static SENSOR_DEVICE_ATTR_RO(pwm2_max, fw_pwm_max, 1);
+
+static SENSOR_DEVICE_ATTR_RO(fan3_input, fw_fan_speed, 2);
+static SENSOR_DEVICE_ATTR_WO(fan3_target, fw_fan_target, 2);
+static SENSOR_DEVICE_ATTR_RO(fan3_fault, fw_fan_fault, 2);
+static SENSOR_DEVICE_ATTR_RO(fan3_alarm, fw_fan_alarm, 2);
+static SENSOR_DEVICE_ATTR_WO(pwm3_enable, fw_pwm_enable, 2);
+static SENSOR_DEVICE_ATTR_WO(pwm3, fw_pwm, 2);
+static SENSOR_DEVICE_ATTR_RO(pwm3_min, fw_pwm_min, 2);
+static SENSOR_DEVICE_ATTR_RO(pwm3_max, fw_pwm_max, 2);
+
+static SENSOR_DEVICE_ATTR_RO(fan4_input, fw_fan_speed, 3);
+static SENSOR_DEVICE_ATTR_WO(fan4_target, fw_fan_target, 3);
+static SENSOR_DEVICE_ATTR_RO(fan4_fault, fw_fan_fault, 3);
+static SENSOR_DEVICE_ATTR_RO(fan4_alarm, fw_fan_alarm, 3);
+static SENSOR_DEVICE_ATTR_WO(pwm4_enable, fw_pwm_enable, 3);
+static SENSOR_DEVICE_ATTR_WO(pwm4, fw_pwm, 3);
+static SENSOR_DEVICE_ATTR_RO(pwm4_min, fw_pwm_min, 3);
+static SENSOR_DEVICE_ATTR_RO(pwm4_max, fw_pwm_max, 3);
+
+static struct attribute
+	*fw_hwmon_attrs[(EC_FAN_SPEED_ENTRIES * FW_ATTRS_PER_FAN) + 1] = {
+		&sensor_dev_attr_fan1_input.dev_attr.attr,
+		&sensor_dev_attr_fan1_target.dev_attr.attr,
+		&sensor_dev_attr_fan1_fault.dev_attr.attr,
+		&sensor_dev_attr_fan1_alarm.dev_attr.attr,
+		&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+		&sensor_dev_attr_pwm1.dev_attr.attr,
+		&sensor_dev_attr_pwm1_min.dev_attr.attr,
+		&sensor_dev_attr_pwm1_max.dev_attr.attr,
+
+		&sensor_dev_attr_fan2_input.dev_attr.attr,
+		&sensor_dev_attr_fan2_target.dev_attr.attr,
+		&sensor_dev_attr_fan2_fault.dev_attr.attr,
+		&sensor_dev_attr_fan2_alarm.dev_attr.attr,
+		&sensor_dev_attr_pwm2_enable.dev_attr.attr,
+		&sensor_dev_attr_pwm2.dev_attr.attr,
+		&sensor_dev_attr_pwm2_min.dev_attr.attr,
+		&sensor_dev_attr_pwm2_max.dev_attr.attr,
+
+		&sensor_dev_attr_fan3_input.dev_attr.attr,
+		&sensor_dev_attr_fan3_target.dev_attr.attr,
+		&sensor_dev_attr_fan3_fault.dev_attr.attr,
+		&sensor_dev_attr_fan3_alarm.dev_attr.attr,
+		&sensor_dev_attr_pwm3_enable.dev_attr.attr,
+		&sensor_dev_attr_pwm3.dev_attr.attr,
+		&sensor_dev_attr_pwm3_min.dev_attr.attr,
+		&sensor_dev_attr_pwm3_max.dev_attr.attr,
+
+		&sensor_dev_attr_fan4_input.dev_attr.attr,
+		&sensor_dev_attr_fan4_target.dev_attr.attr,
+		&sensor_dev_attr_fan4_fault.dev_attr.attr,
+		&sensor_dev_attr_fan4_alarm.dev_attr.attr,
+		&sensor_dev_attr_pwm4_enable.dev_attr.attr,
+		&sensor_dev_attr_pwm4.dev_attr.attr,
+		&sensor_dev_attr_pwm4_min.dev_attr.attr,
+		&sensor_dev_attr_pwm4_max.dev_attr.attr,
+
+		NULL,
+	};
+
+ATTRIBUTE_GROUPS(fw_hwmon);
+
+// --- generic sysfs attributes ---
+static DEVICE_ATTR_RO(framework_privacy);
+
+static struct attribute *framework_laptop_attrs[] = {
+	&dev_attr_framework_privacy.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(framework_laptop);
+
+// --- platform driver ---
+static struct acpi_battery_hook framework_laptop_battery_hook = {
+	.add_battery = framework_laptop_battery_add,
+	.remove_battery = framework_laptop_battery_remove,
+	.name = "Framework Laptop Battery Extension",
+};
+
+static const struct acpi_device_id device_ids[] = {
+	{"FRMW0001", 0},
+	{"FRMW0004", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, device_ids);
+
+static const struct dmi_system_id framework_laptop_dmi_table[] __initconst = {
+	{
+		/* the Framework Laptop */
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Framework"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Laptop"),
+		},
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(dmi, framework_laptop_dmi_table);
+
+static int device_match_cros_ec(struct device *dev, const void* foo) {
+	const char* name = dev_name(dev);
+	if (strncmp(name, "cros-ec-dev", 11))
+		return 0;
+	return 1;
+}
+
+static int framework_probe(struct platform_device *pdev)
+{
+	struct device *dev;
+	struct framework_data *data;
+	int ret = 0;
+
+	dev = &pdev->dev;
+
+	ec_device = bus_find_device(&platform_bus_type, NULL, NULL, device_match_cros_ec);
+	if (!ec_device) {
+		dev_err(dev, DRV_NAME ": failed to find EC %s.\n", FRAMEWORK_LAPTOP_EC_DEVICE_NAME);
+		return -EINVAL;
+	}
+	ec_device = ec_device->parent;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, data);
+	data->pdev = pdev;
+
+	data->kb_led.name = DRV_NAME "::kbd_backlight";
+	data->kb_led.brightness_get = kb_led_get;
+	data->kb_led.brightness_set_blocking = kb_led_set;
+	data->kb_led.max_brightness = 100;
+	ret = devm_led_classdev_register(&pdev->dev, &data->kb_led);
+	if (ret)
+		return ret;
+
+#if 0
+	/* Register the driver */
+	ret = platform_driver_register(&cros_ec_lpc_driver);
+	if (ret) {
+		pr_err(DRV_NAME ": can't register driver: %d\n", ret);
+		return ret;
+	}
+
+	/* Register the device, and it'll get hooked up automatically */
+	ret = platform_device_register(&cros_ec_lpc_device);
+	if (ret) {
+		pr_err(DRV_NAME ": can't register device: %d\n", ret);
+		platform_driver_unregister(&cros_ec_lpc_driver);
+	}
+#endif
+
+	struct cros_ec_device *ec = dev_get_drvdata(ec_device);
+	if (ec->cmd_readmem) {
+		// Count the number of fans
+		size_t fan_count;
+		if (ec_count_fans(&fan_count) < 0) {
+			dev_err(dev, DRV_NAME ": failed to count fans.\n");
+			return -EINVAL;
+		}
+		// NULL terminates the list after the last detected fan
+		fw_hwmon_attrs[fan_count * FW_ATTRS_PER_FAN] = NULL;
+
+		data->hwmon_dev = hwmon_device_register_with_groups(
+			dev, DRV_NAME, NULL, fw_hwmon_groups);
+		if (IS_ERR(data->hwmon_dev))
+			return PTR_ERR(data->hwmon_dev);
+
+	} else {
+		dev_err(dev, DRV_NAME ": fan readings could not be enabled for this EC %s.\n",
+		FRAMEWORK_LAPTOP_EC_DEVICE_NAME);
+	}
+
+	battery_hook_register(&framework_laptop_battery_hook);
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
+static void framework_remove(struct platform_device *pdev)
+#else
+static int framework_remove(struct platform_device *pdev)
+#endif
+{
+	struct framework_data *data;
+
+	data = (struct framework_data *)platform_get_drvdata(pdev);
+
+	battery_hook_unregister(&framework_laptop_battery_hook);
+
+	// Make sure it's not null before we try to unregister it
+	if (data && data->hwmon_dev)
+		hwmon_device_unregister(data->hwmon_dev);
+
+	put_device(ec_device);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
+	return;
+#else
+	return 0;
+#endif
+}
+
+static struct platform_driver framework_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.acpi_match_table = device_ids,
+		.dev_groups = framework_laptop_groups,
+	},
+	.probe = framework_probe,
+	.remove = framework_remove,
+};
+
+static int __init framework_laptop_init(void)
+{
+	int ret;
+
+	if (!dmi_check_system(framework_laptop_dmi_table)) {
+		pr_err(DRV_NAME ": unsupported system.\n");
+		return -ENODEV;
+	}
+
+	ret = platform_driver_register(&framework_driver);
+	if (ret)
+		goto fail;
+
+	fwdevice = platform_device_alloc(DRV_NAME, PLATFORM_DEVID_NONE);
+	if (!fwdevice)
+	{
+		ret = -ENOMEM;
+		goto fail_platform_driver;
+	}
+
+	ret = platform_device_add(fwdevice);
+	if (ret)
+		goto fail_device_add;
+
+	return 0;
+
+fail_device_add:
+	platform_device_del(fwdevice);
+	fwdevice = NULL;
+
+fail_platform_driver:
+	platform_driver_unregister(&framework_driver);
+
+fail:
+	return ret;
+}
+
+static void __exit framework_laptop_exit(void)
+{
+	if (fwdevice)
+	{
+		platform_device_unregister(fwdevice);
+		platform_driver_unregister(&framework_driver);
+	}
+}
+
+module_init(framework_laptop_init);
+module_exit(framework_laptop_exit);
+
+MODULE_DESCRIPTION("Framework Laptop Platform Driver");
+MODULE_AUTHOR("Dustin L. Howett <dustin@howett.net>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_SOFTDEP("pre: cros_ec_lpcs");
# ----------------------------------------
# Module: bmi260
# Version: v1.1.0
# ----------------------------------------
diff --git a/drivers/custom/bmi260/Makefile b/drivers/custom/bmi260/Makefile
new file mode 100644
index 000000000000..9ffaba87b5fe
--- /dev/null
+++ b/drivers/custom/bmi260/Makefile
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Makefile for Bosch BMI260 IMU
+#
+obj-m += bmi260_core.o
+obj-m += bmi260_i2c.o
+# TODO: bmi260_spi
+
+KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build
+
+all default: modules
+install: modules_install
+
+modules modules_install help clean:
+	$(MAKE) -C $(KERNEL_SRC) M=$(shell pwd) $@
diff --git a/drivers/custom/bmi260/bmi260.h b/drivers/custom/bmi260/bmi260.h
new file mode 100644
index 000000000000..54bf47185d3f
--- /dev/null
+++ b/drivers/custom/bmi260/bmi260.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+#ifndef BMI260_H_
+#define BMI260_H_
+
+#include <linux/version.h>
+#include <linux/iio/iio.h>
+#include <linux/regulator/consumer.h>
+
+enum bmi260_int_pin {
+	BMI260_PIN_INT1,
+	BMI260_PIN_INT2
+};
+
+struct bmi260_config {
+	int accel_scale;
+	int accel_odr;
+	int accel_uodr;
+	int gyro_scale;
+	int gyro_odr;
+	int gyro_uodr;
+	bool irq;
+	bool suspended;
+};
+
+struct bmi260_data {
+	struct regmap *regmap;
+	struct iio_trigger *trig;
+	struct regulator_bulk_data supplies[2];
+	struct iio_mount_matrix orientation;
+	enum bmi260_int_pin int_pin;
+	bool use_spi;
+	struct bmi260_config conf;
+
+	/*
+	 * Ensure natural alignment for timestamp if present.
+	 * Max length needed: 2 * 3 channels + 4 bytes padding + 8 byte ts.
+	 * If fewer channels are enabled, less space may be needed, as
+	 * long as the timestamp is still aligned to 8 bytes.
+	 */
+	__le16 buf[12] __aligned(8);
+};
+
+extern const struct regmap_config bmi260_regmap_config;
+
+int bmi260_core_probe(struct device *dev, struct regmap *regmap,
+		      int irq, const char *name, bool use_spi);
+
+int bmi260_enable_irq(struct regmap *regmap, enum bmi260_int_pin pin, bool enable);
+
+int bmi260_probe_trigger(struct iio_dev *indio_dev, int irq, u32 irq_type);
+
+extern const struct dev_pm_ops bmi260_pm_ops;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 13, 0)
+#define BMI260_EXPORT_SYMBOL(symbol)	EXPORT_SYMBOL_NS_GPL(symbol, "IIO_BMI260");
+#define BMI260_IMPORT_NS		MODULE_IMPORT_NS("IIO_BMI260");
+#else
+#define BMI260_EXPORT_SYMBOL(symbol)	EXPORT_SYMBOL_NS_GPL(symbol, IIO_BMI260);
+#define BMI260_IMPORT_NS		MODULE_IMPORT_NS(IIO_BMI260);
+#endif
+
+#endif  /* BMI260_H_ */
diff --git a/drivers/custom/bmi260/bmi260_config.h b/drivers/custom/bmi260/bmi260_config.h
new file mode 100644
index 000000000000..c5ce53fedd56
--- /dev/null
+++ b/drivers/custom/bmi260/bmi260_config.h
@@ -0,0 +1,718 @@
+/*
+ * Copyright (c) 2020 Bosch Sensortec GmbH. All rights reserved.
+ *
+ * BSD-3-Clause
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+const unsigned char bmi260_config_file[] = {
+	0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0x63, 0xb3, 0xc8, 0x2e, 0x00, 0x2e,
+	0x80, 0x2e, 0x15, 0x03, 0x80, 0x2e, 0xbb, 0xb4, 0x80, 0x2e, 0x91, 0x03,
+	0xc8, 0x2e, 0x00, 0x2e, 0x80, 0x2e, 0xe7, 0xb3, 0x50, 0x30, 0x21, 0x2e,
+	0x59, 0xf5, 0x10, 0x30, 0x21, 0x2e, 0x4a, 0xf1, 0x21, 0x2e, 0x6a, 0xf5,
+	0x80, 0x2e, 0xe0, 0x01, 0x0d, 0x0d, 0x01, 0x00, 0x22, 0x00, 0x76, 0x00,
+	0x00, 0x10, 0x00, 0x10, 0xc8, 0x00, 0x01, 0x1c, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0xfd, 0x2d, 0xe4, 0x78,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x0d, 0x00, 0x00,
+	0x88, 0x00, 0x05, 0xe0, 0xaa, 0x38, 0x05, 0xe0, 0x90, 0x30, 0x86, 0x00,
+	0x30, 0x0a, 0x80, 0x40, 0x10, 0x27, 0xe8, 0x73, 0x04, 0x30, 0x00, 0x02,
+	0x00, 0x01, 0x00, 0x30, 0x10, 0x0b, 0x09, 0x08, 0xfa, 0x00, 0x96, 0x00,
+	0x4b, 0x09, 0x11, 0x00, 0x11, 0x00, 0x02, 0x00, 0x00, 0x00, 0x22, 0x07,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x01,
+	0xe6, 0x78, 0x84, 0x00, 0x9c, 0x6c, 0x07, 0x00, 0x64, 0x75, 0xaa, 0x7e,
+	0x5f, 0x05, 0xbe, 0x0a, 0x5f, 0x05, 0x96, 0xe8, 0xef, 0x41, 0x01, 0x00,
+	0x0c, 0x00, 0x0c, 0x00, 0x4a, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x0c, 0x00,
+	0xf0, 0x3c, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
+	0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xa1, 0x01, 0x8f, 0x01,
+	0x9d, 0x01, 0x8b, 0x01, 0x00, 0x0c, 0xff, 0x0f, 0x00, 0x04, 0xc0, 0x00,
+	0x5b, 0xf5, 0x74, 0x01, 0x1e, 0xf2, 0xfd, 0xf5, 0xfc, 0xf5, 0x6f, 0x01,
+	0x77, 0x01, 0x80, 0x00, 0xa0, 0x00, 0x5f, 0xff, 0x00, 0x08, 0x00, 0xf8,
+	0x7a, 0x01, 0x85, 0x01, 0x7f, 0x01, 0x84, 0x01, 0x4c, 0x04, 0xe8, 0x03,
+	0xff, 0x7f, 0xb8, 0x7e, 0xe1, 0x7a, 0x81, 0x01, 0x7c, 0x01, 0x7e, 0x01,
+	0xc8, 0x00, 0xcb, 0x00, 0xcb, 0x00, 0xd2, 0x00, 0x88, 0x01, 0x69, 0xf5,
+	0xe0, 0x00, 0x3f, 0xff, 0x19, 0xf4, 0x58, 0xf5, 0x66, 0xf5, 0x64, 0xf5,
+	0xc0, 0xf1, 0xba, 0xf1, 0xa0, 0x00, 0xa6, 0x01, 0xf7, 0x00, 0xf9, 0x00,
+	0xb7, 0x01, 0xff, 0x3f, 0xff, 0xfb, 0x00, 0x38, 0x00, 0x30, 0xb8, 0x01,
+	0xbf, 0x01, 0xc1, 0x01, 0xc7, 0x01, 0xcf, 0x01, 0xff, 0x01, 0x95, 0x01,
+	0x74, 0xf7, 0x00, 0x40, 0xff, 0x00, 0x00, 0x80, 0x7c, 0x0f, 0xeb, 0x00,
+	0x7f, 0xff, 0xc2, 0xf5, 0x68, 0xf7, 0xb3, 0xf1, 0x76, 0x0f, 0x6a, 0x0f,
+	0x70, 0x0f, 0x8f, 0x0f, 0x58, 0xf7, 0x5b, 0xf7, 0x92, 0x0f, 0x86, 0x00,
+	0x81, 0x0f, 0x94, 0x0f, 0xc6, 0xf1, 0x8e, 0x0f, 0x6c, 0xf7, 0x00, 0xe0,
+	0x00, 0xff, 0xd1, 0xf5, 0x96, 0x0f, 0x99, 0x0f, 0xff, 0x03, 0x00, 0xfc,
+	0xf0, 0x3f, 0x8b, 0x00, 0x90, 0x00, 0x8f, 0x00, 0x95, 0x00, 0x92, 0x00,
+	0x98, 0x00, 0x8d, 0x00, 0xa2, 0x00, 0xb9, 0x00, 0x2d, 0xf5, 0xca, 0xf5,
+	0x75, 0x01, 0x20, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x1a, 0x24, 0x22, 0x00, 0x80, 0x2e, 0x00, 0xb0, 0x17, 0x52, 0x00, 0x2e,
+	0x60, 0x40, 0x41, 0x40, 0x0d, 0xbc, 0x98, 0xbc, 0xc0, 0x2e, 0x01, 0x0a,
+	0x0f, 0xb8, 0x19, 0x52, 0x53, 0x3c, 0x52, 0x40, 0x40, 0x40, 0x4b, 0x00,
+	0x82, 0x16, 0x26, 0xb9, 0x01, 0xb8, 0x41, 0x40, 0x10, 0x08, 0x97, 0xb8,
+	0x01, 0x08, 0xc0, 0x2e, 0x11, 0x30, 0x01, 0x08, 0x43, 0x86, 0x25, 0x40,
+	0x04, 0x40, 0xd8, 0xbe, 0x2c, 0x0b, 0x22, 0x11, 0x54, 0x42, 0x03, 0x80,
+	0x4b, 0x0e, 0xf6, 0x2f, 0xb8, 0x2e, 0x1b, 0x50, 0x10, 0x50, 0x1d, 0x52,
+	0x05, 0x2e, 0xd5, 0x00, 0xfb, 0x7f, 0x00, 0x2e, 0x13, 0x40, 0x93, 0x42,
+	0x41, 0x0e, 0xfb, 0x2f, 0x98, 0x2e, 0x0b, 0x03, 0x98, 0x2e, 0x87, 0xcf,
+	0x01, 0x2e, 0x6e, 0x01, 0x00, 0xb2, 0xfb, 0x6f, 0x0b, 0x2f, 0x01, 0x2e,
+	0x69, 0xf7, 0xb1, 0x3f, 0x01, 0x08, 0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e,
+	0x6e, 0x01, 0x21, 0x2e, 0x69, 0xf7, 0x80, 0x2e, 0x29, 0x02, 0xf0, 0x5f,
+	0xb8, 0x2e, 0x01, 0x2e, 0xc0, 0xf8, 0x03, 0x2e, 0xfc, 0xf5, 0x1f, 0x54,
+	0x21, 0x56, 0x82, 0x08, 0x0b, 0x2e, 0x69, 0xf7, 0xcb, 0x0a, 0x23, 0x58,
+	0x80, 0x90, 0xdd, 0xbe, 0x4c, 0x08, 0x5f, 0xb9, 0x59, 0x22, 0x80, 0x90,
+	0x07, 0x2f, 0x03, 0x34, 0xc3, 0x08, 0xf2, 0x3a, 0x0a, 0x08, 0x02, 0x35,
+	0xc0, 0x90, 0x4a, 0x0a, 0x48, 0x22, 0xc0, 0x2e, 0x23, 0x2e, 0xfc, 0xf5,
+	0x03, 0x2e, 0x77, 0x01, 0x43, 0x40, 0xbf, 0xbc, 0x37, 0xbc, 0x30, 0x50,
+	0x40, 0xb2, 0x0c, 0xb8, 0xe0, 0x7f, 0xfb, 0x7f, 0x01, 0x30, 0x23, 0x2f,
+	0x01, 0x2e, 0x7c, 0x00, 0x00, 0xb2, 0x04, 0x2f, 0x04, 0x30, 0x98, 0x2e,
+	0x7f, 0x02, 0x29, 0x2e, 0x7c, 0x00, 0x3b, 0xbc, 0xbc, 0xbc, 0x0f, 0xb8,
+	0x9d, 0xb8, 0x23, 0x2e, 0x78, 0x01, 0xd0, 0x7f, 0x98, 0x2e, 0x77, 0xb1,
+	0x10, 0x25, 0xd0, 0x6f, 0x00, 0x90, 0x06, 0x2f, 0xfb, 0x6f, 0xe0, 0x6f,
+	0x22, 0x30, 0xd0, 0x5f, 0x4a, 0x08, 0x80, 0x2e, 0x95, 0xcf, 0xfb, 0x6f,
+	0xe0, 0x6f, 0x12, 0x30, 0xd0, 0x5f, 0x4a, 0x08, 0x80, 0x2e, 0x95, 0xcf,
+	0xe0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x11, 0x30, 0x23, 0x2e, 0x7c, 0x00,
+	0xfb, 0x6f, 0xd0, 0x5f, 0xb8, 0x2e, 0x29, 0x50, 0x25, 0x52, 0x11, 0x42,
+	0x00, 0x2e, 0x27, 0x52, 0x01, 0x42, 0x01, 0x30, 0x2b, 0x54, 0x11, 0x42,
+	0x42, 0x0e, 0xfc, 0x2f, 0xb8, 0x2e, 0x2d, 0x54, 0x00, 0x2e, 0x83, 0x40,
+	0xbd, 0x84, 0x18, 0x1a, 0x80, 0x40, 0x13, 0x2f, 0xc0, 0x90, 0x22, 0x2f,
+	0x03, 0x35, 0x03, 0x0f, 0x0a, 0x2f, 0x09, 0x2e, 0x7e, 0x01, 0x00, 0xb3,
+	0x01, 0x2f, 0x04, 0xa8, 0x04, 0x2f, 0x00, 0x30, 0x80, 0x42, 0x21, 0x2e,
+	0x7f, 0x01, 0xb8, 0x2e, 0x83, 0x42, 0xc0, 0x2e, 0x23, 0x2e, 0x7f, 0x01,
+	0x02, 0x35, 0x82, 0x0e, 0x0d, 0x2f, 0x03, 0x3b, 0x03, 0x00, 0x0c, 0xa8,
+	0x09, 0x2f, 0x2f, 0x58, 0x3b, 0x81, 0x3d, 0x86, 0x04, 0x41, 0xc2, 0x42,
+	0xc8, 0x84, 0x01, 0x87, 0x01, 0x42, 0x83, 0x42, 0xb8, 0x2e, 0xb8, 0x2e,
+	0x01, 0x2e, 0x86, 0x01, 0x01, 0x86, 0x13, 0x25, 0xd2, 0x40, 0x50, 0x50,
+	0xc3, 0x40, 0x23, 0xbd, 0x2f, 0xb9, 0xbc, 0xb9, 0xfb, 0x7f, 0x80, 0xb2,
+	0xe3, 0x7f, 0x0b, 0x30, 0x39, 0x2f, 0x05, 0x2e, 0x7e, 0x00, 0x80, 0x90,
+	0x04, 0x2f, 0x81, 0x84, 0x25, 0x2e, 0x7e, 0x00, 0x37, 0x2e, 0x7f, 0x00,
+	0x41, 0x40, 0x02, 0x40, 0x02, 0x80, 0x94, 0xbc, 0x94, 0xb9, 0x00, 0x40,
+	0x04, 0xbc, 0x21, 0xbd, 0x04, 0xb8, 0x21, 0xb9, 0x07, 0x52, 0xd3, 0x7f,
+	0xc2, 0x7f, 0xb0, 0x7f, 0x98, 0x2e, 0xb3, 0xc0, 0xd1, 0x6f, 0xc2, 0x6f,
+	0x51, 0x28, 0x41, 0x0f, 0x11, 0x30, 0x0d, 0x2f, 0xc2, 0x0e, 0x07, 0x2e,
+	0x7f, 0x00, 0x19, 0x28, 0x04, 0x2f, 0xc0, 0xa6, 0x04, 0x2f, 0x21, 0x2e,
+	0x7f, 0x00, 0x02, 0x2d, 0x21, 0x2e, 0x7f, 0x00, 0x04, 0x2c, 0x02, 0x30,
+	0x02, 0x30, 0x25, 0x2e, 0x7f, 0x00, 0xb0, 0x6f, 0x07, 0x2e, 0x7f, 0x00,
+	0x58, 0x0f, 0xfb, 0x6f, 0xe0, 0x6f, 0xb0, 0x5f, 0x4a, 0x22, 0x80, 0x2e,
+	0x95, 0xcf, 0xe0, 0x6f, 0x01, 0x30, 0x98, 0x2e, 0x95, 0xcf, 0x00, 0x30,
+	0x21, 0x2e, 0x7e, 0x00, 0xfb, 0x6f, 0xb0, 0x5f, 0xb8, 0x2e, 0x03, 0x2e,
+	0xd5, 0x00, 0x16, 0xb8, 0x02, 0x34, 0x4a, 0x0c, 0x21, 0x2e, 0x2d, 0xf5,
+	0xc0, 0x2e, 0x23, 0x2e, 0xd5, 0x00, 0x20, 0x50, 0xf6, 0x7f, 0xe7, 0x7f,
+	0x00, 0x2e, 0x4b, 0x5c, 0x00, 0x2e, 0x87, 0x41, 0xff, 0xbf, 0xff, 0xbb,
+	0xc0, 0x91, 0x02, 0x2f, 0x37, 0x30, 0x2f, 0x2e, 0x69, 0xf5, 0xb8, 0x8f,
+	0x06, 0x32, 0xc7, 0x41, 0xfe, 0x09, 0xc0, 0xb3, 0x04, 0x2f, 0x17, 0x30,
+	0x2f, 0x2e, 0x9c, 0x01, 0x2d, 0x2e, 0x61, 0xf5, 0xf6, 0x6f, 0xe7, 0x6f,
+	0xe0, 0x5f, 0xc8, 0x2e, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e, 0x56, 0xc7,
+	0x98, 0x2e, 0x49, 0xc3, 0x00, 0x30, 0xfb, 0x6f, 0xf0, 0x5f, 0x21, 0x2e,
+	0x7e, 0x00, 0x21, 0x2e, 0xce, 0x00, 0xb8, 0x2e, 0x21, 0x2e, 0x59, 0xf5,
+	0x10, 0x30, 0xc0, 0x2e, 0x21, 0x2e, 0x4a, 0xf1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x9a, 0x01, 0x34, 0x03, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x30, 0x50, 0xe5, 0x7f, 0xf6, 0x7f, 0xd7, 0x7f, 0x00, 0x2e,
+	0x4b, 0x5a, 0x00, 0x2e, 0x46, 0x41, 0x6f, 0xbf, 0x6f, 0xbb, 0x80, 0x91,
+	0x02, 0x2f, 0x36, 0x30, 0x2d, 0x2e, 0x69, 0xf5, 0x46, 0x30, 0x0f, 0x2e,
+	0xa4, 0xf1, 0xbe, 0x09, 0x77, 0x8b, 0x80, 0xb3, 0x06, 0x2f, 0x0d, 0x2e,
+	0xff, 0x00, 0x84, 0xaf, 0x02, 0x2f, 0x16, 0x30, 0x2d, 0x2e, 0xdc, 0x00,
+	0x86, 0x30, 0x46, 0x43, 0x00, 0x2e, 0xf6, 0x6f, 0xe5, 0x6f, 0xd7, 0x6f,
+	0xd0, 0x5f, 0xc8, 0x2e, 0x03, 0x2e, 0x9f, 0x00, 0x1b, 0xbc, 0x60, 0x50,
+	0x9f, 0xbc, 0x0c, 0xb8, 0xf0, 0x7f, 0x40, 0xb2, 0xeb, 0x7f, 0x2b, 0x2f,
+	0x03, 0x2e, 0xfc, 0x00, 0x41, 0x40, 0x01, 0x2e, 0xfd, 0x00, 0x01, 0x1a,
+	0x11, 0x2f, 0x71, 0x58, 0x23, 0x2e, 0xfd, 0x00, 0x10, 0x41, 0xa0, 0x7f,
+	0x38, 0x81, 0x01, 0x41, 0xd0, 0x7f, 0xb1, 0x7f, 0x98, 0x2e, 0x64, 0xcf,
+	0xd0, 0x6f, 0x07, 0x80, 0xa1, 0x6f, 0x11, 0x42, 0x00, 0x2e, 0xb1, 0x6f,
+	0x01, 0x42, 0x11, 0x30, 0x01, 0x2e, 0xb7, 0x01, 0x00, 0xa8, 0x03, 0x30,
+	0xcb, 0x22, 0x4a, 0x25, 0x01, 0x2e, 0xfc, 0x00, 0x3c, 0x89, 0x6f, 0x52,
+	0x07, 0x54, 0x98, 0x2e, 0xc4, 0xce, 0xc1, 0x6f, 0xf0, 0x6f, 0x98, 0x2e,
+	0x95, 0xcf, 0x04, 0x2d, 0x01, 0x30, 0xf0, 0x6f, 0x98, 0x2e, 0x95, 0xcf,
+	0xeb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e, 0x11, 0x30, 0x81, 0x08, 0x01, 0x2e,
+	0x6a, 0xf7, 0x71, 0x3f, 0x23, 0xbd, 0x01, 0x08, 0x02, 0x0a, 0xc0, 0x2e,
+	0x21, 0x2e, 0x6a, 0xf7, 0x80, 0x2e, 0x00, 0xc1, 0x30, 0x50, 0x98, 0x2e,
+	0xd7, 0x0e, 0x50, 0x32, 0x98, 0x2e, 0x40, 0x03, 0x00, 0x30, 0xf0, 0x7f,
+	0x21, 0x2e, 0x69, 0xf5, 0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x00, 0x2e,
+	0x01, 0x80, 0x08, 0xa2, 0xfb, 0x2f, 0x03, 0x2e, 0x8f, 0x00, 0x01, 0x2e,
+	0x93, 0x00, 0x9f, 0xbc, 0x9f, 0xb8, 0x0f, 0xb8, 0x08, 0x0a, 0x21, 0x2e,
+	0x79, 0x00, 0x98, 0x2e, 0xab, 0xb6, 0x03, 0x2e, 0xa4, 0x01, 0x21, 0x2e,
+	0x7a, 0x00, 0x40, 0xb2, 0x10, 0x2f, 0x01, 0x2e, 0x79, 0x00, 0x00, 0xb2,
+	0x0c, 0x2f, 0x05, 0x2e, 0x8a, 0x00, 0x01, 0x52, 0x98, 0x2e, 0xc7, 0xc1,
+	0xf0, 0x7f, 0x98, 0x2e, 0x46, 0x02, 0x98, 0x2e, 0x34, 0xb2, 0x10, 0x30,
+	0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0xa0, 0x01, 0x00, 0xb2, 0x07, 0x2f,
+	0x01, 0x2e, 0x7a, 0x00, 0x00, 0xb2, 0x03, 0x2f, 0x03, 0x50, 0x05, 0x52,
+	0x98, 0x2e, 0x07, 0xcc, 0x01, 0x2e, 0x8e, 0x01, 0x00, 0xb2, 0x2c, 0x2f,
+	0x05, 0x2e, 0x8a, 0x00, 0x07, 0x52, 0x98, 0x2e, 0xc7, 0xc1, 0x03, 0x2e,
+	0x9a, 0x01, 0x40, 0xb2, 0xf0, 0x7f, 0x08, 0x2f, 0x01, 0x2e, 0x7a, 0x00,
+	0x00, 0xb2, 0x04, 0x2f, 0x00, 0x30, 0x21, 0x2e, 0x9a, 0x01, 0x98, 0x2e,
+	0x48, 0xb6, 0x01, 0x2e, 0x78, 0x00, 0x00, 0xb2, 0x15, 0x2f, 0x98, 0x2e,
+	0x81, 0xb5, 0x98, 0x2e, 0xb6, 0x03, 0x07, 0x50, 0x98, 0x2e, 0x4d, 0xc3,
+	0x07, 0x50, 0x98, 0x2e, 0x5a, 0xc7, 0x98, 0x2e, 0xb8, 0x02, 0x07, 0x52,
+	0x98, 0x2e, 0xff, 0xc5, 0x21, 0x2e, 0x72, 0x01, 0x98, 0x2e, 0xe6, 0xb2,
+	0x10, 0x30, 0x21, 0x2e, 0x7b, 0x00, 0x01, 0x2e, 0x9c, 0x01, 0x00, 0xb2,
+	0x04, 0x2f, 0x98, 0x2e, 0x29, 0x02, 0x00, 0x30, 0x21, 0x2e, 0x9c, 0x01,
+	0x01, 0x2e, 0xff, 0x00, 0x04, 0xae, 0x0b, 0x2f, 0x01, 0x2e, 0x8e, 0x01,
+	0x00, 0xb2, 0x07, 0x2f, 0x07, 0x52, 0x98, 0x2e, 0x8e, 0x0e, 0x00, 0xb2,
+	0x02, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0xd7, 0x00, 0x01, 0x2e, 0xd7, 0x00,
+	0x00, 0x90, 0x90, 0x2e, 0x2b, 0xb1, 0x01, 0x2e, 0x6c, 0x01, 0x00, 0xb2,
+	0x04, 0x2f, 0x98, 0x2e, 0x2f, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0xdc, 0x00,
+	0x01, 0x2e, 0xdc, 0x00, 0x00, 0xb2, 0x12, 0x2f, 0x01, 0x2e, 0xff, 0x00,
+	0x00, 0x90, 0x02, 0x2f, 0x98, 0x2e, 0x1f, 0x0e, 0x09, 0x2d, 0x98, 0x2e,
+	0x81, 0x0d, 0x01, 0x2e, 0xff, 0x00, 0x04, 0x90, 0x02, 0x2f, 0x50, 0x32,
+	0x98, 0x2e, 0x40, 0x03, 0x00, 0x30, 0x21, 0x2e, 0xdc, 0x00, 0x01, 0x2e,
+	0xd6, 0x00, 0x00, 0xb2, 0x90, 0x2e, 0x43, 0xb1, 0x01, 0x2e, 0xd6, 0x00,
+	0x01, 0x31, 0x01, 0x08, 0x00, 0xb2, 0x04, 0x2f, 0x98, 0x2e, 0x47, 0xcb,
+	0x10, 0x30, 0x21, 0x2e, 0x7b, 0x00, 0x81, 0x30, 0x01, 0x2e, 0xd6, 0x00,
+	0x01, 0x08, 0x00, 0xb2, 0x61, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e,
+	0xff, 0x00, 0x98, 0xbc, 0x98, 0xb8, 0x05, 0xb2, 0x11, 0x58, 0x23, 0x2f,
+	0x07, 0x90, 0x0b, 0x54, 0x00, 0x30, 0x37, 0x2f, 0x15, 0x41, 0x04, 0x41,
+	0xdc, 0xbe, 0x44, 0xbe, 0xdc, 0xba, 0x2c, 0x01, 0x61, 0x00, 0x11, 0x56,
+	0x4a, 0x0f, 0x0c, 0x2f, 0xd1, 0x42, 0x94, 0xb8, 0xc1, 0x42, 0x11, 0x30,
+	0x05, 0x2e, 0x6a, 0xf7, 0x2c, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x08, 0x22,
+	0x98, 0x2e, 0xf3, 0x03, 0x21, 0x2d, 0x61, 0x30, 0x23, 0x2e, 0xff, 0x00,
+	0x98, 0x2e, 0xf3, 0x03, 0x00, 0x30, 0x21, 0x2e, 0x5a, 0xf5, 0x18, 0x2d,
+	0xe1, 0x7f, 0x50, 0x30, 0x98, 0x2e, 0x40, 0x03, 0x11, 0x52, 0x09, 0x50,
+	0x50, 0x42, 0x70, 0x30, 0x0f, 0x54, 0x42, 0x42, 0x7e, 0x82, 0xe2, 0x6f,
+	0x80, 0xb2, 0x42, 0x42, 0x05, 0x2f, 0x21, 0x2e, 0xff, 0x00, 0x10, 0x30,
+	0x98, 0x2e, 0xf3, 0x03, 0x03, 0x2d, 0x60, 0x30, 0x21, 0x2e, 0xff, 0x00,
+	0x01, 0x2e, 0xff, 0x00, 0x06, 0x90, 0x18, 0x2f, 0x01, 0x2e, 0x77, 0x00,
+	0x0d, 0x54, 0x09, 0x52, 0xe0, 0x7f, 0x98, 0x2e, 0x7a, 0xc1, 0xe1, 0x6f,
+	0x08, 0x1a, 0x40, 0x30, 0x08, 0x2f, 0x21, 0x2e, 0xff, 0x00, 0x20, 0x30,
+	0x98, 0x2e, 0xe4, 0xb6, 0x50, 0x32, 0x98, 0x2e, 0x40, 0x03, 0x05, 0x2d,
+	0x98, 0x2e, 0x38, 0x0e, 0x00, 0x30, 0x21, 0x2e, 0xff, 0x00, 0x00, 0x30,
+	0x21, 0x2e, 0xd6, 0x00, 0x18, 0x2d, 0x01, 0x2e, 0xff, 0x00, 0x03, 0xaa,
+	0x01, 0x2f, 0x98, 0x2e, 0x45, 0x0e, 0x01, 0x2e, 0xff, 0x00, 0x3f, 0x80,
+	0x03, 0xa2, 0x01, 0x2f, 0x00, 0x2e, 0x02, 0x2d, 0x98, 0x2e, 0x5b, 0x0e,
+	0x30, 0x30, 0x98, 0x2e, 0xf8, 0xb6, 0x00, 0x30, 0x21, 0x2e, 0xd7, 0x00,
+	0x50, 0x32, 0x98, 0x2e, 0x40, 0x03, 0x01, 0x2e, 0x7b, 0x00, 0x00, 0xb2,
+	0x24, 0x2f, 0x98, 0x2e, 0xf5, 0xcb, 0x03, 0x2e, 0x6a, 0x01, 0x13, 0x54,
+	0x01, 0x0a, 0xbb, 0x84, 0x83, 0x86, 0x21, 0x2e, 0x74, 0x01, 0xe0, 0x40,
+	0x15, 0x52, 0xc4, 0x40, 0x82, 0x40, 0xa8, 0xb9, 0x52, 0x42, 0x43, 0xbe,
+	0x53, 0x42, 0x04, 0x0a, 0x50, 0x42, 0xe1, 0x7f, 0xf0, 0x31, 0x41, 0x40,
+	0xf2, 0x6f, 0x25, 0xbd, 0x08, 0x08, 0x02, 0x0a, 0xd0, 0x7f, 0x98, 0x2e,
+	0xa8, 0xcf, 0x06, 0xbc, 0xd1, 0x6f, 0xe2, 0x6f, 0x08, 0x0a, 0x80, 0x42,
+	0x98, 0x2e, 0x07, 0x02, 0x00, 0x30, 0x21, 0x2e, 0xa4, 0x01, 0x21, 0x2e,
+	0xa0, 0x01, 0x21, 0x2e, 0x7b, 0x00, 0x21, 0x2e, 0x8e, 0x01, 0x80, 0x2e,
+	0x08, 0xb0, 0x70, 0x50, 0x0b, 0x2e, 0xa3, 0x01, 0x21, 0x50, 0x03, 0x2e,
+	0x78, 0x01, 0x08, 0x18, 0x3b, 0x54, 0x31, 0x50, 0x94, 0x40, 0x30, 0x00,
+	0x33, 0x52, 0xf0, 0x7f, 0x01, 0x00, 0x4c, 0x16, 0x2c, 0x05, 0xe2, 0x7f,
+	0xcd, 0x16, 0x59, 0x07, 0x97, 0x40, 0xd2, 0x7f, 0x67, 0x04, 0x82, 0x40,
+	0x35, 0x56, 0xab, 0x7f, 0xc4, 0x7f, 0x90, 0x7f, 0xb5, 0x7f, 0xaa, 0x06,
+	0x98, 0x2e, 0x0c, 0xc1, 0x50, 0x25, 0xd0, 0x6f, 0xbb, 0x6f, 0x0b, 0x42,
+	0x3e, 0x80, 0xcb, 0x6f, 0x3b, 0x84, 0xe1, 0x6f, 0x83, 0x40, 0x4b, 0x42,
+	0xc1, 0x86, 0x03, 0x2e, 0xa3, 0x01, 0x83, 0x42, 0x82, 0x84, 0x01, 0x42,
+	0xbc, 0x8e, 0x80, 0x40, 0x00, 0xb2, 0x04, 0x2f, 0x03, 0x2e, 0x7d, 0x01,
+	0x41, 0x82, 0x23, 0x2e, 0x7d, 0x01, 0x67, 0x25, 0xe2, 0x41, 0x2a, 0x0f,
+	0x92, 0x6f, 0xc1, 0x41, 0xe7, 0x7f, 0x37, 0x2f, 0x07, 0x2e, 0x7b, 0x01,
+	0x2b, 0x0e, 0x29, 0x2f, 0x3d, 0x52, 0x02, 0x35, 0x41, 0x40, 0x8a, 0x0e,
+	0x03, 0x30, 0x03, 0x2f, 0x05, 0x2e, 0x7f, 0x01, 0x80, 0xb2, 0x1b, 0x2f,
+	0xc2, 0x35, 0x8a, 0x0e, 0x2f, 0x2f, 0x2f, 0x54, 0x01, 0x30, 0x83, 0x40,
+	0xff, 0x86, 0xc3, 0xa2, 0x02, 0x2f, 0x00, 0x2e, 0x0c, 0x2c, 0x03, 0x30,
+	0x00, 0x90, 0x01, 0x2f, 0x23, 0x2e, 0x7d, 0x01, 0x3d, 0x56, 0xc2, 0x86,
+	0x01, 0x80, 0xc0, 0x42, 0x23, 0x2e, 0x7c, 0x01, 0x13, 0x30, 0xbb, 0x80,
+	0x23, 0x2e, 0x84, 0x01, 0x18, 0x2c, 0x01, 0x42, 0x00, 0x35, 0x21, 0x2e,
+	0x7c, 0x01, 0x13, 0x2d, 0x0a, 0x04, 0x28, 0x1e, 0x21, 0x2e, 0x7b, 0x01,
+	0x10, 0x30, 0x21, 0x30, 0x98, 0x2e, 0x8b, 0x02, 0x0a, 0x2c, 0x03, 0x30,
+	0x0a, 0x00, 0x28, 0x1c, 0x21, 0x2e, 0x7a, 0x01, 0x20, 0x30, 0x11, 0x30,
+	0x98, 0x2e, 0x8b, 0x02, 0x03, 0x30, 0xc3, 0x7f, 0xd6, 0x7f, 0x25, 0x25,
+	0x37, 0x52, 0xe0, 0x6f, 0x98, 0x2e, 0x0c, 0xb7, 0xe1, 0x6f, 0xd0, 0x6f,
+	0x42, 0x40, 0x39, 0x52, 0x98, 0x2e, 0x0c, 0xb7, 0xe1, 0x6f, 0xd0, 0x6f,
+	0x42, 0x40, 0x01, 0x40, 0xf3, 0x6f, 0xd3, 0x00, 0xcb, 0x1e, 0x39, 0x52,
+	0x13, 0x42, 0xe0, 0x7f, 0x98, 0x2e, 0x0c, 0xb7, 0xe0, 0x6f, 0x3e, 0x84,
+	0xf1, 0x6f, 0x82, 0x40, 0x03, 0x40, 0x51, 0x04, 0x59, 0x1c, 0x01, 0x42,
+	0x03, 0x82, 0x00, 0x30, 0x42, 0x40, 0x80, 0xb2, 0x12, 0x2f, 0xc1, 0x6f,
+	0x40, 0x90, 0x10, 0x22, 0x82, 0xac, 0x01, 0x30, 0x04, 0x2f, 0x05, 0x2e,
+	0x7d, 0x01, 0x03, 0x35, 0x13, 0x0e, 0x07, 0x2f, 0x3f, 0x54, 0x86, 0x88,
+	0x39, 0x87, 0x01, 0x43, 0xc1, 0x42, 0xc2, 0x86, 0x81, 0x42, 0xc1, 0x42,
+	0x00, 0x2e, 0xab, 0x6f, 0x90, 0x5f, 0xb8, 0x2e, 0x01, 0x2e, 0x85, 0x01,
+	0x01, 0x80, 0xf0, 0x50, 0x02, 0x40, 0x04, 0x40, 0x1a, 0x25, 0xa3, 0xbe,
+	0x03, 0x40, 0x71, 0x82, 0x12, 0x40, 0xdf, 0xba, 0x42, 0xbe, 0x45, 0x42,
+	0x4f, 0xba, 0xb1, 0xbd, 0x00, 0x40, 0xf1, 0x7f, 0xbf, 0xb8, 0x2f, 0xb9,
+	0x0c, 0xb8, 0x24, 0x7f, 0xd0, 0x7f, 0x31, 0x7f, 0x80, 0xb2, 0xeb, 0x7f,
+	0x08, 0x2f, 0x10, 0x6f, 0x00, 0x90, 0x0b, 0x2f, 0x20, 0x6f, 0x00, 0x90,
+	0x08, 0x2f, 0x30, 0x6f, 0x00, 0x90, 0x05, 0x2f, 0x01, 0x30, 0x23, 0x2e,
+	0x7d, 0x00, 0xd0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0x05, 0x2e, 0x7d, 0x00,
+	0x80, 0x90, 0x00, 0x30, 0x41, 0x52, 0x45, 0x56, 0x07, 0x2f, 0x41, 0x58,
+	0x00, 0x2e, 0x10, 0x43, 0x63, 0x0e, 0xfc, 0x2f, 0x81, 0x84, 0x25, 0x2e,
+	0x7d, 0x00, 0x09, 0x2e, 0x85, 0x01, 0x01, 0x85, 0xb0, 0x7f, 0xc0, 0x7f,
+	0x00, 0x2e, 0x82, 0x40, 0x03, 0x41, 0x02, 0x89, 0x24, 0xbd, 0x05, 0x41,
+	0xb1, 0xbd, 0xb1, 0xb9, 0x24, 0xba, 0x54, 0xbd, 0xa3, 0x7f, 0x5c, 0x05,
+	0x24, 0xb9, 0x01, 0x56, 0x43, 0x58, 0x82, 0x7f, 0x95, 0x7f, 0x73, 0x7f,
+	0x64, 0x7f, 0x00, 0x2e, 0xf2, 0x6f, 0x40, 0x7f, 0x51, 0x7f, 0x00, 0x2e,
+	0x90, 0x40, 0xf2, 0x7f, 0x00, 0x90, 0x04, 0x2f, 0x51, 0x6f, 0x00, 0x30,
+	0x40, 0x42, 0x44, 0x2c, 0x62, 0x6f, 0xc1, 0x40, 0x98, 0x2e, 0x74, 0xc0,
+	0x51, 0x6f, 0x00, 0x2e, 0x44, 0x40, 0x00, 0xb3, 0x2c, 0x2f, 0x62, 0x6f,
+	0x95, 0x6f, 0x83, 0x40, 0xc5, 0x0e, 0x07, 0x2f, 0x75, 0x6f, 0x10, 0x30,
+	0x45, 0x41, 0x40, 0xa1, 0x05, 0x30, 0x05, 0x22, 0x18, 0x1a, 0x02, 0x2f,
+	0x00, 0x30, 0x40, 0x42, 0x2b, 0x2d, 0x10, 0x30, 0x20, 0x28, 0x84, 0x6f,
+	0x40, 0x42, 0xc4, 0x0e, 0x24, 0x2f, 0xc0, 0x6f, 0x00, 0x90, 0x21, 0x2f,
+	0x45, 0x6f, 0x10, 0x30, 0x05, 0x15, 0xb3, 0xbd, 0xc4, 0x7f, 0xdc, 0x0a,
+	0x41, 0x58, 0x65, 0x01, 0x45, 0x5c, 0x0b, 0x30, 0x25, 0x1a, 0x00, 0x2f,
+	0x0b, 0x43, 0x01, 0x89, 0x27, 0x2e, 0x73, 0x01, 0x66, 0x0e, 0xf7, 0x2f,
+	0xb0, 0x7f, 0x0e, 0x2d, 0xa2, 0x6f, 0xc2, 0x0e, 0x08, 0x2f, 0x10, 0x30,
+	0x40, 0x42, 0x02, 0x30, 0x74, 0x6f, 0x63, 0x6f, 0x04, 0x41, 0x00, 0xa1,
+	0x02, 0x22, 0xc0, 0x42, 0x00, 0x2e, 0x62, 0x6f, 0x73, 0x6f, 0x40, 0x6f,
+	0x01, 0x80, 0xc1, 0x86, 0x81, 0x84, 0x41, 0x82, 0x03, 0xa2, 0x62, 0x7f,
+	0x73, 0x7f, 0xa5, 0x2f, 0xeb, 0x6f, 0xd0, 0x6f, 0xb1, 0x6f, 0x10, 0x5f,
+	0x80, 0x2e, 0x95, 0xcf, 0x01, 0x2e, 0x87, 0x01, 0x02, 0x40, 0x01, 0x40,
+	0x90, 0x50, 0x2f, 0xbd, 0x93, 0xbc, 0x2f, 0xb9, 0x9c, 0xb8, 0xfb, 0x7f,
+	0xe1, 0x7f, 0x80, 0xb2, 0x0b, 0x30, 0x65, 0x2f, 0x05, 0x2e, 0xce, 0x00,
+	0x47, 0x52, 0x80, 0x90, 0x0b, 0x2f, 0x5b, 0x42, 0x5b, 0x42, 0x81, 0x84,
+	0x25, 0x2e, 0xce, 0x00, 0x37, 0x2e, 0xcf, 0x00, 0x37, 0x2e, 0xd0, 0x00,
+	0x37, 0x2e, 0xd1, 0x00, 0x4b, 0x42, 0x00, 0x2e, 0x03, 0x40, 0x12, 0x40,
+	0x01, 0x40, 0x00, 0x40, 0x0a, 0xbe, 0x27, 0xbd, 0x2e, 0xb8, 0x92, 0xbc,
+	0x18, 0xb9, 0xb9, 0xbd, 0xba, 0xb9, 0x4a, 0xba, 0x07, 0x5a, 0x1a, 0x25,
+	0x17, 0x2e, 0xcf, 0x00, 0x77, 0x82, 0x83, 0x7f, 0xab, 0x7f, 0x75, 0x7f,
+	0x94, 0x7f, 0xd2, 0x7f, 0xc0, 0x7f, 0x98, 0x2e, 0xd1, 0xc3, 0x03, 0x2e,
+	0xcf, 0x00, 0x08, 0x1a, 0xb0, 0x7f, 0x01, 0x30, 0x01, 0x2f, 0x23, 0x2e,
+	0xd1, 0x00, 0x01, 0x2e, 0xd1, 0x00, 0xd1, 0x6f, 0x41, 0x0e, 0x14, 0x2f,
+	0xc1, 0x6f, 0x40, 0xb2, 0x0b, 0x2f, 0x43, 0xb2, 0x09, 0x2f, 0x07, 0x54,
+	0x47, 0x56, 0x98, 0x2e, 0x0b, 0xc4, 0x00, 0x90, 0x06, 0x2f, 0xb1, 0x6f,
+	0x23, 0x2e, 0xd0, 0x00, 0x03, 0x2d, 0xb1, 0x6f, 0x23, 0x2e, 0xd0, 0x00,
+	0xd1, 0x6f, 0x23, 0x2e, 0xd1, 0x00, 0x03, 0x2e, 0xd1, 0x00, 0x41, 0x82,
+	0x23, 0x2e, 0xd1, 0x00, 0x07, 0x50, 0x47, 0x52, 0x12, 0x40, 0x52, 0x42,
+	0x00, 0x2e, 0x12, 0x40, 0x52, 0x42, 0x00, 0x2e, 0x00, 0x40, 0x40, 0x42,
+	0x00, 0x2e, 0x03, 0x2e, 0xd0, 0x00, 0xe0, 0x6f, 0x98, 0x2e, 0x95, 0xcf,
+	0xb1, 0x6f, 0x23, 0x2e, 0xcf, 0x00, 0x06, 0x2d, 0x37, 0x2e, 0xce, 0x00,
+	0xe0, 0x6f, 0x01, 0x30, 0x98, 0x2e, 0x95, 0xcf, 0xfb, 0x6f, 0x70, 0x5f,
+	0xb8, 0x2e, 0xd0, 0x50, 0x80, 0x7f, 0x91, 0x7f, 0xd7, 0x7f, 0xc5, 0x7f,
+	0xb3, 0x7f, 0xa2, 0x7f, 0xe4, 0x7f, 0xf6, 0x7f, 0x7b, 0x7f, 0x00, 0x2e,
+	0x4b, 0x50, 0x00, 0x2e, 0x01, 0x40, 0x9f, 0xbc, 0x9f, 0xb8, 0x40, 0x90,
+	0x02, 0x2f, 0x31, 0x30, 0x23, 0x2e, 0x69, 0xf5, 0x38, 0x82, 0x61, 0x7f,
+	0x20, 0x30, 0x41, 0x40, 0x23, 0x2e, 0xd6, 0x00, 0x03, 0x2e, 0xd6, 0x00,
+	0x08, 0x08, 0x00, 0xb2, 0x0b, 0x2f, 0x49, 0x50, 0x1a, 0x25, 0x12, 0x40,
+	0x32, 0x7f, 0x73, 0x82, 0x12, 0x40, 0x42, 0x7f, 0x00, 0x2e, 0x00, 0x40,
+	0x50, 0x7f, 0x98, 0x2e, 0x6a, 0xd6, 0x01, 0x2e, 0xd6, 0x00, 0x81, 0x30,
+	0x01, 0x08, 0x00, 0xb2, 0x42, 0x2f, 0x03, 0x2e, 0x89, 0x00, 0x01, 0x2e,
+	0x89, 0x00, 0x97, 0xbc, 0x06, 0xbc, 0x9f, 0xb8, 0x0f, 0xb8, 0x00, 0x90,
+	0x23, 0x2e, 0x6d, 0x01, 0x10, 0x30, 0x01, 0x30, 0x2a, 0x2f, 0x03, 0x2e,
+	0xff, 0x00, 0x44, 0xb2, 0x05, 0x2f, 0x47, 0xb2, 0x00, 0x30, 0x2d, 0x2f,
+	0x21, 0x2e, 0xd6, 0x00, 0x2b, 0x2d, 0x03, 0x2e, 0xfd, 0xf5, 0x9e, 0xbc,
+	0x9f, 0xb8, 0x40, 0x90, 0x14, 0x2f, 0x03, 0x2e, 0xfc, 0xf5, 0x99, 0xbc,
+	0x9f, 0xb8, 0x40, 0x90, 0x0e, 0x2f, 0x03, 0x2e, 0x49, 0xf1, 0x4d, 0x54,
+	0x4a, 0x08, 0x40, 0x90, 0x08, 0x2f, 0x98, 0x2e, 0xe4, 0x01, 0x00, 0xb2,
+	0x10, 0x30, 0x03, 0x2f, 0x50, 0x30, 0x21, 0x2e, 0xff, 0x00, 0x10, 0x2d,
+	0x98, 0x2e, 0xe4, 0xb6, 0x00, 0x30, 0x21, 0x2e, 0xd6, 0x00, 0x0a, 0x2d,
+	0x05, 0x2e, 0x69, 0xf7, 0x2d, 0xbd, 0x2f, 0xb9, 0x80, 0xb2, 0x01, 0x2f,
+	0x21, 0x2e, 0xd7, 0x00, 0x23, 0x2e, 0xd6, 0x00, 0x60, 0x6f, 0xe1, 0x31,
+	0x01, 0x42, 0x00, 0x2e, 0xf6, 0x6f, 0xe4, 0x6f, 0x80, 0x6f, 0x91, 0x6f,
+	0xa2, 0x6f, 0xb3, 0x6f, 0xc5, 0x6f, 0xd7, 0x6f, 0x7b, 0x6f, 0x30, 0x5f,
+	0xc8, 0x2e, 0xa0, 0x50, 0x82, 0x7f, 0x90, 0x7f, 0xd7, 0x7f, 0xc5, 0x7f,
+	0xb3, 0x7f, 0xa1, 0x7f, 0xe4, 0x7f, 0xf6, 0x7f, 0x7b, 0x7f, 0x00, 0x2e,
+	0x4b, 0x54, 0x00, 0x2e, 0x80, 0x40, 0x0f, 0xbc, 0x0f, 0xb8, 0x00, 0x90,
+	0x02, 0x2f, 0x30, 0x30, 0x21, 0x2e, 0x69, 0xf5, 0xb7, 0x84, 0x62, 0x7f,
+	0x98, 0x2e, 0xe4, 0x01, 0x00, 0xb2, 0x90, 0x2e, 0x95, 0xb4, 0x03, 0x2e,
+	0x8c, 0x00, 0x07, 0x2e, 0x8e, 0x00, 0x3f, 0xba, 0x05, 0x2e, 0xa0, 0x00,
+	0xa3, 0xbd, 0x9f, 0xb8, 0x01, 0x2e, 0xa0, 0x00, 0x4c, 0x0a, 0xbf, 0xb9,
+	0x04, 0xbe, 0x4b, 0x0a, 0x05, 0x2e, 0xa0, 0x00, 0xcf, 0xb9, 0x01, 0x2e,
+	0x96, 0x00, 0x22, 0xbe, 0xcb, 0x0a, 0x4f, 0xba, 0x03, 0xbc, 0x05, 0x2e,
+	0x98, 0x00, 0xdc, 0x0a, 0x0f, 0xb8, 0x03, 0x2e, 0x90, 0x00, 0x2f, 0xbe,
+	0x18, 0x0a, 0xcf, 0xb9, 0x9f, 0xbc, 0x05, 0x2e, 0x9f, 0x00, 0x9f, 0xb8,
+	0x03, 0x0a, 0x2f, 0xbd, 0x01, 0x0a, 0x2f, 0xb9, 0x82, 0x0a, 0x25, 0x2e,
+	0x78, 0x00, 0x05, 0x2e, 0xc1, 0xf5, 0x2e, 0xbd, 0x2e, 0xb9, 0x01, 0x2e,
+	0x7a, 0x00, 0x31, 0x30, 0x8a, 0x04, 0x00, 0x90, 0x07, 0x2f, 0x01, 0x2e,
+	0xff, 0x00, 0x04, 0xa2, 0x03, 0x2f, 0x01, 0x2e, 0x78, 0x00, 0x00, 0xb2,
+	0x0c, 0x2f, 0x51, 0x50, 0x07, 0x52, 0x98, 0x2e, 0xfc, 0x01, 0x05, 0x2e,
+	0xd8, 0x00, 0x80, 0x90, 0x10, 0x30, 0x01, 0x2f, 0x21, 0x2e, 0xd8, 0x00,
+	0x25, 0x2e, 0x8e, 0x01, 0x98, 0x2e, 0xed, 0x01, 0x00, 0xb2, 0x22, 0x30,
+	0x21, 0x30, 0x03, 0x2f, 0x01, 0x2e, 0x7a, 0x00, 0x00, 0x90, 0x05, 0x2f,
+	0x01, 0x2e, 0x79, 0x00, 0x01, 0xb2, 0x30, 0x30, 0x01, 0x30, 0x41, 0x22,
+	0x01, 0x2e, 0x9b, 0x01, 0x08, 0x1a, 0x0e, 0x2f, 0x23, 0x2e, 0x9b, 0x01,
+	0x33, 0x30, 0x53, 0x50, 0x0b, 0x09, 0x01, 0x40, 0x4f, 0x56, 0x46, 0xbe,
+	0x4b, 0x08, 0x4c, 0x0a, 0x01, 0x42, 0x0a, 0x80, 0x1f, 0x52, 0x01, 0x42,
+	0x00, 0x2e, 0x01, 0x2e, 0x78, 0x00, 0x00, 0xb2, 0x1f, 0x2f, 0x03, 0x2e,
+	0xc0, 0xf5, 0xf0, 0x30, 0x48, 0x08, 0x47, 0xaa, 0x74, 0x30, 0x07, 0x2e,
+	0xdb, 0x00, 0x61, 0x22, 0x4b, 0x1a, 0x05, 0x2f, 0x07, 0x2e, 0x66, 0xf5,
+	0xbf, 0xbd, 0xbf, 0xb9, 0xc0, 0x90, 0x0b, 0x2f, 0x55, 0x56, 0x04, 0x30,
+	0xd4, 0x42, 0xd2, 0x42, 0x81, 0x04, 0x24, 0xbd, 0xfe, 0x80, 0x81, 0x84,
+	0xc4, 0x42, 0x23, 0x2e, 0xdb, 0x00, 0x02, 0x42, 0x02, 0x32, 0x25, 0x2e,
+	0x62, 0xf5, 0x05, 0x2e, 0x6b, 0x01, 0x81, 0x80, 0x21, 0x2e, 0x6b, 0x01,
+	0x62, 0x6f, 0x00, 0x31, 0x80, 0x42, 0x00, 0x2e, 0x05, 0x2e, 0x8a, 0x00,
+	0x0d, 0x50, 0x90, 0x08, 0x80, 0xb2, 0x0b, 0x2f, 0x05, 0x2e, 0xca, 0xf5,
+	0xf0, 0x3e, 0x90, 0x08, 0x25, 0x2e, 0xca, 0xf5, 0x05, 0x2e, 0x59, 0xf5,
+	0xe0, 0x3f, 0x90, 0x08, 0x25, 0x2e, 0x59, 0xf5, 0xf6, 0x6f, 0xe4, 0x6f,
+	0x90, 0x6f, 0xa1, 0x6f, 0xb3, 0x6f, 0xc5, 0x6f, 0xd7, 0x6f, 0x7b, 0x6f,
+	0x82, 0x6f, 0x60, 0x5f, 0xc8, 0x2e, 0xc0, 0x50, 0x80, 0x7f, 0x92, 0x7f,
+	0xd5, 0x7f, 0xc4, 0x7f, 0xb3, 0x7f, 0xa1, 0x7f, 0xe7, 0x7f, 0xf6, 0x7f,
+	0x7b, 0x7f, 0x00, 0x2e, 0x4b, 0x50, 0x00, 0x2e, 0x02, 0x40, 0x2f, 0xbd,
+	0x2f, 0xb9, 0x80, 0x90, 0x02, 0x2f, 0x32, 0x30, 0x25, 0x2e, 0x69, 0xf5,
+	0x37, 0x80, 0x00, 0x2e, 0x00, 0x40, 0x60, 0x7f, 0x98, 0x2e, 0xe4, 0x01,
+	0x63, 0x6f, 0x02, 0x30, 0x62, 0x7f, 0x50, 0x7f, 0x02, 0x32, 0x1f, 0x52,
+	0x80, 0x2e, 0x6e, 0xb5, 0x1a, 0x09, 0x00, 0xb3, 0x14, 0x2f, 0x00, 0xb2,
+	0x03, 0x2f, 0x09, 0x2e, 0x78, 0x00, 0x00, 0x91, 0x0c, 0x2f, 0x43, 0x7f,
+	0x98, 0x2e, 0x32, 0x03, 0x57, 0x50, 0x02, 0x8a, 0x02, 0x32, 0x04, 0x30,
+	0x25, 0x2e, 0x64, 0xf5, 0x1f, 0x52, 0x50, 0x6f, 0x43, 0x6f, 0x44, 0x43,
+	0x25, 0x2e, 0x60, 0xf5, 0xd9, 0x08, 0xc0, 0xb2, 0x6d, 0x2f, 0x98, 0x2e,
+	0xed, 0x01, 0x00, 0xb2, 0x06, 0x2f, 0x01, 0x2e, 0x7a, 0x00, 0x00, 0xb2,
+	0x02, 0x2f, 0x50, 0x6f, 0x00, 0x90, 0x0a, 0x2f, 0x01, 0x2e, 0xda, 0x00,
+	0x00, 0x90, 0x19, 0x2f, 0x10, 0x30, 0x21, 0x2e, 0xda, 0x00, 0x00, 0x30,
+	0x98, 0x2e, 0xcd, 0xb6, 0x13, 0x2d, 0x01, 0x2e, 0xc3, 0xf5, 0x0c, 0xbc,
+	0x0f, 0xb8, 0x12, 0x30, 0x10, 0x04, 0x03, 0xb0, 0x26, 0x25, 0x59, 0x50,
+	0x05, 0x52, 0x98, 0x2e, 0xfc, 0x01, 0x10, 0x30, 0x21, 0x2e, 0xa0, 0x01,
+	0x02, 0x30, 0x60, 0x7f, 0x25, 0x2e, 0xda, 0x00, 0x50, 0x6f, 0x00, 0xb2,
+	0x03, 0x2f, 0x05, 0x2e, 0x79, 0x00, 0x80, 0x90, 0x0e, 0x2f, 0x05, 0x2e,
+	0xd9, 0x00, 0x80, 0x90, 0x2c, 0x2f, 0x11, 0x30, 0x02, 0x30, 0x23, 0x2e,
+	0xd9, 0x00, 0x23, 0x2e, 0x7c, 0x00, 0x25, 0x2e, 0x7d, 0x00, 0x25, 0x2e,
+	0xa5, 0x01, 0x22, 0x2d, 0x05, 0x2e, 0xa5, 0x01, 0x81, 0x82, 0x23, 0x2e,
+	0xa5, 0x01, 0x12, 0x30, 0x4a, 0x08, 0x40, 0xb2, 0x05, 0x2f, 0x03, 0x2e,
+	0x58, 0xf5, 0x98, 0xbc, 0x9e, 0xb8, 0x43, 0x90, 0x10, 0x2f, 0x01, 0x2e,
+	0xc1, 0xf5, 0x0e, 0xbc, 0x0e, 0xb8, 0x32, 0x30, 0x90, 0x04, 0x5b, 0x50,
+	0x01, 0x52, 0x98, 0x2e, 0xfc, 0x01, 0x12, 0x30, 0x25, 0x2e, 0xa4, 0x01,
+	0x00, 0x30, 0x21, 0x2e, 0xd9, 0x00, 0x50, 0x6f, 0x62, 0x7f, 0x00, 0x2e,
+	0x62, 0x6f, 0x80, 0x90, 0x05, 0x2f, 0x02, 0x30, 0x25, 0x2e, 0x9b, 0x01,
+	0x1f, 0x54, 0x25, 0x2e, 0x64, 0xf5, 0x1f, 0x52, 0x23, 0x2e, 0x60, 0xf5,
+	0x02, 0x32, 0x00, 0x90, 0x02, 0x2f, 0x03, 0x30, 0x27, 0x2e, 0xd8, 0x00,
+	0x07, 0x2e, 0x60, 0xf5, 0x1a, 0x09, 0x00, 0x91, 0x90, 0x2e, 0xde, 0xb4,
+	0x19, 0x09, 0x00, 0x91, 0x90, 0x2e, 0xde, 0xb4, 0x80, 0x6f, 0x92, 0x6f,
+	0xa1, 0x6f, 0xb3, 0x6f, 0xc4, 0x6f, 0xd5, 0x6f, 0x7b, 0x6f, 0xf6, 0x6f,
+	0xe7, 0x6f, 0x40, 0x5f, 0xc8, 0x2e, 0x5d, 0x52, 0x00, 0x51, 0x52, 0x40,
+	0x47, 0x40, 0xf8, 0xbc, 0x9c, 0xb9, 0x1a, 0x25, 0x01, 0x2e, 0x9f, 0x00,
+	0xf3, 0x7f, 0x8f, 0xbe, 0x72, 0x88, 0xeb, 0x7f, 0x5f, 0xbb, 0x0b, 0x30,
+	0x78, 0xb8, 0x6b, 0x56, 0xd3, 0x08, 0x70, 0x8a, 0xfc, 0xbf, 0x0b, 0x43,
+	0xc4, 0x7f, 0xfc, 0xbb, 0x1e, 0x0b, 0x21, 0x2e, 0xe1, 0x00, 0x1b, 0x7f,
+	0x4b, 0x43, 0x00, 0xb3, 0xd6, 0x7f, 0xa7, 0x7f, 0xb5, 0x7f, 0x93, 0x7f,
+	0x90, 0x2e, 0x39, 0xb6, 0x01, 0x2e, 0xfb, 0x00, 0x00, 0xb2, 0x0b, 0x2f,
+	0x5f, 0x52, 0x01, 0x2e, 0xf6, 0x00, 0x82, 0x7f, 0x98, 0x2e, 0xbb, 0xcc,
+	0x0b, 0x30, 0x37, 0x2e, 0xfb, 0x00, 0x82, 0x6f, 0x93, 0x6f, 0x1a, 0x25,
+	0xc0, 0xb2, 0x8b, 0x7f, 0x14, 0x2f, 0x26, 0xbc, 0x25, 0xbd, 0x06, 0xb8,
+	0x2f, 0xb9, 0x80, 0xb2, 0x14, 0xb0, 0x0c, 0x2f, 0x61, 0x50, 0x63, 0x54,
+	0x0b, 0x30, 0x0b, 0x2e, 0xa0, 0x00, 0x69, 0x58, 0x1b, 0x42, 0x9b, 0x42,
+	0x6c, 0x09, 0x2b, 0x2e, 0xa0, 0x00, 0x0b, 0x42, 0x8b, 0x42, 0x86, 0x7f,
+	0x73, 0x84, 0x6d, 0x50, 0xd8, 0x08, 0x67, 0x52, 0x07, 0x50, 0x72, 0x7f,
+	0x63, 0x7f, 0x98, 0x2e, 0xc2, 0xc0, 0xd1, 0x6f, 0x62, 0x6f, 0xd1, 0x0a,
+	0x01, 0x2e, 0xf6, 0x00, 0xc5, 0x6f, 0xb4, 0x6f, 0x72, 0x6f, 0x5f, 0x52,
+	0x65, 0x5c, 0x98, 0x2e, 0x06, 0xcd, 0x23, 0x6f, 0x90, 0x6f, 0x61, 0x52,
+	0xc0, 0xb2, 0x04, 0xbd, 0x54, 0x40, 0xaf, 0xb9, 0x45, 0x40, 0xd1, 0x7f,
+	0x02, 0x30, 0x06, 0x2f, 0xc0, 0xb2, 0x02, 0x30, 0x03, 0x2f, 0x63, 0x5c,
+	0x12, 0x30, 0x94, 0x43, 0x85, 0x43, 0x03, 0xbf, 0x6f, 0xbb, 0x80, 0xb3,
+	0x20, 0x2f, 0x06, 0x6f, 0x26, 0x01, 0x16, 0x6f, 0x6e, 0x03, 0x45, 0x42,
+	0xc0, 0x90, 0x29, 0x2e, 0xf7, 0x00, 0x63, 0x52, 0x14, 0x2f, 0x63, 0x5c,
+	0x00, 0x2e, 0x93, 0x41, 0x86, 0x41, 0xe3, 0x04, 0xae, 0x07, 0x80, 0xab,
+	0x04, 0x2f, 0x80, 0x91, 0x0a, 0x2f, 0x86, 0x6f, 0x73, 0x0f, 0x07, 0x2f,
+	0x83, 0x6f, 0xc0, 0xb2, 0x04, 0x2f, 0x54, 0x42, 0x45, 0x42, 0x12, 0x30,
+	0x04, 0x2c, 0x11, 0x30, 0x02, 0x2c, 0x11, 0x30, 0x11, 0x30, 0x02, 0xbc,
+	0x0f, 0xb8, 0xc2, 0x7f, 0x00, 0xb2, 0x0a, 0x2f, 0x01, 0x2e, 0xb7, 0x01,
+	0x05, 0x2e, 0x71, 0x01, 0x10, 0x1a, 0x02, 0x2f, 0x21, 0x2e, 0x71, 0x01,
+	0x03, 0x2d, 0x02, 0x2c, 0x01, 0x30, 0x01, 0x30, 0xf0, 0x6f, 0x98, 0x2e,
+	0x95, 0xcf, 0xc1, 0x6f, 0xa0, 0x6f, 0x98, 0x2e, 0x95, 0xcf, 0xd2, 0x6f,
+	0x1b, 0x52, 0x01, 0x2e, 0xf7, 0x00, 0x82, 0x40, 0x50, 0x42, 0x0c, 0x2c,
+	0x42, 0x42, 0x11, 0x30, 0x23, 0x2e, 0xfb, 0x00, 0x01, 0x30, 0xf0, 0x6f,
+	0x98, 0x2e, 0x95, 0xcf, 0xa0, 0x6f, 0x01, 0x30, 0x98, 0x2e, 0x95, 0xcf,
+	0x00, 0x2e, 0xeb, 0x6f, 0x00, 0x5f, 0xb8, 0x2e, 0x60, 0x51, 0x0a, 0x25,
+	0x36, 0x88, 0xf4, 0x7f, 0xeb, 0x7f, 0x00, 0x32, 0x7b, 0x52, 0x32, 0x30,
+	0x13, 0x30, 0x98, 0x2e, 0x15, 0xcb, 0x0a, 0x25, 0x33, 0x84, 0xd2, 0x7f,
+	0x43, 0x30, 0x07, 0x50, 0x35, 0x52, 0x98, 0x2e, 0x95, 0xc1, 0xd2, 0x6f,
+	0x73, 0x52, 0x98, 0x2e, 0xd7, 0xc7, 0x2a, 0x25, 0xb0, 0x86, 0xc0, 0x7f,
+	0xd3, 0x7f, 0xaf, 0x84, 0x75, 0x50, 0xf1, 0x6f, 0x98, 0x2e, 0x4d, 0xc8,
+	0x2a, 0x25, 0xae, 0x8a, 0xaa, 0x88, 0xf2, 0x6e, 0x77, 0x50, 0xc1, 0x6f,
+	0xd3, 0x6f, 0xf4, 0x7f, 0x98, 0x2e, 0xb6, 0xc8, 0xe0, 0x6e, 0x00, 0xb2,
+	0x32, 0x2f, 0x7d, 0x54, 0x83, 0x86, 0xf1, 0x6f, 0xc3, 0x7f, 0x04, 0x30,
+	0x30, 0x30, 0xf4, 0x7f, 0xd0, 0x7f, 0xb2, 0x7f, 0xe3, 0x30, 0xc5, 0x6f,
+	0x56, 0x40, 0x45, 0x41, 0x28, 0x08, 0x03, 0x14, 0x0e, 0xb4, 0x08, 0xbc,
+	0x82, 0x40, 0x10, 0x0a, 0x79, 0x54, 0x26, 0x05, 0x91, 0x7f, 0x44, 0x28,
+	0xa3, 0x7f, 0x98, 0x2e, 0xd9, 0xc0, 0x08, 0xb9, 0x33, 0x30, 0x53, 0x09,
+	0xc1, 0x6f, 0xd3, 0x6f, 0xf4, 0x6f, 0x83, 0x17, 0x47, 0x40, 0x6c, 0x15,
+	0xb2, 0x6f, 0xbe, 0x09, 0x75, 0x0b, 0x90, 0x42, 0x45, 0x42, 0x51, 0x0e,
+	0x32, 0xbc, 0x02, 0x89, 0xa1, 0x6f, 0x7e, 0x86, 0xf4, 0x7f, 0xd0, 0x7f,
+	0xb2, 0x7f, 0x04, 0x30, 0x91, 0x6f, 0xd6, 0x2f, 0xeb, 0x6f, 0xa0, 0x5e,
+	0xb8, 0x2e, 0x01, 0x2e, 0x77, 0xf7, 0x09, 0xbc, 0x0f, 0xb8, 0x00, 0xb2,
+	0x10, 0x50, 0xfb, 0x7f, 0x10, 0x30, 0x0b, 0x2f, 0x03, 0x2e, 0x8a, 0x00,
+	0x96, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x05, 0x2f, 0x03, 0x2e, 0x68, 0xf7,
+	0x9e, 0xbc, 0x9f, 0xb8, 0x40, 0xb2, 0x07, 0x2f, 0x03, 0x2e, 0xfe, 0x00,
+	0x41, 0x90, 0x01, 0x2f, 0x98, 0x2e, 0xcd, 0xb6, 0x03, 0x2c, 0x00, 0x30,
+	0x21, 0x2e, 0xfe, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0xb8, 0x2e, 0x20, 0x50,
+	0xe0, 0x7f, 0xfb, 0x7f, 0x00, 0x2e, 0x73, 0x50, 0x98, 0x2e, 0x3b, 0xc8,
+	0x75, 0x50, 0x98, 0x2e, 0xa7, 0xc8, 0x03, 0x50, 0x98, 0x2e, 0x55, 0xcc,
+	0xe1, 0x6f, 0x77, 0x50, 0x98, 0x2e, 0xe0, 0xc9, 0xfb, 0x6f, 0x00, 0x30,
+	0xe0, 0x5f, 0x21, 0x2e, 0xfe, 0x00, 0xb8, 0x2e, 0x03, 0xbc, 0x21, 0x2e,
+	0x6a, 0x01, 0x03, 0x2e, 0x6a, 0x01, 0x40, 0xb2, 0x10, 0x30, 0x21, 0x2e,
+	0x7b, 0x00, 0x01, 0x30, 0x05, 0x2f, 0x05, 0x2e, 0x6d, 0x01, 0x80, 0x90,
+	0x01, 0x2f, 0x23, 0x2e, 0x6f, 0xf5, 0xc0, 0x2e, 0x21, 0x2e, 0x6e, 0x01,
+	0x30, 0x25, 0x00, 0x30, 0x21, 0x2e, 0x5a, 0xf5, 0x10, 0x50, 0x21, 0x2e,
+	0xdc, 0x00, 0x21, 0x2e, 0xd6, 0x00, 0xfb, 0x7f, 0x98, 0x2e, 0xf3, 0x03,
+	0x40, 0x30, 0x21, 0x2e, 0xff, 0x00, 0xfb, 0x6f, 0xf0, 0x5f, 0x03, 0x25,
+	0x80, 0x2e, 0xe4, 0xb6, 0x10, 0x50, 0x03, 0x40, 0x19, 0x18, 0x83, 0x56,
+	0x19, 0x05, 0x36, 0x25, 0xf7, 0x7f, 0x4a, 0x17, 0x54, 0x18, 0xec, 0x18,
+	0x09, 0x17, 0x01, 0x30, 0x0c, 0x07, 0xe2, 0x18, 0xde, 0x00, 0xf2, 0x6f,
+	0x97, 0x02, 0x7f, 0x58, 0xdc, 0x00, 0x91, 0x02, 0xbf, 0xb8, 0x21, 0xbd,
+	0x8a, 0x0a, 0xc0, 0x2e, 0x02, 0x42, 0xf0, 0x5f, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1,
+	0x01, 0x2e, 0x5d, 0xf7, 0x08, 0xbc, 0x80, 0xac, 0x0e, 0xbb, 0x02, 0x2f,
+	0x00, 0x30, 0x41, 0x04, 0x82, 0x06, 0xc0, 0xa4, 0x00, 0x30, 0x11, 0x2f,
+	0x40, 0xa9, 0x03, 0x2f, 0x40, 0x91, 0x0d, 0x2f, 0x00, 0xa7, 0x0b, 0x2f,
+	0x80, 0xb3, 0x7f, 0x58, 0x02, 0x2f, 0x90, 0xa1, 0x26, 0x13, 0x20, 0x23,
+	0x80, 0x90, 0x10, 0x30, 0x01, 0x2f, 0xcc, 0x0e, 0x00, 0x2f, 0x00, 0x30,
+	0xb8, 0x2e, 0x81, 0x50, 0x18, 0x08, 0x08, 0xbc, 0x88, 0xb6, 0x0d, 0x17,
+	0xc6, 0xbd, 0x56, 0xbc, 0x83, 0x58, 0xda, 0xba, 0x04, 0x01, 0x1d, 0x0a,
+	0x10, 0x50, 0x05, 0x30, 0x32, 0x25, 0x45, 0x03, 0xfb, 0x7f, 0xf6, 0x30,
+	0x21, 0x25, 0x98, 0x2e, 0x37, 0xca, 0x16, 0xb5, 0x9a, 0xbc, 0x06, 0xb8,
+	0x80, 0xa8, 0x41, 0x0a, 0x0e, 0x2f, 0x80, 0x90, 0x02, 0x2f, 0x35, 0x50,
+	0x48, 0x0f, 0x09, 0x2f, 0xbf, 0xa0, 0x04, 0x2f, 0xbf, 0x90, 0x06, 0x2f,
+	0x83, 0x54, 0xca, 0x0f, 0x03, 0x2f, 0x00, 0x2e, 0x02, 0x2c, 0x83, 0x52,
+	0x35, 0x52, 0xf2, 0x33, 0x98, 0x2e, 0xd9, 0xc0, 0xfb, 0x6f, 0xf1, 0x37,
+	0xc0, 0x2e, 0x01, 0x08, 0xf0, 0x5f, 0x8b, 0x56, 0x85, 0x54, 0xd0, 0x40,
+	0xc4, 0x40, 0x0b, 0x2e, 0xfd, 0xf3, 0x8b, 0x52, 0x90, 0x42, 0x94, 0x42,
+	0x95, 0x42, 0x05, 0x30, 0x8d, 0x50, 0x0f, 0x88, 0x06, 0x40, 0x04, 0x41,
+	0x96, 0x42, 0xc5, 0x42, 0x48, 0xbe, 0x73, 0x30, 0x0d, 0x2e, 0x6d, 0x01,
+	0x4f, 0xba, 0x84, 0x42, 0x03, 0x42, 0x81, 0xb3, 0x02, 0x2f, 0x2b, 0x2e,
+	0x6f, 0xf5, 0x06, 0x2d, 0x05, 0x2e, 0x77, 0xf7, 0x89, 0x56, 0x93, 0x08,
+	0x25, 0x2e, 0x77, 0xf7, 0x87, 0x54, 0x25, 0x2e, 0xc2, 0xf5, 0x07, 0x2e,
+	0xfd, 0xf3, 0x42, 0x30, 0xb4, 0x33, 0xda, 0x0a, 0x4c, 0x00, 0x27, 0x2e,
+	0xfd, 0xf3, 0x43, 0x40, 0xd4, 0x3f, 0xdc, 0x08, 0x43, 0x42, 0x00, 0x2e,
+	0x00, 0x2e, 0x43, 0x40, 0x24, 0x30, 0xdc, 0x0a, 0x43, 0x42, 0x04, 0x80,
+	0x03, 0x2e, 0xfd, 0xf3, 0x4a, 0x0a, 0x23, 0x2e, 0xfd, 0xf3, 0x61, 0x34,
+	0xc0, 0x2e, 0x01, 0x42, 0x00, 0x2e, 0x60, 0x50, 0x1a, 0x25, 0x7a, 0x86,
+	0xe0, 0x7f, 0xf3, 0x7f, 0x03, 0x25, 0x8f, 0x52, 0x41, 0x84, 0xdb, 0x7f,
+	0x33, 0x30, 0x98, 0x2e, 0x16, 0xc2, 0x1a, 0x25, 0x7d, 0x82, 0xf0, 0x6f,
+	0xe2, 0x6f, 0x32, 0x25, 0x16, 0x40, 0x94, 0x40, 0x26, 0x01, 0x85, 0x40,
+	0x8e, 0x17, 0xc4, 0x42, 0x6e, 0x03, 0x95, 0x42, 0x41, 0x0e, 0xf4, 0x2f,
+	0xdb, 0x6f, 0xa0, 0x5f, 0xb8, 0x2e, 0xb0, 0x51, 0xfb, 0x7f, 0x98, 0x2e,
+	0xe8, 0x0d, 0x5a, 0x25, 0x98, 0x2e, 0x0f, 0x0e, 0x97, 0x58, 0x32, 0x87,
+	0xc4, 0x7f, 0x65, 0x89, 0x6b, 0x8d, 0x91, 0x5a, 0x65, 0x7f, 0xe1, 0x7f,
+	0x83, 0x7f, 0xa6, 0x7f, 0x74, 0x7f, 0xd0, 0x7f, 0xb6, 0x7f, 0x94, 0x7f,
+	0x17, 0x30, 0x93, 0x52, 0x95, 0x54, 0x51, 0x7f, 0x00, 0x2e, 0x85, 0x6f,
+	0x42, 0x7f, 0x00, 0x2e, 0x51, 0x41, 0x45, 0x81, 0x42, 0x41, 0x13, 0x40,
+	0x3b, 0x8a, 0x00, 0x40, 0x4b, 0x04, 0xd0, 0x06, 0xc0, 0xac, 0x85, 0x7f,
+	0x02, 0x2f, 0x02, 0x30, 0x51, 0x04, 0xd3, 0x06, 0x41, 0x84, 0x05, 0x30,
+	0x5d, 0x02, 0xc9, 0x16, 0xdf, 0x08, 0xd3, 0x00, 0x8d, 0x02, 0xaf, 0xbc,
+	0xb1, 0xb9, 0x59, 0x0a, 0x65, 0x6f, 0x11, 0x43, 0xa1, 0xb4, 0x52, 0x41,
+	0x53, 0x41, 0x01, 0x43, 0x34, 0x7f, 0x65, 0x7f, 0x26, 0x31, 0xe5, 0x6f,
+	0xd4, 0x6f, 0x98, 0x2e, 0x37, 0xca, 0x32, 0x6f, 0x75, 0x6f, 0x83, 0x40,
+	0x42, 0x41, 0x23, 0x7f, 0x12, 0x7f, 0xf6, 0x30, 0x40, 0x25, 0x51, 0x25,
+	0x98, 0x2e, 0x37, 0xca, 0x14, 0x6f, 0x20, 0x05, 0x70, 0x6f, 0x25, 0x6f,
+	0x69, 0x07, 0xa2, 0x6f, 0x31, 0x6f, 0x0b, 0x30, 0x04, 0x42, 0x9b, 0x42,
+	0x8b, 0x42, 0x55, 0x42, 0x32, 0x7f, 0x40, 0xa9, 0xc3, 0x6f, 0x71, 0x7f,
+	0x02, 0x30, 0xd0, 0x40, 0xc3, 0x7f, 0x03, 0x2f, 0x40, 0x91, 0x15, 0x2f,
+	0x00, 0xa7, 0x13, 0x2f, 0x00, 0xa4, 0x11, 0x2f, 0x84, 0xbd, 0x98, 0x2e,
+	0x79, 0xca, 0x55, 0x6f, 0x83, 0x54, 0x54, 0x41, 0x82, 0x00, 0xf3, 0x3f,
+	0x45, 0x41, 0xcb, 0x02, 0xf6, 0x30, 0x98, 0x2e, 0x37, 0xca, 0x35, 0x6f,
+	0xa4, 0x6f, 0x41, 0x43, 0x03, 0x2c, 0x00, 0x43, 0xa4, 0x6f, 0x35, 0x6f,
+	0x17, 0x30, 0x42, 0x6f, 0x51, 0x6f, 0x93, 0x40, 0x42, 0x82, 0x00, 0x41,
+	0xc3, 0x00, 0x03, 0x43, 0x51, 0x7f, 0x00, 0x2e, 0x94, 0x40, 0x41, 0x41,
+	0x4c, 0x02, 0xc4, 0x6f, 0x9d, 0x56, 0x63, 0x0e, 0x74, 0x6f, 0x51, 0x43,
+	0xa5, 0x7f, 0x8a, 0x2f, 0x09, 0x2e, 0x6d, 0x01, 0x01, 0xb3, 0x21, 0x2f,
+	0x97, 0x58, 0x90, 0x6f, 0x13, 0x41, 0xb6, 0x6f, 0xe4, 0x7f, 0x00, 0x2e,
+	0x91, 0x41, 0x14, 0x40, 0x92, 0x41, 0x15, 0x40, 0x17, 0x2e, 0x6f, 0xf5,
+	0xb6, 0x7f, 0xd0, 0x7f, 0xcb, 0x7f, 0x98, 0x2e, 0x00, 0x0c, 0x07, 0x15,
+	0xc2, 0x6f, 0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0xc3, 0xa3, 0xc1, 0x8f,
+	0xe4, 0x6f, 0xd0, 0x6f, 0xe6, 0x2f, 0x14, 0x30, 0x05, 0x2e, 0x6f, 0xf5,
+	0x14, 0x0b, 0x29, 0x2e, 0x6f, 0xf5, 0x18, 0x2d, 0x99, 0x56, 0x04, 0x32,
+	0xb5, 0x6f, 0x1c, 0x01, 0x51, 0x41, 0x52, 0x41, 0xc3, 0x40, 0xb5, 0x7f,
+	0xe4, 0x7f, 0x98, 0x2e, 0x1f, 0x0c, 0xe4, 0x6f, 0x21, 0x87, 0x00, 0x43,
+	0x04, 0x32, 0x9b, 0x54, 0x5a, 0x0e, 0xef, 0x2f, 0x1f, 0x54, 0x09, 0x2e,
+	0x77, 0xf7, 0x22, 0x0b, 0x29, 0x2e, 0x77, 0xf7, 0xfb, 0x6f, 0x50, 0x5e,
+	0xb8, 0x2e, 0x10, 0x50, 0x01, 0x2e, 0xff, 0x00, 0x00, 0xb2, 0xfb, 0x7f,
+	0x51, 0x2f, 0x01, 0xb2, 0x48, 0x2f, 0x02, 0xb2, 0x42, 0x2f, 0x03, 0x90,
+	0x56, 0x2f, 0xa3, 0x52, 0x79, 0x80, 0x42, 0x40, 0x81, 0x84, 0x00, 0x40,
+	0x42, 0x42, 0x98, 0x2e, 0x93, 0x0c, 0xa5, 0x54, 0xa3, 0x50, 0xa1, 0x40,
+	0x98, 0xbd, 0x82, 0x40, 0x3e, 0x82, 0xda, 0x0a, 0x44, 0x40, 0x8b, 0x16,
+	0xe3, 0x00, 0x53, 0x42, 0x00, 0x2e, 0x43, 0x40, 0x9a, 0x02, 0x52, 0x42,
+	0x00, 0x2e, 0x41, 0x40, 0x1f, 0x54, 0x4a, 0x0e, 0x3a, 0x2f, 0x3a, 0x82,
+	0x00, 0x30, 0x41, 0x40, 0x21, 0x2e, 0x94, 0x0f, 0x40, 0xb2, 0x0a, 0x2f,
+	0x98, 0x2e, 0xb1, 0x0c, 0x98, 0x2e, 0x45, 0x0e, 0x98, 0x2e, 0x5b, 0x0e,
+	0xfb, 0x6f, 0xf0, 0x5f, 0x00, 0x30, 0x80, 0x2e, 0xf8, 0xb6, 0xa9, 0x52,
+	0x9f, 0x54, 0x42, 0x42, 0x4f, 0x84, 0x73, 0x30, 0xa7, 0x52, 0x83, 0x42,
+	0x1b, 0x30, 0x6b, 0x42, 0x23, 0x30, 0x27, 0x2e, 0x6c, 0x01, 0x37, 0x2e,
+	0xff, 0x00, 0x21, 0x2e, 0x6b, 0x01, 0x7a, 0x84, 0x17, 0x2c, 0x42, 0x42,
+	0x30, 0x30, 0x21, 0x2e, 0xff, 0x00, 0x12, 0x2d, 0x21, 0x30, 0x00, 0x30,
+	0x23, 0x2e, 0xff, 0x00, 0x21, 0x2e, 0x7b, 0xf7, 0x0b, 0x2d, 0x17, 0x30,
+	0x98, 0x2e, 0x51, 0x0c, 0xa1, 0x50, 0x0c, 0x82, 0x72, 0x30, 0x2f, 0x2e,
+	0xff, 0x00, 0x25, 0x2e, 0x7b, 0xf7, 0x40, 0x42, 0x00, 0x2e, 0xfb, 0x6f,
+	0xf0, 0x5f, 0xb8, 0x2e, 0x70, 0x50, 0x0a, 0x25, 0x39, 0x86, 0xfb, 0x7f,
+	0xe1, 0x32, 0x62, 0x30, 0x98, 0x2e, 0xc2, 0xc4, 0x81, 0x56, 0xa5, 0x6f,
+	0xab, 0x08, 0x91, 0x6f, 0x4b, 0x08, 0xab, 0x56, 0xc4, 0x6f, 0x23, 0x09,
+	0x4d, 0xba, 0x93, 0xbc, 0x8c, 0x0b, 0xd1, 0x6f, 0x0b, 0x09, 0x97, 0x52,
+	0xad, 0x5e, 0x56, 0x42, 0xaf, 0x09, 0x4d, 0xba, 0x23, 0xbd, 0x94, 0x0a,
+	0xe5, 0x6f, 0x68, 0xbb, 0xeb, 0x08, 0xbd, 0xb9, 0x63, 0xbe, 0xfb, 0x6f,
+	0x52, 0x42, 0xe3, 0x0a, 0xc0, 0x2e, 0x43, 0x42, 0x90, 0x5f, 0x9d, 0x50,
+	0x03, 0x2e, 0x25, 0xf3, 0x13, 0x40, 0x00, 0x40, 0x9b, 0xbc, 0x9b, 0xb4,
+	0x08, 0xbd, 0xb8, 0xb9, 0x98, 0xbc, 0xda, 0x0a, 0x08, 0xb6, 0x89, 0x16,
+	0xc0, 0x2e, 0x19, 0x00, 0x62, 0x02, 0x10, 0x50, 0xfb, 0x7f, 0x98, 0x2e,
+	0x81, 0x0d, 0x01, 0x2e, 0xff, 0x00, 0x31, 0x30, 0x08, 0x04, 0xfb, 0x6f,
+	0x01, 0x30, 0xf0, 0x5f, 0x23, 0x2e, 0x6b, 0x01, 0x21, 0x2e, 0x6c, 0x01,
+	0xb8, 0x2e, 0x01, 0x2e, 0x6c, 0x01, 0x03, 0x2e, 0x6b, 0x01, 0x48, 0x0e,
+	0x01, 0x2f, 0x80, 0x2e, 0x1f, 0x0e, 0xb8, 0x2e, 0xaf, 0x50, 0x21, 0x34,
+	0x01, 0x42, 0x82, 0x30, 0xc1, 0x32, 0x25, 0x2e, 0x62, 0xf5, 0x01, 0x00,
+	0x22, 0x30, 0x01, 0x40, 0x4a, 0x0a, 0x01, 0x42, 0xb8, 0x2e, 0xaf, 0x54,
+	0xf0, 0x3b, 0x83, 0x40, 0xd8, 0x08, 0xb1, 0x52, 0x83, 0x42, 0x00, 0x30,
+	0x83, 0x30, 0x50, 0x42, 0xc4, 0x32, 0x27, 0x2e, 0x64, 0xf5, 0x94, 0x00,
+	0x50, 0x42, 0x40, 0x42, 0xd3, 0x3f, 0x84, 0x40, 0x7d, 0x82, 0xe3, 0x08,
+	0x40, 0x42, 0x83, 0x42, 0xb8, 0x2e, 0xa9, 0x52, 0x00, 0x30, 0x40, 0x42,
+	0x7c, 0x86, 0x85, 0x52, 0x09, 0x2e, 0x7f, 0x0f, 0x8b, 0x54, 0xc4, 0x42,
+	0xd3, 0x86, 0x54, 0x40, 0x55, 0x40, 0x94, 0x42, 0x85, 0x42, 0x21, 0x2e,
+	0x6c, 0x01, 0x42, 0x40, 0x25, 0x2e, 0xfd, 0xf3, 0xc0, 0x42, 0x7e, 0x82,
+	0x05, 0x2e, 0xd7, 0x00, 0x80, 0xb2, 0x14, 0x2f, 0x05, 0x2e, 0x89, 0x00,
+	0x27, 0xbd, 0x2f, 0xb9, 0x80, 0x90, 0x02, 0x2f, 0x21, 0x2e, 0x6f, 0xf5,
+	0x0c, 0x2d, 0x07, 0x2e, 0x80, 0x0f, 0x14, 0x30, 0x1c, 0x09, 0x05, 0x2e,
+	0x77, 0xf7, 0x89, 0x56, 0x47, 0xbe, 0x93, 0x08, 0x94, 0x0a, 0x25, 0x2e,
+	0x77, 0xf7, 0xb3, 0x54, 0x50, 0x42, 0x4a, 0x0e, 0xfc, 0x2f, 0xb8, 0x2e,
+	0x50, 0x50, 0x02, 0x30, 0x43, 0x86, 0xb1, 0x50, 0xfb, 0x7f, 0xe3, 0x7f,
+	0xd2, 0x7f, 0xc0, 0x7f, 0xb1, 0x7f, 0x00, 0x2e, 0x41, 0x40, 0x00, 0x40,
+	0x48, 0x04, 0x98, 0x2e, 0x74, 0xc0, 0x1e, 0xaa, 0xd3, 0x6f, 0x14, 0x30,
+	0xb1, 0x6f, 0xe3, 0x22, 0xc0, 0x6f, 0x52, 0x40, 0xe4, 0x6f, 0x4c, 0x0e,
+	0x12, 0x42, 0xd3, 0x7f, 0xeb, 0x2f, 0x03, 0x2e, 0x95, 0x0f, 0x40, 0x90,
+	0x11, 0x30, 0x03, 0x2f, 0x23, 0x2e, 0x95, 0x0f, 0x02, 0x2c, 0x00, 0x30,
+	0xd0, 0x6f, 0xfb, 0x6f, 0xb0, 0x5f, 0xb8, 0x2e, 0x40, 0x50, 0xf1, 0x7f,
+	0x0a, 0x25, 0x3c, 0x86, 0xeb, 0x7f, 0x41, 0x33, 0x22, 0x30, 0x98, 0x2e,
+	0xc2, 0xc4, 0xd3, 0x6f, 0xf4, 0x30, 0xdc, 0x09, 0xb7, 0x58, 0xc2, 0x6f,
+	0x94, 0x09, 0xb9, 0x58, 0x6a, 0xbb, 0xdc, 0x08, 0xb4, 0xb9, 0xb1, 0xbd,
+	0xb5, 0x5a, 0x95, 0x08, 0x21, 0xbd, 0xf6, 0xbf, 0x77, 0x0b, 0x51, 0xbe,
+	0xf1, 0x6f, 0xeb, 0x6f, 0x52, 0x42, 0x54, 0x42, 0xc0, 0x2e, 0x43, 0x42,
+	0xc0, 0x5f, 0x50, 0x50, 0xcd, 0x50, 0x31, 0x30, 0x11, 0x42, 0xfb, 0x7f,
+	0x7b, 0x30, 0x0b, 0x42, 0x11, 0x30, 0x02, 0x80, 0x23, 0x33, 0x01, 0x42,
+	0x03, 0x00, 0x07, 0x2e, 0x80, 0x03, 0x05, 0x2e, 0xd5, 0x00, 0x49, 0x52,
+	0xe2, 0x7f, 0xd3, 0x7f, 0xc0, 0x7f, 0x98, 0x2e, 0xb6, 0x0e, 0xd1, 0x6f,
+	0x08, 0x0a, 0x1a, 0x25, 0x7b, 0x86, 0xd0, 0x7f, 0x01, 0x33, 0x12, 0x30,
+	0x98, 0x2e, 0xc2, 0xc4, 0xd1, 0x6f, 0x08, 0x0a, 0x00, 0xb2, 0x0d, 0x2f,
+	0xe3, 0x6f, 0x01, 0x2e, 0x80, 0x03, 0x51, 0x30, 0xc7, 0x86, 0x23, 0x2e,
+	0x21, 0xf2, 0x08, 0xbc, 0xc0, 0x42, 0x98, 0x2e, 0x0b, 0x03, 0x00, 0x2e,
+	0x00, 0x2e, 0xd0, 0x2e, 0xb0, 0x6f, 0x0b, 0xb8, 0x03, 0x2e, 0x1b, 0x00,
+	0x08, 0x1a, 0xb0, 0x7f, 0x70, 0x30, 0x04, 0x2f, 0x21, 0x2e, 0x21, 0xf2,
+	0x00, 0x2e, 0x00, 0x2e, 0xd0, 0x2e, 0x98, 0x2e, 0x6d, 0xc0, 0x98, 0x2e,
+	0x5d, 0xc0, 0xbb, 0x50, 0x98, 0x2e, 0x46, 0xc3, 0xbd, 0x50, 0x98, 0x2e,
+	0xfc, 0xc5, 0xbf, 0x50, 0x21, 0x2e, 0x77, 0x01, 0x6f, 0x50, 0x98, 0x2e,
+	0x64, 0xcf, 0xc3, 0x50, 0x21, 0x2e, 0x85, 0x01, 0xc1, 0x56, 0xc5, 0x52,
+	0x27, 0x2e, 0x86, 0x01, 0x23, 0x2e, 0x87, 0x01, 0xc7, 0x50, 0x98, 0x2e,
+	0x53, 0xc7, 0xc9, 0x50, 0x98, 0x2e, 0x44, 0xcb, 0x10, 0x30, 0x98, 0x2e,
+	0xcd, 0xb6, 0x20, 0x26, 0xc0, 0x6f, 0x02, 0x31, 0x12, 0x42, 0xab, 0x33,
+	0x0b, 0x42, 0x37, 0x80, 0x01, 0x30, 0x01, 0x42, 0xf3, 0x37, 0xcf, 0x52,
+	0xd3, 0x50, 0x44, 0x40, 0xa2, 0x0a, 0x42, 0x42, 0x8b, 0x31, 0x09, 0x2e,
+	0x5e, 0xf7, 0xd1, 0x54, 0xe3, 0x08, 0x83, 0x42, 0x1b, 0x42, 0x23, 0x33,
+	0x4b, 0x00, 0xbc, 0x84, 0x0b, 0x40, 0x33, 0x30, 0x83, 0x42, 0x0b, 0x42,
+	0xe0, 0x7f, 0xd1, 0x7f, 0x98, 0x2e, 0x07, 0x02, 0xd1, 0x6f, 0x80, 0x30,
+	0x40, 0x42, 0x03, 0x30, 0xe0, 0x6f, 0xcb, 0x54, 0x04, 0x30, 0x00, 0x2e,
+	0x00, 0x2e, 0x01, 0x89, 0x62, 0x0e, 0xfa, 0x2f, 0x43, 0x42, 0x11, 0x30,
+	0xfb, 0x6f, 0xc0, 0x2e, 0x01, 0x42, 0xb0, 0x5f, 0xc1, 0x4a, 0x00, 0x00,
+	0x6d, 0x57, 0x00, 0x00, 0x77, 0x8e, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff,
+	0xd3, 0xff, 0xff, 0xff, 0xe5, 0xff, 0xff, 0xff, 0xee, 0xe1, 0xff, 0xff,
+	0x7c, 0x13, 0x00, 0x00, 0x46, 0xe6, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0x80, 0x2e,
+	0x00, 0xc1, 0x80, 0x2e, 0x00, 0xc1, 0xfd, 0x2d
+};
diff --git a/drivers/custom/bmi260/bmi260_core.c b/drivers/custom/bmi260/bmi260_core.c
new file mode 100644
index 000000000000..d27414814710
--- /dev/null
+++ b/drivers/custom/bmi260/bmi260_core.c
@@ -0,0 +1,1022 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * IIO core driver for Bosch BMI260 6-Axis IMU.
+ *
+ * Copyright (C) 2023, Justin Weiss <justin@justinweiss.com>
+ */
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/property.h>
+#include <linux/regulator/consumer.h>
+#include <linux/acpi.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+
+#include "bmi260.h"
+#include "bmi260_config.h"
+
+#define BMI260_REG_CHIP_ID	0x00
+#define BMI260_CHIP_ID_VAL	0x27 /* 0x24 for BMI270 */
+
+#define BMI260_REG_PMU_STATUS	0x03
+
+/* X axis data low byte address, the rest can be obtained using axis offset */
+#define BMI260_REG_DATA_AUX_XOUT_L	0x04
+#define BMI260_REG_DATA_ACCEL_XOUT_L	0x0C
+#define BMI260_REG_DATA_GYRO_XOUT_L	0x12
+
+#define BMI260_REG_INTERNAL_STATUS	0x21
+#define BMI260_STATUS_MESSAGE_MASK	GENMASK(3, 0)
+
+#define BMI260_REG_ACCEL_CONFIG		0x40
+#define BMI260_ACCEL_CONFIG_ODR_MASK	GENMASK(3, 0)
+#define BMI260_ACCEL_CONFIG_BWP_MASK	GENMASK(6, 4)
+
+#define BMI260_REG_ACCEL_RANGE		0x41
+#define BMI260_ACCEL_RANGE_MASK		GENMASK(1, 0)
+#define BMI260_ACCEL_RANGE_2G		0x00
+#define BMI260_ACCEL_RANGE_4G		0x01
+#define BMI260_ACCEL_RANGE_8G		0x02
+#define BMI260_ACCEL_RANGE_16G		0x03
+
+#define BMI260_REG_GYRO_CONFIG		0x42
+#define BMI260_GYRO_CONFIG_ODR_MASK	GENMASK(3, 0)
+#define BMI260_GYRO_CONFIG_BWP_MASK	GENMASK(5, 4)
+
+#define BMI260_REG_GYRO_RANGE		0x43
+#define BMI260_GYRO_RANGE_MASK		GENMASK(2, 0)
+#define BMI260_GYRO_RANGE_2000DPS	0x00
+#define BMI260_GYRO_RANGE_1000DPS	0x01
+#define BMI260_GYRO_RANGE_500DPS	0x02
+#define BMI260_GYRO_RANGE_250DPS	0x03
+#define BMI260_GYRO_RANGE_125DPS	0x04
+
+#define BMI260_REG_INIT_CTRL		0x59
+#define BMI260_REG_INIT_DATA		0x5E
+
+#define BMI260_REG_PWR_CONF		0x7C
+#define BMI260_PWR_CONF_ADV_PWR_SAVE	BIT(0)
+#define BMI260_PWR_CONF_FIFO_WAKE_UP	BIT(1)
+#define BMI260_PWR_CONF_FUP_EN		BIT(2)
+
+#define BMI260_REG_PWR_CTRL		0x7D
+#define BMI260_PWR_CTRL_AUX_EN		BIT(0)
+#define BMI260_PWR_CTRL_GYR_EN		BIT(1)
+#define BMI260_PWR_CTRL_ACC_EN		BIT(2)
+#define BMI260_PWR_CTRL_TEMP_EN		BIT(3)
+
+#define BMI260_REG_CMD			0x7E
+#define BMI260_CMD_SOFTRESET		0xB6
+
+#define BMI260_REG_FIFO_CONFIG_1	0x49
+#define BMI260_FIFO_TAG_INT1_LEVEL	BIT(0)
+#define BMI260_FIFO_TAG_INT2_LEVEL	BIT(2)
+
+#define BMI260_REG_INT1_IO_CTRL		0x53
+#define BMI260_REG_INT2_IO_CTRL		0x54
+#define BMI260_INT_IO_CTRL_MASK		GENMASK(4, 1)
+#define BMI260_ACTIVE_HIGH		BIT(1)
+#define BMI260_OPEN_DRAIN		BIT(2)
+#define BMI260_OUTPUT_EN		BIT(3)
+#define BMI260_INPUT_EN			BIT(4)
+
+#define BMI260_REG_INT_MAP_DATA		0x58
+#define BMI260_INT1_MAP_DRDY_EN		BIT(2)
+#define BMI260_INT2_MAP_DRDY_EN		BIT(6)
+
+#define BMI260_REG_DUMMY		0x7F
+
+#define BMI260_NORMAL_WRITE_USLEEP	2
+#define BMI260_SUSPENDED_WRITE_USLEEP	450
+#define BMI260_SOFTRESET_USLEEP		2000
+#define BMI260_INIT_USLEEP		22000
+
+#define BMI260_CHANNEL(_type, _axis, _index) {			\
+	.type = _type,						\
+	.modified = 1,						\
+	.channel2 = IIO_MOD_##_axis,				\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),		\
+	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) |  \
+		BIT(IIO_CHAN_INFO_SAMP_FREQ),			\
+	.scan_index = _index,					\
+	.scan_type = {						\
+		.sign = 's',					\
+		.realbits = 16,					\
+		.storagebits = 16,				\
+		.endianness = IIO_LE,				\
+	},							\
+	.ext_info = bmi260_ext_info,				\
+}
+
+/* scan indexes follow DATA register order */
+enum bmi260_scan_axis {
+	BMI260_SCAN_AUX_X = 0,
+	BMI260_SCAN_AUX_Y,
+	BMI260_SCAN_AUX_Z,
+	BMI260_SCAN_AUX_R,
+	BMI260_SCAN_ACCEL_X,
+	BMI260_SCAN_ACCEL_Y,
+	BMI260_SCAN_ACCEL_Z,
+	BMI260_SCAN_GYRO_X,
+	BMI260_SCAN_GYRO_Y,
+	BMI260_SCAN_GYRO_Z,
+	BMI260_SCAN_TIMESTAMP,
+};
+
+enum bmi260_sensor_type {
+	BMI260_ACCEL	= 0,
+	BMI260_GYRO,
+	BMI260_AUX,
+	BMI260_NUM_SENSORS /* must be last */
+};
+
+const struct regmap_config bmi260_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+BMI260_EXPORT_SYMBOL(bmi260_regmap_config);
+
+struct bmi260_regs {
+	u8 data; /* LSB byte register for X-axis */
+	u8 config;
+	u8 config_odr_mask;
+	u8 config_bwp_mask;
+	u8 range;
+};
+
+static struct bmi260_regs bmi260_regs[] = {
+	[BMI260_ACCEL] = {
+		.data	= BMI260_REG_DATA_ACCEL_XOUT_L,
+		.config	= BMI260_REG_ACCEL_CONFIG,
+		.config_odr_mask = BMI260_ACCEL_CONFIG_ODR_MASK,
+		.config_bwp_mask = BMI260_ACCEL_CONFIG_BWP_MASK,
+		.range	= BMI260_REG_ACCEL_RANGE,
+	},
+	[BMI260_GYRO] = {
+		.data	= BMI260_REG_DATA_GYRO_XOUT_L,
+		.config	= BMI260_REG_GYRO_CONFIG,
+		.config_odr_mask = BMI260_GYRO_CONFIG_ODR_MASK,
+		.config_bwp_mask = BMI260_GYRO_CONFIG_BWP_MASK,
+		.range	= BMI260_REG_GYRO_RANGE,
+	},
+};
+
+struct bmi260_scale {
+	u8 bits;
+	int uscale;
+};
+
+struct bmi260_odr {
+	u8 bits;
+	int odr;
+	int uodr;
+};
+
+static const struct bmi260_scale bmi260_accel_scale[] = {
+	{ BMI260_ACCEL_RANGE_2G, 598},
+	{ BMI260_ACCEL_RANGE_4G, 1197},
+	{ BMI260_ACCEL_RANGE_8G, 2394},
+	{ BMI260_ACCEL_RANGE_16G, 4788},
+};
+
+static const struct bmi260_scale bmi260_gyro_scale[] = {
+	{ BMI260_GYRO_RANGE_2000DPS, 1065},
+	{ BMI260_GYRO_RANGE_1000DPS, 532},
+	{ BMI260_GYRO_RANGE_500DPS, 266},
+	{ BMI260_GYRO_RANGE_250DPS, 133},
+	{ BMI260_GYRO_RANGE_125DPS, 66},
+};
+
+struct bmi260_scale_item {
+	const struct bmi260_scale *tbl;
+	int num;
+};
+
+static const struct  bmi260_scale_item bmi260_scale_table[] = {
+	[BMI260_ACCEL] = {
+		.tbl	= bmi260_accel_scale,
+		.num	= ARRAY_SIZE(bmi260_accel_scale),
+	},
+	[BMI260_GYRO] = {
+		.tbl	= bmi260_gyro_scale,
+		.num	= ARRAY_SIZE(bmi260_gyro_scale),
+	},
+};
+
+static const struct bmi260_odr bmi260_accel_odr[] = {
+	{0x01, 0, 781250},
+	{0x02, 1, 562500},
+	{0x03, 3, 125000},
+	{0x04, 6, 250000},
+	{0x05, 12, 500000},
+	{0x06, 25, 0},
+	{0x07, 50, 0},
+	{0x08, 100, 0},
+	{0x09, 200, 0},
+	{0x0A, 400, 0},
+	{0x0B, 800, 0},
+	{0x0C, 1600, 0},
+};
+
+static const struct bmi260_odr bmi260_gyro_odr[] = {
+	{0x06, 25, 0},
+	{0x07, 50, 0},
+	{0x08, 100, 0},
+	{0x09, 200, 0},
+	{0x0A, 400, 0},
+	{0x0B, 800, 0},
+	{0x0C, 1600, 0},
+	{0x0D, 3200, 0},
+};
+
+struct bmi260_odr_item {
+	const struct bmi260_odr *tbl;
+	int num;
+};
+
+static const struct  bmi260_odr_item bmi260_odr_table[] = {
+	[BMI260_ACCEL] = {
+		.tbl	= bmi260_accel_odr,
+		.num	= ARRAY_SIZE(bmi260_accel_odr),
+	},
+	[BMI260_GYRO] = {
+		.tbl	= bmi260_gyro_odr,
+		.num	= ARRAY_SIZE(bmi260_gyro_odr),
+	},
+};
+
+#ifdef CONFIG_ACPI
+/*
+ * Support for getting accelerometer information from ACPI nodes.
+ * Based off of the bmc150 implementation.
+ */
+static bool bmi260_apply_acpi_orientation(struct device *dev,
+					  struct iio_mount_matrix *orientation)
+{
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct acpi_device *adev = ACPI_COMPANION(dev);
+	char *name, *alt_name, *label, *str;
+	union acpi_object *obj, *elements;
+	acpi_status status;
+	int i, j, val[3];
+
+	if (!adev)
+		return false;
+
+	alt_name = "ROMS";
+	label = "accel-display";
+
+	if (acpi_has_method(adev->handle, alt_name)) {
+		name = alt_name;
+		indio_dev->label = label;
+	} else {
+		return false;
+	}
+
+	status = acpi_evaluate_object(adev->handle, name, NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_warn(dev, "Failed to get ACPI mount matrix: %d\n", status);
+		return false;
+	}
+
+	obj = buffer.pointer;
+	if (obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 3)
+		goto unknown_format;
+
+	elements = obj->package.elements;
+	for (i = 0; i < 3; i++) {
+		if (elements[i].type != ACPI_TYPE_STRING)
+			goto unknown_format;
+
+		str = elements[i].string.pointer;
+		if (sscanf(str, "%d %d %d", &val[0], &val[1], &val[2]) != 3)
+			goto unknown_format;
+
+		for (j = 0; j < 3; j++) {
+			switch (val[j]) {
+			case -1: str = "-1"; break;
+			case 0:  str = "0";  break;
+			case 1:  str = "1";  break;
+			default: goto unknown_format;
+			}
+			orientation->rotation[i * 3 + j] = str;
+		}
+	}
+
+	kfree(buffer.pointer);
+	return true;
+
+unknown_format:
+	dev_warn(dev, "Unknown ACPI mount matrix format, ignoring\n");
+	kfree(buffer.pointer);
+	return false;
+}
+
+#else
+static bool bmi260_apply_acpi_orientation(struct device *dev,
+					  struct iio_mount_matrix *orientation)
+{
+	return false;
+}
+#endif
+
+static const struct iio_mount_matrix *
+bmi260_get_mount_matrix(const struct iio_dev *indio_dev,
+			const struct iio_chan_spec *chan)
+{
+	struct bmi260_data *data = iio_priv(indio_dev);
+
+	return &data->orientation;
+}
+
+static const struct iio_chan_spec_ext_info bmi260_ext_info[] = {
+	IIO_MOUNT_MATRIX(IIO_SHARED_BY_DIR, bmi260_get_mount_matrix),
+	{ }
+};
+
+static const struct iio_chan_spec bmi260_channels[] = {
+	BMI260_CHANNEL(IIO_ACCEL, X, BMI260_SCAN_ACCEL_X),
+	BMI260_CHANNEL(IIO_ACCEL, Y, BMI260_SCAN_ACCEL_Y),
+	BMI260_CHANNEL(IIO_ACCEL, Z, BMI260_SCAN_ACCEL_Z),
+	BMI260_CHANNEL(IIO_ANGL_VEL, X, BMI260_SCAN_GYRO_X),
+	BMI260_CHANNEL(IIO_ANGL_VEL, Y, BMI260_SCAN_GYRO_Y),
+	BMI260_CHANNEL(IIO_ANGL_VEL, Z, BMI260_SCAN_GYRO_Z),
+	IIO_CHAN_SOFT_TIMESTAMP(BMI260_SCAN_TIMESTAMP),
+};
+
+static enum bmi260_sensor_type bmi260_to_sensor(enum iio_chan_type iio_type)
+{
+	switch (iio_type) {
+	case IIO_ACCEL:
+		return BMI260_ACCEL;
+	case IIO_ANGL_VEL:
+		return BMI260_GYRO;
+	default:
+		return -EINVAL;
+	}
+}
+
+static
+int bmi260_set_scale(struct bmi260_data *data, enum bmi260_sensor_type t,
+		     int uscale)
+{
+	int i;
+
+	for (i = 0; i < bmi260_scale_table[t].num; i++)
+		if (bmi260_scale_table[t].tbl[i].uscale == uscale)
+			break;
+
+	if (i == bmi260_scale_table[t].num)
+		return -EINVAL;
+
+	return regmap_write(data->regmap, bmi260_regs[t].range,
+			    bmi260_scale_table[t].tbl[i].bits);
+}
+
+static
+int bmi260_get_scale(struct bmi260_data *data, enum bmi260_sensor_type t,
+		     int *uscale)
+{
+	int i, ret, val;
+
+	ret = regmap_read(data->regmap, bmi260_regs[t].range, &val);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < bmi260_scale_table[t].num; i++)
+		if (bmi260_scale_table[t].tbl[i].bits == val) {
+			*uscale = bmi260_scale_table[t].tbl[i].uscale;
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static int bmi260_get_data(struct bmi260_data *data, int chan_type,
+			   int axis, int *val)
+{
+	u8 reg;
+	int ret;
+	__le16 sample;
+	enum bmi260_sensor_type t = bmi260_to_sensor(chan_type);
+
+	reg = bmi260_regs[t].data + (axis - IIO_MOD_X) * sizeof(sample);
+
+	ret = regmap_bulk_read(data->regmap, reg, &sample, sizeof(sample));
+	if (ret)
+		return ret;
+
+	*val = sign_extend32(le16_to_cpu(sample), 15);
+
+	return 0;
+}
+
+static
+int bmi260_set_odr(struct bmi260_data *data, enum bmi260_sensor_type t,
+		   int odr, int uodr)
+{
+	int i;
+
+	for (i = 0; i < bmi260_odr_table[t].num; i++)
+		if (bmi260_odr_table[t].tbl[i].odr == odr &&
+		    bmi260_odr_table[t].tbl[i].uodr == uodr)
+			break;
+
+	if (i >= bmi260_odr_table[t].num)
+		return -EINVAL;
+
+	return regmap_update_bits(data->regmap,
+				  bmi260_regs[t].config,
+				  bmi260_regs[t].config_odr_mask,
+				  bmi260_odr_table[t].tbl[i].bits);
+}
+
+static int bmi260_get_odr(struct bmi260_data *data, enum bmi260_sensor_type t,
+			  int *odr, int *uodr)
+{
+	int i, val, ret;
+
+	ret = regmap_read(data->regmap, bmi260_regs[t].config, &val);
+	if (ret)
+		return ret;
+
+	val &= bmi260_regs[t].config_odr_mask;
+
+	for (i = 0; i < bmi260_odr_table[t].num; i++)
+		if (val == bmi260_odr_table[t].tbl[i].bits)
+			break;
+
+	if (i >= bmi260_odr_table[t].num)
+		return -EINVAL;
+
+	*odr = bmi260_odr_table[t].tbl[i].odr;
+	*uodr = bmi260_odr_table[t].tbl[i].uodr;
+
+	return 0;
+}
+
+static irqreturn_t bmi260_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct bmi260_data *data = iio_priv(indio_dev);
+	int i, ret, j = 0, base = BMI260_REG_DATA_AUX_XOUT_L;
+	__le16 sample;
+
+	if (data->conf.suspended)
+		return IRQ_NONE;
+
+	for_each_set_bit(i, indio_dev->active_scan_mask,
+			 indio_dev->masklength) {
+		ret = regmap_bulk_read(data->regmap, base + i * sizeof(sample),
+				       &sample, sizeof(sample));
+		if (ret)
+			goto done;
+		data->buf[j++] = sample;
+	}
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data->buf, pf->timestamp);
+done:
+	iio_trigger_notify_done(indio_dev->trig);
+	return IRQ_HANDLED;
+}
+
+static int bmi260_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val, int *val2, long mask)
+{
+	int ret;
+	struct bmi260_data *data = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = bmi260_get_data(data, chan->type, chan->channel2, val);
+		if (ret)
+			return ret;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		ret = bmi260_get_scale(data,
+				       bmi260_to_sensor(chan->type), val2);
+		return ret ? ret : IIO_VAL_INT_PLUS_MICRO;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		ret = bmi260_get_odr(data, bmi260_to_sensor(chan->type),
+				     val, val2);
+		return ret ? ret : IIO_VAL_INT_PLUS_MICRO;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int bmi260_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val, int val2, long mask)
+{
+	struct bmi260_data *data = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		return bmi260_set_scale(data,
+					bmi260_to_sensor(chan->type), val2);
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		return bmi260_set_odr(data, bmi260_to_sensor(chan->type),
+				      val, val2);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static
+IIO_CONST_ATTR(in_accel_sampling_frequency_available,
+	       "0.78125 1.5625 3.125 6.25 12.5 25 50 100 200 400 800 1600");
+static
+IIO_CONST_ATTR(in_anglvel_sampling_frequency_available,
+	       "25 50 100 200 400 800 1600 3200");
+static
+IIO_CONST_ATTR(in_accel_scale_available,
+	       "0.000598 0.001197 0.002394 0.004788");
+static
+IIO_CONST_ATTR(in_anglvel_scale_available,
+	       "0.001065 0.000532 0.000266 0.000133 0.000066");
+
+static struct attribute *bmi260_attrs[] = {
+	&iio_const_attr_in_accel_sampling_frequency_available.dev_attr.attr,
+	&iio_const_attr_in_anglvel_sampling_frequency_available.dev_attr.attr,
+	&iio_const_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_const_attr_in_anglvel_scale_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group bmi260_attrs_group = {
+	.attrs = bmi260_attrs,
+};
+
+static const struct iio_info bmi260_info = {
+	.read_raw = bmi260_read_raw,
+	.write_raw = bmi260_write_raw,
+	.attrs = &bmi260_attrs_group,
+};
+
+static int bmi260_write_conf_reg(struct regmap *regmap, unsigned int reg,
+				 unsigned int mask, unsigned int bits,
+				 unsigned int write_usleep)
+{
+	int ret;
+	unsigned int val;
+
+	ret = regmap_read(regmap, reg, &val);
+	if (ret)
+		return ret;
+
+	val = (val & ~mask) | bits;
+
+	ret = regmap_write(regmap, reg, val);
+	if (ret)
+		return ret;
+
+	/*
+	 * We need to wait after writing before we can write again. See the
+	 * datasheet, page 93.
+	 */
+	usleep_range(write_usleep, write_usleep + 1000);
+
+	return 0;
+}
+
+static int bmi260_config_pin(struct regmap *regmap, enum bmi260_int_pin pin,
+			     bool level_triggered, u8 irq_mask,
+			     unsigned long write_usleep)
+{
+	int ret;
+	struct device *dev = regmap_get_device(regmap);
+	unsigned int ctrl_reg;
+	unsigned int drdy_val;
+	unsigned int level_val;
+	u8 int_out_ctrl_bits;
+	const char *pin_name;
+
+	switch (pin) {
+	case BMI260_PIN_INT1:
+		ctrl_reg = BMI260_REG_INT1_IO_CTRL;
+		drdy_val = BMI260_INT1_MAP_DRDY_EN;
+		level_val = BMI260_FIFO_TAG_INT1_LEVEL;
+		break;
+	case BMI260_PIN_INT2:
+		ctrl_reg = BMI260_REG_INT2_IO_CTRL;
+		drdy_val = BMI260_INT2_MAP_DRDY_EN;
+		level_val = BMI260_FIFO_TAG_INT2_LEVEL;
+		break;
+	}
+
+	/*
+	 * Enable the requested pin with the right settings:
+	 * - Push-pull/open-drain
+	 * - Active low/high
+	 */
+	int_out_ctrl_bits = BMI260_OUTPUT_EN | BMI260_INPUT_EN;
+	int_out_ctrl_bits |= irq_mask;
+
+	ret = bmi260_write_conf_reg(regmap, ctrl_reg,
+				    BMI260_INT_IO_CTRL_MASK, int_out_ctrl_bits,
+				    write_usleep);
+	if (ret)
+		return ret;
+
+	/* Set level/edge triggered */
+	if (level_triggered) {
+		ret = bmi260_write_conf_reg(regmap, BMI260_REG_FIFO_CONFIG_1,
+		                            level_val, level_val,
+		                            write_usleep);
+		if (ret)
+			return ret;
+	}
+
+	/* Map interrupts to the requested pin. */
+	ret = bmi260_write_conf_reg(regmap, BMI260_REG_INT_MAP_DATA,
+				    drdy_val, drdy_val,
+				    write_usleep);
+	if (ret) {
+		switch (pin) {
+		case BMI260_PIN_INT1:
+			pin_name = "INT1";
+			break;
+		case BMI260_PIN_INT2:
+			pin_name = "INT2";
+			break;
+		}
+		dev_err(dev, "Failed to configure %s IRQ pin", pin_name);
+	}
+
+	return ret;
+}
+
+int bmi260_enable_irq(struct regmap *regmap, enum bmi260_int_pin pin, bool enable)
+{
+	unsigned int enable_bit = 0;
+	unsigned int mask = 0;
+
+	switch (pin) {
+	case BMI260_PIN_INT1:
+		mask = BMI260_INT1_MAP_DRDY_EN;
+		break;
+	case BMI260_PIN_INT2:
+		mask = BMI260_INT2_MAP_DRDY_EN;
+		break;
+	}
+
+	if (enable)
+		enable_bit = mask;
+
+	return bmi260_write_conf_reg(regmap, BMI260_REG_INT_MAP_DATA,
+				     mask, enable_bit,
+				     BMI260_NORMAL_WRITE_USLEEP);
+}
+BMI260_EXPORT_SYMBOL(bmi260_enable_irq);
+
+static int bmi260_get_irq(struct fwnode_handle *fwnode, enum bmi260_int_pin *pin)
+{
+	int irq;
+
+	/* Use INT1 if possible, otherwise fall back to INT2. */
+	irq = fwnode_irq_get_byname(fwnode, "INT1");
+	if (irq > 0) {
+		*pin = BMI260_PIN_INT1;
+		return irq;
+	}
+
+	irq = fwnode_irq_get_byname(fwnode, "INT2");
+	if (irq > 0)
+		*pin = BMI260_PIN_INT2;
+
+	return irq;
+}
+
+static int bmi260_config_device_irq(struct iio_dev *indio_dev, int irq_type,
+				    enum bmi260_int_pin pin)
+{
+	bool open_drain;
+	u8 irq_mask;
+	bool level_triggered = true;
+	struct bmi260_data *data = iio_priv(indio_dev);
+	struct device *dev = regmap_get_device(data->regmap);
+
+	/* Edge-triggered, active-low is the default if we set all zeroes. */
+	if (irq_type == IRQF_TRIGGER_RISING) {
+		irq_mask = BMI260_ACTIVE_HIGH;
+		level_triggered = false;
+	} else if (irq_type == IRQF_TRIGGER_FALLING) {
+		irq_mask = 0;
+		level_triggered = false;
+	} else if (irq_type == IRQF_TRIGGER_HIGH) {
+		irq_mask = BMI260_ACTIVE_HIGH;
+	} else if (irq_type == IRQF_TRIGGER_LOW) {
+		irq_mask = 0;
+	} else {
+		dev_err(&indio_dev->dev,
+			"Invalid interrupt type 0x%x specified\n", irq_type);
+		return -EINVAL;
+	}
+
+	open_drain = device_property_read_bool(dev, "drive-open-drain");
+
+	if (open_drain)
+		irq_mask |= BMI260_OPEN_DRAIN;
+
+	return bmi260_config_pin(data->regmap, pin, level_triggered, irq_mask,
+				 BMI260_NORMAL_WRITE_USLEEP);
+}
+
+static int bmi260_setup_irq(struct iio_dev *indio_dev, int irq,
+			    enum bmi260_int_pin pin)
+{
+	struct irq_data *desc;
+	u32 irq_type;
+	int ret;
+
+	desc = irq_get_irq_data(irq);
+	if (!desc) {
+		dev_err(&indio_dev->dev, "Could not find IRQ %d\n", irq);
+		return -EINVAL;
+	}
+
+	irq_type = irqd_get_trigger_type(desc);
+
+	ret = bmi260_config_device_irq(indio_dev, irq_type, pin);
+	if (ret)
+		return ret;
+
+	return bmi260_probe_trigger(indio_dev, irq, irq_type);
+}
+
+static int bmi260_chip_init(void *void_data)
+{
+	struct bmi260_data *data = void_data;
+	int ret;
+	unsigned int val;
+	struct device *dev = regmap_get_device(data->regmap);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(data->supplies), data->supplies);
+	if (ret) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(data->regmap, BMI260_REG_CMD, BMI260_CMD_SOFTRESET);
+	if (ret)
+		goto disable_regulator;
+
+	usleep_range(BMI260_SOFTRESET_USLEEP, BMI260_SOFTRESET_USLEEP + 1);
+
+	/*
+	 * CS rising edge is needed before starting SPI, so do a dummy read
+	 * See Section 4.4, page 25 of the datasheet
+	 */
+	if (data->use_spi) {
+		ret = regmap_read(data->regmap, BMI260_REG_DUMMY, &val);
+		if (ret)
+			goto disable_regulator;
+	}
+
+	ret = regmap_read(data->regmap, BMI260_REG_CHIP_ID, &val);
+	if (ret) {
+		dev_err(dev, "Error reading chip id\n");
+		goto disable_regulator;
+	}
+	if (val != BMI260_CHIP_ID_VAL) {
+		dev_err(dev, "Wrong chip id, got %x expected %x\n",
+			val, BMI260_CHIP_ID_VAL);
+		ret = -ENODEV;
+		goto disable_regulator;
+	}
+
+	ret = bmi260_write_conf_reg(data->regmap, BMI260_REG_PWR_CONF,
+				    BMI260_PWR_CONF_ADV_PWR_SAVE, false,
+				    BMI260_SUSPENDED_WRITE_USLEEP);
+	if (ret) {
+		dev_err(dev, "Error disabling advanced power saving\n");
+		goto disable_regulator;
+	}
+
+	/* Upload the config file */
+	ret = regmap_write(data->regmap, BMI260_REG_INIT_CTRL, 0);
+	if (ret) {
+		dev_err(dev, "Error preparing for config upload\n");
+		goto disable_regulator;
+	}
+
+	ret = regmap_raw_write(data->regmap, BMI260_REG_INIT_DATA, bmi260_config_file, ARRAY_SIZE(bmi260_config_file));
+	if (ret) {
+		dev_err(dev, "Error uploading config\n");
+		goto disable_regulator;
+	}
+
+	ret = regmap_write(data->regmap, BMI260_REG_INIT_CTRL, 1);
+	if (ret) {
+		dev_err(dev, "Error finalizing config upload\n");
+		goto disable_regulator;
+	}
+
+	usleep_range(BMI260_INIT_USLEEP, BMI260_INIT_USLEEP + 1);
+
+	ret = regmap_read(data->regmap, BMI260_REG_INTERNAL_STATUS, &val);
+	if (ret) {
+		dev_err(dev, "Error reading chip status\n");
+		goto disable_regulator;
+	}
+	if ((val & BMI260_STATUS_MESSAGE_MASK) != 0x01) {
+		dev_err(dev, "Chip failed to init\n");
+		ret = -ENODEV;
+		goto disable_regulator;
+	}
+
+	/* Enable accel and gyro */
+	ret = regmap_update_bits(data->regmap, BMI260_REG_PWR_CTRL,
+				 BMI260_PWR_CTRL_ACC_EN | BMI260_PWR_CTRL_GYR_EN,
+				 BMI260_PWR_CTRL_ACC_EN | BMI260_PWR_CTRL_GYR_EN);
+	if (ret)
+		goto disable_regulator;
+
+	return 0;
+
+disable_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(data->supplies), data->supplies);
+	return ret;
+}
+
+static int bmi260_data_rdy_trigger_set_state(struct iio_trigger *trig,
+					     bool enable)
+{
+	struct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);
+	struct bmi260_data *data = iio_priv(indio_dev);
+	// FIXME: the irq enable func is exported, it could be called from elsewhere
+	data->conf.irq = enable;
+	
+	return bmi260_enable_irq(data->regmap, data->int_pin, enable);
+}
+static const struct iio_trigger_ops bmi260_trigger_ops = {
+	.set_trigger_state = &bmi260_data_rdy_trigger_set_state,
+};
+
+int bmi260_probe_trigger(struct iio_dev *indio_dev, int irq, u32 irq_type)
+{
+	struct bmi260_data *data = iio_priv(indio_dev);
+	int ret;
+
+	data->trig = devm_iio_trigger_alloc(&indio_dev->dev, "%s-dev%d",
+					    indio_dev->name,
+					    iio_device_id(indio_dev));
+
+	if (data->trig == NULL)
+		return -ENOMEM;
+
+	ret = devm_request_irq(&indio_dev->dev, irq,
+			       &iio_trigger_generic_data_rdy_poll,
+			       irq_type, "bmi260", data->trig);
+	if (ret)
+		return ret;
+
+	data->trig->dev.parent = regmap_get_device(data->regmap);
+	data->trig->ops = &bmi260_trigger_ops;
+	iio_trigger_set_drvdata(data->trig, indio_dev);
+
+	ret = devm_iio_trigger_register(&indio_dev->dev, data->trig);
+	if (ret)
+		return ret;
+
+	indio_dev->trig = iio_trigger_get(data->trig);
+
+	return 0;
+}
+
+static void bmi260_chip_uninit(void *data)
+{
+	struct bmi260_data *bmi_data = data;
+	struct device *dev = regmap_get_device(bmi_data->regmap);
+	int ret;
+
+	/* Disable accel and gyro */
+	regmap_update_bits(bmi_data->regmap, BMI260_REG_PWR_CTRL,
+			   BMI260_PWR_CTRL_ACC_EN | BMI260_PWR_CTRL_GYR_EN,
+			   0);
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(bmi_data->supplies),
+				     bmi_data->supplies);
+	if (ret)
+		dev_err(dev, "Failed to disable regulators: %d\n", ret);
+}
+
+int bmi260_core_probe(struct device *dev, struct regmap *regmap,
+		      int irq, const char *name, bool use_spi)
+{
+	struct iio_dev *indio_dev;
+	struct bmi260_data *data;
+	enum bmi260_int_pin int_pin = BMI260_PIN_INT1;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(dev, sizeof(*data));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	data = iio_priv(indio_dev);
+	dev_set_drvdata(dev, indio_dev);
+	data->regmap = regmap;
+	data->use_spi = use_spi;
+
+	data->supplies[0].supply = "vdd";
+	data->supplies[1].supply = "vddio";
+	ret = devm_regulator_bulk_get(dev,
+				      ARRAY_SIZE(data->supplies),
+				      data->supplies);
+	if (ret) {
+		dev_err(dev, "Failed to get regulators: %d\n", ret);
+		return ret;
+	}
+
+	if (!bmi260_apply_acpi_orientation(dev, &data->orientation)) {
+		ret = iio_read_mount_matrix(dev, &data->orientation);
+		if (ret)
+			return ret;
+	}
+
+	ret = bmi260_chip_init(data);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action_or_reset(dev, bmi260_chip_uninit, data);
+	if (ret)
+		return ret;
+
+	indio_dev->channels = bmi260_channels;
+	indio_dev->num_channels = ARRAY_SIZE(bmi260_channels);
+	indio_dev->name = name;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->info = &bmi260_info;
+
+	ret = devm_iio_triggered_buffer_setup(dev, indio_dev,
+					      iio_pollfunc_store_time,
+					      bmi260_trigger_handler, NULL);
+	if (ret)
+		return ret;
+
+	if (!irq) {
+		irq = bmi260_get_irq(dev_fwnode(dev), &int_pin);
+	}
+
+	if (irq > 0) {
+		data->int_pin = int_pin;
+		ret = bmi260_setup_irq(indio_dev, irq, int_pin);
+		if (ret)
+			dev_err(&indio_dev->dev, "Failed to setup IRQ %d\n",
+				irq);
+	} else {
+		dev_info(&indio_dev->dev, "Not setting up IRQ trigger\n");
+	}
+
+	return devm_iio_device_register(dev, indio_dev);
+}
+BMI260_EXPORT_SYMBOL(bmi260_core_probe);
+
+static int bmi260_chip_resume(struct device *dev) {
+	struct bmi260_data *data = iio_priv(dev_get_drvdata(dev));
+	int ret = bmi260_chip_init(data);
+	if (ret)
+		return ret;
+	bmi260_set_scale(data, BMI260_ACCEL, data->conf.accel_scale);
+	bmi260_set_scale(data, BMI260_GYRO, data->conf.gyro_scale);
+	bmi260_set_odr(data, BMI260_ACCEL, data->conf.accel_odr, data->conf.accel_uodr);
+	bmi260_set_odr(data, BMI260_GYRO, data->conf.gyro_odr, data->conf.gyro_uodr);
+	bmi260_enable_irq(data->regmap, data->int_pin, data->conf.irq);
+	data->conf.suspended = false;
+	return 0;
+}
+
+static int bmi260_chip_suspend(struct device *dev) {
+	struct bmi260_data *data = iio_priv(dev_get_drvdata(dev));
+	data->conf.suspended = true;
+	bmi260_get_scale(data, BMI260_ACCEL, &data->conf.accel_scale);
+	bmi260_get_scale(data, BMI260_GYRO, &data->conf.gyro_scale);
+	bmi260_get_odr(data, BMI260_ACCEL, &data->conf.accel_odr, &data->conf.accel_uodr);
+	bmi260_get_odr(data, BMI260_GYRO, &data->conf.gyro_odr, &data->conf.gyro_uodr);
+	bmi260_chip_uninit(data);
+	return 0;
+}
+
+EXPORT_GPL_DEV_SLEEP_PM_OPS(bmi260_pm_ops) = {
+	LATE_SYSTEM_SLEEP_PM_OPS(bmi260_chip_suspend, bmi260_chip_resume)
+};
+
+MODULE_AUTHOR("Justin Weiss <justin@justinweiss.com>");
+MODULE_DESCRIPTION("Bosch BMI260 driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/custom/bmi260/bmi260_i2c.c b/drivers/custom/bmi260/bmi260_i2c.c
new file mode 100644
index 000000000000..23c6233239a0
--- /dev/null
+++ b/drivers/custom/bmi260/bmi260_i2c.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * I2C driver for Bosch BMI260 IMU.
+ *
+ * Copyright (C) 2023, Justin Weiss
+ */
+#include <linux/i2c.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/version.h>
+
+#include "bmi260.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static int bmi260_i2c_probe(struct i2c_client *client)
+{
+	const struct i2c_device_id *id = i2c_client_get_device_id(client);
+#else
+static int bmi260_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+#endif
+	struct regmap *regmap;
+	const char *name;
+
+	regmap = devm_regmap_init_i2c(client, &bmi260_regmap_config);
+	if (IS_ERR(regmap)) {
+		dev_err(&client->dev, "Failed to register i2c regmap: %pe\n",
+			regmap);
+		return PTR_ERR(regmap);
+	}
+
+	if (id)
+		name = id->name;
+	else
+		name = dev_name(&client->dev);
+
+	return bmi260_core_probe(&client->dev, regmap, client->irq, name, false);
+}
+
+static const struct i2c_device_id bmi260_i2c_id[] = {
+	{"bmi260", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, bmi260_i2c_id);
+
+static const struct acpi_device_id bmi260_acpi_match[] = {
+	{"BOSC0260", 0},
+	{"BMI0260", 0},
+	{"BOSC0160", 0},
+	{"BMI0160", 0},
+	{"10EC5280", 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, bmi260_acpi_match);
+
+static const struct of_device_id bmi260_of_match[] = {
+	{ .compatible = "bosch,bmi260" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bmi260_of_match);
+
+static struct i2c_driver bmi260_i2c_driver = {
+	.driver = {
+		.name			= "bmi260_i2c",
+		.acpi_match_table	= bmi260_acpi_match,
+		.of_match_table		= bmi260_of_match,
+		.pm					= &bmi260_pm_ops,
+	},
+	.probe		= bmi260_i2c_probe,
+	.id_table	= bmi260_i2c_id,
+};
+module_i2c_driver(bmi260_i2c_driver);
+
+MODULE_AUTHOR("Justin Weiss <justin@justinweiss.com>");
+MODULE_DESCRIPTION("BMI260 I2C driver");
+MODULE_LICENSE("GPL v2");
+BMI260_IMPORT_NS;
# ----------------------------------------
# Module: xonedo
# Version: b1cd46868954
# ----------------------------------------
diff --git a/drivers/custom/xonedo/Kbuild b/drivers/custom/xonedo/Kbuild
new file mode 100644
index 000000000000..9a45c80af092
--- /dev/null
+++ b/drivers/custom/xonedo/Kbuild
@@ -0,0 +1,17 @@
+xone_gip-y := bus/bus.o bus/protocol.o auth/auth.o auth/crypto.o driver/common.o
+xone_dongle-y := transport/dongle.o transport/mt76.o
+xone_gip_gamepad-y := driver/gamepad.o
+xone_gip_headset-y := driver/headset.o
+xone_gip_chatpad-y := driver/chatpad.o
+xone_gip_madcatz_strat-y := driver/madcatz_strat.o
+xone_gip_madcatz_glam-y := driver/madcatz_glam.o
+xone_gip_pdp_jaguar-y := driver/pdp_jaguar.o
+
+obj-m := xone_gip.o \
+	xone_dongle.o \
+	xone_gip_gamepad.o \
+	xone_gip_headset.o \
+	xone_gip_chatpad.o \
+	xone_gip_madcatz_strat.o \
+	xone_gip_madcatz_glam.o \
+	xone_gip_pdp_jaguar.o
diff --git a/drivers/custom/xonedo/Makefile b/drivers/custom/xonedo/Makefile
new file mode 100644
index 000000000000..fead9075836e
--- /dev/null
+++ b/drivers/custom/xonedo/Makefile
@@ -0,0 +1,34 @@
+KVERSION := $(shell uname -r)
+KDIR := /lib/modules/${KVERSION}/build
+MAKEFLAGS+="-j $(shell nproc)"
+
+default: clean
+	$(MAKE) -C $(KDIR) M=$$PWD
+
+debug: clean
+	$(MAKE) -C $(KDIR) M=$$PWD ccflags-y="-Og -g3 -DDEBUG"
+
+clean:
+	$(MAKE) -C $(KDIR) M=$$PWD clean
+
+unload:
+	./modules_load.sh unload
+
+load: unload
+	./modules_load.sh
+
+test:
+	$(MAKE) debug &&\
+		$(MAKE) load
+	$(MAKE) clean
+
+remove: clean
+	./uninstall.sh
+
+install: clean
+	./install.sh
+	./install/firmware.sh --skip-disclaimer
+
+install-debug: clean
+	./install.sh --debug
+	./install/firmware.sh --skip-disclaimer
diff --git a/drivers/custom/xonedo/auth/auth.c b/drivers/custom/xonedo/auth/auth.c
new file mode 100644
index 000000000000..307225e436f3
--- /dev/null
+++ b/drivers/custom/xonedo/auth/auth.c
@@ -0,0 +1,665 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2023 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/random.h>
+#include <crypto/hash.h>
+
+#include "auth.h"
+#include "crypto.h"
+#include "../bus/bus.h"
+
+enum gip_auth_context {
+	GIP_AUTH_CTX_HANDSHAKE = 0x00,
+	GIP_AUTH_CTX_CONTROL = 0x01,
+};
+
+enum gip_auth_command_handshake {
+	GIP_AUTH_CMD_HOST_HELLO = 0x01,
+	GIP_AUTH_CMD_CLIENT_HELLO = 0x02,
+	GIP_AUTH_CMD_CLIENT_CERTIFICATE = 0x03,
+	GIP_AUTH_CMD_HOST_SECRET = 0x05,
+	GIP_AUTH_CMD_HOST_FINISH = 0x07,
+	GIP_AUTH_CMD_CLIENT_FINISH = 0x08,
+
+	GIP_AUTH2_CMD_HOST_HELLO = 0x21,
+	GIP_AUTH2_CMD_CLIENT_HELLO = 0x22,
+	GIP_AUTH2_CMD_CLIENT_CERTIFICATE = 0x23,
+	GIP_AUTH2_CMD_CLIENT_PUBKEY = 0x24,
+	GIP_AUTH2_CMD_HOST_PUBKEY = 0x25,
+	GIP_AUTH2_CMD_HOST_FINISH = 0x26,
+	GIP_AUTH2_CMD_CLIENT_FINISH = 0x27,
+};
+
+enum gip_auth_command_control {
+	GIP_AUTH_CTRL_COMPLETE = 0x00,
+	GIP_AUTH_CTRL_RESET = 0x01,
+};
+
+enum gip_auth_option {
+	GIP_AUTH_OPT_ACKNOWLEDGE = BIT(0),
+	GIP_AUTH_OPT_REQUEST = BIT(1),
+	GIP_AUTH_OPT_FROM_HOST = BIT(6),
+	GIP_AUTH_OPT_FROM_CLIENT = BIT(6) | BIT(7),
+};
+
+struct gip_auth_header_handshake {
+	u8 context;
+	u8 options;
+	u8 error;
+	u8 command;
+	__be16 length;
+} __packed;
+
+struct gip_auth_header_data {
+	u8 command;
+	u8 version;
+	__be16 length;
+} __packed;
+
+struct gip_auth_header_full {
+	struct gip_auth_header_handshake handshake;
+	struct gip_auth_header_data data;
+} __packed;
+
+struct gip_auth_header_control {
+	u8 context;
+	u8 control;
+} __packed;
+
+struct gip_auth_request {
+	struct gip_auth_header_handshake header;
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth_pkt_host_hello {
+	struct gip_auth_header_full header;
+
+	u8 random[GIP_AUTH_RANDOM_LEN];
+	u8 unknown1[4];
+	u8 unknown2[4];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth_pkt_host_secret {
+	struct gip_auth_header_full header;
+
+	u8 encrypted_pms[GIP_AUTH_ENCRYPTED_PMS_LEN];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth_pkt_host_finish {
+	struct gip_auth_header_full header;
+
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth_pkt_client_hello {
+	u8 random[GIP_AUTH_RANDOM_LEN];
+	u8 unknown[48];
+} __packed;
+
+struct gip_auth_pkt_client_finish {
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+	u8 unknown[32];
+} __packed;
+
+struct gip_auth2_pkt_host_hello {
+	struct gip_auth_header_full header;
+
+	u8 random[GIP_AUTH_RANDOM_LEN];
+	u8 unknown[4];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth2_pkt_host_pubkey {
+	struct gip_auth_header_full header;
+
+	u8 pubkey[GIP_AUTH2_PUBKEY_LEN];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth2_pkt_host_finish {
+	struct gip_auth_header_full header;
+
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+
+	u8 trailer[GIP_AUTH_TRAILER_LEN];
+} __packed;
+
+struct gip_auth2_pkt_client_hello {
+	u8 random[GIP_AUTH_RANDOM_LEN];
+	u8 unknown1[108];
+	u8 unknown2[32];
+} __packed;
+
+struct gip_auth2_pkt_client_cert {
+	char header[4];
+	u8 unknown1[136];
+	char chip[32];
+	char revision[20];
+	u8 unknown2[576];
+} __packed;
+
+struct gip_auth2_pkt_client_pubkey {
+	u8 pubkey[GIP_AUTH2_PUBKEY_LEN];
+	u8 unknown[64];
+} __packed;
+
+struct gip_auth2_pkt_client_finish {
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+	u8 unknown[32];
+} __packed;
+
+static int gip_auth_send_pkt(struct gip_auth *auth,
+			     enum gip_auth_command_handshake cmd,
+			     void *pkt, u16 len)
+{
+	struct gip_auth_header_full *hdr = pkt;
+	u16 data_len = len - sizeof(hdr->handshake) - GIP_AUTH_TRAILER_LEN;
+
+	hdr->handshake.context = GIP_AUTH_CTX_HANDSHAKE;
+	hdr->handshake.options = GIP_AUTH_OPT_ACKNOWLEDGE |
+				 GIP_AUTH_OPT_FROM_HOST;
+	hdr->handshake.command = cmd;
+	hdr->handshake.length = cpu_to_be16(data_len);
+
+	hdr->data.command = cmd;
+	hdr->data.version = cmd >= GIP_AUTH2_CMD_HOST_HELLO ? 0x02 : 0x01;
+	hdr->data.length = cpu_to_be16(data_len - sizeof(hdr->data));
+
+	auth->last_sent_command = cmd;
+	crypto_shash_update(auth->shash_transcript,
+			    pkt + sizeof(hdr->handshake), data_len);
+
+	return gip_send_authenticate(auth->client, pkt, len, true);
+}
+
+static int gip_auth_request_pkt(struct gip_auth *auth,
+				enum gip_auth_command_handshake cmd, u16 len)
+{
+	struct gip_auth_request req = {};
+	u16 data_len = len + sizeof(struct gip_auth_header_data);
+
+	req.header.context = GIP_AUTH_CTX_HANDSHAKE;
+	req.header.options = GIP_AUTH_OPT_REQUEST | GIP_AUTH_OPT_FROM_HOST;
+	req.header.command = cmd;
+	req.header.length = cpu_to_be16(data_len);
+
+	return gip_send_authenticate(auth->client, &req, sizeof(req), true);
+}
+
+static int gip_auth2_send_hello(struct gip_auth *auth)
+{
+	struct gip_auth2_pkt_host_hello pkt = {};
+
+	get_random_bytes(auth->random_host, sizeof(auth->random_host));
+	memcpy(pkt.random, auth->random_host, sizeof(pkt.random));
+
+	return gip_auth_send_pkt(auth, GIP_AUTH2_CMD_HOST_HELLO,
+				 &pkt, sizeof(pkt));
+}
+
+static int gip_auth2_handle_pkt_hello(struct gip_auth *auth,
+				      void *data, u32 len)
+{
+	struct gip_auth2_pkt_client_hello *pkt = data;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	memcpy(auth->random_client, pkt->random, sizeof(auth->random_client));
+
+	return gip_auth_request_pkt(auth, GIP_AUTH2_CMD_CLIENT_CERTIFICATE,
+				    sizeof(struct gip_auth2_pkt_client_cert));
+}
+
+static int gip_auth2_handle_pkt_certificate(struct gip_auth *auth,
+					    void *data, u32 len)
+{
+	struct gip_auth2_pkt_client_cert *pkt = data;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	dev_dbg(&auth->client->dev,
+		"%s: header=%.*s, chip=%.*s, revision=%.*s\n", __func__,
+		(int)sizeof(pkt->header), pkt->header,
+		(int)sizeof(pkt->chip), pkt->chip,
+		(int)sizeof(pkt->revision), pkt->revision);
+
+	return gip_auth_request_pkt(auth, GIP_AUTH2_CMD_CLIENT_PUBKEY,
+				    sizeof(struct gip_auth2_pkt_client_pubkey));
+}
+
+static int gip_auth2_handle_pkt_pubkey(struct gip_auth *auth,
+				       void *data, u32 len)
+{
+	struct gip_auth2_pkt_client_pubkey *pkt = data;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	memcpy(auth->pubkey_client2, pkt->pubkey, sizeof(pkt->pubkey));
+	schedule_work(&auth->work_exchange_ecdh);
+
+	return 0;
+}
+
+static void gip_auth2_exchange_ecdh(struct work_struct *work)
+{
+	struct gip_auth *auth = container_of(work, typeof(*auth),
+					     work_exchange_ecdh);
+	struct gip_auth2_pkt_host_pubkey pkt = {};
+	u8 random[GIP_AUTH_RANDOM_LEN * 2];
+	u8 secret[GIP_AUTH2_SECRET_LEN];
+	int err;
+
+	memcpy(random, auth->random_host, sizeof(auth->random_host));
+	memcpy(random + sizeof(auth->random_host), auth->random_client,
+	       sizeof(auth->random_client));
+
+	err = gip_auth_compute_ecdh(auth->pubkey_client2, pkt.pubkey,
+				    sizeof(pkt.pubkey), secret);
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute ECDH failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_auth_compute_prf(auth->shash_prf, "Master Secret",
+				   secret, sizeof(secret),
+				   random, sizeof(random),
+				   auth->master_secret,
+				   sizeof(auth->master_secret));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute PRF failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_auth_send_pkt(auth, GIP_AUTH2_CMD_HOST_PUBKEY,
+				&pkt, sizeof(pkt));
+	if (err)
+		dev_err(&auth->client->dev, "%s: send pkt failed: %d\n",
+			__func__, err);
+}
+
+static int gip_auth_send_pkt_hello(struct gip_auth *auth)
+{
+	struct gip_auth_pkt_host_hello pkt = {};
+
+	get_random_bytes(auth->random_host, sizeof(auth->random_host));
+	memcpy(pkt.random, auth->random_host, sizeof(pkt.random));
+
+	return gip_auth_send_pkt(auth, GIP_AUTH_CMD_HOST_HELLO,
+				 &pkt, sizeof(pkt));
+}
+
+static int gip_auth_send_pkt_finish(struct gip_auth *auth,
+				    enum gip_auth_command_handshake cmd)
+{
+	struct gip_auth_pkt_host_finish pkt = {};
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+	int err;
+
+	err = gip_auth_get_transcript(auth->shash_transcript, transcript);
+	if (err) {
+		dev_err(&auth->client->dev, "%s: get transcript failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	err = gip_auth_compute_prf(auth->shash_prf, "Host Finished",
+				   auth->master_secret,
+				   sizeof(auth->master_secret),
+				   transcript, sizeof(transcript),
+				   pkt.transcript, sizeof(pkt.transcript));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute PRF failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	return gip_auth_send_pkt(auth, cmd, &pkt, sizeof(pkt));
+}
+
+static int gip_auth_handle_pkt_acknowledge(struct gip_auth *auth)
+{
+	switch (auth->last_sent_command) {
+	case GIP_AUTH2_CMD_HOST_HELLO:
+		return gip_auth_request_pkt(auth, GIP_AUTH2_CMD_CLIENT_HELLO,
+					    sizeof(struct gip_auth2_pkt_client_hello));
+	case GIP_AUTH2_CMD_HOST_PUBKEY:
+		return gip_auth_send_pkt_finish(auth, GIP_AUTH2_CMD_HOST_FINISH);
+	case GIP_AUTH2_CMD_HOST_FINISH:
+		return gip_auth_request_pkt(auth, GIP_AUTH2_CMD_CLIENT_FINISH,
+					    sizeof(struct gip_auth2_pkt_client_finish));
+	case GIP_AUTH_CMD_HOST_HELLO:
+		return gip_auth_request_pkt(auth, GIP_AUTH_CMD_CLIENT_HELLO,
+					    sizeof(struct gip_auth_pkt_client_hello));
+	case GIP_AUTH_CMD_HOST_SECRET:
+		return gip_auth_send_pkt_finish(auth, GIP_AUTH_CMD_HOST_FINISH);
+	case GIP_AUTH_CMD_HOST_FINISH:
+		return gip_auth_request_pkt(auth, GIP_AUTH_CMD_CLIENT_FINISH,
+					    sizeof(struct gip_auth_pkt_client_finish));
+	default:
+		return -EPROTO;
+	}
+}
+
+static int gip_auth_handle_pkt_hello(struct gip_auth *auth,
+				     void *data, u32 len)
+{
+	struct gip_auth_pkt_client_hello *pkt = data;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	memcpy(auth->random_client, pkt->random, sizeof(pkt->random));
+
+	return gip_auth_request_pkt(auth, GIP_AUTH_CMD_CLIENT_CERTIFICATE,
+				    GIP_AUTH_CERTIFICATE_MAX_LEN);
+}
+
+static int gip_auth_handle_pkt_certificate(struct gip_auth *auth,
+					   void *data, u32 len)
+{
+	/* ASN.1 SEQUENCE (len = 0x04 + 0x010a) */
+	u8 asn1_seq[] = { 0x30, 0x82, 0x01, 0x0a };
+	int i;
+
+	if (len > GIP_AUTH_CERTIFICATE_MAX_LEN)
+		return -EINVAL;
+
+	/*
+	 * Poor way of extracting a pubkey from an X.509 certificate.
+	 * The certificates issued by Microsoft do not comply with RFC 5280.
+	 * They have an empty subject and no subjectAltName.
+	 * This is explicitly forbidden by section 4.2.1.6 of the RFC.
+	 * The kernel's ASN.1 parser will fail when using x509_cert_parse.
+	 */
+	for (i = 0; i + sizeof(asn1_seq) <= len; i++) {
+		if (memcmp(data + i, asn1_seq, sizeof(asn1_seq)))
+			continue;
+
+		if (i + GIP_AUTH_PUBKEY_LEN > len)
+			return -EINVAL;
+
+		memcpy(auth->pubkey_client, data + i, GIP_AUTH_PUBKEY_LEN);
+		schedule_work(&auth->work_exchange_rsa);
+
+		return 0;
+	}
+
+	return -EPROTO;
+}
+
+static int gip_auth_handle_pkt_finish(struct gip_auth *auth,
+				      void *data, u32 len)
+{
+	struct gip_auth_pkt_client_finish *pkt = data;
+	u8 transcript[GIP_AUTH_TRANSCRIPT_LEN];
+	u8 finished[GIP_AUTH_TRANSCRIPT_LEN];
+	int err;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	err = gip_auth_get_transcript(auth->shash_transcript, transcript);
+	if (err) {
+		dev_err(&auth->client->dev, "%s: get transcript failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	err = gip_auth_compute_prf(auth->shash_prf, "Device Finished",
+				   auth->master_secret,
+				   sizeof(auth->master_secret),
+				   transcript, sizeof(transcript),
+				   finished, sizeof(finished));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute PRF failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	if (memcmp(pkt->transcript, finished, sizeof(finished))) {
+		dev_err(&auth->client->dev, "%s: transcript mismatch\n",
+			__func__);
+		return -EPROTO;
+	}
+
+	schedule_work(&auth->work_complete);
+
+	return 0;
+}
+
+static void gip_auth_exchange_rsa(struct work_struct *work)
+{
+	struct gip_auth *auth = container_of(work, typeof(*auth),
+					     work_exchange_rsa);
+	struct gip_auth_pkt_host_secret pkt = {};
+	u8 random[GIP_AUTH_RANDOM_LEN * 2];
+	int err;
+
+	memcpy(random, auth->random_host, sizeof(auth->random_host));
+	memcpy(random + sizeof(auth->random_host), auth->random_client,
+	       sizeof(auth->random_client));
+
+	/* get random premaster secret */
+	get_random_bytes(auth->pms, sizeof(auth->pms));
+
+	err = gip_auth_encrypt_rsa(auth->pubkey_client,
+				   sizeof(auth->pubkey_client),
+				   auth->pms, sizeof(auth->pms),
+				   pkt.encrypted_pms,
+				   sizeof(pkt.encrypted_pms));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: encrypt RSA failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_auth_compute_prf(auth->shash_prf, "Master Secret",
+				   auth->pms, sizeof(auth->pms),
+				   random, sizeof(random),
+				   auth->master_secret,
+				   sizeof(auth->master_secret));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute PRF failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_auth_send_pkt(auth, GIP_AUTH_CMD_HOST_SECRET,
+				&pkt, sizeof(pkt));
+	if (err)
+		dev_err(&auth->client->dev, "%s: send pkt failed: %d\n",
+			__func__, err);
+}
+
+int gip_auth_send_complete(struct gip_client *client)
+{
+	struct gip_auth_header_control hdr = {};
+
+	hdr.context = GIP_AUTH_CTX_CONTROL;
+	hdr.control = GIP_AUTH_CTRL_COMPLETE;
+
+	return gip_send_authenticate(client, &hdr, sizeof(hdr), false);
+}
+EXPORT_SYMBOL_GPL(gip_auth_send_complete);
+
+static void gip_auth_complete_handshake(struct work_struct *work)
+{
+	struct gip_auth *auth = container_of(work, typeof(*auth),
+					     work_complete);
+	u8 random[GIP_AUTH_RANDOM_LEN * 2];
+	u8 key[GIP_AUTH_SESSION_KEY_LEN];
+	int err;
+
+	memcpy(random, auth->random_host, sizeof(auth->random_host));
+	memcpy(random + sizeof(auth->random_host), auth->random_client,
+	       sizeof(auth->random_client));
+
+	err = gip_auth_compute_prf(auth->shash_prf,
+				   "EXPORTER DAWN data channel session key for controller",
+				   auth->master_secret,
+				   sizeof(auth->master_secret),
+				   random, sizeof(random),
+				   key, sizeof(key));
+	if (err) {
+		dev_err(&auth->client->dev, "%s: compute PRF failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	dev_dbg(&auth->client->dev, "%s: key=%*phD\n", __func__,
+		(int)sizeof(key), key);
+
+	err = gip_auth_send_complete(auth->client);
+	if (err) {
+		dev_err(&auth->client->dev, "%s: send complete failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_set_encryption_key(auth->client, key, sizeof(key));
+	if (err)
+		dev_err(&auth->client->dev,
+			"%s: set encryption key failed: %d\n", __func__, err);
+}
+
+static int gip_auth_dispatch_pkt(struct gip_auth *auth,
+				 enum gip_auth_command_handshake cmd,
+				 void *data, u32 len)
+{
+	switch (cmd) {
+	case GIP_AUTH2_CMD_CLIENT_HELLO:
+		return gip_auth2_handle_pkt_hello(auth, data, len);
+	case GIP_AUTH2_CMD_CLIENT_CERTIFICATE:
+		return gip_auth2_handle_pkt_certificate(auth, data, len);
+	case GIP_AUTH2_CMD_CLIENT_PUBKEY:
+		return gip_auth2_handle_pkt_pubkey(auth, data, len);
+	case GIP_AUTH2_CMD_CLIENT_FINISH:
+		return gip_auth_handle_pkt_finish(auth, data, len);
+	case GIP_AUTH_CMD_CLIENT_HELLO:
+		return gip_auth_handle_pkt_hello(auth, data, len);
+	case GIP_AUTH_CMD_CLIENT_CERTIFICATE:
+		return gip_auth_handle_pkt_certificate(auth, data, len);
+	case GIP_AUTH_CMD_CLIENT_FINISH:
+		return gip_auth_handle_pkt_finish(auth, data, len);
+	default:
+		return -EPROTO;
+	}
+}
+
+static int gip_auth_process_pkt_data(struct gip_auth *auth, void *data, u32 len)
+{
+	struct gip_auth_header_full *hdr = data;
+	int err;
+
+	if (len < sizeof(*hdr))
+		return -EINVAL;
+
+	/* client uses auth v2 */
+	if (hdr->handshake.command != hdr->data.command) {
+		/* reset transcript hash and restart handshake */
+		dev_dbg(&auth->client->dev, "%s: protocol upgrade\n", __func__);
+		crypto_shash_init(auth->shash_transcript);
+		return gip_auth2_send_hello(auth);
+	}
+
+	err = gip_auth_dispatch_pkt(auth, hdr->data.command,
+				    data + sizeof(*hdr), len - sizeof(*hdr));
+	if (err)
+		return err;
+
+	return crypto_shash_update(auth->shash_transcript,
+				   data + sizeof(hdr->handshake),
+				   len - sizeof(hdr->handshake));
+}
+
+int gip_auth_process_pkt(struct gip_auth *auth, void *data, u32 len)
+{
+	struct gip_auth_header_handshake *hdr = data;
+
+	if (!auth->client)
+		return -ENODEV;
+
+	if (len < sizeof(*hdr))
+		return -EINVAL;
+
+	if (hdr->error)
+		return -EPROTO;
+
+	if (hdr->options & GIP_AUTH_OPT_ACKNOWLEDGE) {
+		if (hdr->command == 0x01)
+			return gip_auth_handle_pkt_acknowledge(auth);
+
+		dev_err(&auth->client->dev, "%s: handshake failed: 0x%02x\n",
+			__func__, hdr->command);
+		return -EPROTO;
+	}
+
+	return gip_auth_process_pkt_data(auth, data, len);
+}
+EXPORT_SYMBOL_GPL(gip_auth_process_pkt);
+
+static void gip_auth_release(void *res)
+{
+	struct gip_auth *auth = res;
+
+	cancel_work_sync(&auth->work_exchange_rsa);
+	cancel_work_sync(&auth->work_exchange_ecdh);
+	cancel_work_sync(&auth->work_complete);
+
+	crypto_free_shash(auth->shash_transcript->tfm);
+	crypto_free_shash(auth->shash_prf->tfm);
+	kfree(auth->shash_transcript);
+	kfree(auth->shash_prf);
+
+	auth->client = NULL;
+	auth->shash_transcript = NULL;
+	auth->shash_prf = NULL;
+}
+
+int gip_auth_start_handshake(struct gip_auth *auth, struct gip_client *client)
+{
+	struct shash_desc *shash_transcript, *shash_prf;
+	int err;
+
+	shash_transcript = gip_auth_alloc_shash("sha256");
+	if (IS_ERR(shash_transcript))
+		return PTR_ERR(shash_transcript);
+
+	shash_prf = gip_auth_alloc_shash("hmac(sha256)");
+	if (IS_ERR(shash_prf)) {
+		crypto_free_shash(shash_transcript->tfm);
+		kfree(shash_transcript);
+		return PTR_ERR(shash_prf);
+	}
+
+	auth->client = client;
+	auth->shash_transcript = shash_transcript;
+	auth->shash_prf = shash_prf;
+
+	INIT_WORK(&auth->work_exchange_rsa, gip_auth_exchange_rsa);
+	INIT_WORK(&auth->work_exchange_ecdh, gip_auth2_exchange_ecdh);
+	INIT_WORK(&auth->work_complete, gip_auth_complete_handshake);
+
+	err = devm_add_action_or_reset(&client->dev, gip_auth_release, auth);
+	if (err)
+		return err;
+
+	return gip_auth_send_pkt_hello(auth);
+}
+EXPORT_SYMBOL_GPL(gip_auth_start_handshake);
diff --git a/drivers/custom/xonedo/auth/auth.h b/drivers/custom/xonedo/auth/auth.h
new file mode 100644
index 000000000000..85d2c8165fb0
--- /dev/null
+++ b/drivers/custom/xonedo/auth/auth.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2023 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
+/* trailer is required for v1 clients */
+#define GIP_AUTH_TRAILER_LEN 8
+#define GIP_AUTH_RANDOM_LEN 32
+#define GIP_AUTH_CERTIFICATE_MAX_LEN 1024
+#define GIP_AUTH_PUBKEY_LEN 270
+#define GIP_AUTH_SECRET_LEN 48
+#define GIP_AUTH_ENCRYPTED_PMS_LEN 256
+#define GIP_AUTH_TRANSCRIPT_LEN 32
+#define GIP_AUTH_SESSION_KEY_LEN 16
+
+#define GIP_AUTH2_PUBKEY_LEN 64
+#define GIP_AUTH2_SECRET_LEN 32
+
+struct gip_client;
+
+struct gip_auth {
+	struct gip_client *client;
+
+	struct shash_desc *shash_transcript;
+	struct shash_desc *shash_prf;
+
+	struct work_struct work_exchange_rsa;
+	struct work_struct work_exchange_ecdh;
+	struct work_struct work_complete;
+
+	u8 last_sent_command;
+
+	u8 random_host[GIP_AUTH_RANDOM_LEN];
+	u8 random_client[GIP_AUTH_RANDOM_LEN];
+
+	u8 pubkey_client[GIP_AUTH_PUBKEY_LEN];
+	u8 pubkey_client2[GIP_AUTH2_PUBKEY_LEN];
+
+	u8 pms[GIP_AUTH_SECRET_LEN];
+	u8 master_secret[GIP_AUTH_SECRET_LEN];
+};
+
+int gip_auth_send_complete(struct gip_client *client);
+int gip_auth_process_pkt(struct gip_auth *auth, void *data, u32 len);
+int gip_auth_start_handshake(struct gip_auth *auth, struct gip_client *client);
diff --git a/drivers/custom/xonedo/auth/crypto.c b/drivers/custom/xonedo/auth/crypto.c
new file mode 100644
index 000000000000..e099f3732400
--- /dev/null
+++ b/drivers/custom/xonedo/auth/crypto.c
@@ -0,0 +1,285 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2023 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/scatterlist.h>
+#include <linux/version.h>
+#include <crypto/hash.h>
+#include <crypto/sha2.h>
+#include <crypto/akcipher.h>
+#include <crypto/kpp.h>
+#include <crypto/ecdh.h>
+
+#include "crypto.h"
+
+#define GIP_AUTH_ECDH_SECRET_LEN 32
+
+struct shash_desc *gip_auth_alloc_shash(const char *alg)
+{
+	struct crypto_shash *tfm;
+	struct shash_desc *desc;
+
+	tfm = crypto_alloc_shash(alg, 0, 0);
+	if (IS_ERR(tfm))
+		return ERR_CAST(tfm);
+
+	desc = kzalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (!desc) {
+		crypto_free_shash(tfm);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	desc->tfm = tfm;
+	crypto_shash_init(desc);
+
+	return desc;
+}
+
+int gip_auth_get_transcript(struct shash_desc *desc, void *transcript)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
+	void *state = kzalloc(crypto_shash_descsize(desc->tfm), GFP_KERNEL);
+	int err;
+
+	err = crypto_shash_export(desc, state);
+	if (err)
+		goto get_transcript_error;
+
+	err = crypto_shash_final(desc, transcript);
+	if (err)
+		goto get_transcript_error;
+
+	err = crypto_shash_import(desc, state);
+
+get_transcript_error:
+	kfree(state);
+	return err;
+#else
+	struct sha256_state state;
+	int err;
+
+	err = crypto_shash_export(desc, &state);
+	if (err)
+		return err;
+
+	err = crypto_shash_final(desc, transcript);
+	if (err)
+		return err;
+
+	return crypto_shash_import(desc, &state);
+#endif
+}
+
+int gip_auth_compute_prf(struct shash_desc *desc, const char *label,
+			 u8 *key, int key_len,
+			 u8 *seed, int seed_len,
+			 u8 *out, int out_len)
+{
+	u8 hash[SHA256_DIGEST_SIZE], hash_out[SHA256_DIGEST_SIZE];
+	int err;
+
+	err = crypto_shash_setkey(desc->tfm, key, key_len);
+	if (err)
+		return err;
+
+	crypto_shash_init(desc);
+	crypto_shash_update(desc, label, strlen(label));
+	crypto_shash_update(desc, seed, seed_len);
+	crypto_shash_final(desc, hash);
+
+	while (out_len > 0) {
+		crypto_shash_init(desc);
+		crypto_shash_update(desc, hash, sizeof(hash));
+		crypto_shash_update(desc, label, strlen(label));
+		crypto_shash_update(desc, seed, seed_len);
+		crypto_shash_final(desc, hash_out);
+
+		memcpy(out, hash_out, min_t(int, out_len, sizeof(hash)));
+		out += sizeof(hash);
+		out_len -= sizeof(hash);
+
+		crypto_shash_digest(desc, hash, sizeof(hash), hash);
+	}
+
+	return 0;
+}
+
+int gip_auth_encrypt_rsa(u8 *key, int key_len,
+			 u8 *in, int in_len,
+			 u8 *out, int out_len)
+{
+	struct crypto_akcipher *tfm;
+	struct akcipher_request *req;
+	struct scatterlist src, dest;
+	DECLARE_CRYPTO_WAIT(wait);
+	u8 *buf;
+	int err;
+
+	buf = kzalloc(out_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	tfm = crypto_alloc_akcipher("pkcs1pad(rsa)", 0, 0);
+	if (IS_ERR(tfm)) {
+		err = PTR_ERR(tfm);
+		goto err_free_buf;
+	}
+
+	err = crypto_akcipher_set_pub_key(tfm, key, key_len);
+	if (err)
+		goto err_free_tfm;
+
+	req = akcipher_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		err = -ENOMEM;
+		goto err_free_tfm;
+	}
+
+	sg_init_one(&src, in, in_len);
+	sg_init_one(&dest, buf, out_len);
+
+	akcipher_request_set_crypt(req, &src, &dest, in_len, out_len);
+	akcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				      crypto_req_done, &wait);
+	err = crypto_wait_req(crypto_akcipher_encrypt(req), &wait);
+	if (!err)
+		memcpy(out, buf, out_len);
+
+	akcipher_request_free(req);
+
+err_free_tfm:
+	crypto_free_akcipher(tfm);
+err_free_buf:
+	kfree(buf);
+
+	return err;
+}
+
+static int gip_auth_ecdh_get_pubkey(struct crypto_kpp *tfm,
+				    u8 *out, int len)
+{
+	struct kpp_request *req;
+	struct scatterlist dest;
+	struct ecdh key = {};
+	DECLARE_CRYPTO_WAIT(wait);
+	void *privkey, *pubkey;
+	unsigned int privkey_len;
+	int err;
+
+	privkey_len = crypto_ecdh_key_len(&key);
+	privkey = kzalloc(privkey_len, GFP_KERNEL);
+	if (!privkey)
+		return -ENOMEM;
+
+	pubkey = kzalloc(len, GFP_KERNEL);
+	if (!pubkey)
+		goto err_free_privkey;
+
+	/* generate private key */
+	err = crypto_ecdh_encode_key(privkey, privkey_len, &key);
+	if (err)
+		goto err_free_pubkey;
+
+	err = crypto_kpp_set_secret(tfm, privkey, privkey_len);
+	if (err)
+		goto err_free_pubkey;
+
+	req = kpp_request_alloc(tfm, GFP_KERNEL);
+	if (!req) {
+		err = -ENOMEM;
+		goto err_free_pubkey;
+	}
+
+	sg_init_one(&dest, pubkey, len);
+
+	kpp_request_set_input(req, NULL, 0);
+	kpp_request_set_output(req, &dest, len);
+	kpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				 crypto_req_done, &wait);
+	err = crypto_wait_req(crypto_kpp_generate_public_key(req), &wait);
+	if (!err)
+		memcpy(out, pubkey, len);
+
+	kpp_request_free(req);
+
+err_free_pubkey:
+	kfree(pubkey);
+err_free_privkey:
+	kfree(privkey);
+
+	return err;
+}
+
+static int gip_auth_ecdh_get_secret(struct crypto_kpp *tfm,
+				    u8 *pubkey, int pubkey_len,
+				    u8 *secret, int secret_len)
+{
+	struct kpp_request *req;
+	struct scatterlist src, dest;
+	DECLARE_CRYPTO_WAIT(wait);
+	int err;
+
+	req = kpp_request_alloc(tfm, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	sg_init_one(&src, pubkey, pubkey_len);
+	sg_init_one(&dest, secret, secret_len);
+
+	kpp_request_set_input(req, &src, pubkey_len);
+	kpp_request_set_output(req, &dest, secret_len);
+	kpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				 crypto_req_done, &wait);
+	err = crypto_wait_req(crypto_kpp_compute_shared_secret(req), &wait);
+
+	kpp_request_free(req);
+
+	return err;
+}
+
+int gip_auth_compute_ecdh(u8 *pubkey_in, u8 *pubkey_out,
+			  int pubkey_len, u8 *secret_hash)
+{
+	struct crypto_kpp *tfm_ecdh;
+	struct crypto_shash *tfm_sha;
+	u8 *secret;
+	int err;
+
+	secret = kzalloc(GIP_AUTH_ECDH_SECRET_LEN, GFP_KERNEL);
+	if (!secret)
+		return -ENOMEM;
+
+	tfm_ecdh = crypto_alloc_kpp("ecdh-nist-p256", 0, 0);
+	if (IS_ERR(tfm_ecdh)) {
+		err = PTR_ERR(tfm_ecdh);
+		goto err_free_secret;
+	}
+
+	tfm_sha = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm_sha)) {
+		err = PTR_ERR(tfm_sha);
+		goto err_free_ecdh;
+	}
+
+	err = gip_auth_ecdh_get_pubkey(tfm_ecdh, pubkey_out, pubkey_len);
+	if (err)
+		goto err_free_sha;
+
+	err = gip_auth_ecdh_get_secret(tfm_ecdh, pubkey_in, pubkey_len,
+				       secret, GIP_AUTH_ECDH_SECRET_LEN);
+	if (err)
+		goto err_free_sha;
+
+	crypto_shash_tfm_digest(tfm_sha, secret, GIP_AUTH_ECDH_SECRET_LEN,
+				secret_hash);
+
+err_free_sha:
+	crypto_free_shash(tfm_sha);
+err_free_ecdh:
+	crypto_free_kpp(tfm_ecdh);
+err_free_secret:
+	kfree(secret);
+
+	return err;
+}
diff --git a/drivers/custom/xonedo/auth/crypto.h b/drivers/custom/xonedo/auth/crypto.h
new file mode 100644
index 000000000000..a34972e35b28
--- /dev/null
+++ b/drivers/custom/xonedo/auth/crypto.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2023 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include <linux/types.h>
+
+struct shash_desc *gip_auth_alloc_shash(const char *alg);
+int gip_auth_get_transcript(struct shash_desc *desc, void *transcript);
+int gip_auth_compute_prf(struct shash_desc *desc, const char *label,
+			 u8 *key, int key_len,
+			 u8 *seed, int seed_len,
+			 u8 *out, int out_len);
+
+int gip_auth_encrypt_rsa(u8 *key, int key_len,
+			 u8 *in, int in_len,
+			 u8 *out, int out_len);
+int gip_auth_compute_ecdh(u8 *pubkey_in, u8 *pubkey_out,
+			  int pubkey_len, u8 *secret_hash);
diff --git a/drivers/custom/xonedo/bus/bus.c b/drivers/custom/xonedo/bus/bus.c
new file mode 100644
index 000000000000..783b01350abb
--- /dev/null
+++ b/drivers/custom/xonedo/bus/bus.c
@@ -0,0 +1,355 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/idr.h>
+#include <linux/version.h>
+
+#include "bus.h"
+
+#define to_gip_adapter(d) container_of(d, struct gip_adapter, dev)
+#define to_gip_client(d) container_of(d, struct gip_client, dev)
+#define to_gip_driver(d) container_of(d, struct gip_driver, drv)
+
+static DEFINE_IDA(gip_adapter_ida);
+
+static void gip_adapter_release(struct device *dev)
+{
+	kfree(to_gip_adapter(dev));
+}
+
+static struct device_type gip_adapter_type = {
+	.release = gip_adapter_release,
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
+static int gip_client_uevent(struct device *dev, struct kobj_uevent_env *env)
+#else
+static int gip_client_uevent(const struct device *dev,
+			     struct kobj_uevent_env *env)
+#endif
+{
+	struct gip_client *client = to_gip_client(dev);
+	struct gip_classes *classes = client->classes;
+
+	if (!classes || !classes->count)
+		return -EINVAL;
+
+	return add_uevent_var(env, "MODALIAS=gip:%s", classes->strings[0]);
+}
+
+static void gip_client_release(struct device *dev)
+{
+	struct gip_client *client = to_gip_client(dev);
+
+	gip_free_client_info(client);
+	kfree(client->chunk_buf_out);
+	kfree(client->chunk_buf_in);
+	kfree(client);
+}
+
+static struct device_type gip_client_type = {
+	.uevent = gip_client_uevent,
+	.release = gip_client_release,
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int gip_bus_match(struct device *dev, struct device_driver *driver)
+#else
+static int gip_bus_match(struct device *dev, const struct device_driver *driver)
+#endif
+{
+	struct gip_client *client;
+	struct gip_driver *drv;
+	int i;
+
+	if (dev->type != &gip_client_type)
+		return false;
+
+	client = to_gip_client(dev);
+	drv = to_gip_driver(driver);
+
+	for (i = 0; i < client->classes->count; i++)
+		if (!strcmp(client->classes->strings[i], drv->class))
+			return true;
+
+	return false;
+}
+
+static int gip_bus_probe(struct device *dev)
+{
+	struct gip_client *client = to_gip_client(dev);
+	struct gip_driver *drv = to_gip_driver(dev->driver);
+	int err = 0;
+
+	if (down_interruptible(&client->drv_lock))
+		return -EINTR;
+
+	if (!client->drv) {
+		err = drv->probe(client);
+		if (!err)
+			client->drv = drv;
+	}
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static void gip_bus_remove(struct device *dev)
+{
+	struct gip_client *client = to_gip_client(dev);
+	struct gip_driver *drv;
+
+	down(&client->drv_lock);
+
+	drv = client->drv;
+	if (drv) {
+		client->drv = NULL;
+		if (drv->remove)
+			drv->remove(client);
+	}
+
+	up(&client->drv_lock);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 13, 0)
+static int gip_bus_remove_compat(struct device *dev)
+{
+	gip_bus_remove(dev);
+
+	return 0;
+}
+#endif
+
+static struct bus_type gip_bus_type = {
+	.name = "xone-gip",
+	.match = gip_bus_match,
+	.probe = gip_bus_probe,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 13, 0)
+	.remove = gip_bus_remove_compat,
+#else
+	.remove = gip_bus_remove,
+#endif
+};
+
+struct gip_adapter *gip_create_adapter(struct device *parent,
+				       struct gip_adapter_ops *ops,
+				       int audio_pkts)
+{
+	struct gip_adapter *adap;
+	int err;
+
+	adap = kzalloc(sizeof(*adap), GFP_KERNEL);
+	if (!adap)
+		return ERR_PTR(-ENOMEM);
+
+	adap->id = ida_simple_get(&gip_adapter_ida, 0, 0, GFP_KERNEL);
+	if (adap->id < 0) {
+		err = adap->id;
+		goto err_put_device;
+	}
+
+	adap->clients_wq = alloc_ordered_workqueue("gip%d", 0, adap->id);
+	if (!adap->clients_wq) {
+		err = -ENOMEM;
+		goto err_remove_ida;
+	}
+
+	adap->dev.parent = parent;
+	adap->dev.type = &gip_adapter_type;
+	adap->dev.bus = &gip_bus_type;
+	adap->ops = ops;
+	adap->audio_packet_count = audio_pkts;
+	dev_set_name(&adap->dev, "gip%d", adap->id);
+	spin_lock_init(&adap->send_lock);
+
+	err = device_register(&adap->dev);
+	if (err)
+		goto err_destroy_queue;
+
+	dev_dbg(&adap->dev, "%s: registered\n", __func__);
+
+	return adap;
+
+err_destroy_queue:
+	destroy_workqueue(adap->clients_wq);
+err_remove_ida:
+	ida_simple_remove(&gip_adapter_ida, adap->id);
+err_put_device:
+	put_device(&adap->dev);
+
+	return ERR_PTR(err);
+}
+EXPORT_SYMBOL_GPL(gip_create_adapter);
+
+int gip_power_off_adapter(struct gip_adapter *adap)
+{
+	struct gip_client *client = adap->clients[0];
+
+	if (!client)
+		return 0;
+
+	/* power off main client */
+	return gip_set_power_mode(client, GIP_PWR_OFF);
+}
+EXPORT_SYMBOL_GPL(gip_power_off_adapter);
+
+void gip_destroy_adapter(struct gip_adapter *adap)
+{
+	struct gip_client *client;
+	int i;
+
+	/* ensure all state changes have been processed */
+	flush_workqueue(adap->clients_wq);
+
+	for (i = GIP_MAX_CLIENTS - 1; i >= 0; i--) {
+		client = adap->clients[i];
+		if (!client || !device_is_registered(&client->dev))
+			continue;
+
+		device_unregister(&client->dev);
+	}
+
+	ida_simple_remove(&gip_adapter_ida, adap->id);
+	destroy_workqueue(adap->clients_wq);
+
+	dev_dbg(&adap->dev, "%s: unregistered\n", __func__);
+	device_unregister(&adap->dev);
+}
+EXPORT_SYMBOL_GPL(gip_destroy_adapter);
+
+static void gip_register_client(struct work_struct *work)
+{
+	struct gip_client *client = container_of(work, typeof(*client),
+						 work_register);
+	int err;
+
+	client->dev.parent = &client->adapter->dev;
+	client->dev.type = &gip_client_type;
+	client->dev.bus = &gip_bus_type;
+	sema_init(&client->drv_lock, 1);
+	dev_set_name(&client->dev, "gip%d.%u", client->adapter->id, client->id);
+
+	err = device_register(&client->dev);
+	if (err)
+		dev_err(&client->dev, "%s: register failed: %d\n",
+			__func__, err);
+	else
+		dev_dbg(&client->dev, "%s: registered\n", __func__);
+}
+
+static void gip_unregister_client(struct work_struct *work)
+{
+	struct gip_client *client = container_of(work, typeof(*client),
+						 work_unregister);
+
+	if (!device_is_registered(&client->dev))
+		return;
+
+	dev_dbg(&client->dev, "%s: unregistered\n", __func__);
+	device_unregister(&client->dev);
+}
+
+struct gip_client *gip_get_client(struct gip_adapter *adap, u8 id)
+{
+	struct gip_client *client;
+
+	client = adap->clients[id];
+	if (client)
+		return client;
+
+	client = kzalloc(sizeof(*client), GFP_ATOMIC);
+	if (!client)
+		return ERR_PTR(-ENOMEM);
+
+	client->id = id;
+	client->adapter = adap;
+	sema_init(&client->drv_lock, 1);
+	INIT_WORK(&client->work_register, gip_register_client);
+	INIT_WORK(&client->work_unregister, gip_unregister_client);
+
+	adap->clients[id] = client;
+
+	dev_dbg(&client->adapter->dev, "%s: initialized client %u\n",
+		__func__, id);
+
+	return client;
+}
+
+void gip_add_client(struct gip_client *client)
+{
+	queue_work(client->adapter->clients_wq, &client->work_register);
+}
+
+void gip_remove_client(struct gip_client *client)
+{
+	client->adapter->clients[client->id] = NULL;
+	queue_work(client->adapter->clients_wq, &client->work_unregister);
+}
+
+void gip_free_client_info(struct gip_client *client)
+{
+	int i;
+
+	kfree(client->client_commands);
+	kfree(client->firmware_versions);
+	kfree(client->audio_formats);
+	kfree(client->capabilities_out);
+	kfree(client->capabilities_in);
+
+	if (client->classes)
+		for (i = 0; i < client->classes->count; i++)
+			kfree(client->classes->strings[i]);
+
+	kfree(client->classes);
+	kfree(client->interfaces);
+	kfree(client->hid_descriptor);
+
+	client->client_commands = NULL;
+	client->audio_formats = NULL;
+	client->capabilities_out = NULL;
+	client->capabilities_in = NULL;
+	client->classes = NULL;
+	client->interfaces = NULL;
+	client->hid_descriptor = NULL;
+}
+
+int __gip_register_driver(struct gip_driver *drv, struct module *owner,
+			  const char *mod_name)
+{
+	drv->drv.name = drv->name;
+	drv->drv.bus = &gip_bus_type;
+	drv->drv.owner = owner;
+	drv->drv.mod_name = mod_name;
+
+	return driver_register(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(__gip_register_driver);
+
+void gip_unregister_driver(struct gip_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+EXPORT_SYMBOL_GPL(gip_unregister_driver);
+
+static int __init gip_bus_init(void)
+{
+	return bus_register(&gip_bus_type);
+}
+
+static void __exit gip_bus_exit(void)
+{
+	bus_unregister(&gip_bus_type);
+}
+
+module_init(gip_bus_init);
+module_exit(gip_bus_exit);
+
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/bus/bus.h b/drivers/custom/xonedo/bus/bus.h
new file mode 100644
index 000000000000..b69732349274
--- /dev/null
+++ b/drivers/custom/xonedo/bus/bus.h
@@ -0,0 +1,129 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/semaphore.h>
+
+#include "protocol.h"
+
+#define GIP_MAX_CLIENTS 16
+
+#define gip_register_driver(drv) \
+	__gip_register_driver(drv, THIS_MODULE, KBUILD_MODNAME)
+
+#define module_gip_driver(drv) \
+	module_driver(drv, gip_register_driver, gip_unregister_driver)
+
+struct gip_adapter_buffer {
+	enum gip_adapter_buffer_type {
+		GIP_BUF_DATA,
+		GIP_BUF_AUDIO,
+	} type;
+
+	void *context;
+	void *data;
+	int length;
+};
+
+struct gip_adapter_ops {
+	int (*get_buffer)(struct gip_adapter *adap,
+			  struct gip_adapter_buffer *buf);
+	int (*submit_buffer)(struct gip_adapter *adap,
+			     struct gip_adapter_buffer *buf);
+	int (*set_encryption_key)(struct gip_adapter *adap, u8 *key, int len);
+	int (*enable_audio)(struct gip_adapter *adap);
+	int (*init_audio_in)(struct gip_adapter *adap);
+	int (*init_audio_out)(struct gip_adapter *adap, int pkt_len);
+	int (*disable_audio)(struct gip_adapter *adap);
+};
+
+struct gip_adapter {
+	struct device dev;
+	int id;
+
+	struct gip_adapter_ops *ops;
+	int audio_packet_count;
+
+	struct gip_client *clients[GIP_MAX_CLIENTS];
+	struct workqueue_struct *clients_wq;
+
+	/* serializes access to data sequence number */
+	spinlock_t send_lock;
+
+	u8 data_sequence;
+	u8 audio_sequence;
+};
+
+struct gip_client {
+	struct device dev;
+	u8 id;
+
+	struct gip_adapter *adapter;
+	struct gip_driver *drv;
+	struct semaphore drv_lock;
+
+	struct work_struct work_register;
+	struct work_struct work_unregister;
+
+	struct gip_chunk_buffer *chunk_buf_out;
+	struct gip_chunk_buffer *chunk_buf_in;
+	struct gip_hardware hardware;
+
+	struct gip_info_element *client_commands;
+	struct gip_info_element *firmware_versions;
+	struct gip_info_element *audio_formats;
+	struct gip_info_element *capabilities_out;
+	struct gip_info_element *capabilities_in;
+	struct gip_classes *classes;
+	struct gip_info_element *interfaces;
+	struct gip_info_element *hid_descriptor;
+
+	struct gip_audio_config audio_config_in;
+	struct gip_audio_config audio_config_out;
+};
+
+struct gip_driver_ops {
+	int (*battery)(struct gip_client *client,
+		       enum gip_battery_type type,
+		       enum gip_battery_level level);
+	int (*authenticate)(struct gip_client *client, void *data, u32 len);
+	int (*authenticated)(struct gip_client *client);
+	int (*guide_button)(struct gip_client *client, bool down);
+	int (*audio_ready)(struct gip_client *client);
+	int (*audio_volume)(struct gip_client *client, u8 in, u8 out);
+	int (*hid_report)(struct gip_client *client, void *data, u32 len);
+	int (*input)(struct gip_client *client, void *data, u32 len);
+	int (*firmware)(struct gip_client *client, void *data, u32 len);
+	int (*audio_samples)(struct gip_client *client, void *data, u32 len);
+};
+
+struct gip_driver {
+	struct device_driver drv;
+	const char *name;
+	const char *class;
+
+	struct gip_driver_ops ops;
+
+	int (*probe)(struct gip_client *client);
+	void (*remove)(struct gip_client *client);
+};
+
+struct gip_adapter *gip_create_adapter(struct device *parent,
+				       struct gip_adapter_ops *ops,
+				       int audio_pkts);
+int gip_power_off_adapter(struct gip_adapter *adap);
+void gip_destroy_adapter(struct gip_adapter *adap);
+
+struct gip_client *gip_get_client(struct gip_adapter *adap, u8 id);
+void gip_add_client(struct gip_client *client);
+void gip_remove_client(struct gip_client *client);
+void gip_free_client_info(struct gip_client *client);
+
+int __gip_register_driver(struct gip_driver *drv, struct module *owner,
+			  const char *mod_name);
+void gip_unregister_driver(struct gip_driver *drv);
diff --git a/drivers/custom/xonedo/bus/protocol.c b/drivers/custom/xonedo/bus/protocol.c
new file mode 100644
index 000000000000..0184b90c3499
--- /dev/null
+++ b/drivers/custom/xonedo/bus/protocol.c
@@ -0,0 +1,1622 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/slab.h>
+#include <linux/bitfield.h>
+#include <linux/uuid.h>
+
+#include "bus.h"
+
+#define GIP_HDR_CLIENT_ID GENMASK(3, 0)
+#define GIP_HDR_MIN_LENGTH 3
+
+/* max length, even for wireless packets (except audio) */
+#define GIP_PKT_MAX_LENGTH 58
+
+/* reliable packet transmission coalesce count */
+#define GIP_PKT_COALESCE_COUNT 5
+
+#define GIP_CHUNK_BUF_MAX_LENGTH 0xffff
+
+#define GIP_BATT_LEVEL GENMASK(1, 0)
+#define GIP_BATT_TYPE GENMASK(3, 2)
+#define GIP_STATUS_CONNECTED BIT(7)
+
+#define GIP_VKEY_LEFT_WIN 0x5b
+
+#define gip_dbg(client, ...) dev_dbg(&(client)->adapter->dev, __VA_ARGS__)
+#define gip_warn(client, ...) dev_warn(&(client)->adapter->dev, __VA_ARGS__)
+#define gip_err(client, ...) dev_err(&(client)->adapter->dev, __VA_ARGS__)
+
+enum gip_command_core {
+	GIP_CMD_ACKNOWLEDGE = 0x01,
+	GIP_CMD_ANNOUNCE = 0x02,
+	GIP_CMD_STATUS = 0x03,
+	GIP_CMD_IDENTIFY = 0x04,
+	GIP_CMD_POWER = 0x05,
+	GIP_CMD_AUTHENTICATE = 0x06,
+	GIP_CMD_VIRTUAL_KEY = 0x07,
+	GIP_CMD_AUDIO_CONTROL = 0x08,
+	GIP_CMD_LED = 0x0a,
+	GIP_CMD_HID_REPORT = 0x0b,
+	GIP_CMD_FIRMWARE = 0x0c,
+	GIP_CMD_SERIAL_NUMBER = 0x1e,
+	GIP_CMD_AUDIO_SAMPLES = 0x60,
+};
+
+enum gip_command_client {
+	GIP_CMD_RUMBLE = 0x09,
+	GIP_CMD_INPUT = 0x20,
+};
+
+enum gip_option {
+	GIP_OPT_ACKNOWLEDGE = BIT(4),
+	GIP_OPT_INTERNAL = BIT(5),
+	GIP_OPT_CHUNK_START = BIT(6),
+	GIP_OPT_CHUNK = BIT(7),
+};
+
+enum gip_audio_control {
+	GIP_AUD_CTRL_VOLUME_CHAT = 0x00,
+	GIP_AUD_CTRL_FORMAT_CHAT = 0x01,
+	GIP_AUD_CTRL_FORMAT = 0x02,
+	GIP_AUD_CTRL_VOLUME = 0x03,
+};
+
+enum gip_audio_volume_mute {
+	GIP_AUD_VOLUME_UNMUTED = 0x04,
+	GIP_AUD_VOLUME_MIC_MUTED = 0x05,
+};
+
+struct gip_pkt_acknowledge {
+	u8 unknown;
+	u8 command;
+	u8 options;
+	__le16 length;
+	u8 padding[2];
+	__le16 remaining;
+} __packed;
+
+struct gip_pkt_announce {
+	u8 address[6];
+	__le16 unknown;
+	__le16 vendor_id;
+	__le16 product_id;
+	struct gip_version {
+		__le16 major;
+		__le16 minor;
+		__le16 build;
+		__le16 revision;
+	} __packed fw_version, hw_version;
+} __packed;
+
+struct gip_pkt_status {
+	u8 status;
+	u8 unknown[3];
+} __packed;
+
+struct gip_pkt_identify {
+	u8 unknown[16];
+	__le16 client_commands_offset;
+	__le16 firmware_versions_offset;
+	__le16 audio_formats_offset;
+	__le16 capabilities_out_offset;
+	__le16 capabilities_in_offset;
+	__le16 classes_offset;
+	__le16 interfaces_offset;
+	__le16 hid_descriptor_offset;
+} __packed;
+
+struct gip_pkt_power {
+	u8 mode;
+} __packed;
+
+struct gip_pkt_virtual_key {
+	u8 down;
+	u8 key;
+} __packed;
+
+struct gip_pkt_audio_control {
+	u8 subcommand;
+} __packed;
+
+struct gip_pkt_audio_volume_chat {
+	struct gip_pkt_audio_control control;
+	u8 mute;
+	u8 gain_out;
+	u8 out;
+	u8 in;
+} __packed;
+
+struct gip_pkt_audio_format_chat {
+	struct gip_pkt_audio_control control;
+	u8 in_out;
+} __packed;
+
+struct gip_pkt_audio_format {
+	struct gip_pkt_audio_control control;
+	u8 in;
+	u8 out;
+} __packed;
+
+struct gip_pkt_audio_volume {
+	struct gip_pkt_audio_control control;
+	u8 mute;
+	u8 out;
+	u8 chat;
+	u8 in;
+	u8 unknown1;
+	u8 unknown2[2];
+} __packed;
+
+struct gip_pkt_led {
+	u8 unknown;
+	u8 mode;
+	u8 brightness;
+} __packed;
+
+struct gip_pkt_serial_number {
+	u8 unknown[2];
+	char serial[14];
+} __packed;
+
+struct gip_pkt_audio_samples {
+	__le16 length_out;
+	u8 samples[];
+} __packed;
+
+struct gip_command_descriptor {
+	u8 marker;
+	u8 unknown1;
+	u8 command;
+	u8 length;
+	u8 unknown2[3];
+	u8 options;
+	u8 unknown3[15];
+} __packed;
+
+struct gip_firmware_version {
+	__le16 major;
+	__le16 minor;
+} __packed;
+
+static int gip_encode_varint(u8 *buf, u32 val)
+{
+	int i;
+
+	/* encode variable-length integer */
+	for (i = 0; i < sizeof(val); i++) {
+		buf[i] = val;
+		if (val > GENMASK(6, 0))
+			buf[i] |= BIT(7);
+
+		val >>= 7;
+		if (!val)
+			break;
+	}
+
+	return i + 1;
+}
+
+static int gip_decode_varint(u8 *data, int len, u32 *val)
+{
+	int i;
+
+	/* decode variable-length integer */
+	for (i = 0; i < sizeof(*val) && i < len; i++) {
+		*val |= (data[i] & GENMASK(6, 0)) << (i * 7);
+
+		if (!(data[i] & BIT(7)))
+			break;
+	}
+
+	return i + 1;
+}
+
+static int gip_get_actual_header_length(struct gip_header *hdr)
+{
+	u32 pkt_len = hdr->packet_length;
+	u32 chunk_offset = hdr->chunk_offset;
+	int len = GIP_HDR_MIN_LENGTH;
+
+	do {
+		len++;
+		pkt_len >>= 7;
+	} while (pkt_len);
+
+	if (hdr->options & GIP_OPT_CHUNK) {
+		while (chunk_offset) {
+			len++;
+			chunk_offset >>= 7;
+		}
+	}
+
+	return len;
+}
+
+static int gip_get_header_length(struct gip_header *hdr)
+{
+	int len = gip_get_actual_header_length(hdr);
+
+	/* round up to nearest even length */
+	return len + (len % 2);
+}
+
+static void gip_encode_header(struct gip_header *hdr, u8 *buf)
+{
+	int hdr_len = 0;
+
+	buf[hdr_len++] = hdr->command;
+	buf[hdr_len++] = hdr->options;
+	buf[hdr_len++] = hdr->sequence;
+
+	hdr_len += gip_encode_varint(buf + hdr_len, hdr->packet_length);
+
+	/* header length must be even */
+	if (gip_get_actual_header_length(hdr) % 2) {
+		buf[hdr_len - 1] |= BIT(7);
+		buf[hdr_len++] = 0;
+	}
+
+	if (hdr->options & GIP_OPT_CHUNK)
+		gip_encode_varint(buf + hdr_len, hdr->chunk_offset);
+}
+
+static int gip_decode_header(struct gip_header *hdr, u8 *data, int len)
+{
+	int hdr_len = 0;
+
+	hdr->command = data[hdr_len++];
+	hdr->options = data[hdr_len++];
+	hdr->sequence = data[hdr_len++];
+	hdr->packet_length = 0;
+	hdr->chunk_offset = 0;
+
+	hdr_len += gip_decode_varint(data + hdr_len, len - hdr_len,
+				     &hdr->packet_length);
+
+	if (hdr->options & GIP_OPT_CHUNK)
+		hdr_len += gip_decode_varint(data + hdr_len, len - hdr_len,
+					     &hdr->chunk_offset);
+
+	return hdr_len;
+}
+
+static int gip_init_chunk_buffer(struct gip_client *client,
+				 struct gip_header *hdr,
+				 struct gip_chunk_buffer **buf,
+				 bool is_input)
+{
+	/* offset is total length of all chunks */
+	if (hdr->chunk_offset > GIP_CHUNK_BUF_MAX_LENGTH)
+		return -EINVAL;
+
+	if (*buf) {
+		gip_err(client, "%s: already initialized (%s)\n", __func__,
+				is_input ? "in" : "out");
+		kfree(*buf);
+		*buf = NULL;
+	}
+
+	*buf = kzalloc(sizeof(**buf) + hdr->chunk_offset, GFP_ATOMIC);
+	if (!*buf)
+		return -ENOMEM;
+
+	(*buf)->header = *hdr;
+	/* clear GIP_OPT_ACKNOWLEDGE and GIP_OPT_CHUNK_START */
+	(*buf)->header.options &= ~(GIP_OPT_ACKNOWLEDGE | GIP_OPT_CHUNK_START);
+	(*buf)->length = hdr->chunk_offset;
+	gip_dbg(client, "%s[%s]: command=0x%02x, length=0x%04x\n", __func__,
+		is_input ? "in" : "out",
+		(*buf)->header.command, (*buf)->length);
+
+	return 0;
+}
+
+static int gip_send_pkt_simple(struct gip_client *client,
+			       struct gip_header *hdr, void *data)
+{
+	struct gip_adapter *adap = client->adapter;
+	struct gip_adapter_buffer buf = {};
+	int hdr_len, err;
+	unsigned long flags;
+
+	buf.type = GIP_BUF_DATA;
+
+	spin_lock_irqsave(&adap->send_lock, flags);
+
+	err = adap->ops->get_buffer(adap, &buf);
+	if (err) {
+		gip_err(client, "%s: get buffer failed: %d\n", __func__, err);
+		goto err_unlock;
+	}
+
+	hdr_len = gip_get_header_length(hdr);
+	if (buf.length < hdr_len + hdr->packet_length) {
+		err = -ENOSPC;
+		goto err_unlock;
+	}
+
+	/* sequence number is always greater than zero */
+	while (!hdr->sequence)
+		hdr->sequence = adap->data_sequence++;
+
+	gip_encode_header(hdr, buf.data);
+	if (data)
+		memcpy(buf.data + hdr_len, data, hdr->packet_length);
+
+	/* set actual length */
+	buf.length = hdr_len + hdr->packet_length;
+
+	/* debug message sent */
+	gip_dbg(client, "%s: cmd=0x%02x len=0x%04x seq=0x%02x offset=0x%04x\n",
+		__func__, hdr->command, buf.length, hdr->sequence,
+		hdr->chunk_offset);
+
+	/* always fails on adapter removal */
+	err = adap->ops->submit_buffer(adap, &buf);
+	if (err)
+		gip_dbg(client, "%s: submit buffer failed: %d\n", __func__, err);
+
+err_unlock:
+	spin_unlock_irqrestore(&adap->send_lock, flags);
+
+	return err;
+}
+
+static int gip_send_pkt(struct gip_client *client,
+			struct gip_header *hdr, void *data)
+{
+	int err;
+
+	/* packet fits into single buffer */
+	if (hdr->packet_length <= GIP_PKT_MAX_LENGTH)
+		return gip_send_pkt_simple(client, hdr, data);
+
+	/* chunk offset of first chunk is total length */
+	hdr->options |= GIP_OPT_ACKNOWLEDGE | GIP_OPT_CHUNK_START |
+			GIP_OPT_CHUNK;
+	hdr->chunk_offset = hdr->packet_length;
+	hdr->packet_length = GIP_PKT_MAX_LENGTH;
+
+	err = gip_send_pkt_simple(client, hdr, data);
+	if (err)
+		return err;
+
+	/* allocate output buffer for all chunks */
+	err = gip_init_chunk_buffer(client, hdr, &client->chunk_buf_in, false);
+	if (err)
+		return err;
+
+	if (data)
+		memcpy(client->chunk_buf_in->data, data, hdr->chunk_offset);
+
+	return 0;
+}
+
+static int gip_acknowledge_pkt(struct gip_client *client,
+			       struct gip_header *ack)
+{
+	struct gip_chunk_buffer *buf = client->chunk_buf_out;
+	struct gip_header hdr = {};
+	struct gip_pkt_acknowledge pkt = {};
+	u32 len = ack->chunk_offset + ack->packet_length;
+
+	hdr.command = GIP_CMD_ACKNOWLEDGE;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.sequence = ack->sequence;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.command = ack->command;
+	pkt.options = client->id | GIP_OPT_INTERNAL;
+	pkt.length = cpu_to_le16(len);
+
+	if ((ack->options & GIP_OPT_CHUNK) && buf)
+		pkt.remaining = cpu_to_le16(buf->length - len);
+
+	gip_dbg(client, "%s: ACME(host) command=0x%02x, length=0x%04x\n",
+		__func__, pkt.command, len);
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+
+static int gip_request_identification(struct gip_client *client)
+{
+	struct gip_header hdr = {};
+
+	hdr.command = GIP_CMD_IDENTIFY;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+
+	return gip_send_pkt(client, &hdr, NULL);
+}
+
+int gip_set_power_mode(struct gip_client *client, enum gip_power_mode mode)
+{
+	struct gip_header hdr = {};
+	struct gip_pkt_power pkt = {};
+
+	hdr.command = GIP_CMD_POWER;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.mode = mode;
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+EXPORT_SYMBOL_GPL(gip_set_power_mode);
+
+int gip_send_authenticate(struct gip_client *client, void *pkt, u32 len,
+			  bool acknowledge)
+{
+	struct gip_header hdr = {};
+
+	hdr.command = GIP_CMD_AUTHENTICATE;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = len;
+
+	if (acknowledge)
+		hdr.options |= GIP_OPT_ACKNOWLEDGE;
+
+	return gip_send_pkt(client, &hdr, pkt);
+}
+
+static int gip_set_audio_format_chat(struct gip_client *client,
+				     enum gip_audio_format_chat in_out)
+{
+	struct gip_header hdr = {};
+	struct gip_pkt_audio_format_chat pkt = {};
+
+	hdr.command = GIP_CMD_AUDIO_CONTROL;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.control.subcommand = GIP_AUD_CTRL_FORMAT_CHAT;
+	pkt.in_out = in_out;
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+
+static int gip_set_audio_format(struct gip_client *client,
+				enum gip_audio_format in,
+				enum gip_audio_format out)
+{
+	struct gip_header hdr = {};
+	struct gip_pkt_audio_format pkt = {};
+
+	hdr.command = GIP_CMD_AUDIO_CONTROL;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.control.subcommand = GIP_AUD_CTRL_FORMAT;
+	pkt.in = in;
+	pkt.out = out;
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+
+int gip_suggest_audio_format(struct gip_client *client,
+			     enum gip_audio_format in,
+			     enum gip_audio_format out,
+			     bool chat)
+{
+	int err;
+
+	/* special handling for the chat headset */
+	if (chat)
+		err = gip_set_audio_format_chat(client,
+						GIP_AUD_FORMAT_CHAT_24KHZ);
+	else
+		err = gip_set_audio_format(client, in, out);
+
+	if (err) {
+		gip_err(client, "%s: set format failed: %d\n", __func__, err);
+		return err;
+	}
+
+	client->audio_config_in.format = in;
+	client->audio_config_out.format = out;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gip_suggest_audio_format);
+
+int gip_set_audio_volume(struct gip_client *client, u8 in, u8 chat, u8 out)
+{
+	struct gip_header hdr = {};
+	struct gip_pkt_audio_volume pkt = {};
+
+	hdr.command = GIP_CMD_AUDIO_CONTROL;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.control.subcommand = GIP_AUD_CTRL_VOLUME;
+	pkt.mute = GIP_AUD_VOLUME_UNMUTED;
+	pkt.out = out;
+	pkt.chat = chat;
+	pkt.in = in;
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+EXPORT_SYMBOL_GPL(gip_set_audio_volume);
+
+int gip_send_rumble(struct gip_client *client, void *pkt, u32 len)
+{
+	struct gip_header hdr = {};
+
+	hdr.command = GIP_CMD_RUMBLE;
+	hdr.options = client->id;
+	hdr.packet_length = len;
+
+	return gip_send_pkt(client, &hdr, pkt);
+}
+EXPORT_SYMBOL_GPL(gip_send_rumble);
+
+int gip_set_led_mode(struct gip_client *client,
+		     enum gip_led_mode mode, u8 brightness)
+{
+	struct gip_header hdr = {};
+	struct gip_pkt_led pkt = {};
+
+	hdr.command = GIP_CMD_LED;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = sizeof(pkt);
+
+	pkt.mode = mode;
+	pkt.brightness = brightness;
+
+	return gip_send_pkt(client, &hdr, &pkt);
+}
+EXPORT_SYMBOL_GPL(gip_set_led_mode);
+
+static void gip_copy_audio_samples(struct gip_client *client,
+				   void *samples, void *buf)
+{
+	struct gip_audio_config *cfg = &client->audio_config_out;
+	struct gip_header hdr = {};
+	void *src, *dest;
+	int hdr_len, i;
+
+	hdr.command = GIP_CMD_AUDIO_SAMPLES;
+	hdr.options = client->id | GIP_OPT_INTERNAL;
+	hdr.packet_length = cfg->fragment_size;
+
+	hdr_len = gip_get_header_length(&hdr);
+
+	for (i = 0; i < client->adapter->audio_packet_count; i++) {
+		src = samples + i * cfg->fragment_size;
+		dest = buf + i * cfg->packet_size;
+
+		/* sequence number is always greater than zero */
+		do {
+			hdr.sequence = client->adapter->audio_sequence++;
+		} while (!hdr.sequence);
+
+		gip_encode_header(&hdr, dest);
+		memcpy(dest + hdr_len, src, cfg->fragment_size);
+	}
+}
+
+int gip_send_audio_samples(struct gip_client *client, void *samples)
+{
+	struct gip_adapter *adap = client->adapter;
+	struct gip_adapter_buffer buf = {};
+	int err;
+
+	buf.type = GIP_BUF_AUDIO;
+
+	/* returns ENOSPC if no buffer is available */
+	err = adap->ops->get_buffer(adap, &buf);
+	if (err) {
+		gip_err(client, "%s: get buffer failed: %d\n", __func__, err);
+		return err;
+	}
+
+	gip_copy_audio_samples(client, samples, buf.data);
+
+	/* set actual length */
+	buf.length = client->audio_config_out.packet_size *
+		     adap->audio_packet_count;
+
+	/* always fails on adapter removal */
+	err = adap->ops->submit_buffer(adap, &buf);
+	if (err)
+		gip_dbg(client, "%s: submit buffer failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(gip_send_audio_samples);
+
+bool gip_has_interface(struct gip_client *client, const guid_t *guid)
+{
+	int i;
+
+	for (i = 0; i < client->interfaces->count; i++) {
+		if (guid_equal((guid_t *)client->interfaces->data + i, guid))
+			return true;
+	}
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(gip_has_interface);
+
+int gip_set_encryption_key(struct gip_client *client, u8 *key, int len)
+{
+	struct gip_adapter *adap = client->adapter;
+	int err;
+
+	if (!adap->ops->set_encryption_key) {
+		gip_dbg(client, "%s: no callback, notifying driver.\n",
+				__func__);
+		if (client->drv->ops.authenticated)
+			return client->drv->ops.authenticated(client);
+		return 0;
+	}
+
+	err = adap->ops->set_encryption_key(adap, key, len);
+	if (err) {
+		gip_err(client, "%s: set key failed: %d\n", __func__, err);
+		return err;
+	}
+
+	if (client->drv->ops.authenticated)
+		client->drv->ops.authenticated(client);
+
+	return 0;
+}
+
+int gip_enable_audio(struct gip_client *client)
+{
+	struct gip_adapter *adap = client->adapter;
+	int err;
+
+	if (!adap->ops->enable_audio)
+		return 0;
+
+	err = adap->ops->enable_audio(adap);
+	if (err)
+		gip_err(client, "%s: enable failed: %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(gip_enable_audio);
+
+int gip_init_audio_in(struct gip_client *client)
+{
+	struct gip_adapter *adap = client->adapter;
+	int err;
+
+	if (!adap->ops->init_audio_in)
+		return 0;
+
+	err = adap->ops->init_audio_in(adap);
+	if (err)
+		gip_err(client, "%s: init failed: %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(gip_init_audio_in);
+
+int gip_init_audio_out(struct gip_client *client)
+{
+	struct gip_adapter *adap = client->adapter;
+	int err;
+
+	if (!adap->ops->init_audio_out)
+		return 0;
+
+	err = adap->ops->init_audio_out(adap,
+					client->audio_config_out.packet_size);
+	if (err)
+		gip_err(client, "%s: init failed: %d\n", __func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(gip_init_audio_out);
+
+int gip_init_extra_data(struct gip_client *client)
+{
+	struct gip_header hdr = {
+		.command = 0x4d, // ???
+		.options = GIP_OPT_ACKNOWLEDGE, // Because 4
+		.sequence = 1,
+		.packet_length = 2,
+	};
+	u8 packet_data[] = { 0x07, 0x00 };
+
+	return gip_send_pkt(client, &hdr, &packet_data);
+}
+EXPORT_SYMBOL_GPL(gip_init_extra_data);
+
+void gip_disable_audio(struct gip_client *client)
+{
+	struct gip_adapter *adap = client->adapter;
+	int err;
+
+	if (!adap->ops->disable_audio)
+		return;
+
+	/* always fails on adapter removal */
+	err = adap->ops->disable_audio(adap);
+	if (err)
+		gip_dbg(client, "%s: disable failed: %d\n", __func__, err);
+}
+EXPORT_SYMBOL_GPL(gip_disable_audio);
+
+static int gip_make_audio_config(struct gip_client *client,
+				 struct gip_audio_config *cfg)
+{
+	struct gip_header hdr = {};
+
+	switch (cfg->format) {
+	case GIP_AUD_FORMAT_16KHZ_MONO:
+		cfg->channels = 1;
+		cfg->sample_rate = 16000;
+		break;
+	case GIP_AUD_FORMAT_24KHZ_MONO:
+		cfg->channels = 1;
+		cfg->sample_rate = 24000;
+		break;
+	case GIP_AUD_FORMAT_48KHZ_STEREO:
+		cfg->channels = 2;
+		cfg->sample_rate = 48000;
+		break;
+	default:
+		gip_err(client, "%s: unknown format: 0x%02x\n",
+			__func__, cfg->format);
+		return -ENOTSUPP;
+	}
+
+	cfg->buffer_size = cfg->sample_rate * cfg->channels *
+			   sizeof(s16) * GIP_AUDIO_INTERVAL / MSEC_PER_SEC;
+	cfg->fragment_size = cfg->buffer_size /
+			     client->adapter->audio_packet_count;
+
+	/* pseudo header for length calculation */
+	hdr.packet_length = cfg->fragment_size;
+	cfg->packet_size = gip_get_header_length(&hdr) + cfg->fragment_size;
+
+	gip_dbg(client, "%s: rate=%d/%d, buffer=%d\n", __func__,
+		cfg->sample_rate, cfg->channels, cfg->buffer_size);
+
+	return 0;
+}
+
+static struct gip_info_element *gip_parse_info_element(u8 *data, u32 len,
+						       __le16 offset,
+						       int item_length)
+{
+	struct gip_info_element *elem;
+	u16 off = le16_to_cpu(offset);
+	u8 count;
+	int total;
+
+	if (!off)
+		return ERR_PTR(-ENOTSUPP);
+
+	if (len < off + sizeof(count))
+		return ERR_PTR(-EINVAL);
+
+	count = data[off++];
+	if (!count)
+		return ERR_PTR(-ENOTSUPP);
+
+	total = count * item_length;
+	if (len < off + total)
+		return ERR_PTR(-EINVAL);
+
+	elem = kzalloc(sizeof(*elem) + total, GFP_ATOMIC);
+	if (!elem)
+		return ERR_PTR(-ENOMEM);
+
+	elem->count = count;
+	memcpy(elem->data, data + off, total);
+
+	return elem;
+}
+
+static int gip_parse_client_commands(struct gip_client *client,
+				     struct gip_pkt_identify *pkt,
+				     u8 *data, u32 len)
+{
+	struct gip_info_element *cmds;
+	struct gip_command_descriptor *desc;
+	int i;
+
+	cmds = gip_parse_info_element(data, len, pkt->client_commands_offset,
+				      sizeof(*desc));
+	if (IS_ERR(cmds)) {
+		if (PTR_ERR(cmds) == -ENOTSUPP)
+			return 0;
+
+		gip_err(client, "%s: parse failed: %ld\n",
+			__func__, PTR_ERR(cmds));
+		return PTR_ERR(cmds);
+	}
+
+	for (i = 0; i < cmds->count; i++) {
+		desc = (struct gip_command_descriptor *)cmds->data + i;
+		gip_dbg(client,
+			"%s: command=0x%02x, length=0x%02x, options=0x%02x\n",
+			__func__, desc->command, desc->length, desc->options);
+	}
+
+	client->client_commands = cmds;
+
+	return 0;
+}
+
+static int gip_parse_firmware_versions(struct gip_client *client,
+				       struct gip_pkt_identify *pkt,
+				       u8 *data, u32 len)
+{
+	struct gip_info_element *vers;
+	struct gip_firmware_version *ver;
+	int i;
+
+	vers = gip_parse_info_element(data, len, pkt->firmware_versions_offset,
+				      sizeof(*ver));
+	if (IS_ERR(vers)) {
+		gip_err(client, "%s: parse failed: %ld\n",
+			__func__, PTR_ERR(vers));
+		return PTR_ERR(vers);
+	}
+
+	for (i = 0; i < vers->count; i++) {
+		ver = (struct gip_firmware_version *)vers->data + i;
+		gip_dbg(client, "%s: version=%u.%u\n", __func__,
+			le16_to_cpu(ver->major), le16_to_cpu(ver->minor));
+	}
+
+	client->firmware_versions = vers;
+
+	return 0;
+}
+
+static int gip_parse_audio_formats(struct gip_client *client,
+				   struct gip_pkt_identify *pkt,
+				   u8 *data, u32 len)
+{
+	struct gip_info_element *fmts;
+
+	fmts = gip_parse_info_element(data, len,
+				      pkt->audio_formats_offset, 2);
+	if (IS_ERR(fmts)) {
+		if (PTR_ERR(fmts) == -ENOTSUPP)
+			return 0;
+
+		gip_err(client, "%s: parse failed: %ld\n",
+			__func__, PTR_ERR(fmts));
+		return PTR_ERR(fmts);
+	}
+
+	gip_dbg(client, "%s: formats=%*phD\n", __func__,
+		fmts->count * 2, fmts->data);
+	client->audio_formats = fmts;
+
+	return 0;
+}
+
+static int gip_parse_capabilities(struct gip_client *client,
+				  struct gip_pkt_identify *pkt,
+				  u8 *data, u32 len)
+{
+	struct gip_info_element *caps;
+
+	caps = gip_parse_info_element(data, len,
+				      pkt->capabilities_out_offset, 1);
+	if (IS_ERR(caps)) {
+		gip_err(client, "%s: parse out failed: %ld\n",
+			__func__, PTR_ERR(caps));
+		return PTR_ERR(caps);
+	}
+
+	gip_dbg(client, "%s: out=%*phD\n", __func__, caps->count, caps->data);
+	client->capabilities_out = caps;
+
+	caps = gip_parse_info_element(data, len,
+				      pkt->capabilities_in_offset, 1);
+	if (IS_ERR(caps)) {
+		gip_err(client, "%s: parse in failed: %ld\n",
+			__func__, PTR_ERR(caps));
+		return PTR_ERR(caps);
+	}
+
+	gip_dbg(client, "%s: in=%*phD\n", __func__, caps->count, caps->data);
+	client->capabilities_in = caps;
+
+	return 0;
+}
+
+static int gip_parse_classes(struct gip_client *client,
+			     struct gip_pkt_identify *pkt,
+			     u8 *data, u32 len)
+{
+	struct gip_classes *classes;
+	u16 off = le16_to_cpu(pkt->classes_offset);
+	u8 count;
+	u16 str_len;
+	char *str;
+
+	if (len < off + sizeof(count))
+		return -EINVAL;
+
+	/* number of individual strings */
+	count = data[off++];
+	if (!count)
+		return -EINVAL;
+
+	classes = kzalloc(sizeof(*classes) + sizeof(char *) * count,
+			  GFP_ATOMIC);
+	if (!classes)
+		return -ENOMEM;
+
+	client->classes = classes;
+
+	while (classes->count < count) {
+		if (len < off + sizeof(str_len))
+			return -EINVAL;
+
+		str_len = le16_to_cpup((__le16 *)(data + off));
+		off += sizeof(str_len);
+		if (!str_len || len < off + str_len)
+			return -EINVAL;
+
+		/* null-terminated string */
+		str = kzalloc(str_len + 1, GFP_ATOMIC);
+		if (!str)
+			return -ENOMEM;
+
+		memcpy(str, data + off, str_len);
+		classes->strings[classes->count] = str;
+		classes->count++;
+		off += str_len;
+
+		gip_dbg(client, "%s: class=%s\n", __func__, str);
+	}
+
+	return 0;
+}
+
+static int gip_parse_interfaces(struct gip_client *client,
+				struct gip_pkt_identify *pkt,
+				u8 *data, u32 len)
+{
+	struct gip_info_element *intfs;
+	guid_t *guid;
+	int i;
+
+	intfs = gip_parse_info_element(data, len, pkt->interfaces_offset,
+				       sizeof(guid_t));
+	if (IS_ERR(intfs)) {
+		gip_err(client, "%s: parse failed: %ld\n",
+			__func__, PTR_ERR(intfs));
+		return PTR_ERR(intfs);
+	}
+
+	for (i = 0; i < intfs->count; i++) {
+		guid = (guid_t *)intfs->data + i;
+		gip_dbg(client, "%s: guid=%pUb\n", __func__, guid);
+	}
+
+	client->interfaces = intfs;
+
+	return 0;
+}
+
+static int gip_parse_hid_descriptor(struct gip_client *client,
+				    struct gip_pkt_identify *pkt,
+				    u8 *data, u32 len)
+{
+	struct gip_info_element *desc;
+
+	desc = gip_parse_info_element(data, len,
+				      pkt->hid_descriptor_offset, 1);
+	if (IS_ERR(desc)) {
+		if (PTR_ERR(desc) == -ENOTSUPP)
+			return 0;
+
+		gip_err(client, "%s: parse failed: %ld\n",
+			__func__, PTR_ERR(desc));
+		return PTR_ERR(desc);
+	}
+
+	gip_dbg(client, "%s: length=0x%02x\n", __func__, desc->count);
+	client->hid_descriptor = desc;
+
+	return 0;
+}
+
+static int gip_send_remaining_chunks(struct gip_client *client, u32 offset)
+{
+	struct gip_chunk_buffer *buf = client->chunk_buf_in;
+	struct gip_header hdr = buf->header;
+	u32 len = buf->length - offset;
+	int err;
+
+	gip_dbg(client, "%s: sending chunk 0x%04x/0x%04x/0x%04x\n", __func__,
+		len, hdr.chunk_offset, buf->length);
+
+	int coalesce_count = GIP_PKT_COALESCE_COUNT;
+	while (len && coalesce_count) {
+		/* require acknowledgment for last chunk */
+		if (len <= GIP_PKT_MAX_LENGTH)
+			hdr.options |= GIP_OPT_ACKNOWLEDGE;
+
+		hdr.packet_length = min_t(u32, len, GIP_PKT_MAX_LENGTH);
+		hdr.chunk_offset = buf->length - len;
+
+		err = gip_send_pkt_simple(client, &hdr,
+					  buf->data + hdr.chunk_offset);
+		if (err)
+			return err;
+
+		len -= hdr.packet_length;
+		coalesce_count--;
+	}
+
+	return 0;
+}
+
+static int gip_handle_pkt_acknowledge(struct gip_client *client,
+				      void *data, u32 len)
+{
+	struct gip_pkt_acknowledge *pkt = data;
+	struct gip_chunk_buffer *buf = client->chunk_buf_in;
+	struct gip_header hdr;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	if (!buf)
+		return 0;
+
+	gip_dbg(client, "%s: ACME(dev) cmd=0x%02x/0x%02x, len=0x%04x/0x%04x\n",
+		__func__, pkt->command, buf->header.command,
+		le16_to_cpu(pkt->length), buf->length);
+
+	/* acknowledgment for different command */
+	if (pkt->command != buf->header.command)
+		return 0;
+
+	/*
+	 * offset comes from the device and may be malicious or invalid
+	 * so sanitize value to prevent buffer overflow.
+	 */
+	if (le16_to_cpu(pkt->length) < buf->length)
+		return gip_send_remaining_chunks(client, le16_to_cpu(pkt->length));
+
+	gip_dbg(client, "%s: all chunks sent\n", __func__);
+
+	/* empty chunk signals the completion of the transfer */
+	hdr = buf->header;
+	hdr.packet_length = 0;
+	hdr.chunk_offset = buf->length;
+
+	kfree(buf);
+	client->chunk_buf_in = NULL;
+
+	return gip_send_pkt_simple(client, &hdr, NULL);
+}
+
+static int gip_handle_pkt_announce(struct gip_client *client,
+				   void *data, u32 len)
+{
+	struct gip_pkt_announce *pkt = data;
+	struct gip_hardware *hw = &client->hardware;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	if (!hw->vendor && !hw->product && !hw->version) {
+		hw->vendor = le16_to_cpu(pkt->vendor_id);
+		hw->product = le16_to_cpu(pkt->product_id);
+		hw->version = (le16_to_cpu(pkt->fw_version.major) << 8) |
+			      le16_to_cpu(pkt->fw_version.minor);
+	}
+
+	gip_dbg(client, "%s: address=%pM, vendor=0x%04x, product=0x%04x\n",
+		__func__, pkt->address, hw->vendor, hw->product);
+	gip_dbg(client, "%s: firmware=%u.%u.%u.%u, hardware=%u.%u.%u.%u\n",
+		__func__,
+		le16_to_cpu(pkt->fw_version.major),
+		le16_to_cpu(pkt->fw_version.minor),
+		le16_to_cpu(pkt->fw_version.build),
+		le16_to_cpu(pkt->fw_version.revision),
+		le16_to_cpu(pkt->hw_version.major),
+		le16_to_cpu(pkt->hw_version.minor),
+		le16_to_cpu(pkt->hw_version.build),
+		le16_to_cpu(pkt->hw_version.revision));
+
+	return gip_request_identification(client);
+}
+
+static int gip_handle_pkt_status(struct gip_client *client,
+				 void *data, u32 len)
+{
+	struct gip_pkt_status *pkt = data;
+	int err = 0;
+	u8 batt_type, batt_lvl;
+
+	/* some devices occasionally send larger status packets */
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	if (!(pkt->status & GIP_STATUS_CONNECTED)) {
+		gip_dbg(client, "%s: disconnected\n", __func__);
+		gip_remove_client(client);
+		return 0;
+	}
+
+	batt_type = FIELD_GET(GIP_BATT_TYPE, pkt->status);
+	batt_lvl = FIELD_GET(GIP_BATT_LEVEL, pkt->status);
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.battery)
+		err = client->drv->ops.battery(client, batt_type, batt_lvl);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_identify(struct gip_client *client,
+				   void *data, u32 len)
+{
+	struct gip_pkt_identify *pkt = data;
+	int err;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	if (client->classes) {
+		gip_warn(client, "%s: already identified\n", __func__);
+		return 0;
+	}
+
+	/* skip unknown header */
+	data += sizeof(pkt->unknown);
+	len -= sizeof(pkt->unknown);
+
+	err = gip_parse_client_commands(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_firmware_versions(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_audio_formats(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_capabilities(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_classes(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_interfaces(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	err = gip_parse_hid_descriptor(client, pkt, data, len);
+	if (err)
+		goto err_free_info;
+
+	gip_add_client(client);
+
+	return 0;
+
+err_free_info:
+	gip_free_client_info(client);
+
+	return err;
+}
+
+static int gip_handle_pkt_authenticate(struct gip_client *client,
+				       void *data, u32 len)
+{
+	int err = 0;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.authenticate)
+		err = client->drv->ops.authenticate(client, data, len);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_virtual_key(struct gip_client *client,
+				      void *data, u32 len)
+{
+	struct gip_pkt_virtual_key *pkt = data;
+	int err = 0;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	if (pkt->key != GIP_VKEY_LEFT_WIN)
+		return -EINVAL;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.guide_button)
+		err = client->drv->ops.guide_button(client, pkt->down);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_format_chat(struct gip_client *client,
+					    void *data, u32 len)
+{
+	struct gip_pkt_audio_format_chat *pkt = data;
+	struct gip_audio_config *in = &client->audio_config_in;
+	struct gip_audio_config *out = &client->audio_config_out;
+	int err;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	/* chat headsets apparently default to 24 kHz */
+	if (pkt->in_out != GIP_AUD_FORMAT_CHAT_24KHZ ||
+	    in->buffer_size || out->buffer_size)
+		return -EPROTO;
+
+	err = gip_make_audio_config(client, in);
+	if (err)
+		return err;
+
+	err = gip_make_audio_config(client, out);
+	if (err)
+		return err;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.audio_ready)
+		err = client->drv->ops.audio_ready(client);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_volume_chat(struct gip_client *client,
+					    void *data, u32 len)
+{
+	struct gip_pkt_audio_volume_chat *pkt = data;
+	int err = 0;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.audio_volume)
+		err = client->drv->ops.audio_volume(client, pkt->in, pkt->out);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_format(struct gip_client *client,
+				       void *data, u32 len)
+{
+	struct gip_pkt_audio_format *pkt = data;
+	struct gip_audio_config *in = &client->audio_config_in;
+	struct gip_audio_config *out = &client->audio_config_out;
+	int err;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	/* format has already been accepted */
+	if (in->buffer_size || out->buffer_size)
+		return -EPROTO;
+
+	/* client rejected format, accept new format */
+	if (pkt->in != in->format || pkt->out != out->format) {
+		gip_warn(client, "%s: rejected: 0x%02x/0x%02x\n",
+			 __func__, in->format, out->format);
+		return gip_suggest_audio_format(client, pkt->in, pkt->out,
+						false);
+	}
+
+	err = gip_make_audio_config(client, in);
+	if (err)
+		return err;
+
+	err = gip_make_audio_config(client, out);
+	if (err)
+		return err;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.audio_ready)
+		err = client->drv->ops.audio_ready(client);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_volume(struct gip_client *client,
+				       void *data, u32 len)
+{
+	struct gip_pkt_audio_volume *pkt = data;
+	int err = 0;
+
+	if (len != sizeof(*pkt))
+		return -EINVAL;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.audio_volume)
+		err = client->drv->ops.audio_volume(client, pkt->in, pkt->out);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_control(struct gip_client *client,
+					void *data, u32 len)
+{
+	struct gip_pkt_audio_control *pkt = data;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	switch (pkt->subcommand) {
+	case GIP_AUD_CTRL_FORMAT_CHAT:
+		return gip_handle_pkt_audio_format_chat(client, data, len);
+	case GIP_AUD_CTRL_VOLUME_CHAT:
+		return gip_handle_pkt_audio_volume_chat(client, data, len);
+	case GIP_AUD_CTRL_FORMAT:
+		return gip_handle_pkt_audio_format(client, data, len);
+	case GIP_AUD_CTRL_VOLUME:
+		return gip_handle_pkt_audio_volume(client, data, len);
+	}
+
+	gip_err(client, "%s: unknown subcommand: 0x%02x\n",
+		__func__, pkt->subcommand);
+
+	return -EPROTO;
+}
+
+static int gip_handle_pkt_hid_report(struct gip_client *client,
+				     void *data, u32 len)
+{
+	int err = 0;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.hid_report)
+		err = client->drv->ops.hid_report(client, data, len);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_input(struct gip_client *client,
+				void *data, u32 len)
+{
+	int err = 0;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.input)
+		err = client->drv->ops.input(client, data, len);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_audio_samples(struct gip_client *client,
+					void *data, u32 len)
+{
+	struct gip_pkt_audio_samples *pkt = data;
+	int err = 0;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.audio_samples)
+		err = client->drv->ops.audio_samples(client, pkt->samples,
+						     len - sizeof(*pkt));
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_handle_pkt_firmware(struct gip_client *client, void *data,
+				   u32 len)
+{
+	int err;
+
+	if (down_trylock(&client->drv_lock))
+		return -EBUSY;
+
+	if (client->drv && client->drv->ops.firmware)
+		err = client->drv->ops.firmware(client, data, len);
+
+	up(&client->drv_lock);
+
+	return err;
+}
+
+static int gip_dispatch_pkt(struct gip_client *client,
+			    struct gip_header *hdr, void *data, u32 len)
+{
+	if (hdr->options & GIP_OPT_INTERNAL) {
+		switch (hdr->command) {
+		case GIP_CMD_ACKNOWLEDGE:
+			return gip_handle_pkt_acknowledge(client, data, len);
+		case GIP_CMD_ANNOUNCE:
+			return gip_handle_pkt_announce(client, data, len);
+		case GIP_CMD_STATUS:
+			return gip_handle_pkt_status(client, data, len);
+		case GIP_CMD_IDENTIFY:
+			return gip_handle_pkt_identify(client, data, len);
+		case GIP_CMD_AUTHENTICATE:
+			return gip_handle_pkt_authenticate(client, data, len);
+		case GIP_CMD_VIRTUAL_KEY:
+			return gip_handle_pkt_virtual_key(client, data, len);
+		case GIP_CMD_AUDIO_CONTROL:
+			return gip_handle_pkt_audio_control(client, data, len);
+		case GIP_CMD_HID_REPORT:
+			return gip_handle_pkt_hid_report(client, data, len);
+		case GIP_CMD_AUDIO_SAMPLES:
+			return gip_handle_pkt_audio_samples(client, data, len);
+		default:
+			return 0;
+		}
+	}
+
+	switch (hdr->command) {
+	case GIP_CMD_INPUT:
+		return gip_handle_pkt_input(client, data, len);
+	case GIP_CMD_FIRMWARE:
+		return gip_handle_pkt_firmware(client, data, len);
+	default:
+		pr_debug("%s: Unknown hdr command", __func__);
+	}
+
+	return 0;
+}
+
+static int gip_process_pkt_chunked(struct gip_client *client,
+				   struct gip_header *hdr, void *data)
+{
+	struct gip_chunk_buffer *buf = client->chunk_buf_out;
+	int err;
+	u32 len;
+
+	gip_dbg(client, "%s: flags=[%s %s %s], offset=0x%04x, length=0x%04x\n",
+		__func__,
+		hdr->options & GIP_OPT_CHUNK_START? "Ini":"...",
+		hdr->options & GIP_OPT_ACKNOWLEDGE? "Ack":"...",
+		hdr->options & GIP_OPT_INTERNAL? "Sys":"...",
+		hdr->chunk_offset, hdr->packet_length);
+
+	if (!buf) {
+		/* older gamepads occasionally send spurious completions */
+		if (!hdr->packet_length)
+			return 0;
+
+		gip_err(client, "%s: buffer not allocated\n", __func__);
+		return -EPROTO;
+	}
+
+	if (hdr->command != buf->header.command) {
+		gip_err(client, "%s: conflicting packet\n", __func__);
+		return -EALREADY;
+	}
+
+	len = hdr->chunk_offset + hdr->packet_length;
+	if (buf->length < len) {
+		gip_err(client, "%s: buffer too small\n", __func__);
+		return -EINVAL;
+	}
+
+	if (hdr->packet_length) {
+		/*
+		 * acknowledge last non-empty chunked packet even when
+		 * not asked in current chunk header
+		 */
+		bool last_chunk = (buf->length == len);
+		if ((hdr->options & GIP_OPT_ACKNOWLEDGE) || last_chunk) {
+			err = gip_acknowledge_pkt(client, hdr);
+			if (err)
+				return err;
+		}
+		memcpy(buf->data + hdr->chunk_offset, data, hdr->packet_length);
+		return 0;
+	}
+
+	/* empty chunk signals the completion of the transfer */
+	err = gip_dispatch_pkt(client, hdr, buf->data, buf->length);
+
+	kfree(buf);
+	client->chunk_buf_out = NULL;
+
+	return err;
+}
+
+static int gip_process_pkt(struct gip_client *client,
+			   struct gip_header *hdr, void *data)
+{
+	int err;
+
+	if (hdr->options & GIP_OPT_CHUNK_START) {
+		err = gip_init_chunk_buffer(client, hdr,
+					    &client->chunk_buf_out, true);
+		if (err)
+			return err;
+
+		hdr->chunk_offset = 0;
+	}
+
+	if (hdr->options & GIP_OPT_CHUNK)
+		return gip_process_pkt_chunked(client, hdr, data);
+
+	if (hdr->options & GIP_OPT_ACKNOWLEDGE) {
+		err = gip_acknowledge_pkt(client, hdr);
+		if (err)
+			return err;
+	}
+
+	return gip_dispatch_pkt(client, hdr, data, hdr->packet_length);
+}
+
+int gip_process_buffer(struct gip_adapter *adap, void *data, int len)
+{
+	struct gip_header hdr;
+	struct gip_client *client;
+	int hdr_len, err;
+
+	while (len > GIP_HDR_MIN_LENGTH) {
+		hdr_len = gip_decode_header(&hdr, data, len);
+		if (len < hdr_len + hdr.packet_length)
+			return -EINVAL;
+
+		client = gip_get_client(adap, hdr.options & GIP_HDR_CLIENT_ID);
+		if (IS_ERR(client))
+			return PTR_ERR(client);
+
+		err = gip_process_pkt(client, &hdr, data + hdr_len);
+		if (err)
+			return err;
+
+		data += hdr_len + hdr.packet_length;
+		len -= hdr_len + hdr.packet_length;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gip_process_buffer);
diff --git a/drivers/custom/xonedo/bus/protocol.h b/drivers/custom/xonedo/bus/protocol.h
new file mode 100644
index 000000000000..2f90018f5bf5
--- /dev/null
+++ b/drivers/custom/xonedo/bus/protocol.h
@@ -0,0 +1,122 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include <linux/types.h>
+#include <linux/uuid.h>
+
+#define GIP_VID_MICROSOFT 0x045e
+
+/* time between audio packets in ms */
+#define GIP_AUDIO_INTERVAL 8
+
+enum gip_battery_type {
+	GIP_BATT_TYPE_NONE = 0x00,
+	GIP_BATT_TYPE_STANDARD = 0x01,
+	GIP_BATT_TYPE_KIT = 0x02,
+};
+
+enum gip_battery_level {
+	GIP_BATT_LEVEL_LOW = 0x00,
+	GIP_BATT_LEVEL_NORMAL = 0x01,
+	GIP_BATT_LEVEL_HIGH = 0x02,
+	GIP_BATT_LEVEL_FULL = 0x03,
+};
+
+enum gip_power_mode {
+	GIP_PWR_ON = 0x00,
+	GIP_PWR_SLEEP = 0x01,
+	GIP_PWR_OFF = 0x04,
+	GIP_PWR_RESET = 0x07,
+};
+
+enum gip_audio_format {
+	GIP_AUD_FORMAT_16KHZ_MONO = 0x05,
+	GIP_AUD_FORMAT_24KHZ_MONO = 0x09,
+	GIP_AUD_FORMAT_48KHZ_STEREO = 0x10,
+};
+
+enum gip_audio_format_chat {
+	GIP_AUD_FORMAT_CHAT_24KHZ = 0x04,
+	GIP_AUD_FORMAT_CHAT_16KHZ = 0x05,
+};
+
+enum gip_led_mode {
+	GIP_LED_OFF = 0x00,
+	GIP_LED_ON = 0x01,
+	GIP_LED_BLINK_FAST = 0x02,
+	GIP_LED_BLINK_NORMAL = 0x03,
+	GIP_LED_BLINK_SLOW = 0x04,
+	GIP_LED_FADE_SLOW = 0x08,
+	GIP_LED_FADE_FAST = 0x09,
+};
+
+struct gip_header {
+	u8 command;
+	u8 options;
+	u8 sequence;
+	u32 packet_length;
+	u32 chunk_offset;
+};
+
+struct gip_chunk_buffer {
+	struct gip_header header;
+	u32 length;
+	u8 data[];
+};
+
+struct gip_hardware {
+	u16 vendor;
+	u16 product;
+	u16 version;
+};
+
+struct gip_info_element {
+	u8 count;
+	u8 data[];
+};
+
+struct gip_audio_config {
+	enum gip_audio_format format;
+
+	int channels;
+	int sample_rate;
+
+	int buffer_size;
+	int fragment_size;
+	int packet_size;
+};
+
+struct gip_classes {
+	u8 count;
+	const char *strings[];
+};
+
+struct gip_client;
+struct gip_adapter;
+
+int gip_set_power_mode(struct gip_client *client, enum gip_power_mode mode);
+int gip_send_authenticate(struct gip_client *client, void *pkt, u32 len,
+			  bool acknowledge);
+int gip_suggest_audio_format(struct gip_client *client,
+			     enum gip_audio_format in,
+			     enum gip_audio_format out,
+			     bool chat);
+int gip_set_audio_volume(struct gip_client *client, u8 in, u8 chat, u8 out);
+int gip_send_rumble(struct gip_client *client, void *pkt, u32 len);
+int gip_set_led_mode(struct gip_client *client,
+		     enum gip_led_mode mode, u8 brightness);
+int gip_send_audio_samples(struct gip_client *client, void *samples);
+int gip_init_extra_data(struct gip_client *client);
+
+bool gip_has_interface(struct gip_client *client, const guid_t *guid);
+int gip_set_encryption_key(struct gip_client *client, u8 *key, int len);
+int gip_enable_audio(struct gip_client *client);
+int gip_init_audio_in(struct gip_client *client);
+int gip_init_audio_out(struct gip_client *client);
+void gip_disable_audio(struct gip_client *client);
+
+int gip_process_buffer(struct gip_adapter *adap, void *data, int len);
diff --git a/drivers/custom/xonedo/driver/chatpad.c b/drivers/custom/xonedo/driver/chatpad.c
new file mode 100644
index 000000000000..9a7e72f4148b
--- /dev/null
+++ b/drivers/custom/xonedo/driver/chatpad.c
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+#include <linux/hid.h>
+
+#include "common.h"
+
+#define GIP_CP_NAME "Microsoft Xbox Chatpad"
+
+struct gip_chatpad {
+	struct gip_client *client;
+	struct gip_input input;
+
+	struct hid_device *hid_dev;
+};
+
+static int gip_chatpad_hid_start(struct hid_device *dev)
+{
+	return 0;
+}
+
+static void gip_chatpad_hid_stop(struct hid_device *dev)
+{
+}
+
+static int gip_chatpad_hid_open(struct hid_device *dev)
+{
+	return 0;
+}
+
+static void gip_chatpad_hid_close(struct hid_device *dev)
+{
+}
+
+static int gip_chatpad_hid_parse(struct hid_device *dev)
+{
+	struct gip_chatpad *chatpad = dev->driver_data;
+	struct gip_client *client = chatpad->client;
+	struct gip_info_element *desc_info = client->hid_descriptor;
+	struct hid_descriptor *desc = (struct hid_descriptor *)desc_info->data;
+
+	if (desc->bLength < sizeof(*desc) || desc->bNumDescriptors != 1) {
+		dev_err(&client->dev, "%s: invalid descriptor\n", __func__);
+		return -EINVAL;
+	}
+
+	dev->version = le16_to_cpu(desc->bcdHID);
+	dev->country = desc->bCountryCode;
+
+	return hid_parse_report(dev, desc_info->data + sizeof(*desc),
+				desc_info->count - sizeof(*desc));
+}
+
+static int gip_chatpad_hid_raw_request(struct hid_device *dev,
+				       unsigned char report_num, __u8 *buf,
+				       size_t len, unsigned char report_type,
+				       int request_type)
+{
+	return 0;
+}
+
+static struct hid_ll_driver gip_chatpad_hid_driver = {
+	.start = gip_chatpad_hid_start,
+	.stop = gip_chatpad_hid_stop,
+	.open = gip_chatpad_hid_open,
+	.close = gip_chatpad_hid_close,
+	.parse = gip_chatpad_hid_parse,
+	.raw_request = gip_chatpad_hid_raw_request,
+};
+
+static int gip_chatpad_init_input(struct gip_chatpad *chatpad)
+{
+	int err;
+
+	input_set_capability(chatpad->input.dev, EV_KEY, BTN_MODE);
+
+	err = input_register_device(chatpad->input.dev);
+	if (err)
+		dev_err(&chatpad->client->dev, "%s: register failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+
+static int gip_chatpad_init_hid(struct gip_chatpad *chatpad)
+{
+	struct gip_client *client = chatpad->client;
+	struct hid_device *dev;
+	int err;
+
+	dev = hid_allocate_device();
+	if (IS_ERR(dev)) {
+		dev_err(&client->dev, "%s: allocate failed: %ld\n",
+			__func__, PTR_ERR(dev));
+		return PTR_ERR(dev);
+	}
+
+	dev->bus = BUS_USB;
+	dev->vendor = client->hardware.vendor;
+	dev->product = client->hardware.product;
+	dev->version = client->hardware.version;
+	dev->dev.parent = &client->dev;
+	dev->ll_driver = &gip_chatpad_hid_driver;
+
+	strscpy(dev->name, GIP_CP_NAME, sizeof(dev->name));
+	snprintf(dev->phys, sizeof(dev->phys), "%s/input1",
+		 dev_name(&client->dev));
+
+	dev->driver_data = chatpad;
+
+	err = hid_add_device(dev);
+	if (err) {
+		dev_err(&client->dev, "%s: add failed: %d\n", __func__, err);
+		hid_destroy_device(dev);
+		return err;
+	}
+
+	chatpad->hid_dev = dev;
+
+	return 0;
+}
+
+static int gip_chatpad_op_guide_button(struct gip_client *client, bool down)
+{
+	struct gip_chatpad *chatpad = dev_get_drvdata(&client->dev);
+
+	input_report_key(chatpad->input.dev, BTN_MODE, down);
+	input_sync(chatpad->input.dev);
+
+	return 0;
+}
+
+static int gip_chatpad_op_hid_report(struct gip_client *client,
+				     void *data, u32 len)
+{
+	struct gip_chatpad *chatpad = dev_get_drvdata(&client->dev);
+
+	return hid_input_report(chatpad->hid_dev, HID_INPUT_REPORT,
+				data, len, true);
+}
+
+static int gip_chatpad_probe(struct gip_client *client)
+{
+	struct gip_chatpad *chatpad;
+	struct gip_info_element *hid_desc = client->hid_descriptor;
+	int err;
+
+	if (!hid_desc || hid_desc->count < sizeof(struct hid_descriptor))
+		return -ENODEV;
+
+	chatpad = devm_kzalloc(&client->dev, sizeof(*chatpad), GFP_KERNEL);
+	if (!chatpad)
+		return -ENOMEM;
+
+	chatpad->client = client;
+
+	err = gip_set_power_mode(client, GIP_PWR_ON);
+	if (err)
+		return err;
+
+	err = gip_init_input(&chatpad->input, client, GIP_CP_NAME);
+	if (err)
+		return err;
+
+	err = gip_chatpad_init_input(chatpad);
+	if (err)
+		return err;
+
+	err = gip_chatpad_init_hid(chatpad);
+	if (err)
+		return err;
+
+	dev_set_drvdata(&client->dev, chatpad);
+
+	return 0;
+}
+
+static void gip_chatpad_remove(struct gip_client *client)
+{
+	struct gip_chatpad *chatpad = dev_get_drvdata(&client->dev);
+
+	hid_destroy_device(chatpad->hid_dev);
+}
+
+static struct gip_driver gip_chatpad_driver = {
+	.name = "xone-gip-chatpad",
+	.class = "Windows.Xbox.Input.Chatpad",
+	.ops = {
+		.guide_button = gip_chatpad_op_guide_button,
+		.hid_report = gip_chatpad_op_hid_report,
+	},
+	.probe = gip_chatpad_probe,
+	.remove = gip_chatpad_remove,
+};
+module_gip_driver(gip_chatpad_driver);
+
+MODULE_ALIAS("gip:Windows.Xbox.Input.Chatpad");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP chatpad driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/driver/common.c b/drivers/custom/xonedo/driver/common.c
new file mode 100644
index 000000000000..29a8f6dcb706
--- /dev/null
+++ b/drivers/custom/xonedo/driver/common.c
@@ -0,0 +1,219 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/sysfs.h>
+
+#include "common.h"
+
+#define GIP_LED_BRIGHTNESS_DEFAULT 20
+#define GIP_LED_BRIGHTNESS_MAX 50
+
+static enum power_supply_property gip_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_SCOPE,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+};
+
+static int gip_get_battery_prop(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct gip_battery *batt = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = batt->status;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		val->intval = batt->capacity;
+		break;
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+		break;
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		val->strval = batt->name;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int gip_init_battery(struct gip_battery *batt, struct gip_client *client,
+		     const char *name)
+{
+	struct power_supply_config cfg = {};
+
+	batt->name = name;
+	batt->status = POWER_SUPPLY_STATUS_UNKNOWN;
+	batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;
+
+	batt->desc.name = dev_name(&client->dev);
+	batt->desc.type = POWER_SUPPLY_TYPE_BATTERY;
+	batt->desc.properties = gip_battery_props;
+	batt->desc.num_properties = ARRAY_SIZE(gip_battery_props);
+	batt->desc.get_property = gip_get_battery_prop;
+
+	cfg.drv_data = batt;
+
+	batt->supply = devm_power_supply_register(&client->dev, &batt->desc,
+						  &cfg);
+	if (IS_ERR(batt->supply)) {
+		dev_err(&client->dev, "%s: register failed: %ld\n",
+			__func__, PTR_ERR(batt->supply));
+		return PTR_ERR(batt->supply);
+	}
+
+	power_supply_powers(batt->supply, &client->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gip_init_battery);
+
+void gip_report_battery(struct gip_battery *batt,
+			enum gip_battery_type type,
+			enum gip_battery_level level)
+{
+	if (type == GIP_BATT_TYPE_NONE)
+		batt->status = POWER_SUPPLY_STATUS_NOT_CHARGING;
+	else
+		batt->status = POWER_SUPPLY_STATUS_DISCHARGING;
+
+	if (type == GIP_BATT_TYPE_NONE)
+		batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;
+	else if (level == GIP_BATT_LEVEL_LOW)
+		batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_LOW;
+	else if (level == GIP_BATT_LEVEL_NORMAL)
+		batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+	else if (level == GIP_BATT_LEVEL_HIGH)
+		batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;
+	else if (level == GIP_BATT_LEVEL_FULL)
+		batt->capacity = POWER_SUPPLY_CAPACITY_LEVEL_FULL;
+
+	if (batt->supply)
+		power_supply_changed(batt->supply);
+}
+EXPORT_SYMBOL_GPL(gip_report_battery);
+
+static void gip_led_brightness_set(struct led_classdev *dev,
+				   enum led_brightness brightness)
+{
+	struct gip_led *led = container_of(dev, typeof(*led), dev);
+	int err;
+
+	if (dev->flags & LED_UNREGISTERING)
+		return;
+
+	dev_dbg(&led->client->dev, "%s: brightness=%d\n", __func__, brightness);
+
+	err = gip_set_led_mode(led->client, led->mode, brightness);
+	if (err)
+		dev_err(&led->client->dev, "%s: set LED mode failed: %d\n",
+			__func__, err);
+}
+
+static ssize_t gip_led_mode_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct gip_led *led = container_of(cdev, typeof(*led), dev);
+
+	return sprintf(buf, "%u\n", led->mode);
+}
+
+static ssize_t gip_led_mode_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct led_classdev *cdev = dev_get_drvdata(dev);
+	struct gip_led *led = container_of(cdev, typeof(*led), dev);
+	u8 mode;
+	int err;
+
+	err = kstrtou8(buf, 10, &mode);
+	if (err)
+		return err;
+
+	dev_dbg(&led->client->dev, "%s: mode=%u\n", __func__, mode);
+	led->mode = mode;
+
+	err = gip_set_led_mode(led->client, mode, cdev->brightness);
+	if (err) {
+		dev_err(&led->client->dev, "%s: set LED mode failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	return count;
+}
+
+static struct device_attribute gip_led_attr_mode =
+	__ATTR(mode, 0644, gip_led_mode_show, gip_led_mode_store);
+
+static struct attribute *gip_led_attrs[] = {
+	&gip_led_attr_mode.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(gip_led);
+
+int gip_init_led(struct gip_led *led, struct gip_client *client)
+{
+	int err;
+
+	/* set default brightness */
+	err = gip_set_led_mode(client, GIP_LED_ON, GIP_LED_BRIGHTNESS_DEFAULT);
+	if (err) {
+		dev_err(&client->dev, "%s: set brightness failed: %d\n",
+			__func__, err);
+		return err;
+	}
+
+	led->dev.name = devm_kasprintf(&client->dev, GFP_KERNEL,
+				       "%s:white:status",
+					dev_name(&client->dev));
+	if (!led->dev.name)
+		return -ENOMEM;
+
+	led->dev.brightness = GIP_LED_BRIGHTNESS_DEFAULT;
+	led->dev.max_brightness = GIP_LED_BRIGHTNESS_MAX;
+	led->dev.brightness_set = gip_led_brightness_set;
+	led->dev.groups = gip_led_groups;
+
+	led->client = client;
+	led->mode = GIP_LED_ON;
+
+	err = devm_led_classdev_register(&client->dev, &led->dev);
+	if (err)
+		dev_err(&client->dev, "%s: register failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(gip_init_led);
+
+int gip_init_input(struct gip_input *input, struct gip_client *client,
+		   const char *name)
+{
+	input->dev = devm_input_allocate_device(&client->dev);
+	if (!input->dev)
+		return -ENOMEM;
+
+	input->dev->phys = devm_kasprintf(&client->dev, GFP_KERNEL,
+					  "%s/input0", dev_name(&client->dev));
+	if (!input->dev->phys)
+		return -ENOMEM;
+
+	input->dev->name = name;
+	input->dev->id.bustype = BUS_VIRTUAL;
+	input->dev->id.vendor = client->hardware.vendor;
+	input->dev->id.product = client->hardware.product;
+	input->dev->id.version = client->hardware.version;
+	input->dev->dev.parent = &client->dev;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(gip_init_input);
diff --git a/drivers/custom/xonedo/driver/common.h b/drivers/custom/xonedo/driver/common.h
new file mode 100644
index 000000000000..b97b4571a58c
--- /dev/null
+++ b/drivers/custom/xonedo/driver/common.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include <linux/power_supply.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+
+#include "../bus/bus.h"
+
+struct gip_battery {
+	struct power_supply *supply;
+	struct power_supply_desc desc;
+
+	const char *name;
+	int status;
+	int capacity;
+};
+
+struct gip_led {
+	struct led_classdev dev;
+
+	struct gip_client *client;
+	enum gip_led_mode mode;
+};
+
+struct gip_input {
+	struct input_dev *dev;
+};
+
+struct gip_vidpid {
+	u16 vendor;
+	u16 product;
+};
+
+int gip_init_battery(struct gip_battery *batt, struct gip_client *client,
+		     const char *name);
+void gip_report_battery(struct gip_battery *batt,
+			enum gip_battery_type type,
+			enum gip_battery_level level);
+
+int gip_init_led(struct gip_led *led, struct gip_client *client);
+
+int gip_init_input(struct gip_input *input, struct gip_client *client,
+		   const char *name);
diff --git a/drivers/custom/xonedo/driver/gamepad.c b/drivers/custom/xonedo/driver/gamepad.c
new file mode 100644
index 000000000000..f6ee883a7b7f
--- /dev/null
+++ b/drivers/custom/xonedo/driver/gamepad.c
@@ -0,0 +1,559 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+#include <linux/uuid.h>
+#include <linux/timer.h>
+#include <linux/version.h>
+
+#include "common.h"
+#include "../auth/auth.h"
+
+#define GIP_GP_NAME "Microsoft Xbox Controller"
+
+#define GIP_VENDOR_MICROSOFT 0x045e
+#define GIP_PRODUCT_ELITE_SERIES_2 0x0b00
+#define GIP_PRODUCT_ELITE 0x02e3
+
+/*
+ * Various versions of the Elite Series 2 firmware have changed the way paddle
+ * states are sent. Paddle support is only reported up to this firmware
+ * version.
+ */
+#define GIP_ELITE_SERIES_2_4X_FIRMWARE 0x04FF
+#define GIP_ELITE_SERIES_2_510_FIRMWARE 0x050A
+
+#define GIP_GP_RUMBLE_DELAY msecs_to_jiffies(10)
+#define GIP_GP_RUMBLE_MAX 100
+
+/* button offset from end of packet */
+#define GIP_GP_BTN_SHARE_OFFSET 18
+
+static const guid_t gip_gamepad_guid_share =
+	GUID_INIT(0xecddd2fe, 0xd387, 0x4294,
+		  0xbd, 0x96, 0x1a, 0x71, 0x2e, 0x3d, 0xc7, 0x7d);
+
+static const guid_t gip_gamepad_guid_dli =
+	GUID_INIT(0x87f2e56b, 0xc3bb, 0x49b1,
+		  0x82, 0x65, 0xff, 0xff, 0xf3, 0x77, 0x99, 0xee);
+
+enum gip_gamepad_button {
+	GIP_GP_BTN_MENU = BIT(2),
+	GIP_GP_BTN_VIEW = BIT(3),
+	GIP_GP_BTN_A = BIT(4),
+	GIP_GP_BTN_B = BIT(5),
+	GIP_GP_BTN_X = BIT(6),
+	GIP_GP_BTN_Y = BIT(7),
+	GIP_GP_BTN_DPAD_U = BIT(8),
+	GIP_GP_BTN_DPAD_D = BIT(9),
+	GIP_GP_BTN_DPAD_L = BIT(10),
+	GIP_GP_BTN_DPAD_R = BIT(11),
+	GIP_GP_BTN_BUMPER_L = BIT(12),
+	GIP_GP_BTN_BUMPER_R = BIT(13),
+	GIP_GP_BTN_STICK_L = BIT(14),
+	GIP_GP_BTN_STICK_R = BIT(15),
+};
+
+enum gip_gamepad_paddle {
+	GIP_GP_BTN_P1 = BIT(0),
+	GIP_GP_BTN_P2 = BIT(1),
+	GIP_GP_BTN_P3 = BIT(2),
+	GIP_GP_BTN_P4 = BIT(3),
+};
+
+enum gip_gamepad_motor {
+	GIP_GP_MOTOR_R = BIT(0),
+	GIP_GP_MOTOR_L = BIT(1),
+	GIP_GP_MOTOR_RT = BIT(2),
+	GIP_GP_MOTOR_LT = BIT(3),
+};
+
+/*
+ * Remember, xpad keeps the 4 bytes.
+ * Paddles are at [18] in xpad, so, [14] here.
+ * Pad 14 bytes.
+ */
+struct gip_gamepad_pkt_firmware {
+	u8 unknown[14];
+	u8 paddles;
+	u8 profile;
+} __packed;
+
+struct gip_gamepad_pkt_input {
+	__le16 buttons;
+	__le16 trigger_left;
+	__le16 trigger_right;
+	__le16 stick_left_x;
+	__le16 stick_left_y;
+	__le16 stick_right_x;
+	__le16 stick_right_y;
+} __packed;
+
+struct gip_gamepad_pkt_dli {
+	u32 counter_us1;
+	u32 counter_us2;
+} __packed;
+
+struct gip_gamepad_pkt_rumble {
+	u8 unknown;
+	u8 motors;
+	u8 left_trigger;
+	u8 right_trigger;
+	u8 left;
+	u8 right;
+	u8 duration;
+	u8 delay;
+	u8 repeat;
+} __packed;
+
+typedef enum PaddleCapability {
+	PADDLE_NONE,
+	PADDLE_ELITE,
+	PADDLE_ELITE2_4X,  // Still in the same packet
+	PADDLE_ELITE2_510, // Same packet, different location
+	PADDLE_ELITE2_511, // Different packet entirely.
+} PaddleCapability;
+
+struct gip_gamepad {
+	struct gip_client *client;
+	struct gip_battery battery;
+	struct gip_auth auth;
+	struct gip_led led;
+	struct gip_input input;
+
+	bool supports_share;
+	bool supports_dli;
+	PaddleCapability paddle_support;
+
+	struct gip_gamepad_rumble {
+		/* serializes access to rumble packet */
+		spinlock_t lock;
+		unsigned long last;
+		struct timer_list timer;
+		struct gip_gamepad_pkt_rumble pkt;
+	} rumble;
+};
+
+static void gip_gamepad_send_rumble(struct timer_list *timer)
+{
+	// from_timer() has been renamed to timer_container_of() in linux 6.16
+	struct gip_gamepad_rumble *rumble =
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,16,0)
+		timer_container_of(rumble, timer, timer);
+#else
+		from_timer(rumble, timer, timer);
+#endif
+
+	struct gip_gamepad *gamepad = container_of(rumble, typeof(*gamepad),
+						   rumble);
+	unsigned long flags;
+
+	spin_lock_irqsave(&rumble->lock, flags);
+
+	gip_send_rumble(gamepad->client, &rumble->pkt, sizeof(rumble->pkt));
+	rumble->last = jiffies;
+
+	spin_unlock_irqrestore(&rumble->lock, flags);
+}
+
+static int gip_gamepad_queue_rumble(struct input_dev *dev, void *data,
+				    struct ff_effect *effect)
+{
+	struct gip_gamepad_rumble *rumble = input_get_drvdata(dev);
+	u32 mag_left = effect->u.rumble.strong_magnitude;
+	u32 mag_right = effect->u.rumble.weak_magnitude;
+	unsigned long flags;
+
+	if (effect->type != FF_RUMBLE)
+		return 0;
+
+	spin_lock_irqsave(&rumble->lock, flags);
+
+	rumble->pkt.left = (mag_left * GIP_GP_RUMBLE_MAX + S16_MAX) / U16_MAX;
+	rumble->pkt.right = (mag_right * GIP_GP_RUMBLE_MAX + S16_MAX) / U16_MAX;
+
+	/* delay rumble to work around firmware bug */
+	if (!timer_pending(&rumble->timer))
+		mod_timer(&rumble->timer, rumble->last + GIP_GP_RUMBLE_DELAY);
+
+	spin_unlock_irqrestore(&rumble->lock, flags);
+
+	return 0;
+}
+
+static int gip_gamepad_init_rumble(struct gip_gamepad *gamepad)
+{
+	struct gip_gamepad_rumble *rumble = &gamepad->rumble;
+	struct input_dev *dev = gamepad->input.dev;
+
+	spin_lock_init(&rumble->lock);
+	timer_setup(&rumble->timer, gip_gamepad_send_rumble, 0);
+
+	/* stop rumble (required for some exotic gamepads to start input) */
+	rumble->pkt.motors = GIP_GP_MOTOR_R | GIP_GP_MOTOR_L |
+			     GIP_GP_MOTOR_RT | GIP_GP_MOTOR_LT;
+	rumble->pkt.duration = 0xff;
+	rumble->pkt.repeat = 0xeb;
+	gip_gamepad_send_rumble(&rumble->timer);
+
+	input_set_capability(dev, EV_FF, FF_RUMBLE);
+	input_set_drvdata(dev, rumble);
+
+	return input_ff_create_memless(dev, NULL, gip_gamepad_queue_rumble);
+}
+
+static int gip_gamepad_init_extra_data(struct gip_gamepad *gamepad)
+{
+	return gip_init_extra_data(gamepad->client);
+}
+
+static void gip_gamepad_query_paddles(struct gip_gamepad *gamepad)
+{
+	struct gip_hardware hardware = gamepad->client->hardware;
+
+	gamepad->paddle_support = PADDLE_NONE;
+
+	if (hardware.vendor != GIP_VENDOR_MICROSOFT)
+		return;
+
+	if (hardware.product == GIP_PRODUCT_ELITE) {
+		pr_debug("%s: Elite Series 1\n", __func__);
+		gamepad->paddle_support = PADDLE_ELITE;
+		return;
+	}
+
+	if (hardware.product != GIP_PRODUCT_ELITE_SERIES_2) {
+		pr_debug("%s: MS controller, no paddle support", __func__);
+		return;
+	}
+
+	pr_debug("%s: Elite Series 2\n", __func__);
+	if (hardware.version <= GIP_ELITE_SERIES_2_4X_FIRMWARE)
+		gamepad->paddle_support = PADDLE_ELITE2_4X;
+
+	else if (hardware.version <= GIP_ELITE_SERIES_2_510_FIRMWARE)
+		gamepad->paddle_support = PADDLE_ELITE2_510;
+
+	// If new revisions come, this should become LTE new max
+	else if (hardware.version > GIP_ELITE_SERIES_2_510_FIRMWARE) {
+		pr_debug("%s: FW > 5.10\n", __func__);
+		gamepad->paddle_support = PADDLE_ELITE2_511;
+	}
+}
+
+static int gip_gamepad_init_input(struct gip_gamepad *gamepad)
+{
+	struct input_dev *dev = gamepad->input.dev;
+	int err;
+
+	gamepad->supports_share = gip_has_interface(gamepad->client,
+						    &gip_gamepad_guid_share);
+	gamepad->supports_dli = gip_has_interface(gamepad->client,
+						  &gip_gamepad_guid_dli);
+
+	if (gamepad->supports_share)
+		input_set_capability(dev, EV_KEY, KEY_RECORD);
+
+	if (gamepad->paddle_support) {
+		pr_debug("%s: Paddle support detected", __func__);
+		input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY5);
+		input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY6);
+		input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY7);
+		input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY8);
+	}
+
+	input_set_capability(dev, EV_KEY, BTN_MODE);
+	input_set_capability(dev, EV_KEY, BTN_START);
+	input_set_capability(dev, EV_KEY, BTN_SELECT);
+	input_set_capability(dev, EV_KEY, BTN_A);
+	input_set_capability(dev, EV_KEY, BTN_B);
+	input_set_capability(dev, EV_KEY, BTN_X);
+	input_set_capability(dev, EV_KEY, BTN_Y);
+	input_set_capability(dev, EV_KEY, BTN_TL);
+	input_set_capability(dev, EV_KEY, BTN_TR);
+	input_set_capability(dev, EV_KEY, BTN_THUMBL);
+	input_set_capability(dev, EV_KEY, BTN_THUMBR);
+	input_set_abs_params(dev, ABS_X, -32768, 32767, 16, 128);
+	input_set_abs_params(dev, ABS_RX, -32768, 32767, 16, 128);
+	input_set_abs_params(dev, ABS_Y, -32768, 32767, 16, 128);
+	input_set_abs_params(dev, ABS_RY, -32768, 32767, 16, 128);
+	input_set_abs_params(dev, ABS_Z, 0, 1023, 0, 0);
+	input_set_abs_params(dev, ABS_RZ, 0, 1023, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0Y, -1, 1, 0, 0);
+
+	err = gip_gamepad_init_rumble(gamepad);
+	if (err) {
+		dev_err(&gamepad->client->dev, "%s: init rumble failed: %d\n",
+			__func__, err);
+		goto err_delete_timer;
+	}
+
+	err = input_register_device(dev);
+	if (err) {
+		dev_err(&gamepad->client->dev, "%s: register failed: %d\n",
+			__func__, err);
+		goto err_delete_timer;
+	}
+
+	return 0;
+
+err_delete_timer:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,15,0)
+	timer_delete_sync(&gamepad->rumble.timer);
+#else
+	del_timer_sync(&gamepad->rumble.timer);
+#endif
+	return err;
+}
+
+static int gip_gamepad_op_battery(struct gip_client *client,
+				  enum gip_battery_type type,
+				  enum gip_battery_level level)
+{
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+
+	gip_report_battery(&gamepad->battery, type, level);
+
+	return 0;
+}
+
+static int gip_gamepad_op_authenticate(struct gip_client *client,
+				       void *data, u32 len)
+{
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+
+	return gip_auth_process_pkt(&gamepad->auth, data, len);
+}
+
+static int gip_gamepad_op_guide_button(struct gip_client *client, bool down)
+{
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+
+	input_report_key(gamepad->input.dev, BTN_MODE, down);
+	input_sync(gamepad->input.dev);
+
+	return 0;
+}
+
+static int gip_gamepad_op_authenticated(struct gip_client *client)
+{
+	return 0;
+}
+
+static int gip_gamepad_op_firmware(struct gip_client *client, void *data,
+				   u32 len)
+{
+	// First, ensure the data is of the correct size.
+	struct gip_gamepad_pkt_firmware *pkt = data;
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	// Grab our controller
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+	struct input_dev *dev = gamepad->input.dev;
+
+	input_report_key(dev, BTN_TRIGGER_HAPPY5, pkt->paddles & GIP_GP_BTN_P1);
+	input_report_key(dev, BTN_TRIGGER_HAPPY6, pkt->paddles & GIP_GP_BTN_P2);
+	input_report_key(dev, BTN_TRIGGER_HAPPY7, pkt->paddles & GIP_GP_BTN_P3);
+	input_report_key(dev, BTN_TRIGGER_HAPPY8, pkt->paddles & GIP_GP_BTN_P4);
+
+	input_sync(dev);
+	return 0;
+}
+
+static int gip_gamepad_op_input(struct gip_client *client, void *data, u32 len)
+{
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+	struct gip_gamepad_pkt_input *pkt = data;
+	struct input_dev *dev = gamepad->input.dev;
+	u16 buttons;
+	u8 share_offset = GIP_GP_BTN_SHARE_OFFSET;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	buttons = le16_to_cpu(pkt->buttons);
+
+	/* share button byte is always at fixed offset from end of packet */
+	if (gamepad->supports_share) {
+		if (gamepad->supports_dli)
+			share_offset += sizeof(struct gip_gamepad_pkt_dli);
+
+		if (len < share_offset)
+			return -EINVAL;
+
+		input_report_key(dev, KEY_RECORD,
+				 ((u8 *)data)[len - share_offset]);
+	}
+
+	input_report_key(dev, BTN_START, buttons & GIP_GP_BTN_MENU);
+	input_report_key(dev, BTN_SELECT, buttons & GIP_GP_BTN_VIEW);
+	input_report_key(dev, BTN_A, buttons & GIP_GP_BTN_A);
+	input_report_key(dev, BTN_B, buttons & GIP_GP_BTN_B);
+	input_report_key(dev, BTN_X, buttons & GIP_GP_BTN_X);
+	input_report_key(dev, BTN_Y, buttons & GIP_GP_BTN_Y);
+	input_report_key(dev, BTN_TL, buttons & GIP_GP_BTN_BUMPER_L);
+	input_report_key(dev, BTN_TR, buttons & GIP_GP_BTN_BUMPER_R);
+	input_report_key(dev, BTN_THUMBL, buttons & GIP_GP_BTN_STICK_L);
+	input_report_key(dev, BTN_THUMBR, buttons & GIP_GP_BTN_STICK_R);
+
+	/*
+	 * For anyone comparing to xpad's paddle handling source, xone strips
+	 * four bytes of header off of the beginning that xpad doesn't, so all
+	 * offsets are 4 less later revisions put paddle support in the firmware
+	 * packet, check gip_gamepad_op_WTFEVER
+	 *
+	 * For 5.10 and below, the paddle data is in various locations within
+	 * the main input packet, for 5.11 and above the data is stored in a
+	 * separate packet and handeled by gip_gamepad_op_firmware().
+	 */
+
+	int report_paddles = 0, series_1 = 0;
+	u8 paddles;
+
+	// Assume the controller might not send profile data, check length
+	if (gamepad->paddle_support == PADDLE_ELITE2_510 && len > 18) {
+		/*
+		 * On the Elite Series 2 with newer-ISH firmware (<=5.10)
+		 * paddles are stored at byte 18 (22)
+		 */
+		paddles = ((u8 *)data)[18];
+		report_paddles = 1;
+
+		// Ensure a profile is not applied, like xpad.
+		if ((len > 19) && ((u8 *)data)[19] != 0)
+			paddles = 0;
+
+	} else if (gamepad->paddle_support == PADDLE_ELITE2_4X && len > 14) {
+		/*
+		 * On the Elite Series 2 with older firmware (<5.0)
+		 * paddles are stored at byte 14 (18)
+		 */
+		paddles = ((u8 *)data)[14];
+		report_paddles = 1;
+
+		// Ensure a profile is not applied, like xpad.
+		if ((len > 15) && ((u8 *)data)[15] != 0)
+			paddles = 0;
+
+	} else if (gamepad->paddle_support == PADDLE_ELITE && len > 28) {
+		// On the original Elite, paddles are stored at byte 28
+		paddles = ((u8 *)data)[28];
+		report_paddles = 1;
+		series_1 = 1;
+	}
+
+	// Series 1 reports paddles as different buttons than newer ones
+	if (report_paddles) {
+		input_report_key(dev, BTN_TRIGGER_HAPPY5, paddles &
+				 (series_1 ? GIP_GP_BTN_P2 : GIP_GP_BTN_P1));
+		input_report_key(dev, BTN_TRIGGER_HAPPY6, paddles &
+				 (series_1 ? GIP_GP_BTN_P4 : GIP_GP_BTN_P2));
+		input_report_key(dev, BTN_TRIGGER_HAPPY7, paddles &
+				 (series_1 ? GIP_GP_BTN_P1 : GIP_GP_BTN_P3));
+		input_report_key(dev, BTN_TRIGGER_HAPPY8, paddles &
+				 (series_1 ? GIP_GP_BTN_P3 : GIP_GP_BTN_P4));
+	}
+
+	input_report_abs(dev, ABS_X, (s16)le16_to_cpu(pkt->stick_left_x));
+	input_report_abs(dev, ABS_RX, (s16)le16_to_cpu(pkt->stick_right_x));
+	input_report_abs(dev, ABS_Y, ~(s16)le16_to_cpu(pkt->stick_left_y));
+	input_report_abs(dev, ABS_RY, ~(s16)le16_to_cpu(pkt->stick_right_y));
+	input_report_abs(dev, ABS_Z, le16_to_cpu(pkt->trigger_left));
+	input_report_abs(dev, ABS_RZ, le16_to_cpu(pkt->trigger_right));
+	input_report_abs(dev, ABS_HAT0X, !!(buttons & GIP_GP_BTN_DPAD_R) -
+					 !!(buttons & GIP_GP_BTN_DPAD_L));
+	input_report_abs(dev, ABS_HAT0Y, !!(buttons & GIP_GP_BTN_DPAD_D) -
+					 !!(buttons & GIP_GP_BTN_DPAD_U));
+	input_sync(dev);
+	return 0;
+}
+
+static int gip_gamepad_probe(struct gip_client *client)
+{
+	struct gip_gamepad *gamepad;
+	int err;
+
+	gamepad = devm_kzalloc(&client->dev, sizeof(*gamepad), GFP_KERNEL);
+	if (!gamepad)
+		return -ENOMEM;
+
+	gamepad->client = client;
+
+	err = gip_set_power_mode(client, GIP_PWR_ON);
+	if (err)
+		return err;
+
+	gip_gamepad_query_paddles(gamepad);
+
+	/*
+	 * xpad sends this for all Elite 2 firmware versions,
+	 * but it seems to be only necessary for 5.11 paddles.
+	*/
+	if(gamepad->paddle_support == PADDLE_ELITE2_511)
+	{
+		err = gip_gamepad_init_extra_data(gamepad);
+		if (err)
+			return err;
+	}
+
+	err = gip_init_battery(&gamepad->battery, client, GIP_GP_NAME);
+	if (err)
+		return err;
+
+	err = gip_init_led(&gamepad->led, client);
+	if (err)
+		return err;
+
+	err = gip_auth_start_handshake(&gamepad->auth, client);
+	if (err)
+		return err;
+
+	err = gip_init_input(&gamepad->input, client, GIP_GP_NAME);
+	if (err)
+		return err;
+
+	err = gip_gamepad_init_input(gamepad);
+	if (err)
+		return err;
+
+	dev_set_drvdata(&client->dev, gamepad);
+
+	return 0;
+}
+
+static void gip_gamepad_remove(struct gip_client *client)
+{
+	struct gip_gamepad *gamepad = dev_get_drvdata(&client->dev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,15,0)
+	timer_delete_sync(&gamepad->rumble.timer);
+#else
+	del_timer_sync(&gamepad->rumble.timer);
+#endif
+}
+
+static struct gip_driver gip_gamepad_driver = {
+	.name = "xone-gip-gamepad",
+	.class = "Windows.Xbox.Input.Gamepad",
+	.ops = {
+		.battery = gip_gamepad_op_battery,
+		.authenticate = gip_gamepad_op_authenticate,
+		.authenticated = gip_gamepad_op_authenticated,
+		.guide_button = gip_gamepad_op_guide_button,
+		.input = gip_gamepad_op_input,
+		.firmware = gip_gamepad_op_firmware,
+	},
+	.probe = gip_gamepad_probe,
+	.remove = gip_gamepad_remove,
+};
+module_gip_driver(gip_gamepad_driver);
+
+MODULE_ALIAS("gip:Windows.Xbox.Input.Gamepad");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP gamepad driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/driver/headset.c b/drivers/custom/xonedo/driver/headset.c
new file mode 100644
index 000000000000..bfc17171de38
--- /dev/null
+++ b/drivers/custom/xonedo/driver/headset.c
@@ -0,0 +1,644 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+
+#include "common.h"
+#include "../auth/auth.h"
+
+#define GIP_HS_NAME "Microsoft Xbox Headset"
+
+#define GIP_HS_NUM_BUFFERS 128
+
+/* product ID for the chat headset */
+#define GIP_HS_PID_CHAT 0x0111
+
+#define GIP_HS_MAX_RETRIES 6
+#define GIP_HS_POWER_ON_DELAY msecs_to_jiffies(250)
+#define GIP_HS_START_DELAY msecs_to_jiffies(500)
+
+static struct gip_vidpid GIP_HS_CHECK_AUTH_IDS[] = {
+	{ 0x1532, 0x0a16 }, // Razer Thresher
+	{ 0x1532, 0x0a25 }, // Razer Kaira Pro
+	{ 0x1532, 0x0a27 }, // Razer Kaira Pro
+	{ 0x2f12, 0x0023 }, // LucidSound LS35X
+};
+
+static const struct snd_pcm_hardware gip_headset_pcm_hw = {
+	.info = SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BATCH |
+		SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.rates = SNDRV_PCM_RATE_CONTINUOUS,
+	.periods_min = 2,
+	.periods_max = GIP_HS_NUM_BUFFERS,
+};
+
+struct gip_headset {
+	struct gip_client *client;
+	struct gip_battery battery;
+	struct gip_auth auth;
+
+	bool chat_headset;
+
+	struct work_struct work_config;
+	struct delayed_work work_power_on;
+	struct work_struct work_register;
+	bool got_authenticated;
+	int start_counter;
+	bool got_initial_volume;
+	bool got_audio_packet;
+
+	struct hrtimer timer;
+	struct hrtimer start_audio_timer;
+	void *buffer;
+
+	struct gip_headset_stream {
+		struct snd_pcm_substream *substream;
+		snd_pcm_uframes_t pointer;
+		snd_pcm_uframes_t period;
+	} playback, capture;
+
+	struct snd_card *card;
+};
+
+static int gip_headset_pcm_open(struct snd_pcm_substream *sub)
+{
+	struct gip_headset *headset = snd_pcm_substream_chip(sub);
+	struct gip_audio_config *cfg;
+	struct snd_pcm_hardware hw = gip_headset_pcm_hw;
+
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		cfg = &headset->client->audio_config_out;
+	else
+		cfg = &headset->client->audio_config_in;
+
+	hw.rate_min = cfg->sample_rate;
+	hw.rate_max = cfg->sample_rate;
+	hw.channels_min = cfg->channels;
+	hw.channels_max = cfg->channels;
+	hw.buffer_bytes_max = cfg->buffer_size * GIP_HS_NUM_BUFFERS;
+	hw.period_bytes_min = cfg->buffer_size;
+	hw.period_bytes_max = cfg->buffer_size;
+
+	sub->runtime->hw = hw;
+
+	return 0;
+}
+
+static int gip_headset_pcm_close(struct snd_pcm_substream *sub)
+{
+	return 0;
+}
+
+static int gip_headset_pcm_hw_params(struct snd_pcm_substream *sub,
+				     struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = sub->runtime;
+	size_t size = params_buffer_bytes(params);
+
+	if (runtime->dma_area) {
+		if (runtime->dma_bytes >= size)
+			return 0; /* Already large enough */
+		vfree(runtime->dma_area);
+	}
+	runtime->dma_area = vzalloc(size);
+	if (!runtime->dma_area)
+		return -ENOMEM;
+	runtime->dma_bytes = size;
+	return 1;
+}
+
+static int gip_headset_pcm_hw_free(struct snd_pcm_substream *sub)
+{
+	struct snd_pcm_runtime *runtime = sub->runtime;
+
+	vfree(runtime->dma_area);
+	runtime->dma_area = NULL;
+	return 0;
+}
+
+static struct page *gip_headset_pcm_get_page(struct snd_pcm_substream *sub,
+					     unsigned long offset)
+{
+	return vmalloc_to_page(sub->runtime->dma_area + offset);
+}
+
+static int gip_headset_pcm_prepare(struct snd_pcm_substream *sub)
+{
+	return 0;
+}
+
+static int gip_headset_pcm_trigger(struct snd_pcm_substream *sub, int cmd)
+{
+	struct gip_headset *headset = snd_pcm_substream_chip(sub);
+	struct gip_headset_stream *stream;
+
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		stream = &headset->playback;
+	else
+		stream = &headset->capture;
+
+	stream->pointer = 0;
+	stream->period = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		stream->substream = sub;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		stream->substream = NULL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (!stream->substream && sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		memset(headset->buffer, 0,
+		       headset->client->audio_config_out.buffer_size);
+
+	return 0;
+}
+
+static snd_pcm_uframes_t gip_headset_pcm_pointer(struct snd_pcm_substream *sub)
+{
+	struct gip_headset *headset = snd_pcm_substream_chip(sub);
+	struct gip_headset_stream *stream;
+
+	if (sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		stream = &headset->playback;
+	else
+		stream = &headset->capture;
+
+	return bytes_to_frames(sub->runtime, stream->pointer);
+}
+
+static const struct snd_pcm_ops gip_headset_pcm_ops = {
+	.open = gip_headset_pcm_open,
+	.close = gip_headset_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = gip_headset_pcm_hw_params,
+	.hw_free = gip_headset_pcm_hw_free,
+	.prepare = gip_headset_pcm_prepare,
+	.trigger = gip_headset_pcm_trigger,
+	.pointer = gip_headset_pcm_pointer,
+	.page = gip_headset_pcm_get_page,
+};
+
+static bool gip_headset_advance_pointer(struct gip_headset_stream *stream,
+					int len, size_t buf_size)
+{
+	snd_pcm_uframes_t period = stream->substream->runtime->period_size;
+
+	stream->pointer += len;
+	if (stream->pointer >= buf_size)
+		stream->pointer -= buf_size;
+
+	stream->period += len;
+	if (stream->period >= period) {
+		stream->period -= period;
+		return true;
+	}
+
+	return false;
+}
+
+static bool gip_headset_copy_playback(struct gip_headset_stream *stream,
+				      unsigned char *data, int len)
+{
+	unsigned char *src = stream->substream->runtime->dma_area;
+	size_t buf_size = snd_pcm_lib_buffer_bytes(stream->substream);
+	size_t remaining = buf_size - stream->pointer;
+
+	if (len <= remaining) {
+		memcpy(data, src + stream->pointer, len);
+	} else {
+		memcpy(data, src + stream->pointer, remaining);
+		memcpy(data + remaining, src, len - remaining);
+	}
+
+	return gip_headset_advance_pointer(stream, len, buf_size);
+}
+
+static bool gip_headset_copy_capture(struct gip_headset_stream *stream,
+				     unsigned char *data, int len)
+{
+	unsigned char *dest = stream->substream->runtime->dma_area;
+	size_t buf_size = snd_pcm_lib_buffer_bytes(stream->substream);
+	size_t remaining = buf_size - stream->pointer;
+
+	if (len <= remaining) {
+		memcpy(dest + stream->pointer, data, len);
+	} else {
+		memcpy(dest + stream->pointer, data, remaining);
+		memcpy(dest, data + remaining, len - remaining);
+	}
+
+	return gip_headset_advance_pointer(stream, len, buf_size);
+}
+
+static enum hrtimer_restart gip_headset_send_samples(struct hrtimer *timer)
+{
+	struct gip_headset *headset = container_of(timer, typeof(*headset),
+						   timer);
+	struct gip_audio_config *cfg = &headset->client->audio_config_out;
+	struct snd_pcm_substream *sub = headset->playback.substream;
+	bool elapsed = false;
+	int err;
+	unsigned long flags;
+
+	if (sub) {
+		snd_pcm_stream_lock_irqsave(sub, flags);
+
+		if (sub->runtime && snd_pcm_running(sub))
+			elapsed = gip_headset_copy_playback(&headset->playback,
+							    headset->buffer,
+							    cfg->buffer_size);
+
+		snd_pcm_stream_unlock_irqrestore(sub, flags);
+
+		if (elapsed)
+			snd_pcm_period_elapsed(sub);
+	}
+
+	if (headset->got_authenticated) {
+		/* retry if driver runs out of buffers */
+		err = gip_send_audio_samples(headset->client, headset->buffer);
+		if (err && err != -ENOSPC)
+			return HRTIMER_NORESTART;
+	}
+
+	hrtimer_forward_now(timer, ms_to_ktime(GIP_AUDIO_INTERVAL));
+
+	return HRTIMER_RESTART;
+}
+
+/*
+ * start pcm devices then launch the work that
+ * sends START every 500ms until an audio packet is received
+ * or audio volume control command is received
+ * or time out of 3 seconds (5 start message + 500ms timeout)
+ */
+static enum hrtimer_restart gip_headset_start_audio(struct hrtimer *timer)
+{
+	struct gip_headset *headset =
+		container_of(timer, typeof(*headset), start_audio_timer);
+	int err;
+
+	/*
+	 * check if the number of retries are elapsed (5) :
+	 * start audio anyway
+	 */
+	bool max_retries_reached =
+		(headset->start_counter > GIP_HS_MAX_RETRIES ? true : false);
+
+	/* check here if audio was started : HRTIMER_NORESTART */
+	if (headset->got_initial_volume || headset->got_audio_packet ||
+	    max_retries_reached) {
+		dev_dbg(&headset->client->dev,
+			"%s: start audio try %d/%d, audio = %d, vol = %d.\n",
+			__func__, headset->start_counter, GIP_HS_MAX_RETRIES,
+			headset->got_audio_packet, headset->got_initial_volume);
+
+		/* start work handling pcm config and audio timer */
+		schedule_work(&headset->work_register);
+		return HRTIMER_NORESTART;
+	}
+
+	// otherwise resend START and wait for another GIP_HS_START_DELAY ms
+	headset->start_counter++;
+	dev_dbg(&headset->client->dev, "%s: send device start, try %d/%d.\n",
+		__func__, headset->start_counter, GIP_HS_MAX_RETRIES);
+	err = gip_set_power_mode(headset->client, GIP_PWR_ON);
+	if (err)
+		dev_err(&headset->client->dev,
+			"%s: set power mode failed: %d\n", __func__, err);
+	hrtimer_forward_now(timer, ms_to_ktime(GIP_HS_START_DELAY));
+
+	return HRTIMER_RESTART;
+}
+
+static int gip_headset_init_pcm(struct gip_headset *headset)
+{
+	struct snd_card *card;
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_card_new(&headset->client->dev, SNDRV_DEFAULT_IDX1,
+			   SNDRV_DEFAULT_STR1, THIS_MODULE, 0, &card);
+	if (err)
+		return err;
+
+	strscpy(card->driver, "xone-gip-headset", sizeof(card->driver));
+	strscpy(card->shortname, GIP_HS_NAME, sizeof(card->shortname));
+	snprintf(card->longname, sizeof(card->longname), "%s at %s",
+		 GIP_HS_NAME, dev_name(&headset->client->dev));
+
+	headset->card = card;
+
+	err = snd_pcm_new(card, GIP_HS_NAME, 0, 1, 1, &pcm);
+	if (err)
+		return err;
+
+	strscpy(pcm->name, GIP_HS_NAME, sizeof(pcm->name));
+	pcm->private_data = headset;
+
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &gip_headset_pcm_ops);
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &gip_headset_pcm_ops);
+
+	return snd_card_register(card);
+}
+
+static void gip_headset_config(struct work_struct *work)
+{
+	struct gip_headset *headset = container_of(work,
+						   typeof(*headset),
+						   work_config);
+	struct gip_client *client = headset->client;
+	struct gip_info_element *fmts = client->audio_formats;
+	int err;
+
+	dev_dbg(&client->dev, "%s: format=0x%02x/0x%02x\n", __func__,
+		fmts->data[0], fmts->data[1]);
+
+	/* force headset in idle mode */
+	err = gip_set_power_mode(client, GIP_PWR_SLEEP);
+	if (err)
+		dev_err(&client->dev,
+			"%s: set headset power mode to IDLE failed: %d\n",
+			__func__, err);
+	/* suggest initial audio format */
+	dev_dbg(&client->dev, "%s: suggest format.\n", __func__);
+	err = gip_suggest_audio_format(client, fmts->data[0], fmts->data[1],
+				       headset->chat_headset);
+	if (err)
+		dev_err(&client->dev, "%s: suggest format failed: %d\n",
+			__func__, err);
+}
+
+static void gip_headset_power_on(struct work_struct *work)
+{
+	struct gip_headset *headset = container_of(
+		to_delayed_work(work), typeof(*headset), work_power_on);
+	struct gip_client *client = headset->client;
+	const struct device *dev = &client->adapter->dev;
+	int err;
+
+	dev_dbg(dev, "Headset vendor:  0x%04x\n", client->hardware.vendor);
+	dev_dbg(dev, "Headset product: 0x%04x\n", client->hardware.product);
+
+	/* Check if headset needs authentication before receiving audio samples */
+	headset->got_authenticated = true;
+	for (int i = 0; i < ARRAY_SIZE(GIP_HS_CHECK_AUTH_IDS); i++)
+		if (client->hardware.vendor == GIP_HS_CHECK_AUTH_IDS[i].vendor &&
+		    client->hardware.product == GIP_HS_CHECK_AUTH_IDS[i].product) {
+			headset->got_authenticated = false;
+			dev_dbg(dev, "Headset needs auth before receiving audio");
+			break;
+		}
+
+	/* not a standalone headset */
+	if (client->id) {
+		dev_dbg(dev, "Headset is not a standalone headset\n");
+		return;
+	}
+
+	err = gip_init_battery(&headset->battery, client, GIP_HS_NAME);
+	if (err) {
+		dev_err(&client->dev, "%s: init battery failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = gip_auth_start_handshake(&headset->auth, client);
+	if (err)
+		dev_err(&client->dev, "%s: start handshake failed: %d\n",
+			__func__, err);
+}
+
+static void gip_headset_register(struct work_struct *work)
+{
+	struct gip_headset *headset = container_of(work, typeof(*headset),
+						   work_register);
+	struct gip_client *client = headset->client;
+	int err;
+
+	headset->buffer = devm_kzalloc(&client->dev,
+				       client->audio_config_out.buffer_size,
+				       GFP_KERNEL);
+	if (!headset->buffer)
+		return;
+
+	dev_dbg(&client->dev, "%s: init pcm device.\n", __func__);
+	err = gip_headset_init_pcm(headset);
+	if (err) {
+		dev_err(&client->dev, "%s: init PCM failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	/* set hardware volume to maximum for headset jack */
+	/* standalone & chat headsets have physical volume controls */
+	if (client->id && !headset->chat_headset) {
+		err = gip_set_audio_volume(client, 100, 50, 100);
+		if (err) {
+			dev_err(&client->dev, "%s: set volume failed: %d\n",
+				__func__, err);
+			return;
+		}
+	}
+
+	dev_dbg(&client->dev, "%s: init audio out.\n", __func__);
+	err = gip_init_audio_out(client);
+	if (err) {
+		dev_err(&client->dev, "%s: init audio out failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	/* start audio timer */
+	hrtimer_start(&headset->timer, 0, HRTIMER_MODE_REL);
+}
+
+static int gip_headset_op_battery(struct gip_client *client,
+				  enum gip_battery_type type,
+				  enum gip_battery_level level)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+
+	gip_report_battery(&headset->battery, type, level);
+
+	return 0;
+}
+
+static int gip_headset_op_authenticate(struct gip_client *client,
+				       void *data, u32 len)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+
+	return gip_auth_process_pkt(&headset->auth, data, len);
+}
+
+static int gip_headset_op_authenticated(struct gip_client *client)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+	headset->got_authenticated = true;
+	return 0;
+}
+
+/*
+ * headset reported supported audio formats so
+ * we can allocate buffer with proper size
+ */
+static int gip_headset_op_audio_ready(struct gip_client *client)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+
+	dev_dbg(&client->dev,
+		"%s: audio ready : initialize start sequence.\n", __func__);
+	headset->start_counter = 0;
+	hrtimer_start(&headset->start_audio_timer, 0, HRTIMER_MODE_REL);
+	/* start auth handshake after GIP_HS_POWER_ON_DELAY */
+	schedule_delayed_work(&headset->work_power_on, GIP_HS_POWER_ON_DELAY);
+
+	return 0;
+}
+
+static int gip_headset_op_audio_volume(struct gip_client *client,
+				       u8 in, u8 out)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+
+	/* headset reported initial volume, ready to start audio I/O */
+	headset->got_initial_volume = true;
+
+	/* ignore hardware volume, let software handle volume changes */
+	return 0;
+}
+
+static int gip_headset_op_audio_samples(struct gip_client *client,
+					void *data, u32 len)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+	struct snd_pcm_substream *sub = headset->capture.substream;
+	bool elapsed = false;
+	unsigned long flags;
+
+	headset->got_audio_packet = true;
+
+	if (!sub)
+		return 0;
+
+	snd_pcm_stream_lock_irqsave(sub, flags);
+
+	if (sub->runtime && snd_pcm_running(sub))
+		elapsed = gip_headset_copy_capture(&headset->capture,
+						   data, len);
+
+	snd_pcm_stream_unlock_irqrestore(sub, flags);
+
+	if (elapsed)
+		snd_pcm_period_elapsed(sub);
+
+	return 0;
+}
+
+static int gip_headset_probe(struct gip_client *client)
+{
+	struct gip_headset *headset;
+	struct gip_info_element *fmts = client->audio_formats;
+	int err;
+
+	if (!fmts || !fmts->count)
+		return -ENODEV;
+
+	headset = devm_kzalloc(&client->dev, sizeof(*headset), GFP_KERNEL);
+	if (!headset)
+		return -ENOMEM;
+
+	headset->client = client;
+	headset->chat_headset = client->hardware.vendor == GIP_VID_MICROSOFT &&
+				client->hardware.product == GIP_HS_PID_CHAT;
+
+	INIT_WORK(&headset->work_config, gip_headset_config);
+	INIT_DELAYED_WORK(&headset->work_power_on, gip_headset_power_on);
+	INIT_WORK(&headset->work_register, gip_headset_register);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,15,0)
+	hrtimer_setup(&headset->timer, gip_headset_send_samples,
+		      CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer_setup(&headset->start_audio_timer, gip_headset_start_audio,
+		      CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+#else
+	hrtimer_init(&headset->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	headset->timer.function = gip_headset_send_samples;
+	hrtimer_init(&headset->start_audio_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	headset->start_audio_timer.function = gip_headset_start_audio;
+#endif
+
+	err = gip_enable_audio(client);
+	if (err)
+		return err;
+
+	err = gip_init_audio_in(client);
+	if (err) {
+		gip_disable_audio(client);
+		return err;
+	}
+
+	dev_set_drvdata(&client->dev, headset);
+
+	/* start audio configuration */
+	schedule_work(&headset->work_config);
+
+	return 0;
+}
+
+static void gip_headset_remove(struct gip_client *client)
+{
+	struct gip_headset *headset = dev_get_drvdata(&client->dev);
+
+	cancel_work_sync(&headset->work_config);
+	cancel_delayed_work_sync(&headset->work_power_on);
+	cancel_work_sync(&headset->work_register);
+	hrtimer_cancel(&headset->timer);
+	hrtimer_cancel(&headset->start_audio_timer);
+	gip_disable_audio(client);
+
+	if (headset->card) {
+		snd_card_disconnect(headset->card);
+		snd_card_free_when_closed(headset->card);
+	}
+}
+
+static struct gip_driver gip_headset_driver = {
+	.name = "xone-gip-headset",
+	.class = "Windows.Xbox.Input.Headset",
+	.ops = {
+		.battery = gip_headset_op_battery,
+		.authenticate = gip_headset_op_authenticate,
+		.authenticated = gip_headset_op_authenticated,
+		.audio_ready = gip_headset_op_audio_ready,
+		.audio_volume = gip_headset_op_audio_volume,
+		.audio_samples = gip_headset_op_audio_samples,
+	},
+	.probe = gip_headset_probe,
+	.remove = gip_headset_remove,
+};
+module_gip_driver(gip_headset_driver);
+
+MODULE_ALIAS("gip:Windows.Xbox.Input.Headset");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP headset driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/driver/madcatz_glam.c b/drivers/custom/xonedo/driver/madcatz_glam.c
new file mode 100644
index 000000000000..50d067ce5201
--- /dev/null
+++ b/drivers/custom/xonedo/driver/madcatz_glam.c
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2024 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+
+#include "common.h"
+#include "../auth/auth.h"
+
+#define GIP_GL_NAME "Mad Catz Rock Band 4 Drum Kit"
+
+enum gip_glam_button {
+	GIP_GL_BTN_MENU = BIT(2),
+	GIP_GL_BTN_VIEW = BIT(3),
+	GIP_GL_BTN_A = BIT(4),
+	GIP_GL_BTN_B = BIT(5),
+	/* swapped X and Y buttons */
+	GIP_GL_BTN_X = BIT(7),
+	GIP_GL_BTN_Y = BIT(6),
+	GIP_GL_BTN_DPAD_U = BIT(8),
+	GIP_GL_BTN_DPAD_D = BIT(9),
+	GIP_GL_BTN_DPAD_L = BIT(10),
+	GIP_GL_BTN_DPAD_R = BIT(11),
+	GIP_GL_BTN_KICK_1 = BIT(12),
+	GIP_GL_BTN_KICK_2 = BIT(13),
+};
+
+enum gip_glam_pad {
+	GIP_GL_PAD_YELLOW = BIT(0) | BIT(1) | BIT(2),
+	GIP_GL_PAD_RED = BIT(4) | BIT(5) | BIT(6),
+	GIP_GL_PAD_GREEN = BIT(8) | BIT(9) | BIT(10),
+	GIP_GL_PAD_BLUE = BIT(12) | BIT(13) | BIT(14),
+};
+
+enum gip_glam_cymbal {
+	GIP_GL_CBL_BLUE = BIT(0) | BIT(1) | BIT(2),
+	GIP_GL_CBL_YELLOW = BIT(4) | BIT(5) | BIT(6),
+	GIP_GL_CBL_GREEN = BIT(12) | BIT(13) | BIT(14),
+};
+
+struct gip_glam_pkt_input {
+	__le16 buttons;
+	__le16 pads;
+	__le16 cymbals;
+} __packed;
+
+struct gip_glam {
+	struct gip_client *client;
+	struct gip_battery battery;
+	struct gip_input input;
+};
+
+static int gip_glam_init_input(struct gip_glam *glam)
+{
+	struct input_dev *dev = glam->input.dev;
+	int err;
+
+	input_set_capability(dev, EV_KEY, BTN_MODE);
+	input_set_capability(dev, EV_KEY, BTN_START);
+	input_set_capability(dev, EV_KEY, BTN_SELECT);
+	input_set_capability(dev, EV_KEY, BTN_A);
+	input_set_capability(dev, EV_KEY, BTN_B);
+	input_set_capability(dev, EV_KEY, BTN_X);
+	input_set_capability(dev, EV_KEY, BTN_Y);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY1);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY2);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY3);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY4);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY5);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY6);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY7);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY8);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY9);
+	input_set_abs_params(dev, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0Y, -1, 1, 0, 0);
+
+	err = input_register_device(dev);
+	if (err)
+		dev_err(&glam->client->dev, "%s: register failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+
+static int gip_glam_op_battery(struct gip_client *client,
+			       enum gip_battery_type type,
+			       enum gip_battery_level level)
+{
+	struct gip_glam *glam = dev_get_drvdata(&client->dev);
+
+	gip_report_battery(&glam->battery, type, level);
+
+	return 0;
+}
+
+static int gip_glam_op_guide_button(struct gip_client *client, bool down)
+{
+	struct gip_glam *glam = dev_get_drvdata(&client->dev);
+
+	input_report_key(glam->input.dev, BTN_MODE, down);
+	input_sync(glam->input.dev);
+
+	return 0;
+}
+
+static int gip_glam_op_input(struct gip_client *client, void *data, u32 len)
+{
+	struct gip_glam *glam = dev_get_drvdata(&client->dev);
+	struct gip_glam_pkt_input *pkt = data;
+	struct input_dev *dev = glam->input.dev;
+	u16 buttons;
+	u16 pads;
+	u16 cymbals;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	buttons = le16_to_cpu(pkt->buttons);
+	pads = le16_to_cpu(pkt->pads);
+	cymbals = le16_to_cpu(pkt->cymbals);
+
+	input_report_key(dev, BTN_START, buttons & GIP_GL_BTN_MENU);
+	input_report_key(dev, BTN_SELECT, buttons & GIP_GL_BTN_VIEW);
+	input_report_key(dev, BTN_A, buttons & GIP_GL_BTN_A);
+	input_report_key(dev, BTN_B, buttons & GIP_GL_BTN_B);
+	input_report_key(dev, BTN_X, buttons & GIP_GL_BTN_X);
+	input_report_key(dev, BTN_Y, buttons & GIP_GL_BTN_Y);
+	input_report_key(dev, BTN_TRIGGER_HAPPY1, buttons & GIP_GL_BTN_KICK_1);
+	input_report_key(dev, BTN_TRIGGER_HAPPY2, buttons & GIP_GL_BTN_KICK_2);
+	input_report_key(dev, BTN_TRIGGER_HAPPY3, pads & GIP_GL_PAD_RED);
+	input_report_key(dev, BTN_TRIGGER_HAPPY4, pads & GIP_GL_PAD_YELLOW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY5, pads & GIP_GL_PAD_BLUE);
+	input_report_key(dev, BTN_TRIGGER_HAPPY6, pads & GIP_GL_PAD_GREEN);
+	input_report_key(dev, BTN_TRIGGER_HAPPY7, cymbals & GIP_GL_CBL_YELLOW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY8, cymbals & GIP_GL_CBL_BLUE);
+	input_report_key(dev, BTN_TRIGGER_HAPPY9, cymbals & GIP_GL_CBL_GREEN);
+	input_report_abs(dev, ABS_HAT0X, !!(buttons & GIP_GL_BTN_DPAD_R) -
+					 !!(buttons & GIP_GL_BTN_DPAD_L));
+	input_report_abs(dev, ABS_HAT0Y, !!(buttons & GIP_GL_BTN_DPAD_D) -
+					 !!(buttons & GIP_GL_BTN_DPAD_U));
+	input_sync(dev);
+
+	return 0;
+}
+
+static int gip_glam_probe(struct gip_client *client)
+{
+	struct gip_glam *glam;
+	int err;
+
+	glam = devm_kzalloc(&client->dev, sizeof(*glam), GFP_KERNEL);
+	if (!glam)
+		return -ENOMEM;
+
+	glam->client = client;
+
+	err = gip_set_power_mode(client, GIP_PWR_ON);
+	if (err)
+		return err;
+
+	err = gip_init_battery(&glam->battery, client, GIP_GL_NAME);
+	if (err)
+		return err;
+
+	/*
+	 * The Drum Kit sends auth chunks without specifying the
+	 * acknowledgment option while still expecting an acknowledgment.
+	 * The Windows driver handles this by sending an acknowledgment
+	 * after 100 ms when no further chunks are received.
+	 * We skip the handshake instead, as it is not required.
+	 */
+	err = gip_auth_send_complete(client);
+	if (err)
+		return err;
+
+	err = gip_init_input(&glam->input, client, GIP_GL_NAME);
+	if (err)
+		return err;
+
+	err = gip_glam_init_input(glam);
+	if (err)
+		return err;
+
+	dev_set_drvdata(&client->dev, glam);
+
+	return 0;
+}
+
+static struct gip_driver gip_glam_driver = {
+	.name = "xone-gip-madcatz-glam",
+	.class = "MadCatz.Xbox.Drums.Glam",
+	.ops = {
+		.battery = gip_glam_op_battery,
+		.guide_button = gip_glam_op_guide_button,
+		.input = gip_glam_op_input,
+	},
+	.probe = gip_glam_probe,
+};
+module_gip_driver(gip_glam_driver);
+
+MODULE_ALIAS("gip:MadCatz.Xbox.Drums.Glam");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP Mad Catz Drum Kit driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/driver/madcatz_strat.c b/drivers/custom/xonedo/driver/madcatz_strat.c
new file mode 100644
index 000000000000..445dd194429e
--- /dev/null
+++ b/drivers/custom/xonedo/driver/madcatz_strat.c
@@ -0,0 +1,203 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2022 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+
+#include "common.h"
+#include "../auth/auth.h"
+
+#define GIP_ST_NAME "Mad Catz Rock Band 4 Stratocaster"
+
+enum gip_strat_button {
+	GIP_ST_BTN_MENU = BIT(2),
+	GIP_ST_BTN_VIEW = BIT(3),
+	GIP_ST_BTN_DPAD_U = BIT(8),
+	GIP_ST_BTN_DPAD_D = BIT(9),
+	GIP_ST_BTN_DPAD_L = BIT(10),
+	GIP_ST_BTN_DPAD_R = BIT(11),
+};
+
+enum gip_strat_fret {
+	GIP_ST_FRET_GREEN = BIT(0),
+	GIP_ST_FRET_RED = BIT(1),
+	GIP_ST_FRET_YELLOW = BIT(2),
+	GIP_ST_FRET_BLUE = BIT(3),
+	GIP_ST_FRET_ORANGE = BIT(4),
+};
+
+struct gip_strat_pkt_input {
+	__le16 buttons;
+	u8 tilt;
+	u8 whammy;
+	u8 slider;
+	u8 fret_upper;
+	u8 fret_lower;
+} __packed;
+
+struct gip_strat {
+	struct gip_client *client;
+	struct gip_battery battery;
+	struct gip_input input;
+};
+
+static int gip_strat_init_input(struct gip_strat *strat)
+{
+	struct input_dev *dev = strat->input.dev;
+	int err;
+
+	input_set_capability(dev, EV_KEY, BTN_MODE);
+	input_set_capability(dev, EV_KEY, BTN_START);
+	input_set_capability(dev, EV_KEY, BTN_SELECT);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY1);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY2);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY3);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY4);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY5);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY6);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY7);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY8);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY9);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY10);
+	input_set_abs_params(dev, ABS_X, 0, 64, 0, 0);
+	input_set_abs_params(dev, ABS_Y, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_Z, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0Y, -1, 1, 0, 0);
+
+	err = input_register_device(dev);
+	if (err)
+		dev_err(&strat->client->dev, "%s: register failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+
+static int gip_strat_op_battery(struct gip_client *client,
+				enum gip_battery_type type,
+				enum gip_battery_level level)
+{
+	struct gip_strat *strat = dev_get_drvdata(&client->dev);
+
+	gip_report_battery(&strat->battery, type, level);
+
+	return 0;
+}
+
+static int gip_strat_op_guide_button(struct gip_client *client, bool down)
+{
+	struct gip_strat *strat = dev_get_drvdata(&client->dev);
+
+	input_report_key(strat->input.dev, BTN_MODE, down);
+	input_sync(strat->input.dev);
+
+	return 0;
+}
+
+static int gip_strat_op_input(struct gip_client *client, void *data, u32 len)
+{
+	struct gip_strat *strat = dev_get_drvdata(&client->dev);
+	struct gip_strat_pkt_input *pkt = data;
+	struct input_dev *dev = strat->input.dev;
+	u16 buttons;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	buttons = le16_to_cpu(pkt->buttons);
+
+	input_report_key(dev, BTN_START, buttons & GIP_ST_BTN_MENU);
+	input_report_key(dev, BTN_SELECT, buttons & GIP_ST_BTN_VIEW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY1,
+			 pkt->fret_upper & GIP_ST_FRET_GREEN);
+	input_report_key(dev, BTN_TRIGGER_HAPPY2,
+			 pkt->fret_upper & GIP_ST_FRET_RED);
+	input_report_key(dev, BTN_TRIGGER_HAPPY3,
+			 pkt->fret_upper & GIP_ST_FRET_YELLOW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY4,
+			 pkt->fret_upper & GIP_ST_FRET_BLUE);
+	input_report_key(dev, BTN_TRIGGER_HAPPY5,
+			 pkt->fret_upper & GIP_ST_FRET_ORANGE);
+	input_report_key(dev, BTN_TRIGGER_HAPPY6,
+			 pkt->fret_lower & GIP_ST_FRET_GREEN);
+	input_report_key(dev, BTN_TRIGGER_HAPPY7,
+			 pkt->fret_lower & GIP_ST_FRET_RED);
+	input_report_key(dev, BTN_TRIGGER_HAPPY8,
+			 pkt->fret_lower & GIP_ST_FRET_YELLOW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY9,
+			 pkt->fret_lower & GIP_ST_FRET_BLUE);
+	input_report_key(dev, BTN_TRIGGER_HAPPY10,
+			 pkt->fret_lower & GIP_ST_FRET_ORANGE);
+	input_report_abs(dev, ABS_X, pkt->slider);
+	input_report_abs(dev, ABS_Y, pkt->whammy);
+	input_report_abs(dev, ABS_Z, pkt->tilt);
+	input_report_abs(dev, ABS_HAT0X, !!(buttons & GIP_ST_BTN_DPAD_R) -
+					 !!(buttons & GIP_ST_BTN_DPAD_L));
+	input_report_abs(dev, ABS_HAT0Y, !!(buttons & GIP_ST_BTN_DPAD_D) -
+					 !!(buttons & GIP_ST_BTN_DPAD_U));
+	input_sync(dev);
+
+	return 0;
+}
+
+static int gip_strat_probe(struct gip_client *client)
+{
+	struct gip_strat *strat;
+	int err;
+
+	strat = devm_kzalloc(&client->dev, sizeof(*strat), GFP_KERNEL);
+	if (!strat)
+		return -ENOMEM;
+
+	strat->client = client;
+
+	err = gip_set_power_mode(client, GIP_PWR_ON);
+	if (err)
+		return err;
+
+	err = gip_init_battery(&strat->battery, client, GIP_ST_NAME);
+	if (err)
+		return err;
+
+	/*
+	 * The Stratocaster sends auth chunks without specifying the
+	 * acknowledgment option while still expecting an acknowledgment.
+	 * The Windows driver handles this by sending an acknowledgment
+	 * after 100 ms when no further chunks are received.
+	 * We skip the handshake instead, as it is not required.
+	 */
+	err = gip_auth_send_complete(client);
+	if (err)
+		return err;
+
+	err = gip_init_input(&strat->input, client, GIP_ST_NAME);
+	if (err)
+		return err;
+
+	err = gip_strat_init_input(strat);
+	if (err)
+		return err;
+
+	dev_set_drvdata(&client->dev, strat);
+
+	return 0;
+}
+
+static struct gip_driver gip_strat_driver = {
+	.name = "xone-gip-madcatz-strat",
+	.class = "MadCatz.Xbox.Guitar.Stratocaster",
+	.ops = {
+		.battery = gip_strat_op_battery,
+		.guide_button = gip_strat_op_guide_button,
+		.input = gip_strat_op_input,
+	},
+	.probe = gip_strat_probe,
+};
+module_gip_driver(gip_strat_driver);
+
+MODULE_ALIAS("gip:MadCatz.Xbox.Guitar.Stratocaster");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone GIP Mad Catz Stratocaster driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/driver/pdp_jaguar.c b/drivers/custom/xonedo/driver/pdp_jaguar.c
new file mode 100644
index 000000000000..b98caf5fa614
--- /dev/null
+++ b/drivers/custom/xonedo/driver/pdp_jaguar.c
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2022 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ * Copyright (C) 2023 Scott K Logan <logans@cottsay.net>
+ */
+
+#include <linux/module.h>
+
+#include "common.h"
+#include "../auth/auth.h"
+
+#define GIP_JA_NAME "PDP Rock Band 4 Jaguar"
+
+enum gip_jaguar_button {
+	GIP_JA_BTN_MENU = BIT(2),
+	GIP_JA_BTN_VIEW = BIT(3),
+	GIP_JA_BTN_DPAD_U = BIT(8),
+	GIP_JA_BTN_DPAD_D = BIT(9),
+	GIP_JA_BTN_DPAD_L = BIT(10),
+	GIP_JA_BTN_DPAD_R = BIT(11),
+};
+
+enum gip_jaguar_fret {
+	GIP_JA_FRET_GREEN = BIT(4),
+	GIP_JA_FRET_RED = BIT(5),
+	GIP_JA_FRET_BLUE = BIT(6),
+	GIP_JA_FRET_YELLOW = BIT(7),
+	GIP_JA_FRET_ORANGE = BIT(12),
+	GIP_JA_FRET_LOWER = BIT(14),
+};
+
+struct gip_jaguar_pkt_input {
+	__le16 buttons;
+	u8 tilt;
+	u8 whammy;
+} __packed;
+
+struct gip_jaguar {
+	struct gip_client *client;
+	struct gip_battery battery;
+	struct gip_auth auth;
+	struct gip_input input;
+};
+
+static int gip_jaguar_init_input(struct gip_jaguar *guitar)
+{
+	struct input_dev *dev = guitar->input.dev;
+	int err;
+
+	input_set_capability(dev, EV_KEY, BTN_MODE);
+	input_set_capability(dev, EV_KEY, BTN_START);
+	input_set_capability(dev, EV_KEY, BTN_SELECT);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY1);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY2);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY3);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY4);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY5);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY6);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY7);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY8);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY9);
+	input_set_capability(dev, EV_KEY, BTN_TRIGGER_HAPPY10);
+	input_set_abs_params(dev, ABS_Y, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_Z, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(dev, ABS_HAT0Y, -1, 1, 0, 0);
+
+	err = input_register_device(dev);
+	if (err)
+		dev_err(&guitar->client->dev, "%s: register failed: %d\n",
+			__func__, err);
+
+	return err;
+}
+
+static int gip_jaguar_op_battery(struct gip_client *client,
+				 enum gip_battery_type type,
+				 enum gip_battery_level level)
+{
+	struct gip_jaguar *guitar = dev_get_drvdata(&client->dev);
+
+	gip_report_battery(&guitar->battery, type, level);
+
+	return 0;
+}
+
+static int gip_jaguar_op_authenticate(struct gip_client *client,
+				      void *data, u32 len)
+{
+	struct gip_jaguar *guitar = dev_get_drvdata(&client->dev);
+
+	return gip_auth_process_pkt(&guitar->auth, data, len);
+}
+
+static int gip_jaguar_op_guide_button(struct gip_client *client, bool down)
+{
+	struct gip_jaguar *guitar = dev_get_drvdata(&client->dev);
+
+	input_report_key(guitar->input.dev, BTN_MODE, down);
+	input_sync(guitar->input.dev);
+
+	return 0;
+}
+
+static int gip_jaguar_op_input(struct gip_client *client, void *data, u32 len)
+{
+	struct gip_jaguar *guitar = dev_get_drvdata(&client->dev);
+	struct gip_jaguar_pkt_input *pkt = data;
+	struct input_dev *dev = guitar->input.dev;
+	u16 buttons;
+	bool lower;
+
+	if (len < sizeof(*pkt))
+		return -EINVAL;
+
+	buttons = le16_to_cpu(pkt->buttons);
+	lower = buttons & GIP_JA_FRET_LOWER;
+
+	input_report_key(dev, BTN_START, buttons & GIP_JA_BTN_MENU);
+	input_report_key(dev, BTN_SELECT, buttons & GIP_JA_BTN_VIEW);
+	input_report_key(dev, BTN_TRIGGER_HAPPY1,
+			 (buttons & GIP_JA_FRET_GREEN) && !lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY2,
+			 (buttons & GIP_JA_FRET_RED) && !lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY3,
+			 (buttons & GIP_JA_FRET_YELLOW) && !lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY4,
+			 (buttons & GIP_JA_FRET_BLUE) && !lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY5,
+			 (buttons & GIP_JA_FRET_ORANGE) && !lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY6,
+			 (buttons & GIP_JA_FRET_GREEN) && lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY7,
+			 (buttons & GIP_JA_FRET_RED) && lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY8,
+			 (buttons & GIP_JA_FRET_YELLOW) && lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY9,
+			 (buttons & GIP_JA_FRET_BLUE) && lower);
+	input_report_key(dev, BTN_TRIGGER_HAPPY10,
+			 (buttons & GIP_JA_FRET_ORANGE) && lower);
+	input_report_abs(dev, ABS_Y, pkt->whammy);
+	input_report_abs(dev, ABS_Z, pkt->tilt);
+	input_report_abs(dev, ABS_HAT0X, !!(buttons & GIP_JA_BTN_DPAD_R) -
+					 !!(buttons & GIP_JA_BTN_DPAD_L));
+	input_report_abs(dev, ABS_HAT0Y, !!(buttons & GIP_JA_BTN_DPAD_D) -
+					 !!(buttons & GIP_JA_BTN_DPAD_U));
+	input_sync(dev);
+
+	return 0;
+}
+
+static int gip_jaguar_probe(struct gip_client *client)
+{
+	struct gip_jaguar *guitar;
+	int err;
+
+	guitar = devm_kzalloc(&client->dev, sizeof(*guitar), GFP_KERNEL);
+	if (!guitar)
+		return -ENOMEM;
+
+	guitar->client = client;
+
+	err = gip_set_power_mode(client, GIP_PWR_ON);
+	if (err)
+		return err;
+
+	err = gip_init_battery(&guitar->battery, client, GIP_JA_NAME);
+	if (err)
+		return err;
+
+	err = gip_auth_start_handshake(&guitar->auth, client);
+	if (err)
+		return err;
+
+	err = gip_init_input(&guitar->input, client, GIP_JA_NAME);
+	if (err)
+		return err;
+
+	err = gip_jaguar_init_input(guitar);
+	if (err)
+		return err;
+
+	dev_set_drvdata(&client->dev, guitar);
+
+	return 0;
+}
+
+static struct gip_driver gip_jaguar_driver = {
+	.name = "xone-gip-pdp-jaguar",
+	.class = "PDP.Xbox.Guitar.Jaguar",
+	.ops = {
+		.battery = gip_jaguar_op_battery,
+		.authenticate = gip_jaguar_op_authenticate,
+		.guide_button = gip_jaguar_op_guide_button,
+		.input = gip_jaguar_op_input,
+	},
+	.probe = gip_jaguar_probe,
+};
+module_gip_driver(gip_jaguar_driver);
+
+MODULE_ALIAS("gip:PDP.Xbox.Guitar.Jaguar");
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_AUTHOR("Scott K Logan <logans@cottsay.net>");
+MODULE_DESCRIPTION("xone GIP PDP Jaguar driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/install/modprobe.conf b/drivers/custom/xonedo/install/modprobe.conf
new file mode 100644
index 000000000000..11da85aced6c
--- /dev/null
+++ b/drivers/custom/xonedo/install/modprobe.conf
@@ -0,0 +1 @@
+blacklist mt76x2u
diff --git a/drivers/custom/xonedo/transport/dongle.c b/drivers/custom/xonedo/transport/dongle.c
new file mode 100644
index 000000000000..dc9376bb4537
--- /dev/null
+++ b/drivers/custom/xonedo/transport/dongle.c
@@ -0,0 +1,1323 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/bitfield.h>
+#include <linux/version.h>
+#include <linux/usb.h>
+#include <linux/sysfs.h>
+#include <linux/ieee80211.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <net/cfg80211.h>
+
+#include "mt76.h"
+#include "../bus/bus.h"
+
+#define XONE_DONGLE_NUM_IN_URBS 12
+#define XONE_DONGLE_NUM_OUT_URBS 12
+
+#define XONE_DONGLE_LEN_CMD_PKT 0x0654
+#define XONE_DONGLE_LEN_WLAN_PKT 0x8400
+
+#define XONE_DONGLE_MAX_CLIENTS 16
+
+/* autosuspend delay in ms */
+#define XONE_DONGLE_SUSPEND_DELAY 60000
+
+#define XONE_DONGLE_PAIRING_TIMEOUT msecs_to_jiffies(30000)
+#define XONE_DONGLE_PWR_OFF_TIMEOUT msecs_to_jiffies(5000)
+#define XONE_DONGLE_FW_REQ_TIMEOUT_MS 3000
+#define XONE_DONGLE_FW_REQ_RETRIES 11 // 30 seconds
+#define XONE_DONGLE_FW_LOAD_RETRIES 3
+
+#define XONE_DONGLE_OFFICIAL_VENDOR 0x045e
+#define XONE_DONGLE_OFFICIAL_PRODUCT 0x02fe
+#define XONE_DONGLE_KNOCKOFF_PRODUCT1 0x02e6
+
+enum xone_dongle_queue {
+	XONE_DONGLE_QUEUE_DATA = 0x00,
+	XONE_DONGLE_QUEUE_AUDIO = 0x02,
+};
+
+enum xone_dongle_fw_state {
+	XONE_DONGLE_FW_STATE_PENDING,
+	XONE_DONGLE_FW_STATE_STOP_LOADING,
+	XONE_DONGLE_FW_STATE_ERROR,
+	XONE_DONGLE_FW_STATE_READY,
+};
+
+struct xone_dongle_skb_cb {
+	struct xone_dongle *dongle;
+	struct urb *urb;
+};
+
+struct xone_dongle_client {
+	struct xone_dongle *dongle;
+	u8 wcid;
+	u8 address[ETH_ALEN];
+	bool encryption_enabled;
+
+	struct gip_adapter *adapter;
+};
+
+struct xone_dongle_event {
+	enum xone_dongle_event_type {
+		XONE_DONGLE_EVT_ADD_CLIENT,
+		XONE_DONGLE_EVT_REMOVE_CLIENT,
+		XONE_DONGLE_EVT_PAIR_CLIENT,
+		XONE_DONGLE_EVT_ENABLE_PAIRING,
+		XONE_DONGLE_EVT_ENABLE_ENCRYPTION,
+	} type;
+
+	struct xone_dongle *dongle;
+	u8 address[ETH_ALEN];
+	u8 wcid;
+
+	struct work_struct work;
+};
+
+struct xone_dongle {
+	struct xone_mt76 mt;
+
+	struct usb_anchor urbs_in_idle;
+	struct usb_anchor urbs_in_busy;
+	struct usb_anchor urbs_out_idle;
+	struct usb_anchor urbs_out_busy;
+
+	/* serializes pairing changes */
+	struct mutex pairing_lock;
+	struct delayed_work pairing_work;
+	bool pairing;
+
+	/* serializes access to clients array */
+	spinlock_t clients_lock;
+	struct xone_dongle_client *clients[XONE_DONGLE_MAX_CLIENTS];
+	atomic_t client_count;
+	wait_queue_head_t disconnect_wait;
+
+	struct workqueue_struct *event_wq;
+	struct work_struct load_fw_work;
+
+	enum xone_dongle_fw_state fw_state;
+	u16 vendor;
+	u16 product;
+};
+
+static void xone_dongle_prep_packet(struct xone_dongle_client *client,
+				    struct sk_buff *skb,
+				    enum xone_dongle_queue queue)
+{
+	struct ieee80211_qos_hdr hdr = {};
+	struct mt76_txwi txwi = {};
+	u8 data[] = {
+		0x00, 0x00, queue, client->wcid - 1, 0x00, 0x00, 0x00, 0x00,
+	};
+
+	/* frame is sent from AP (DS) */
+	/* duration is the time required to transmit (in s) */
+	hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |
+					IEEE80211_STYPE_QOS_DATA |
+					IEEE80211_FCTL_FROMDS);
+
+	/* encrypt frame on transmission */
+	if (client->encryption_enabled)
+		hdr.frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+
+	hdr.duration_id = cpu_to_le16(144);
+	memcpy(hdr.addr1, client->address, ETH_ALEN);
+	memcpy(hdr.addr2, client->dongle->mt.address, ETH_ALEN);
+	memcpy(hdr.addr3, client->dongle->mt.address, ETH_ALEN);
+
+	/* wait for acknowledgment */
+	txwi.flags = cpu_to_le16(FIELD_PREP(MT_TXWI_FLAGS_MPDU_DENSITY,
+					    IEEE80211_HT_MPDU_DENSITY_4));
+	txwi.rate = cpu_to_le16(FIELD_PREP(MT_RXWI_RATE_PHY, MT_PHY_TYPE_OFDM));
+	txwi.ack_ctl = MT_TXWI_ACK_CTL_REQ;
+	txwi.wcid = client->wcid - 1;
+	txwi.len_ctl = cpu_to_le16(sizeof(hdr) + skb->len);
+
+	memset(skb_push(skb, 2), 0, 2);
+	memcpy(skb_push(skb, sizeof(hdr)), &hdr, sizeof(hdr));
+	memcpy(skb_push(skb, sizeof(txwi)), &txwi, sizeof(txwi));
+	memcpy(skb_push(skb, sizeof(data)), data, sizeof(data));
+
+	xone_mt76_prep_command(skb, 0);
+}
+
+static int xone_dongle_get_buffer(struct gip_adapter *adap,
+				  struct gip_adapter_buffer *buf)
+{
+	struct xone_dongle_client *client = dev_get_drvdata(&adap->dev);
+	struct xone_dongle_skb_cb *cb;
+	struct urb *urb;
+	struct sk_buff *skb;
+
+	urb = usb_get_from_anchor(&client->dongle->urbs_out_idle);
+	if (!urb)
+		return -ENOSPC;
+
+	skb = xone_mt76_alloc_message(XONE_DONGLE_LEN_CMD_PKT, GFP_ATOMIC);
+	if (!skb)
+		return -ENOMEM;
+
+	/* command header + WCID data + TXWI + QoS header + padding */
+	/* see xone_dongle_prep_packet and xone_mt76_prep_message */
+	skb_reserve(skb, MT_CMD_HDR_LEN + 8 + sizeof(struct mt76_txwi) +
+		    sizeof(struct ieee80211_qos_hdr) + 2 + MT_CMD_HDR_LEN);
+
+	cb = (struct xone_dongle_skb_cb *)skb->cb;
+	cb->dongle = client->dongle;
+	cb->urb = urb;
+
+	buf->context = skb;
+	buf->data = skb->data;
+	buf->length = skb_tailroom(skb);
+
+	return 0;
+}
+
+static int xone_dongle_submit_buffer(struct gip_adapter *adap,
+				     struct gip_adapter_buffer *buf)
+{
+	struct xone_dongle_client *client = dev_get_drvdata(&adap->dev);
+	struct xone_dongle_skb_cb *cb;
+	struct sk_buff *skb = buf->context;
+	int err;
+
+	skb_put(skb, buf->length);
+
+	if (buf->type == GIP_BUF_DATA)
+		xone_dongle_prep_packet(client, skb, XONE_DONGLE_QUEUE_DATA);
+	else if (buf->type == GIP_BUF_AUDIO)
+		xone_dongle_prep_packet(client, skb, XONE_DONGLE_QUEUE_AUDIO);
+	else
+		return -EINVAL;
+
+	cb = (struct xone_dongle_skb_cb *)skb->cb;
+	cb->urb->context = skb;
+	cb->urb->transfer_buffer = skb->data;
+	cb->urb->transfer_buffer_length = skb->len;
+	usb_anchor_urb(cb->urb, &client->dongle->urbs_out_busy);
+
+	err = usb_submit_urb(cb->urb, GFP_ATOMIC);
+	if (err) {
+		usb_unanchor_urb(cb->urb);
+		usb_anchor_urb(cb->urb, &client->dongle->urbs_out_idle);
+		dev_kfree_skb_any(skb);
+	}
+
+	usb_free_urb(cb->urb);
+
+	return err;
+}
+
+static int xone_dongle_set_encryption_key(struct gip_adapter *adap,
+					  u8 *key, int len)
+{
+	struct xone_dongle_client *client = dev_get_drvdata(&adap->dev);
+
+	return xone_mt76_set_client_key(&client->dongle->mt, client->wcid,
+					key, len);
+}
+
+static struct gip_adapter_ops xone_dongle_adapter_ops = {
+	.get_buffer = xone_dongle_get_buffer,
+	.submit_buffer = xone_dongle_submit_buffer,
+	.set_encryption_key = xone_dongle_set_encryption_key,
+};
+
+static int xone_dongle_toggle_pairing(struct xone_dongle *dongle, bool enable)
+{
+	struct usb_interface *intf = to_usb_interface(dongle->mt.dev);
+	enum xone_mt76_led_mode led;
+	int err = 0;
+
+	mutex_lock(&dongle->pairing_lock);
+
+	/* pairing is already enabled/disabled */
+	if (dongle->pairing == enable)
+		goto err_unlock;
+
+	err = xone_mt76_set_pairing(&dongle->mt, enable);
+	if (err)
+		goto err_unlock;
+
+	if (enable)
+		led = XONE_MT_LED_BLINK;
+	else if (atomic_read(&dongle->client_count))
+		led = XONE_MT_LED_ON;
+	else
+		led = XONE_MT_LED_OFF;
+
+	err = xone_mt76_set_led_mode(&dongle->mt, led);
+	if (err)
+		goto err_unlock;
+
+	if (enable)
+		usb_autopm_get_interface(intf);
+	else
+		usb_autopm_put_interface(intf);
+
+	dev_dbg(dongle->mt.dev, "%s: enabled=%d\n", __func__, enable);
+	dongle->pairing = enable;
+
+	if (enable)
+		mod_delayed_work(system_wq, &dongle->pairing_work,
+				 XONE_DONGLE_PAIRING_TIMEOUT);
+
+err_unlock:
+	mutex_unlock(&dongle->pairing_lock);
+
+	return err;
+}
+
+static void xone_dongle_pairing_timeout(struct work_struct *work)
+{
+	struct xone_dongle *dongle = container_of(to_delayed_work(work),
+						  typeof(*dongle),
+						  pairing_work);
+	int err;
+
+	if (!dongle)
+		return;
+
+	err = xone_dongle_toggle_pairing(dongle, false);
+	if (err)
+		dev_err(dongle->mt.dev, "%s: disable pairing failed: %d\n",
+			__func__, err);
+}
+
+static ssize_t xone_dongle_pairing_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct usb_interface *intf = to_usb_interface(dev);
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+
+	return sprintf(buf, "%d\n", dongle->pairing);
+}
+
+static ssize_t xone_dongle_pairing_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct usb_interface *intf = to_usb_interface(dev);
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	bool enable;
+	int err;
+
+	err = kstrtobool(buf, &enable);
+	if (err)
+		return err;
+
+	err = pm_runtime_resume_and_get(dev);
+	if (err)
+		return err;
+
+	err = xone_dongle_toggle_pairing(dongle, enable);
+	if (err)
+		return err;
+
+	pm_runtime_put(dev);
+
+	return count;
+}
+
+static struct device_attribute xone_dongle_attr_pairing =
+	__ATTR(pairing, 0644,
+	       xone_dongle_pairing_show,
+	       xone_dongle_pairing_store);
+
+static struct attribute *xone_dongle_attrs[] = {
+	&xone_dongle_attr_pairing.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(xone_dongle);
+
+static struct xone_dongle_client *
+xone_dongle_create_client(struct xone_dongle *dongle, u8 *addr)
+{
+	struct xone_dongle_client *client;
+	int i, err;
+
+	/* find free WCID */
+	for (i = 0; i < XONE_DONGLE_MAX_CLIENTS; i++)
+		if (!dongle->clients[i])
+			break;
+
+	if (i == XONE_DONGLE_MAX_CLIENTS)
+		return ERR_PTR(-ENOSPC);
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return ERR_PTR(-ENOMEM);
+
+	client->dongle = dongle;
+	client->wcid = i + 1;
+	memcpy(client->address, addr, ETH_ALEN);
+
+	client->adapter = gip_create_adapter(dongle->mt.dev,
+					     &xone_dongle_adapter_ops, 1);
+	if (IS_ERR(client->adapter)) {
+		err = PTR_ERR(client->adapter);
+		kfree(client);
+		return ERR_PTR(err);
+	}
+
+	dev_set_drvdata(&client->adapter->dev, client);
+
+	return client;
+}
+
+static int xone_dongle_add_client(struct xone_dongle *dongle, u8 *addr)
+{
+	struct xone_dongle_client *client;
+	int err;
+	unsigned long flags;
+
+	client = xone_dongle_create_client(dongle, addr);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+
+	err = xone_mt76_associate_client(&dongle->mt, client->wcid, addr);
+	if (err)
+		goto err_free_client;
+
+	if (!dongle->pairing) {
+		err = xone_mt76_set_led_mode(&dongle->mt, XONE_MT_LED_ON);
+		if (err)
+			goto err_free_client;
+	}
+
+	dev_dbg(dongle->mt.dev, "%s: wcid=%d, address=%pM\n",
+		__func__, client->wcid, addr);
+
+	spin_lock_irqsave(&dongle->clients_lock, flags);
+	dongle->clients[client->wcid - 1] = client;
+	spin_unlock_irqrestore(&dongle->clients_lock, flags);
+
+	atomic_inc(&dongle->client_count);
+	usb_autopm_get_interface(to_usb_interface(dongle->mt.dev));
+
+	return 0;
+
+err_free_client:
+	gip_destroy_adapter(client->adapter);
+	kfree(client);
+
+	return err;
+}
+
+static int xone_dongle_remove_client(struct xone_dongle *dongle, u8 wcid)
+{
+	struct xone_dongle_client *client;
+	int err;
+	unsigned long flags;
+
+	client = dongle->clients[wcid - 1];
+	if (!client)
+		return 0;
+
+	dev_dbg(dongle->mt.dev, "%s: wcid=%d, address=%pM\n",
+		__func__, wcid, client->address);
+
+	spin_lock_irqsave(&dongle->clients_lock, flags);
+	dongle->clients[wcid - 1] = NULL;
+	spin_unlock_irqrestore(&dongle->clients_lock, flags);
+
+	gip_destroy_adapter(client->adapter);
+	kfree(client);
+
+	err = xone_mt76_remove_client(&dongle->mt, wcid);
+	if (err)
+		dev_err(dongle->mt.dev, "%s: remove failed: %d\n",
+			__func__, err);
+
+	/* turn off LED if all clients have disconnected */
+	if (atomic_dec_and_test(&dongle->client_count) && !dongle->pairing)
+		err = xone_mt76_set_led_mode(&dongle->mt, XONE_MT_LED_OFF);
+
+	wake_up(&dongle->disconnect_wait);
+	usb_autopm_put_interface(to_usb_interface(dongle->mt.dev));
+
+	return err;
+}
+
+static int xone_dongle_pair_client(struct xone_dongle *dongle, u8 *addr)
+{
+	int err;
+
+	dev_dbg(dongle->mt.dev, "%s: address=%pM\n", __func__, addr);
+
+	err = xone_mt76_pair_client(&dongle->mt, addr);
+	if (err)
+		return err;
+
+	return xone_dongle_toggle_pairing(dongle, false);
+}
+
+static int xone_dongle_enable_client_encryption(struct xone_dongle *dongle,
+						u8 wcid)
+{
+	struct xone_dongle_client *client;
+	u8 data[] = { 0x00, 0x00 };
+	int err;
+
+	client = dongle->clients[wcid - 1];
+	if (!client)
+		return -EINVAL;
+
+	dev_dbg(dongle->mt.dev, "%s: wcid=%d, address=%pM\n",
+		__func__, wcid, client->address);
+
+	err = xone_mt76_send_client_command(&dongle->mt, wcid, client->address,
+					    XONE_MT_CLIENT_ENABLE_ENCRYPTION,
+					    data, sizeof(data));
+	if (err)
+		return err;
+
+	client->encryption_enabled = true;
+
+	return 0;
+}
+
+static void xone_dongle_handle_event(struct work_struct *work)
+{
+	struct xone_dongle_event *evt = container_of(work, typeof(*evt), work);
+	int err = 0;
+
+	/* Do not process events when firmware is not ready */
+	if (evt->dongle->fw_state < XONE_DONGLE_FW_STATE_READY) {
+		pr_debug("%s: firmware not loaded yet", __func__);
+		goto handle_event_free;
+	}
+
+	switch (evt->type) {
+	case XONE_DONGLE_EVT_ADD_CLIENT:
+		pr_debug("%s: XONE_DONGLE_EVT_ADD_CLIENT", __func__);
+		err = xone_dongle_add_client(evt->dongle, evt->address);
+		break;
+	case XONE_DONGLE_EVT_REMOVE_CLIENT:
+		pr_debug("%s: XONE_DONGLE_EVT_REMOVE_CLIENT", __func__);
+		err = xone_dongle_remove_client(evt->dongle, evt->wcid);
+		break;
+	case XONE_DONGLE_EVT_PAIR_CLIENT:
+		pr_debug("%s: XONE_DONGLE_EVT_PAIR_CLIENT", __func__);
+		err = xone_dongle_pair_client(evt->dongle, evt->address);
+		break;
+	case XONE_DONGLE_EVT_ENABLE_PAIRING:
+		pr_debug("%s: XONE_DONGLE_EVT_ENABLE_PAIRING", __func__);
+		err = xone_dongle_toggle_pairing(evt->dongle, true);
+		break;
+	case XONE_DONGLE_EVT_ENABLE_ENCRYPTION:
+		pr_debug("%s: XONE_DONGLE_EVT_ENABLE_ENCRYPTION", __func__);
+		err = xone_dongle_enable_client_encryption(evt->dongle,
+							   evt->wcid);
+		break;
+	}
+
+	if (err)
+		dev_err(evt->dongle->mt.dev, "%s: handle event failed: %d\n",
+			__func__, err);
+
+handle_event_free:
+	kfree(evt);
+}
+
+static struct xone_dongle_event *
+xone_dongle_alloc_event(struct xone_dongle *dongle,
+			enum xone_dongle_event_type type)
+{
+	struct xone_dongle_event *evt;
+
+	evt = kzalloc(sizeof(*evt), GFP_ATOMIC);
+	if (!evt)
+		return NULL;
+
+	evt->type = type;
+	evt->dongle = dongle;
+	INIT_WORK(&evt->work, xone_dongle_handle_event);
+
+	return evt;
+}
+
+static int xone_dongle_handle_qos_data(struct xone_dongle *dongle,
+				       struct sk_buff *skb, u8 wcid)
+{
+	struct xone_dongle_client *client;
+	int err = 0;
+	unsigned long flags;
+
+	if (!wcid || wcid > XONE_DONGLE_MAX_CLIENTS)
+		return 0;
+
+	spin_lock_irqsave(&dongle->clients_lock, flags);
+
+	client = dongle->clients[wcid - 1];
+	if (client)
+		err = gip_process_buffer(client->adapter, skb->data, skb->len);
+
+	spin_unlock_irqrestore(&dongle->clients_lock, flags);
+
+	return err;
+}
+
+static int xone_dongle_handle_association(struct xone_dongle *dongle, u8 *addr)
+{
+	struct xone_dongle_event *evt;
+
+	evt = xone_dongle_alloc_event(dongle, XONE_DONGLE_EVT_ADD_CLIENT);
+	if (!evt)
+		return -ENOMEM;
+
+	memcpy(evt->address, addr, ETH_ALEN);
+
+	queue_work(dongle->event_wq, &evt->work);
+
+	return 0;
+}
+
+static int xone_dongle_handle_disassociation(struct xone_dongle *dongle,
+					     u8 wcid)
+{
+	struct xone_dongle_event *evt;
+
+	if (!wcid || wcid > XONE_DONGLE_MAX_CLIENTS)
+		return 0;
+
+	evt = xone_dongle_alloc_event(dongle, XONE_DONGLE_EVT_REMOVE_CLIENT);
+	if (!evt)
+		return -ENOMEM;
+
+	evt->wcid = wcid;
+
+	queue_work(dongle->event_wq, &evt->work);
+
+	return 0;
+}
+
+static int xone_dongle_handle_client_command(struct xone_dongle *dongle,
+					     struct sk_buff *skb,
+					     u8 wcid, u8 *addr)
+{
+	struct xone_dongle_event *evt;
+	enum xone_dongle_event_type evt_type;
+
+	if (skb->len < 2 || skb->data[0] != XONE_MT_WLAN_RESERVED)
+		return -EINVAL;
+
+	switch (skb->data[1]) {
+	case XONE_MT_CLIENT_PAIR_REQ:
+		evt_type = XONE_DONGLE_EVT_PAIR_CLIENT;
+		break;
+	case XONE_MT_CLIENT_ENABLE_ENCRYPTION:
+		if (!wcid || wcid > XONE_DONGLE_MAX_CLIENTS)
+			return -EINVAL;
+
+		evt_type = XONE_DONGLE_EVT_ENABLE_ENCRYPTION;
+		break;
+	default:
+		return 0;
+	}
+
+	evt = xone_dongle_alloc_event(dongle, evt_type);
+	if (!evt)
+		return -ENOMEM;
+
+	evt->wcid = wcid;
+	memcpy(evt->address, addr, ETH_ALEN);
+
+	queue_work(dongle->event_wq, &evt->work);
+
+	return 0;
+}
+
+static int xone_dongle_handle_button(struct xone_dongle *dongle)
+{
+	struct xone_dongle_event *evt;
+
+	evt = xone_dongle_alloc_event(dongle, XONE_DONGLE_EVT_ENABLE_PAIRING);
+	if (!evt)
+		return -ENOMEM;
+
+	queue_work(dongle->event_wq, &evt->work);
+
+	return 0;
+}
+
+static int xone_dongle_handle_loss(struct xone_dongle *dongle,
+				   struct sk_buff *skb)
+{
+	u8 wcid;
+
+	if (skb->len < sizeof(wcid))
+		return -EINVAL;
+
+	wcid = skb->data[0];
+	if (!wcid || wcid > XONE_DONGLE_MAX_CLIENTS)
+		return 0;
+
+	dev_dbg(dongle->mt.dev, "%s: wcid=%d\n", __func__, wcid);
+
+	return xone_dongle_handle_disassociation(dongle, wcid);
+}
+
+static int xone_dongle_process_frame(struct xone_dongle *dongle,
+				     struct sk_buff *skb,
+				     unsigned int hdr_len, u8 wcid)
+{
+	struct ieee80211_hdr_3addr *hdr =
+		(struct ieee80211_hdr_3addr *)skb->data;
+	u16 type;
+
+	/* ignore invalid frames */
+	if (skb->len < hdr_len || hdr_len < sizeof(*hdr))
+		return 0;
+
+	skb_pull(skb, hdr_len);
+	type = le16_to_cpu(hdr->frame_control);
+
+	switch (type & (IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) {
+	case IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA:
+		return xone_dongle_handle_qos_data(dongle, skb, wcid);
+	case IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ASSOC_REQ:
+		return xone_dongle_handle_association(dongle, hdr->addr2);
+	case IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_DISASSOC:
+		return xone_dongle_handle_disassociation(dongle, wcid);
+	case IEEE80211_FTYPE_MGMT | XONE_MT_WLAN_RESERVED:
+		return xone_dongle_handle_client_command(dongle, skb, wcid,
+							 hdr->addr2);
+	}
+
+	return 0;
+}
+
+static int xone_dongle_process_wlan(struct xone_dongle *dongle,
+				    struct sk_buff *skb)
+{
+	struct mt76_rxwi *rxwi = (struct mt76_rxwi *)skb->data;
+	unsigned int hdr_len;
+	u32 ctl;
+
+	if (skb->len < sizeof(*rxwi))
+		return -EINVAL;
+
+	skb_pull(skb, sizeof(*rxwi));
+	hdr_len = ieee80211_get_hdrlen_from_skb(skb);
+
+	/* 2 bytes of padding after 802.11 header */
+	if (rxwi->rxinfo & cpu_to_le32(MT_RXINFO_L2PAD)) {
+		if (skb->len < hdr_len + 2)
+			return -EINVAL;
+
+		memmove(skb->data + 2, skb->data, hdr_len);
+		skb_pull(skb, 2);
+	}
+
+	ctl = le32_to_cpu(rxwi->ctl);
+	skb_trim(skb, FIELD_GET(MT_RXWI_CTL_MPDU_LEN, ctl));
+
+	return xone_dongle_process_frame(dongle, skb, hdr_len,
+					 FIELD_GET(MT_RXWI_CTL_WCID, ctl));
+}
+
+static int xone_dongle_process_message(struct xone_dongle *dongle,
+				       struct sk_buff *skb)
+{
+	enum mt76_dma_msg_port port;
+	u32 info;
+
+	/* command header + trailer */
+	if (skb->len < MT_CMD_HDR_LEN * 2)
+		return -EINVAL;
+
+	info = get_unaligned_le32(skb->data);
+	port = FIELD_GET(MT_RX_FCE_INFO_D_PORT, info);
+
+	/* ignore command reponses */
+	if (FIELD_GET(MT_RX_FCE_INFO_CMD_SEQ, info) == 0x01)
+		return 0;
+
+	/* remove header + trailer */
+	skb_pull(skb, MT_CMD_HDR_LEN);
+	skb_trim(skb, skb->len - MT_CMD_HDR_LEN);
+
+	if (port == MT_WLAN_PORT)
+		return xone_dongle_process_wlan(dongle, skb);
+
+	if (port != MT_CPU_RX_PORT)
+		return 0;
+
+	switch (FIELD_GET(MT_RX_FCE_INFO_EVT_TYPE, info)) {
+	case XONE_MT_EVT_BUTTON:
+		return xone_dongle_handle_button(dongle);
+	case XONE_MT_EVT_PACKET_RX:
+		return xone_dongle_process_wlan(dongle, skb);
+	case XONE_MT_EVT_CLIENT_LOST:
+		return xone_dongle_handle_loss(dongle, skb);
+	}
+
+	return 0;
+}
+
+static int xone_dongle_process_buffer(struct xone_dongle *dongle,
+				      void *data, int len)
+{
+	struct sk_buff *skb;
+	int err;
+
+	if (!len)
+		return 0;
+
+	skb = dev_alloc_skb(len);
+	if (!skb)
+		return -ENOMEM;
+
+	skb_put_data(skb, data, len);
+
+	err = xone_dongle_process_message(dongle, skb);
+	if (err) {
+		dev_err(dongle->mt.dev, "%s: process failed: %d\n",
+			__func__, err);
+		print_hex_dump_debug("xone-dongle packet: ", DUMP_PREFIX_NONE,
+				     16, 1, data, len, false);
+	}
+
+	dev_kfree_skb(skb);
+
+	return err;
+}
+
+static void xone_dongle_complete_in(struct urb *urb)
+{
+	struct xone_dongle *dongle = urb->context;
+	int err;
+
+	switch (urb->status) {
+	case 0:
+		break;
+	case -ENOENT:
+	case -ECONNRESET:
+	case -ESHUTDOWN:
+		usb_anchor_urb(urb, &dongle->urbs_in_idle);
+		return;
+	default:
+		goto resubmit;
+	}
+
+	err = xone_dongle_process_buffer(dongle, urb->transfer_buffer,
+					 urb->actual_length);
+	if (err)
+		dev_err(dongle->mt.dev, "%s: process failed: %d\n",
+			__func__, err);
+
+resubmit:
+	/* can fail during USB device removal */
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		dev_dbg(dongle->mt.dev, "%s: submit failed: %d\n",
+			__func__, err);
+		usb_anchor_urb(urb, &dongle->urbs_in_idle);
+	} else {
+		usb_anchor_urb(urb, &dongle->urbs_in_busy);
+	}
+}
+
+static void xone_dongle_complete_out(struct urb *urb)
+{
+	struct sk_buff *skb = urb->context;
+	struct xone_dongle_skb_cb *cb = (struct xone_dongle_skb_cb *)skb->cb;
+
+	usb_anchor_urb(urb, &cb->dongle->urbs_out_idle);
+	dev_consume_skb_any(skb);
+}
+
+static int xone_dongle_init_urbs_in(struct xone_dongle *dongle,
+				    int ep, int buf_len)
+{
+	struct xone_mt76 *mt = &dongle->mt;
+	struct urb *urb;
+	void *buf;
+	int i, err;
+
+	for (i = 0; i < XONE_DONGLE_NUM_IN_URBS; i++) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+
+		usb_anchor_urb(urb, &dongle->urbs_in_busy);
+		usb_free_urb(urb);
+
+		buf = usb_alloc_coherent(mt->udev, buf_len,
+					 GFP_KERNEL, &urb->transfer_dma);
+		if (!buf)
+			return -ENOMEM;
+
+		usb_fill_bulk_urb(urb, mt->udev,
+				  usb_rcvbulkpipe(mt->udev, ep), buf, buf_len,
+				  xone_dongle_complete_in, dongle);
+		urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+		err = usb_submit_urb(urb, GFP_KERNEL);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static int xone_dongle_init_urbs_out(struct xone_dongle *dongle)
+{
+	struct xone_mt76 *mt = &dongle->mt;
+	struct urb *urb;
+	int i;
+
+	for (i = 0; i < XONE_DONGLE_NUM_OUT_URBS; i++) {
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb)
+			return -ENOMEM;
+
+		usb_fill_bulk_urb(urb, mt->udev,
+				  usb_sndbulkpipe(mt->udev, XONE_MT_EP_OUT),
+				  NULL, 0, xone_dongle_complete_out, NULL);
+		usb_anchor_urb(urb, &dongle->urbs_out_idle);
+		usb_free_urb(urb);
+	}
+
+	return 0;
+}
+
+static int xone_dongle_fw_requester(const struct firmware **fw,
+				    struct xone_dongle *dongle,
+				    const char *fwname)
+{
+	struct device *dev = dongle->mt.dev;
+	int err;
+
+	dev_dbg(dev, "%s: trying to load firmware %s\n", __func__, fwname);
+	for (int i = 0; i < XONE_DONGLE_FW_REQ_RETRIES; ++i) {
+		if (dongle->fw_state == XONE_DONGLE_FW_STATE_STOP_LOADING) {
+			pr_debug("%s: Stopping firmware load on demand", __func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: attempt: %d\n", __func__, i + 1);
+		err = request_firmware(fw, fwname, dev);
+		if (!err)
+			return 0;
+
+		msleep(XONE_DONGLE_FW_REQ_TIMEOUT_MS);
+	}
+
+	return err;
+}
+
+static void xone_dongle_fw_load(struct work_struct *work)
+{
+	struct xone_dongle *dongle =
+		container_of(work, struct xone_dongle, load_fw_work);
+
+	struct xone_mt76 *mt = &dongle->mt;
+	const struct firmware *fw;
+	char fwname[25];
+	int err;
+
+	switch (dongle->product) {
+	case XONE_DONGLE_KNOCKOFF_PRODUCT1:
+		snprintf(fwname, 25, "xow_dongle_%04x_%04x.bin", dongle->vendor,
+			 dongle->product);
+		break;
+
+	case XONE_DONGLE_OFFICIAL_PRODUCT:
+	default:
+		snprintf(fwname, 15, "xow_dongle.bin");
+	}
+
+	err = xone_dongle_fw_requester(&fw, dongle, fwname);
+	if (dongle->fw_state == XONE_DONGLE_FW_STATE_STOP_LOADING) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		return;
+	}
+
+	if (err) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		dev_err(mt->dev, "%s: request firmware failed: %d\n", __func__,
+			err);
+		return;
+	}
+	dev_dbg(mt->dev, "%s: firmware requested successfully\n", __func__);
+
+
+	err = xone_mt76_load_firmware(mt, fw);
+	release_firmware(fw);
+	if (err) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		dev_err(mt->dev, "%s: load firmware failed: %d\n",
+			__func__, err);
+		return;
+	}
+
+	err = xone_dongle_init_urbs_out(dongle);
+	if (err) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		return;
+	}
+
+	err = xone_dongle_init_urbs_in(dongle, XONE_MT_EP_IN_CMD,
+				       XONE_DONGLE_LEN_CMD_PKT);
+	if (err) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		return;
+	}
+
+	err = xone_dongle_init_urbs_in(dongle, XONE_MT_EP_IN_WLAN,
+				       XONE_DONGLE_LEN_WLAN_PKT);
+	if (err) {
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		return;
+	}
+
+	err = xone_mt76_init_radio(mt);
+	if (err){
+		dongle->fw_state = XONE_DONGLE_FW_STATE_ERROR;
+		dev_err(mt->dev, "%s: init radio failed: %d\n", __func__, err);
+		return;
+	}
+
+	dongle->fw_state = XONE_DONGLE_FW_STATE_READY;
+
+	device_wakeup_enable(&dongle->mt.udev->dev);
+	pm_runtime_set_autosuspend_delay(&dongle->mt.udev->dev,
+					 XONE_DONGLE_SUSPEND_DELAY);
+	usb_enable_autosuspend(dongle->mt.udev);
+}
+
+static int xone_dongle_init(struct xone_dongle *dongle)
+{
+	init_usb_anchor(&dongle->urbs_out_idle);
+	init_usb_anchor(&dongle->urbs_out_busy);
+	init_usb_anchor(&dongle->urbs_in_idle);
+	init_usb_anchor(&dongle->urbs_in_busy);
+
+	dongle->fw_state = XONE_DONGLE_FW_STATE_PENDING;
+	schedule_work(&dongle->load_fw_work);
+	return 0;
+}
+
+static int xone_dongle_power_off_clients(struct xone_dongle *dongle)
+{
+	struct xone_dongle_client *client;
+	int i;
+	int err = 0;
+	unsigned long flags;
+
+	if (dongle->fw_state != XONE_DONGLE_FW_STATE_READY)
+		return 0;
+
+	spin_lock_irqsave(&dongle->clients_lock, flags);
+
+	for (i = 0; i < XONE_DONGLE_MAX_CLIENTS; i++) {
+		client = dongle->clients[i];
+		if (!client)
+			continue;
+
+		err = gip_power_off_adapter(client->adapter);
+		if (err)
+			break;
+	}
+
+	spin_unlock_irqrestore(&dongle->clients_lock, flags);
+
+	if (err)
+		return err;
+
+	/* can time out if new client connects */
+	if (!wait_event_timeout(dongle->disconnect_wait,
+				!atomic_read(&dongle->client_count),
+				XONE_DONGLE_PWR_OFF_TIMEOUT))
+		return -ETIMEDOUT;
+
+	return xone_dongle_toggle_pairing(dongle, false);
+}
+
+static void xone_dongle_destroy(struct xone_dongle *dongle)
+{
+	struct xone_dongle_client *client;
+	struct urb *urb;
+	int i;
+
+	usb_kill_anchored_urbs(&dongle->urbs_in_busy);
+	destroy_workqueue(dongle->event_wq);
+	cancel_delayed_work(&dongle->pairing_work);
+
+	if (dongle->fw_state < XONE_DONGLE_FW_STATE_ERROR) {
+		pr_debug("%s: Firmware not loaded, stopping work", __func__);
+		dongle->fw_state = XONE_DONGLE_FW_STATE_STOP_LOADING;
+		pr_debug("%s: Waiting for fw load work to finish", __func__);
+
+		while (dongle->fw_state == XONE_DONGLE_FW_STATE_STOP_LOADING)
+			msleep(500);
+
+		pr_debug("%s: FW loading cancelled", __func__);
+	}
+
+	for (i = 0; i < XONE_DONGLE_MAX_CLIENTS; i++) {
+		client = dongle->clients[i];
+		if (!client)
+			continue;
+
+		gip_destroy_adapter(client->adapter);
+		kfree(client);
+		dongle->clients[i] = NULL;
+	}
+
+	usb_kill_anchored_urbs(&dongle->urbs_out_busy);
+
+	while ((urb = usb_get_from_anchor(&dongle->urbs_out_idle)))
+		usb_free_urb(urb);
+
+	while ((urb = usb_get_from_anchor(&dongle->urbs_in_idle))) {
+		usb_free_coherent(urb->dev, urb->transfer_buffer_length,
+				  urb->transfer_buffer, urb->transfer_dma);
+		usb_free_urb(urb);
+	}
+
+	mutex_destroy(&dongle->pairing_lock);
+}
+
+static int xone_dongle_probe(struct usb_interface *intf,
+			     const struct usb_device_id *id)
+{
+	struct xone_dongle *dongle;
+	int err;
+
+	dongle = devm_kzalloc(&intf->dev, sizeof(*dongle), GFP_KERNEL);
+	if (!dongle)
+		return -ENOMEM;
+
+	dongle->mt.dev = &intf->dev;
+	dongle->mt.udev = interface_to_usbdev(intf);
+
+	dongle->vendor = id->idVendor;
+	dongle->product = id->idProduct;
+
+	dongle->event_wq = alloc_ordered_workqueue("xone_dongle", 0);
+	if (!dongle->event_wq)
+		return -ENOMEM;
+
+	mutex_init(&dongle->pairing_lock);
+	INIT_DELAYED_WORK(&dongle->pairing_work, xone_dongle_pairing_timeout);
+	INIT_WORK(&dongle->load_fw_work, xone_dongle_fw_load);
+	spin_lock_init(&dongle->clients_lock);
+	init_waitqueue_head(&dongle->disconnect_wait);
+
+	usb_reset_device(dongle->mt.udev);
+	err = xone_dongle_init(dongle);
+	if (err) {
+		xone_dongle_destroy(dongle);
+		return err;
+	}
+
+	usb_set_intfdata(intf, dongle);
+
+	err = device_add_groups(&intf->dev, xone_dongle_groups);
+	if (err) {
+		xone_dongle_destroy(dongle);
+		return err;
+	}
+
+	/* enable USB remote wakeup and autosuspend */
+	intf->needs_remote_wakeup = true;
+	return 0;
+}
+
+static void xone_dongle_disconnect(struct usb_interface *intf)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	int err;
+
+	device_remove_groups(&intf->dev, xone_dongle_groups);
+
+	/* can fail during USB device removal */
+	err = xone_dongle_power_off_clients(dongle);
+	if (err)
+		dev_dbg(dongle->mt.dev, "%s: power off failed: %d\n",
+			__func__, err);
+
+	xone_dongle_destroy(dongle);
+	usb_set_intfdata(intf, NULL);
+}
+
+static int xone_dongle_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	int err;
+
+	if (dongle->fw_state != XONE_DONGLE_FW_STATE_READY){
+		pr_debug("%s: Skipping radio suspend", __func__);
+		return 0;
+	}
+
+	err = xone_dongle_power_off_clients(dongle);
+	if (err)
+		dev_err(dongle->mt.dev, "%s: power off failed: %d\n",
+			__func__, err);
+
+	usb_kill_anchored_urbs(&dongle->urbs_in_busy);
+	usb_kill_anchored_urbs(&dongle->urbs_out_busy);
+	cancel_delayed_work(&dongle->pairing_work);
+
+	return xone_mt76_suspend_radio(&dongle->mt);
+}
+
+static int xone_dongle_resume(struct usb_interface *intf)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	struct urb *urb;
+	int err;
+
+	if (dongle->fw_state != XONE_DONGLE_FW_STATE_READY) {
+		pr_debug("%s: Skipping radio resume", __func__);
+		return 0;
+	}
+
+	while ((urb = usb_get_from_anchor(&dongle->urbs_in_idle))) {
+		usb_anchor_urb(urb, &dongle->urbs_in_busy);
+		usb_free_urb(urb);
+
+		err = usb_submit_urb(urb, GFP_KERNEL);
+		if (err)
+			return err;
+	}
+	return xone_mt76_resume_radio(&dongle->mt);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static void xone_dongle_shutdown(struct device *dev)
+{
+	struct usb_interface *intf = to_usb_interface(dev);
+#else
+static void xone_dongle_shutdown(struct usb_interface *intf)
+{
+#endif
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	int err;
+
+	if (dongle->fw_state != XONE_DONGLE_FW_STATE_READY)
+		dongle->fw_state = XONE_DONGLE_FW_STATE_STOP_LOADING;
+
+	if (system_state == SYSTEM_RESTART)
+		return;
+
+	err = xone_dongle_power_off_clients(dongle);
+	if (err)
+		dev_err(dongle->mt.dev, "%s: power off failed: %d\n",
+			__func__, err);
+}
+
+static int xone_dongle_pre_reset(struct usb_interface *intf)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	struct urb *urb;
+
+	pr_debug("%s", __func__);
+
+	/* For reset during probe */
+	if (!dongle)
+		return 0;
+
+	if (dongle->fw_state != XONE_DONGLE_FW_STATE_READY)
+		dongle->fw_state = XONE_DONGLE_FW_STATE_STOP_LOADING;
+
+	cancel_delayed_work(&dongle->pairing_work);
+	usb_kill_anchored_urbs(&dongle->urbs_in_busy);
+	usb_kill_anchored_urbs(&dongle->urbs_out_busy);
+
+	while ((urb = usb_get_from_anchor(&dongle->urbs_out_idle)))
+		usb_free_urb(urb);
+
+	while ((urb = usb_get_from_anchor(&dongle->urbs_in_idle))) {
+		usb_free_coherent(urb->dev, urb->transfer_buffer_length,
+				  urb->transfer_buffer, urb->transfer_dma);
+		usb_free_urb(urb);
+	}
+
+	return 0;
+}
+
+static int xone_dongle_post_reset(struct usb_interface *intf)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+
+	pr_debug("%s", __func__);
+
+	/* For reset during probe */
+	if (!dongle)
+		return 0;
+
+	pr_debug("%s: Re-initializing dongle after reset", __func__);
+	return xone_dongle_init(dongle);
+}
+
+static int xone_dongle_reset_resume(struct usb_interface *intf)
+{
+	struct xone_dongle *dongle = usb_get_intfdata(intf);
+	int err;
+
+	pr_debug("%s", __func__);
+
+	err = usb_reset_device(dongle->mt.udev);
+	if (err == -EINPROGRESS) {
+		pr_debug("%s: Reset already in progress", __func__);
+		return 0;
+	}
+
+	return err;
+}
+
+static const struct usb_device_id xone_dongle_id_table[] = {
+	{ USB_DEVICE(0x045e, 0x02e6) }, /* old dongle */
+	{ USB_DEVICE(0x045e, 0x02fe) }, /* new dongle */
+	{ USB_DEVICE(0x045e, 0x02f9) }, /* built-in dongle (ASUS, Lenovo) */
+	{ USB_DEVICE(0x045e, 0x091e) }, /* built-in dongle (Surface Book 2) */
+	{ },
+};
+
+static struct usb_driver xone_dongle_driver = {
+	.name = "xone-dongle",
+	.probe = xone_dongle_probe,
+	.disconnect = xone_dongle_disconnect,
+	.id_table = xone_dongle_id_table,
+
+#ifdef CONFIG_PM
+	.suspend = xone_dongle_suspend,
+	.resume = xone_dongle_resume,
+	.reset_resume = xone_dongle_reset_resume,
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 8, 0)
+	.drvwrap.driver.shutdown = xone_dongle_shutdown,
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	.driver.shutdown = xone_dongle_shutdown,
+#else
+	.shutdown = xone_dongle_shutdown,
+#endif
+	.pre_reset = xone_dongle_pre_reset,
+	.post_reset = xone_dongle_post_reset,
+	.supports_autosuspend = true,
+	.disable_hub_initiated_lpm = true,
+	.soft_unbind = true,
+};
+
+module_usb_driver(xone_dongle_driver);
+
+MODULE_DEVICE_TABLE(usb, xone_dongle_id_table);
+MODULE_AUTHOR("Severin von Wnuck-Lipinski <severinvonw@outlook.de>");
+MODULE_DESCRIPTION("xone dongle driver");
+MODULE_VERSION("#VERSION#");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/xonedo/transport/mt76.c b/drivers/custom/xonedo/transport/mt76.c
new file mode 100644
index 000000000000..11403efd0a23
--- /dev/null
+++ b/drivers/custom/xonedo/transport/mt76.c
@@ -0,0 +1,1266 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#include <linux/slab.h>
+#include <linux/bitfield.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/firmware.h>
+#include <linux/ieee80211.h>
+
+#include "mt76.h"
+
+/* bulk transfer timeout in ms */
+#define XONE_MT_USB_TIMEOUT 1000
+
+#define XONE_MT_POLL_RETRIES 50
+
+#define XONE_MT_RF_PATCH 0x0130
+#define XONE_MT_FW_LOAD_IVB 0x12
+#define XONE_MT_FW_ILM_OFFSET 0x080000
+#define XONE_MT_FW_DLM_OFFSET 0x110800
+#define XONE_MT_FW_CHUNK_SIZE 0x3800
+
+/* wireless channel bands */
+#define XONE_MT_CH_2G_LOW 0x01
+#define XONE_MT_CH_2G_MID 0x02
+#define XONE_MT_CH_2G_HIGH 0x03
+#define XONE_MT_CH_5G_LOW 0x01
+#define XONE_MT_CH_5G_HIGH 0x02
+
+#define XONE_MT_WCID_KEY_LEN 16
+
+/* commands specific to the dongle's firmware */
+enum xone_mt76_ms_command {
+	XONE_MT_SET_MAC_ADDRESS = 0x00,
+	XONE_MT_ADD_CLIENT = 0x01,
+	XONE_MT_REMOVE_CLIENT = 0x02,
+	XONE_MT_SET_IDLE_TIME = 0x05,
+	XONE_MT_SET_CHAN_CANDIDATES = 0x07,
+};
+
+enum xone_mt76_wow_feature {
+	XONE_MT_WOW_ENABLE = 0x01,
+	XONE_MT_WOW_TRAFFIC = 0x03,
+};
+
+enum xone_mt76_wow_traffic {
+	XONE_MT_WOW_TO_FIRMWARE = 0x00,
+	XONE_MT_WOW_TO_HOST = 0x01,
+};
+
+struct xone_mt76_msg_load_cr {
+	u8 mode;
+	u8 temperature;
+	u8 channel;
+	u8 padding;
+} __packed;
+
+struct xone_mt76_msg_switch_channel {
+	u8 channel;
+	u8 padding1[3];
+	__le16 tx_rx_setting;
+	u8 padding2[10];
+	u8 bandwidth;
+	u8 tx_power;
+	u8 scan;
+	u8 unknown;
+} __packed;
+
+static char override_mac[ETH_ALEN] = { 0 };
+module_param_array(override_mac, byte, NULL, 0444);
+MODULE_PARM_DESC(override_mac, "Override MAC address (6 bytes), helps deconflict counterfeit adapters");
+
+static u32 xone_mt76_read_register(struct xone_mt76 *mt, u32 addr)
+{
+	u8 req = MT_VEND_MULTI_READ;
+	int ret;
+
+	if (addr & MT_VEND_TYPE_CFG) {
+		req = MT_VEND_READ_CFG;
+		addr &= ~MT_VEND_TYPE_CFG;
+	}
+
+	ret = usb_control_msg(mt->udev, usb_rcvctrlpipe(mt->udev, 0), req,
+			      USB_DIR_IN | USB_TYPE_VENDOR, addr >> 16, addr,
+			      &mt->control_data, sizeof(mt->control_data),
+			      XONE_MT_USB_TIMEOUT);
+	if (ret != sizeof(mt->control_data))
+		ret = -EREMOTEIO;
+
+	if (ret < 0) {
+		dev_err(mt->dev, "%s: control message failed: %d\n",
+			__func__, ret);
+		return 0;
+	}
+
+	return le32_to_cpu(mt->control_data);
+}
+
+static void xone_mt76_write_register(struct xone_mt76 *mt, u32 addr, u32 val)
+{
+	u8 req = MT_VEND_MULTI_WRITE;
+	int ret;
+
+	if (addr & MT_VEND_TYPE_CFG) {
+		req = MT_VEND_WRITE_CFG;
+		addr &= ~MT_VEND_TYPE_CFG;
+	}
+
+	mt->control_data = cpu_to_le32(val);
+
+	ret = usb_control_msg(mt->udev, usb_sndctrlpipe(mt->udev, 0), req,
+			      USB_DIR_OUT | USB_TYPE_VENDOR, addr >> 16, addr,
+			      &mt->control_data, sizeof(mt->control_data),
+			      XONE_MT_USB_TIMEOUT);
+	if (ret != sizeof(mt->control_data))
+		ret = -EREMOTEIO;
+
+	if (ret < 0)
+		dev_err(mt->dev, "%s: control message failed: %d\n",
+			__func__, ret);
+}
+
+static int xone_mt76_load_ivb(struct xone_mt76 *mt)
+{
+	/* load interrupt vector block */
+	return usb_control_msg(mt->udev, usb_sndctrlpipe(mt->udev, 0),
+			       MT_VEND_DEV_MODE, USB_DIR_OUT | USB_TYPE_VENDOR,
+			       XONE_MT_FW_LOAD_IVB, 0, NULL, 0,
+			       XONE_MT_USB_TIMEOUT);
+}
+
+static bool xone_mt76_poll(struct xone_mt76 *mt, u32 offset, u32 mask, u32 val)
+{
+	int i;
+	u32 reg;
+
+	for (i = 0; i < XONE_MT_POLL_RETRIES; i++) {
+		reg = xone_mt76_read_register(mt, offset);
+		if ((reg & mask) == val)
+			return true;
+
+		usleep_range(10000, 20000);
+	}
+
+	return false;
+}
+
+static int xone_mt76_read_efuse(struct xone_mt76 *mt, u16 addr,
+				void *data, int len)
+{
+	u32 ctrl, offset, val;
+	int i, remaining;
+
+	ctrl = xone_mt76_read_register(mt, MT_EFUSE_CTRL);
+	ctrl &= ~(MT_EFUSE_CTRL_AIN | MT_EFUSE_CTRL_MODE);
+	ctrl |= MT_EFUSE_CTRL_KICK;
+	ctrl |= FIELD_PREP(MT_EFUSE_CTRL_AIN, addr & ~0x0f);
+	ctrl |= FIELD_PREP(MT_EFUSE_CTRL_MODE, MT_EE_READ);
+	xone_mt76_write_register(mt, MT_EFUSE_CTRL, ctrl);
+
+	if (!xone_mt76_poll(mt, MT_EFUSE_CTRL, MT_EFUSE_CTRL_KICK, 0))
+		return -ETIMEDOUT;
+
+	for (i = 0; i < len; i += sizeof(u32)) {
+		/* block data offset (multiple of 32 bits) */
+		offset = (addr & GENMASK(3, 2)) + i;
+		val = xone_mt76_read_register(mt, MT_EFUSE_DATA_BASE + offset);
+		remaining = min_t(int, len - i, sizeof(u32));
+
+		memcpy(data + i, &val, remaining);
+	}
+
+	return 0;
+}
+
+struct sk_buff *xone_mt76_alloc_message(int len, gfp_t gfp)
+{
+	struct sk_buff *skb;
+
+	/* up to 4 bytes of padding */
+	skb = alloc_skb(MT_CMD_HDR_LEN + len + sizeof(u32) + MT_CMD_HDR_LEN,
+			gfp);
+	if (!skb)
+		return NULL;
+
+	skb_reserve(skb, MT_CMD_HDR_LEN);
+
+	return skb;
+}
+
+static void xone_mt76_prep_message(struct sk_buff *skb, u32 info)
+{
+	int len, pad;
+
+	/* padding and trailer */
+	len = round_up(skb->len, sizeof(u32));
+	pad = len - skb->len + MT_CMD_HDR_LEN;
+
+	put_unaligned_le32(info | FIELD_PREP(MT_MCU_MSG_LEN, len),
+			   skb_push(skb, MT_CMD_HDR_LEN));
+	memset(skb_put(skb, pad), 0, pad);
+}
+
+void xone_mt76_prep_command(struct sk_buff *skb, enum mt76_mcu_cmd cmd)
+{
+	xone_mt76_prep_message(skb, MT_MCU_MSG_TYPE_CMD |
+			       FIELD_PREP(MT_MCU_MSG_PORT, MT_CPU_TX_PORT) |
+			       FIELD_PREP(MT_MCU_MSG_CMD_TYPE, cmd));
+}
+
+static int xone_mt76_send_command(struct xone_mt76 *mt, struct sk_buff *skb,
+				  enum mt76_mcu_cmd cmd)
+{
+	int err;
+
+	xone_mt76_prep_command(skb, cmd);
+
+	err = usb_bulk_msg(mt->udev, usb_sndbulkpipe(mt->udev, XONE_MT_EP_OUT),
+			   skb->data, skb->len, NULL, XONE_MT_USB_TIMEOUT);
+	consume_skb(skb);
+
+	return err;
+}
+
+static int xone_mt76_send_wlan(struct xone_mt76 *mt, struct sk_buff *skb)
+{
+	struct mt76_txwi txwi = {};
+	int err;
+
+	/* wait for acknowledgment */
+	/* ignore wireless client identifier (WCID) */
+	txwi.flags = cpu_to_le16(FIELD_PREP(MT_TXWI_FLAGS_MPDU_DENSITY,
+					    IEEE80211_HT_MPDU_DENSITY_4));
+	txwi.rate = cpu_to_le16(FIELD_PREP(MT_RXWI_RATE_PHY, MT_PHY_TYPE_OFDM));
+	txwi.ack_ctl = MT_TXWI_ACK_CTL_REQ;
+	txwi.wcid = 0xff;
+	txwi.len_ctl = cpu_to_le16(skb->len);
+
+	memcpy(skb_push(skb, sizeof(txwi)), &txwi, sizeof(txwi));
+
+	/* enhanced distributed channel access (EDCA) */
+	/* wireless information valid (WIV) */
+	xone_mt76_prep_message(skb,
+			       FIELD_PREP(MT_TXD_INFO_DPORT, MT_WLAN_PORT) |
+			       FIELD_PREP(MT_TXD_INFO_QSEL, MT_QSEL_EDCA) |
+			       MT_TXD_INFO_WIV |
+			       MT_TXD_INFO_80211);
+
+	err = usb_bulk_msg(mt->udev, usb_sndbulkpipe(mt->udev, XONE_MT_EP_OUT),
+			   skb->data, skb->len, NULL, XONE_MT_USB_TIMEOUT);
+	consume_skb(skb);
+
+	return err;
+}
+
+static int xone_mt76_select_function(struct xone_mt76 *mt,
+				     enum mt76_mcu_function func, u32 val)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32) * 2, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(func, skb_put(skb, sizeof(u32)));
+	put_unaligned_le32(val, skb_put(skb, sizeof(u32)));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_FUN_SET_OP);
+}
+
+static int xone_mt76_load_cr(struct xone_mt76 *mt, enum mt76_mcu_cr_mode mode)
+{
+	struct sk_buff *skb;
+	struct xone_mt76_msg_load_cr msg = {};
+
+	skb = xone_mt76_alloc_message(sizeof(msg), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	msg.mode = mode;
+	skb_put_data(skb, &msg, sizeof(msg));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_LOAD_CR);
+}
+
+static int xone_mt76_send_ms_command(struct xone_mt76 *mt,
+				     enum xone_mt76_ms_command cmd,
+				     void *data, int len)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32) + len, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(cmd, skb_put(skb, sizeof(u32)));
+	skb_put_data(skb, data, len);
+
+	/* send command to Microsoft's proprietary firmware */
+	return xone_mt76_send_command(mt, skb, MT_CMD_INIT_GAIN_OP);
+}
+
+static int xone_mt76_write_burst(struct xone_mt76 *mt, u32 idx,
+				 void *data, int len)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(idx) + len, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* register offset in memory */
+	put_unaligned_le32(idx + MT_MCU_MEMMAP_WLAN, skb_put(skb, sizeof(idx)));
+	skb_put_data(skb, data, len);
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_BURST_WRITE);
+}
+
+int xone_mt76_set_led_mode(struct xone_mt76 *mt, enum xone_mt76_led_mode mode)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(mode, skb_put(skb, sizeof(u32)));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_LED_MODE_OP);
+}
+
+static int xone_mt76_set_power_mode(struct xone_mt76 *mt,
+				    enum mt76_mcu_power_mode mode)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(mode, skb_put(skb, sizeof(u32)));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_POWER_SAVING_OP);
+}
+
+static int xone_mt76_set_wow_enable(struct xone_mt76 *mt, bool enable)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32) + sizeof(u8) * 2, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(XONE_MT_WOW_ENABLE, skb_put(skb, sizeof(u32)));
+	skb_put_u8(skb, enable);
+	skb_put_u8(skb, mt->channel->index);
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_WOW_FEATURE);
+}
+
+static int xone_mt76_set_wow_traffic(struct xone_mt76 *mt,
+				     enum xone_mt76_wow_traffic traffic)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32) + sizeof(u8), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(XONE_MT_WOW_TRAFFIC, skb_put(skb, sizeof(u32)));
+	skb_put_u8(skb, traffic);
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_WOW_FEATURE);
+}
+
+static int xone_mt76_switch_channel(struct xone_mt76 *mt,
+				    struct xone_mt76_channel *chan)
+{
+	struct sk_buff *skb;
+	struct xone_mt76_msg_switch_channel msg = {};
+
+	skb = xone_mt76_alloc_message(sizeof(msg), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* select TX and RX stream 1 */
+	/* enable or disable scanning (unknown purpose) */
+	msg.channel = chan->index;
+	msg.tx_rx_setting = cpu_to_le16(0x0101);
+	msg.bandwidth = chan->bandwidth;
+	msg.tx_power = chan->power;
+	msg.scan = chan->scan;
+	skb_put_data(skb, &msg, sizeof(msg));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_SWITCH_CHANNEL_OP);
+}
+
+static int xone_mt76_calibrate(struct xone_mt76 *mt,
+			       enum mt76_mcu_calibration calib, u32 val)
+{
+	struct sk_buff *skb;
+
+	skb = xone_mt76_alloc_message(sizeof(u32) * 2, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(calib, skb_put(skb, sizeof(u32)));
+	put_unaligned_le32(val, skb_put(skb, sizeof(u32)));
+
+	return xone_mt76_send_command(mt, skb, MT_CMD_CALIBRATION_OP);
+}
+
+static int xone_mt76_send_firmware_part(struct xone_mt76 *mt, u32 offset,
+					const u8 *data, u32 len)
+{
+	struct sk_buff *skb;
+	u32 pos, chunk_len, complete;
+	int err;
+
+	for (pos = 0; pos < len; pos += XONE_MT_FW_CHUNK_SIZE) {
+		chunk_len = min_t(u32, len - pos, XONE_MT_FW_CHUNK_SIZE);
+
+		skb = xone_mt76_alloc_message(chunk_len, GFP_KERNEL);
+		if (!skb)
+			return -ENOMEM;
+
+		skb_put_data(skb, data + pos, chunk_len);
+		chunk_len = roundup(chunk_len, sizeof(u32));
+
+		xone_mt76_write_register(mt, MT_FCE_DMA_ADDR | MT_VEND_TYPE_CFG,
+					 offset + pos);
+		xone_mt76_write_register(mt, MT_FCE_DMA_LEN | MT_VEND_TYPE_CFG,
+					 chunk_len << 16);
+
+		err = xone_mt76_send_command(mt, skb, 0);
+		if (err)
+			return err;
+
+		complete = 0xc0000000 | (chunk_len << 16);
+		if (!xone_mt76_poll(mt, MT_FCE_DMA_LEN | MT_VEND_TYPE_CFG,
+				    0xffffffff, complete))
+			return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int xone_mt76_send_firmware(struct xone_mt76 *mt,
+				   const struct firmware *fw)
+{
+	const struct mt76_fw_header *hdr;
+	u32 ilm_len, dlm_len;
+	int err;
+
+	if (fw->size < sizeof(*hdr))
+		return -EINVAL;
+
+	hdr = (const struct mt76_fw_header *)fw->data;
+	ilm_len = le32_to_cpu(hdr->ilm_len);
+	dlm_len = le32_to_cpu(hdr->dlm_len);
+
+	if (fw->size != sizeof(*hdr) + ilm_len + dlm_len)
+		return -EINVAL;
+
+	dev_dbg(mt->dev, "%s: build=%.16s\n", __func__, hdr->build_time);
+
+	/* configure DMA, enable FCE and packet DMA */
+	xone_mt76_write_register(mt, MT_USB_U3DMA_CFG | MT_VEND_TYPE_CFG,
+				 MT_USB_DMA_CFG_TX_BULK_EN |
+				 MT_USB_DMA_CFG_RX_BULK_EN);
+	xone_mt76_write_register(mt, MT_FCE_PSE_CTRL, 0x01);
+	xone_mt76_write_register(mt, MT_TX_CPU_FROM_FCE_BASE_PTR, 0x00400230);
+	xone_mt76_write_register(mt, MT_TX_CPU_FROM_FCE_MAX_COUNT, 0x01);
+	xone_mt76_write_register(mt, MT_TX_CPU_FROM_FCE_CPU_DESC_IDX, 0x01);
+	xone_mt76_write_register(mt, MT_FCE_PDMA_GLOBAL_CONF, 0x44);
+	xone_mt76_write_register(mt, MT_FCE_SKIP_FS, 0x03);
+
+	/* send instruction local memory */
+	err = xone_mt76_send_firmware_part(mt, XONE_MT_FW_ILM_OFFSET,
+					   fw->data + sizeof(*hdr), ilm_len);
+	if (err)
+		return err;
+
+	/* send data local memory */
+	return xone_mt76_send_firmware_part(mt, XONE_MT_FW_DLM_OFFSET,
+					    fw->data + sizeof(*hdr) + ilm_len,
+					    dlm_len);
+}
+
+static int xone_mt76_reset_firmware(struct xone_mt76 *mt)
+{
+	u32 val;
+	int err;
+
+	/* apply power-on RF patch */
+	val = xone_mt76_read_register(mt, XONE_MT_RF_PATCH | MT_VEND_TYPE_CFG);
+	xone_mt76_write_register(mt, XONE_MT_RF_PATCH | MT_VEND_TYPE_CFG,
+				 val & ~BIT(19));
+
+	err = xone_mt76_load_ivb(mt);
+	if (err)
+		return err;
+
+	/* wait for reset */
+	if (!xone_mt76_poll(mt, MT_FCE_DMA_ADDR | MT_VEND_TYPE_CFG,
+			    0x80000000, 0x80000000))
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+int xone_mt76_load_firmware(struct xone_mt76 *mt, const struct firmware *fw)
+{
+	int err;
+
+	if (xone_mt76_read_register(mt, MT_FCE_DMA_ADDR | MT_VEND_TYPE_CFG)) {
+		dev_dbg(mt->dev, "%s: resetting firmware...\n", __func__);
+		return xone_mt76_reset_firmware(mt);
+	}
+
+	err = xone_mt76_send_firmware(mt, fw);
+	if (err)
+		return err;
+
+	xone_mt76_write_register(mt, MT_FCE_DMA_ADDR | MT_VEND_TYPE_CFG, 0);
+
+	err = xone_mt76_load_ivb(mt);
+	if (err)
+		return err;
+
+	if (!xone_mt76_poll(mt, MT_FCE_DMA_ADDR | MT_VEND_TYPE_CFG, 0x01, 0x01))
+		err = -ETIMEDOUT;
+
+	return err;
+}
+
+static const struct xone_mt76_channel
+xone_mt76_channels[XONE_MT_NUM_CHANNELS] = {
+	{ 0x01, XONE_MT_CH_2G_LOW, MT_PHY_BW_20, 0, true, 0 },
+	{ 0x06, XONE_MT_CH_2G_MID, MT_PHY_BW_20, 0, true, 0 },
+	{ 0x0b, XONE_MT_CH_2G_HIGH, MT_PHY_BW_20, 0, true, 0 },
+	{ 0x24, XONE_MT_CH_5G_LOW, MT_PHY_BW_40, MT_CH_5G_UNII_1, true, 0 },
+	{ 0x28, XONE_MT_CH_5G_LOW, MT_PHY_BW_40, MT_CH_5G_UNII_1, false, 0 },
+	{ 0x2c, XONE_MT_CH_5G_HIGH, MT_PHY_BW_40, MT_CH_5G_UNII_1, true, 0 },
+	{ 0x30, XONE_MT_CH_5G_HIGH, MT_PHY_BW_40, MT_CH_5G_UNII_1, false, 0 },
+	{ 0x95, XONE_MT_CH_5G_LOW, MT_PHY_BW_80, MT_CH_5G_UNII_3, true, 0 },
+	{ 0x99, XONE_MT_CH_5G_LOW, MT_PHY_BW_80, MT_CH_5G_UNII_3, false, 0 },
+	{ 0x9d, XONE_MT_CH_5G_HIGH, MT_PHY_BW_80, MT_CH_5G_UNII_3, true, 0 },
+	{ 0xa1, XONE_MT_CH_5G_HIGH, MT_PHY_BW_80, MT_CH_5G_UNII_3, false, 0 },
+	{ 0xa5, XONE_MT_CH_5G_HIGH, MT_PHY_BW_80, MT_CH_5G_UNII_3, false, 0 },
+};
+
+static int xone_mt76_set_channel_candidates(struct xone_mt76 *mt)
+{
+	struct sk_buff *skb;
+	u8 best_chan = mt->channel->index;
+	u8 chan;
+	int i, err;
+
+	skb = alloc_skb(sizeof(u32) * 2 + sizeof(u32) * XONE_MT_NUM_CHANNELS,
+			GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	put_unaligned_le32(1, skb_put(skb, sizeof(u32)));
+	put_unaligned_le32(best_chan, skb_put(skb, sizeof(u32)));
+	put_unaligned_le32(XONE_MT_NUM_CHANNELS - 1, skb_put(skb, sizeof(u32)));
+
+	for (i = 0; i < XONE_MT_NUM_CHANNELS; i++) {
+		chan = mt->channels[i].index;
+		if (chan != best_chan)
+			put_unaligned_le32(chan, skb_put(skb, sizeof(u32)));
+	}
+
+	err = xone_mt76_send_ms_command(mt, XONE_MT_SET_CHAN_CANDIDATES,
+					skb->data, skb->len);
+	consume_skb(skb);
+
+	return err;
+}
+
+static int xone_mt76_get_channel_power(struct xone_mt76 *mt,
+				       struct xone_mt76_channel *chan)
+{
+	u16 addr;
+	u8 idx, target, offset;
+	u8 entry[8];
+	int err;
+
+	if (chan->bandwidth == MT_PHY_BW_20) {
+		addr = MT_EE_TX_POWER_0_START_2G;
+		idx = 4;
+	} else {
+		/* each group has its own power table */
+		addr = MT_EE_TX_POWER_0_START_5G +
+		       chan->group * MT_TX_POWER_GROUP_SIZE_5G;
+		idx = 5;
+	}
+
+	err = xone_mt76_read_efuse(mt, addr, entry, sizeof(entry));
+	if (err) {
+		dev_err(mt->dev, "%s: read EFUSE failed: %d\n", __func__, err);
+		return err;
+	}
+
+	target = entry[idx];
+	offset = entry[idx + chan->band];
+
+	/* increase or decrease power by offset (in 0.5 dB steps) */
+	if (offset & BIT(7))
+		chan->power = (offset & BIT(6)) ?
+			      target + (offset & GENMASK(5, 0)) :
+			      target - (offset & GENMASK(5, 0));
+	else
+		chan->power = target;
+
+	return 0;
+}
+
+static int xone_mt76_evaluate_channels(struct xone_mt76 *mt)
+{
+	struct xone_mt76_channel *chan;
+	int i, err, pow = 0;
+
+	mt->channel = NULL;
+
+	memcpy(mt->channels, xone_mt76_channels, sizeof(xone_mt76_channels));
+
+	for (i = 0; i < XONE_MT_NUM_CHANNELS; i++) {
+		chan = &mt->channels[i];
+
+		/* original driver increases power for channels 0x24 to 0x30 */
+		err = xone_mt76_get_channel_power(mt, chan);
+		if (err)
+			return err;
+
+		err = xone_mt76_switch_channel(mt, chan);
+		if (err)
+			return err;
+		
+		/* pick the highest power channel seen first */
+		/* the last channel might not be the best one */
+		if (chan->power > pow) {
+			mt->channel = chan;
+			pow = chan->power;
+		}
+
+		dev_dbg(mt->dev, "%s: channel=%u, power=%u\n", __func__,
+			chan->index, chan->power);
+	}
+
+	if (mt->channel == NULL)
+		mt->channel = chan;
+
+	return 0;
+}
+
+static int xone_mt76_init_channels(struct xone_mt76 *mt)
+{
+	int err;
+
+	/* enable promiscuous mode */
+	xone_mt76_write_register(mt, MT_RX_FILTR_CFG, 0x014f13);
+
+	err = xone_mt76_evaluate_channels(mt);
+	if (err)
+		return err;
+
+	/* disable promiscuous mode */
+	xone_mt76_write_register(mt, MT_RX_FILTR_CFG, 0x017f17);
+
+	dev_dbg(mt->dev, "%s: channel=%u\n", __func__, mt->channel->index);
+
+	mt->channel->scan = true;
+
+	err = xone_mt76_switch_channel(mt, mt->channel);
+	if (err)
+		return err;
+
+	err = xone_mt76_set_power_mode(mt, MT_RADIO_OFF);
+	if (err)
+		return err;
+
+	msleep(50);
+
+	err = xone_mt76_set_power_mode(mt, MT_RADIO_ON);
+	if (err)
+		return err;
+
+	mt->channel->scan = false;
+
+	err = xone_mt76_switch_channel(mt, mt->channel);
+	if (err)
+		return err;
+
+	return xone_mt76_set_channel_candidates(mt);
+}
+
+static int xone_mt76_set_idle_time(struct xone_mt76 *mt)
+{
+	__le32 time = cpu_to_le32(64);
+
+	/* prevent wireless clients from disconnecting when idle */
+	return xone_mt76_send_ms_command(mt, XONE_MT_SET_IDLE_TIME,
+					 &time, sizeof(time));
+}
+
+/*
+ * There are a number of knockoff adapters out there that share the same MAC address(es).
+ * This will create problems if two of them are used within range of each other.
+ * So far, the following MACs are known to be associated with knockoff adapters:
+ */
+static const u8 xone_counterfeit_macs[][ETH_ALEN] = {
+	{0x62, 0x45, 0xb4, 0xe7, 0xa4, 0xef},
+};
+
+static int xone_mt76_mac_looks_counterfeit(const u8* addr)
+{
+	for (int i = 0; i < ARRAY_SIZE(xone_counterfeit_macs); i++) {
+		if (ether_addr_equal(addr, xone_counterfeit_macs[i]))
+			return true;
+	}
+
+	return false;
+}
+
+static int xone_mt76_init_address(struct xone_mt76 *mt)
+{
+	int err;
+
+	err = xone_mt76_read_efuse(mt, MT_EE_MAC_ADDR,
+				   mt->address, sizeof(mt->address));
+	if (err)
+		return err;
+
+	dev_dbg(mt->dev, "%s: fuse_address=%pM\n", __func__, mt->address);
+
+	if (xone_mt76_mac_looks_counterfeit(mt->address) && is_zero_ether_addr(override_mac))
+		dev_warn(mt->dev, "%s: MAC address %pM looks suspicious. Counterfeit "
+			 "adapter? That may be fine, but consider passing override_mac= to "
+			 "deconflict with others nearby\n", __func__, mt->address);
+
+	/* Override MAC address if present */
+	if (!is_zero_ether_addr(override_mac)) {
+		memcpy(mt->address, override_mac, ETH_ALEN);
+		dev_dbg(mt->dev, "%s: overriding MAC address to %pM\n", __func__, mt->address);
+	}
+
+	/* some addresses start with 6c:5d:3a */
+	/* clients only connect to 62:45:bx:xx:xx:xx */
+	if (mt->address[0] != 0x62) {
+		mt->address[0] = 0x62;
+		mt->address[1] = 0x45;
+		mt->address[2] = 0xbd;
+		dev_dbg(mt->dev, "%s: address=%pM\n", __func__, mt->address);
+	}
+
+	err = xone_mt76_write_burst(mt, MT_MAC_ADDR_DW0,
+				    mt->address, sizeof(mt->address));
+	if (err)
+		return err;
+
+	err = xone_mt76_write_burst(mt, MT_MAC_BSSID_DW0,
+				    mt->address, sizeof(mt->address));
+	if (err)
+		return err;
+
+	return xone_mt76_send_ms_command(mt, XONE_MT_SET_MAC_ADDRESS,
+					 mt->address, sizeof(mt->address));
+}
+
+static int xone_mt76_calibrate_crystal(struct xone_mt76 *mt)
+{
+	u8 trim[4];
+	u16 val;
+	s8 offset;
+	u32 ctrl;
+	int err;
+
+	err = xone_mt76_read_efuse(mt, MT_EE_XTAL_TRIM_2, trim, sizeof(trim));
+	if (err)
+		return err;
+
+	val = (trim[3] << 8) | trim[2];
+	offset = val & GENMASK(6, 0);
+	if ((val & 0xff) == 0xff)
+		offset = 0;
+	else if (val & BIT(7))
+		offset = -offset;
+
+	val >>= 8;
+	if (!val || val == 0xff) {
+		err = xone_mt76_read_efuse(mt, MT_EE_XTAL_TRIM_1, trim,
+					   sizeof(trim));
+		if (err)
+			return err;
+
+		val = (trim[3] << 8) | trim[2];
+		val &= 0xff;
+		if (!val || val == 0xff)
+			val = 0x14;
+	}
+
+	val = (val & GENMASK(6, 0)) + offset;
+	ctrl = xone_mt76_read_register(mt, MT_XO_CTRL5 | MT_VEND_TYPE_CFG);
+	xone_mt76_write_register(mt, MT_XO_CTRL5 | MT_VEND_TYPE_CFG,
+				 (ctrl & ~MT_XO_CTRL5_C2_VAL) | (val << 8));
+	xone_mt76_write_register(mt, MT_XO_CTRL6 | MT_VEND_TYPE_CFG,
+				 MT_XO_CTRL6_C2_CTRL);
+	xone_mt76_write_register(mt, MT_CMB_CTRL, 0x0091a7ff);
+
+	return 0;
+}
+
+static int xone_mt76_calibrate_radio(struct xone_mt76 *mt)
+{
+	int err;
+
+	/* configure automatic gain control (AGC) */
+	xone_mt76_write_register(mt, MT_BBP(AGC, 8), 0x18365efa);
+	xone_mt76_write_register(mt, MT_BBP(AGC, 9), 0x18365efa);
+
+	/* reset required for reliable WLAN associations */
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL, 0);
+	xone_mt76_write_register(mt, MT_RF_BYPASS_0, 0);
+	xone_mt76_write_register(mt, MT_RF_SETTING_0, 0);
+
+	err = xone_mt76_calibrate(mt, MT_MCU_CAL_TEMP_SENSOR, 0);
+	if (err)
+		return err;
+
+	err = xone_mt76_calibrate(mt, MT_MCU_CAL_RXDCOC, 1);
+	if (err)
+		return err;
+
+	err = xone_mt76_calibrate(mt, MT_MCU_CAL_RC, 0);
+	if (err)
+		return err;
+
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL,
+				 MT_MAC_SYS_CTRL_ENABLE_RX |
+				 MT_MAC_SYS_CTRL_ENABLE_TX);
+
+	return 0;
+}
+
+static void xone_mt76_init_registers(struct xone_mt76 *mt)
+{
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL,
+				 MT_MAC_SYS_CTRL_RESET_BBP |
+				 MT_MAC_SYS_CTRL_RESET_CSR);
+	xone_mt76_write_register(mt, MT_USB_DMA_CFG, 0);
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL, 0);
+	xone_mt76_write_register(mt, MT_PWR_PIN_CFG, 0);
+	xone_mt76_write_register(mt, MT_LDO_CTRL_1, 0x6b006464);
+	xone_mt76_write_register(mt, MT_WPDMA_GLO_CFG, 0x70);
+	xone_mt76_write_register(mt, MT_WMM_AIFSN, 0x2273);
+	xone_mt76_write_register(mt, MT_WMM_CWMIN, 0x2344);
+	xone_mt76_write_register(mt, MT_WMM_CWMAX, 0x34aa);
+	xone_mt76_write_register(mt, MT_FCE_DMA_ADDR, 0x041200);
+	xone_mt76_write_register(mt, MT_TSO_CTRL, 0);
+	xone_mt76_write_register(mt, MT_PBF_SYS_CTRL, 0x080c00);
+	xone_mt76_write_register(mt, MT_PBF_TX_MAX_PCNT, 0x1fbf1f1f);
+	xone_mt76_write_register(mt, MT_FCE_PSE_CTRL, 0x01);
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL,
+				 MT_MAC_SYS_CTRL_ENABLE_RX |
+				 MT_MAC_SYS_CTRL_ENABLE_TX);
+	xone_mt76_write_register(mt, MT_AUTO_RSP_CFG, 0x13);
+	xone_mt76_write_register(mt, MT_MAX_LEN_CFG, 0x3e3fff);
+	xone_mt76_write_register(mt, MT_AMPDU_MAX_LEN_20M1S, 0xfffc9855);
+	xone_mt76_write_register(mt, MT_AMPDU_MAX_LEN_20M2S, 0xff);
+	xone_mt76_write_register(mt, MT_BKOFF_SLOT_CFG, 0x0109);
+	xone_mt76_write_register(mt, MT_PWR_PIN_CFG, 0);
+	xone_mt76_write_register(mt, MT_EDCA_CFG_AC(0), 0x064320);
+	xone_mt76_write_register(mt, MT_EDCA_CFG_AC(1), 0x0a4700);
+	xone_mt76_write_register(mt, MT_EDCA_CFG_AC(2), 0x043238);
+	xone_mt76_write_register(mt, MT_EDCA_CFG_AC(3), 0x03212f);
+	xone_mt76_write_register(mt, MT_TX_PIN_CFG, 0x150f0f);
+	xone_mt76_write_register(mt, MT_TX_SW_CFG0, 0x101001);
+	xone_mt76_write_register(mt, MT_TX_SW_CFG1, 0x010000);
+	xone_mt76_write_register(mt, MT_TXOP_CTRL_CFG, 0x10583f);
+	xone_mt76_write_register(mt, MT_TX_TIMEOUT_CFG, 0x0a0f90);
+	xone_mt76_write_register(mt, MT_TX_RETRY_CFG, 0x47d01f0f);
+	xone_mt76_write_register(mt, MT_CCK_PROT_CFG, 0x03f40003);
+	xone_mt76_write_register(mt, MT_OFDM_PROT_CFG, 0x03f40003);
+	xone_mt76_write_register(mt, MT_MM20_PROT_CFG, 0x01742004);
+	xone_mt76_write_register(mt, MT_GF20_PROT_CFG, 0x01742004);
+	xone_mt76_write_register(mt, MT_GF40_PROT_CFG, 0x03f42084);
+	xone_mt76_write_register(mt, MT_EXP_ACK_TIME, 0x2c00dc);
+	xone_mt76_write_register(mt, MT_TX_ALC_CFG_2, 0x22160a00);
+	xone_mt76_write_register(mt, MT_TX_ALC_CFG_3, 0x22160a76);
+	xone_mt76_write_register(mt, MT_TX_ALC_CFG_0, 0x3f3f1818);
+	xone_mt76_write_register(mt, MT_TX_ALC_CFG_4, 0x0606);
+	xone_mt76_write_register(mt, MT_PIFS_TX_CFG, 0x060fff);
+	xone_mt76_write_register(mt, MT_RX_FILTR_CFG, 0x017f17);
+	xone_mt76_write_register(mt, MT_LEGACY_BASIC_RATE, 0x017f);
+	xone_mt76_write_register(mt, MT_HT_BASIC_RATE, 0x8003);
+	xone_mt76_write_register(mt, MT_PN_PAD_MODE, 0x02);
+	xone_mt76_write_register(mt, MT_TXOP_HLDR_ET, 0x02);
+	xone_mt76_write_register(mt, MT_TX_PROT_CFG6, 0xe3f42004);
+	xone_mt76_write_register(mt, MT_TX_PROT_CFG7, 0xe3f42084);
+	xone_mt76_write_register(mt, MT_TX_PROT_CFG8, 0xe3f42104);
+	xone_mt76_write_register(mt, MT_DACCLK_EN_DLY_CFG, 0);
+	xone_mt76_write_register(mt, MT_RF_PA_MODE_ADJ0, 0xee000000);
+	xone_mt76_write_register(mt, MT_RF_PA_MODE_ADJ1, 0xee000000);
+	xone_mt76_write_register(mt, MT_TX0_RF_GAIN_CORR, 0x0f3c3c3c);
+	xone_mt76_write_register(mt, MT_TX1_RF_GAIN_CORR, 0x0f3c3c3c);
+	xone_mt76_write_register(mt, MT_PBF_CFG, 0x1efebcf5);
+	xone_mt76_write_register(mt, MT_PAUSE_ENABLE_CONTROL1, 0x0a);
+	xone_mt76_write_register(mt, MT_RF_BYPASS_0, 0x7f000000);
+	xone_mt76_write_register(mt, MT_RF_SETTING_0, 0x1a800000);
+	xone_mt76_write_register(mt, MT_XIFS_TIME_CFG, 0x33a40e0a);
+	xone_mt76_write_register(mt, MT_FCE_L2_STUFF, 0x03ff0223);
+	xone_mt76_write_register(mt, MT_TX_RTS_CFG, 0);
+	xone_mt76_write_register(mt, MT_BEACON_TIME_CFG, 0x0640);
+	xone_mt76_write_register(mt, MT_EXT_CCA_CFG, 0xf0e4);
+	xone_mt76_write_register(mt, MT_CH_TIME_CFG, 0x015f);
+}
+
+static u16 xone_mt76_get_chip_id(struct xone_mt76 *mt)
+{
+	u8 id[4];
+
+	if (xone_mt76_read_efuse(mt, MT_EE_CHIP_ID, &id, sizeof(id)))
+		return 0;
+
+	return (id[1] << 8) | id[2];
+}
+
+int xone_mt76_init_radio(struct xone_mt76 *mt)
+{
+	int err;
+
+	dev_dbg(mt->dev, "%s: id=0x%04x\n", __func__,
+		xone_mt76_get_chip_id(mt));
+
+	err = xone_mt76_select_function(mt, MT_Q_SELECT, 1);
+	if (err)
+		return err;
+
+	err = xone_mt76_set_power_mode(mt, MT_RADIO_ON);
+	if (err)
+		return err;
+
+	err = xone_mt76_load_cr(mt, MT_RF_BBP_CR);
+	if (err)
+		return err;
+
+	xone_mt76_init_registers(mt);
+
+	err = xone_mt76_calibrate_crystal(mt);
+	if (err)
+		return err;
+
+	err = xone_mt76_init_address(mt);
+	if (err)
+		return err;
+
+	err = xone_mt76_set_idle_time(mt);
+	if (err)
+		return err;
+
+	err = xone_mt76_calibrate_radio(mt);
+	if (err)
+		return err;
+
+	err = xone_mt76_init_channels(mt);
+	if (err)
+		return err;
+
+	/* mandatory delay after channel change */
+	msleep(1000);
+
+	return xone_mt76_set_pairing(mt, false);
+}
+
+int xone_mt76_suspend_radio(struct xone_mt76 *mt)
+{
+	int err;
+
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL, 0);
+
+	/* enable wake-on-wireless */
+	err = xone_mt76_set_wow_enable(mt, true);
+	if (err)
+		return err;
+
+	err = xone_mt76_set_wow_traffic(mt, XONE_MT_WOW_TO_HOST);
+	if (err)
+		return err;
+
+	dev_dbg(mt->dev, "%s: suspended\n", __func__);
+
+	return 0;
+}
+
+int xone_mt76_resume_radio(struct xone_mt76 *mt)
+{
+	int err;
+
+	err = xone_mt76_set_wow_traffic(mt, XONE_MT_WOW_TO_FIRMWARE);
+	if (err)
+		return err;
+
+	/* disable wake-on-wireless */
+	err = xone_mt76_set_wow_enable(mt, false);
+	if (err)
+		return err;
+
+	err = xone_mt76_switch_channel(mt, mt->channel);
+	if (err)
+		return err;
+
+	err = xone_mt76_set_pairing(mt, false);
+	if (err)
+		return err;
+
+	xone_mt76_write_register(mt, MT_MAC_SYS_CTRL,
+				 MT_MAC_SYS_CTRL_ENABLE_RX |
+				 MT_MAC_SYS_CTRL_ENABLE_TX);
+
+	dev_dbg(mt->dev, "%s: resumed\n", __func__);
+
+	return 0;
+}
+
+static int xone_mt76_write_beacon(struct xone_mt76 *mt, bool pair)
+{
+	struct sk_buff *skb;
+	struct mt76_txwi txwi = {};
+	struct ieee80211_mgmt mgmt = {};
+	u8 data[] = {
+		/* information element with Microsoft's OUI (00:50:f2) */
+		/* probably includes the selected channel pair */
+		0x00, 0x00, 0xdd, 0x10, 0x00, 0x50, 0xf2, 0x11,
+		0x01, 0x10, pair, 0xa5, 0x30, 0x99, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00,
+	};
+	int mgmt_len = sizeof(struct ieee80211_hdr_3addr) +
+		       sizeof(mgmt.u.beacon);
+	int err;
+
+	skb = alloc_skb(sizeof(txwi) + mgmt_len + sizeof(data), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* generate beacon timestamp */
+	/* use hardware sequence control */
+	txwi.flags = cpu_to_le16(MT_TXWI_FLAGS_TS);
+	txwi.rate = cpu_to_le16(FIELD_PREP(MT_RXWI_RATE_PHY, MT_PHY_TYPE_OFDM));
+	txwi.ack_ctl = MT_TXWI_ACK_CTL_NSEQ;
+	txwi.len_ctl = cpu_to_le16(mgmt_len + sizeof(data));
+
+	mgmt.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_BEACON);
+	eth_broadcast_addr(mgmt.da);
+	memcpy(mgmt.sa, mt->address, ETH_ALEN);
+	memcpy(mgmt.bssid, mt->address, ETH_ALEN);
+
+	/* default beacon interval (100 ms) */
+	/* original capability info */
+	mgmt.u.beacon.beacon_int = cpu_to_le16(100);
+	mgmt.u.beacon.capab_info = cpu_to_le16(0xc631);
+
+	skb_put_data(skb, &txwi, sizeof(txwi));
+	skb_put_data(skb, &mgmt, mgmt_len);
+	skb_put_data(skb, data, sizeof(data));
+
+	err = xone_mt76_write_burst(mt, MT_BEACON_BASE, skb->data, skb->len);
+	consume_skb(skb);
+
+	return err;
+}
+
+int xone_mt76_set_pairing(struct xone_mt76 *mt, bool enable)
+{
+	int err;
+
+	err = xone_mt76_write_beacon(mt, enable);
+	if (err)
+		return err;
+
+	/* enable timing synchronization function (TSF) timer */
+	/* enable target beacon transmission time (TBTT) timer */
+	/* set TSF timer to AP mode */
+	/* activate beacon transmission */
+	xone_mt76_write_register(mt, MT_BEACON_TIME_CFG,
+				 MT_BEACON_TIME_CFG_BEACON_TX |
+				 MT_BEACON_TIME_CFG_TBTT_EN |
+				 MT_BEACON_TIME_CFG_SYNC_MODE |
+				 MT_BEACON_TIME_CFG_TIMER_EN |
+				 FIELD_PREP(MT_BEACON_TIME_CFG_INTVAL, 0x0640));
+
+	return 0;
+}
+
+int xone_mt76_pair_client(struct xone_mt76 *mt, u8 *addr)
+{
+	struct sk_buff *skb;
+	struct ieee80211_hdr_3addr hdr = {};
+	u8 data[] = { 0x00, 0x45, 0x55, 0x01, 0x0f, 0x8f, 0xff, 0x87, 0x1f };
+
+	skb = xone_mt76_alloc_message(sizeof(struct mt76_txwi) + sizeof(hdr) +
+				      sizeof(u8) * 2 + sizeof(data),
+				      GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					XONE_MT_WLAN_RESERVED);
+	memcpy(hdr.addr1, addr, ETH_ALEN);
+	memcpy(hdr.addr2, mt->address, ETH_ALEN);
+	memcpy(hdr.addr3, mt->address, ETH_ALEN);
+
+	skb_reserve(skb, sizeof(struct mt76_txwi));
+	skb_put_data(skb, &hdr, sizeof(hdr));
+	skb_put_u8(skb, XONE_MT_WLAN_RESERVED);
+	skb_put_u8(skb, XONE_MT_CLIENT_PAIR_RESP);
+	skb_put_data(skb, data, sizeof(data));
+
+	return xone_mt76_send_wlan(mt, skb);
+}
+
+int xone_mt76_associate_client(struct xone_mt76 *mt, u8 wcid, u8 *addr)
+{
+	struct sk_buff *skb;
+	struct ieee80211_mgmt mgmt = {};
+	u8 data[] = { wcid - 1, 0x00, 0x00, 0x00, 0x40, 0x1f, 0x00, 0x00 };
+	int mgmt_len = sizeof(struct ieee80211_hdr_3addr) +
+		       sizeof(mgmt.u.assoc_resp);
+	int err;
+
+	skb = xone_mt76_alloc_message(sizeof(struct mt76_txwi) + mgmt_len + 8,
+				      GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	mgmt.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					 IEEE80211_STYPE_ASSOC_RESP);
+	memcpy(mgmt.da, addr, ETH_ALEN);
+	memcpy(mgmt.sa, mt->address, ETH_ALEN);
+	memcpy(mgmt.bssid, mt->address, ETH_ALEN);
+
+	/* original status code and association ID */
+	mgmt.u.assoc_resp.status_code = cpu_to_le16(0x0110);
+	mgmt.u.assoc_resp.aid = cpu_to_le16(0x0f00);
+
+	skb_reserve(skb, sizeof(struct mt76_txwi));
+	skb_put_data(skb, &mgmt, mgmt_len);
+	memset(skb_put(skb, 8), 0, 8);
+
+	err = xone_mt76_write_burst(mt, MT_WCID_ADDR(wcid), addr, ETH_ALEN);
+	if (err)
+		goto err_free_skb;
+
+	err = xone_mt76_send_ms_command(mt, XONE_MT_ADD_CLIENT,
+					data, sizeof(data));
+	if (err)
+		goto err_free_skb;
+
+	return xone_mt76_send_wlan(mt, skb);
+
+err_free_skb:
+	kfree_skb(skb);
+
+	return err;
+}
+
+int xone_mt76_send_client_command(struct xone_mt76 *mt, u8 wcid, u8 *addr,
+				  enum xone_mt76_client_command cmd,
+				  u8 *data, int len)
+{
+	struct sk_buff *skb;
+	struct mt76_txwi txwi = {};
+	struct ieee80211_hdr_3addr hdr = {};
+	u8 info[] = {
+		0x00, 0x00, 0x00, wcid - 1, 0x00, 0x00, 0x00, 0x00,
+	};
+
+	skb = xone_mt76_alloc_message(sizeof(info) + sizeof(txwi) +
+				      sizeof(hdr) + sizeof(u8) * 2 + len,
+				      GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	/* wait for acknowledgment */
+	txwi.flags = cpu_to_le16(FIELD_PREP(MT_TXWI_FLAGS_MPDU_DENSITY,
+					    IEEE80211_HT_MPDU_DENSITY_4));
+	txwi.rate = cpu_to_le16(FIELD_PREP(MT_RXWI_RATE_PHY, MT_PHY_TYPE_OFDM));
+	txwi.ack_ctl = MT_TXWI_ACK_CTL_REQ;
+	txwi.wcid = wcid - 1;
+	txwi.len_ctl = cpu_to_le16(sizeof(hdr) + sizeof(u8) * 2 + len);
+
+	hdr.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+					XONE_MT_WLAN_RESERVED);
+	memcpy(hdr.addr1, addr, ETH_ALEN);
+	memcpy(hdr.addr2, mt->address, ETH_ALEN);
+	memcpy(hdr.addr3, mt->address, ETH_ALEN);
+
+	skb_put_data(skb, info, sizeof(info));
+	skb_put_data(skb, &txwi, sizeof(txwi));
+	skb_put_data(skb, &hdr, sizeof(hdr));
+	skb_put_u8(skb, XONE_MT_WLAN_RESERVED);
+	skb_put_u8(skb, cmd);
+
+	if (data)
+		skb_put_data(skb, data, len);
+
+	return xone_mt76_send_command(mt, skb, 0);
+}
+
+int xone_mt76_set_client_key(struct xone_mt76 *mt, u8 wcid, u8 *key, int len)
+{
+	u8 iv[] = { 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00 };
+	__le32 attr = cpu_to_le32(FIELD_PREP(MT_WCID_ATTR_PKEY_MODE,
+					     MT_CIPHER_AES_CCMP) |
+				  MT_WCID_ATTR_PAIRWISE);
+	int err;
+
+	if (len != XONE_MT_WCID_KEY_LEN)
+		return -EINVAL;
+
+	err = xone_mt76_write_burst(mt, MT_WCID_KEY(wcid), key, len);
+	if (err)
+		return err;
+
+	err = xone_mt76_write_burst(mt, MT_WCID_IV(wcid), iv, sizeof(iv));
+	if (err)
+		return err;
+
+	return xone_mt76_write_burst(mt, MT_WCID_ATTR(wcid),
+				     &attr, sizeof(attr));
+}
+
+int xone_mt76_remove_client(struct xone_mt76 *mt, u8 wcid)
+{
+	u8 data[] = { wcid - 1, 0x00, 0x00, 0x00 };
+	u8 addr[ETH_ALEN] = {};
+	u8 iv[8] = {};
+	u32 attr = 0;
+	u8 key[XONE_MT_WCID_KEY_LEN] = {};
+	int err;
+
+	err = xone_mt76_send_ms_command(mt, XONE_MT_REMOVE_CLIENT,
+					data, sizeof(data));
+	if (err)
+		return err;
+
+	err = xone_mt76_write_burst(mt, MT_WCID_ADDR(wcid), addr, sizeof(addr));
+	if (err)
+		return err;
+
+	err = xone_mt76_write_burst(mt, MT_WCID_IV(wcid), iv, sizeof(iv));
+	if (err)
+		return err;
+
+	err = xone_mt76_write_burst(mt, MT_WCID_ATTR(wcid),
+				    &attr, sizeof(attr));
+	if (err)
+		return err;
+
+	return xone_mt76_write_burst(mt, MT_WCID_KEY(wcid), key, sizeof(key));
+}
diff --git a/drivers/custom/xonedo/transport/mt76.h b/drivers/custom/xonedo/transport/mt76.h
new file mode 100644
index 000000000000..f1ba59e42302
--- /dev/null
+++ b/drivers/custom/xonedo/transport/mt76.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ */
+
+#pragma once
+
+#include "mt76_defs.h"
+
+#define XONE_MT_EP_IN_CMD 0x05
+#define XONE_MT_EP_IN_WLAN 0x04
+#define XONE_MT_EP_OUT 0x04
+
+#define XONE_MT_NUM_CHANNELS 12
+
+/* 802.11 frame subtype: reserved */
+#define XONE_MT_WLAN_RESERVED 0x70
+
+enum xone_mt76_led_mode {
+	XONE_MT_LED_BLINK = 0x00,
+	XONE_MT_LED_ON = 0x01,
+	XONE_MT_LED_OFF = 0x02,
+};
+
+enum xone_mt76_event {
+	XONE_MT_EVT_BUTTON = 0x04,
+	XONE_MT_EVT_CHANNELS = 0x0a,
+	XONE_MT_EVT_PACKET_RX = 0x0c,
+	XONE_MT_EVT_COREDUMP = 0x0d,
+	XONE_MT_EVT_CLIENT_LOST = 0x0e,
+};
+
+enum xone_mt76_client_command {
+	XONE_MT_CLIENT_PAIR_REQ = 0x01,
+	XONE_MT_CLIENT_PAIR_RESP = 0x02,
+	XONE_MT_CLIENT_CHANGE_CHAN_REQ = 0x03,
+	XONE_MT_CLIENT_CHANGE_CHAN_RESP = 0x04,
+	XONE_MT_CLIENT_STATISTICS_REQ = 0x05,
+	XONE_MT_CLIENT_STATISTICS_RESP = 0x06,
+	XONE_MT_CLIENT_SCAN_CHAN_REQ = 0x07,
+	XONE_MT_CLIENT_SCAN_CHAN_RESP = 0x08,
+	XONE_MT_CLIENT_ENABLE_ENCRYPTION = 0x10,
+};
+
+struct xone_mt76_channel {
+	u8 index;
+	u8 band;
+	enum mt76_phy_bandwidth bandwidth;
+	enum mt76_cal_channel_group group;
+	bool scan;
+	u8 power;
+};
+
+struct xone_mt76 {
+	struct device *dev;
+	struct usb_device *udev;
+
+	__le32 control_data;
+	u8 address[ETH_ALEN];
+
+	struct xone_mt76_channel channels[XONE_MT_NUM_CHANNELS];
+	struct xone_mt76_channel *channel;
+};
+
+struct sk_buff *xone_mt76_alloc_message(int len, gfp_t gfp);
+void xone_mt76_prep_command(struct sk_buff *skb, enum mt76_mcu_cmd cmd);
+
+int xone_mt76_set_led_mode(struct xone_mt76 *mt, enum xone_mt76_led_mode mode);
+int xone_mt76_load_firmware(struct xone_mt76 *mt, const struct firmware *fw);
+int xone_mt76_init_radio(struct xone_mt76 *mt);
+int xone_mt76_suspend_radio(struct xone_mt76 *mt);
+int xone_mt76_resume_radio(struct xone_mt76 *mt);
+int xone_mt76_set_pairing(struct xone_mt76 *mt, bool enable);
+
+int xone_mt76_pair_client(struct xone_mt76 *mt, u8 *addr);
+int xone_mt76_associate_client(struct xone_mt76 *mt, u8 wcid, u8 *addr);
+int xone_mt76_send_client_command(struct xone_mt76 *mt, u8 wcid, u8 *addr,
+				  enum xone_mt76_client_command cmd,
+				  u8 *data, int len);
+int xone_mt76_set_client_key(struct xone_mt76 *mt, u8 wcid, u8 *key, int len);
+int xone_mt76_remove_client(struct xone_mt76 *mt, u8 wcid);
diff --git a/drivers/custom/xonedo/transport/mt76_defs.h b/drivers/custom/xonedo/transport/mt76_defs.h
new file mode 100644
index 000000000000..f5fe65b149aa
--- /dev/null
+++ b/drivers/custom/xonedo/transport/mt76_defs.h
@@ -0,0 +1,1064 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Based on code from the open source mt76 driver with minor modifications.
+ *
+ * Copyright (C) 2021 Severin von Wnuck-Lipinski <severinvonw@outlook.de>
+ *
+ * Special thanks to the authors of the mt76 driver:
+ *
+ * Copyright (C) Felix Fietkau <nbd@nbd.name>
+ * Copyright (C) Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ * Copyright (C) Stanislaw Gruszka <stf_xl@wp.pl>
+ */
+
+#pragma once
+
+#include <linux/types.h>
+
+#define MT_ASIC_VERSION 0x0000
+
+#define MT_CMB_CTRL 0x0020
+#define MT_CMB_CTRL_XTAL_RDY BIT(22)
+#define MT_CMB_CTRL_PLL_LD BIT(23)
+
+#define MT_EFUSE_CTRL 0x0024
+#define MT_EFUSE_CTRL_AOUT GENMASK(5, 0)
+#define MT_EFUSE_CTRL_MODE GENMASK(7, 6)
+#define MT_EFUSE_CTRL_LDO_OFF_TIME GENMASK(13, 8)
+#define MT_EFUSE_CTRL_LDO_ON_TIME GENMASK(15, 14)
+#define MT_EFUSE_CTRL_AIN GENMASK(25, 16)
+#define MT_EFUSE_CTRL_KICK BIT(30)
+#define MT_EFUSE_CTRL_SEL BIT(31)
+
+#define MT_EFUSE_DATA_BASE 0x0028
+#define MT_EFUSE_DATA(n) (MT_EFUSE_DATA_BASE + ((n) << 2))
+
+#define MT_COEXCFG0 0x0040
+#define MT_COEXCFG0_COEX_EN BIT(0)
+
+#define MT_WLAN_FUN_CTRL 0x0080
+#define MT_WLAN_FUN_CTRL_WLAN_EN BIT(0)
+#define MT_WLAN_FUN_CTRL_WLAN_CLK_EN BIT(1)
+#define MT_WLAN_FUN_CTRL_WLAN_RESET_RF BIT(2)
+
+#define MT_COEXCFG3 0x004c
+
+#define MT_LDO_CTRL_0 0x006c
+#define MT_LDO_CTRL_1 0x0070
+
+#define MT_WLAN_FUN_CTRL_CSR_F20M_CKEN BIT(3)
+
+#define MT_WLAN_FUN_CTRL_PCIE_CLK_REQ BIT(4)
+#define MT_WLAN_FUN_CTRL_FRC_WL_ANT_SEL BIT(5)
+#define MT_WLAN_FUN_CTRL_INV_ANT_SEL BIT(6)
+#define MT_WLAN_FUN_CTRL_WAKE_HOST BIT(7)
+
+#define MT_WLAN_FUN_CTRL_THERM_RST BIT(8)
+#define MT_WLAN_FUN_CTRL_THERM_CKEN BIT(9)
+
+#define MT_XO_CTRL0 0x0100
+#define MT_XO_CTRL1 0x0104
+#define MT_XO_CTRL2 0x0108
+#define MT_XO_CTRL3 0x010c
+#define MT_XO_CTRL4 0x0110
+
+#define MT_XO_CTRL5 0x0114
+#define MT_XO_CTRL5_C2_VAL GENMASK(14, 8)
+
+#define MT_XO_CTRL6 0x0118
+#define MT_XO_CTRL6_C2_CTRL GENMASK(14, 8)
+
+#define MT_XO_CTRL7 0x011c
+
+#define MT_IOCFG_6 0x0124
+
+#define MT_USB_U3DMA_CFG 0x9018
+#define MT_USB_DMA_CFG_RX_BULK_AGG_TOUT GENMASK(7, 0)
+#define MT_USB_DMA_CFG_RX_BULK_AGG_LMT GENMASK(15, 8)
+#define MT_USB_DMA_CFG_UDMA_TX_WL_DROP BIT(16)
+#define MT_USB_DMA_CFG_WAKE_UP_EN BIT(17)
+#define MT_USB_DMA_CFG_RX_DROP_OR_PAD BIT(18)
+#define MT_USB_DMA_CFG_TX_CLR BIT(19)
+#define MT_USB_DMA_CFG_TXOP_HALT BIT(20)
+#define MT_USB_DMA_CFG_RX_BULK_AGG_EN BIT(21)
+#define MT_USB_DMA_CFG_RX_BULK_EN BIT(22)
+#define MT_USB_DMA_CFG_TX_BULK_EN BIT(23)
+#define MT_USB_DMA_CFG_EP_OUT_VALID GENMASK(29, 24)
+#define MT_USB_DMA_CFG_RX_BUSY BIT(30)
+#define MT_USB_DMA_CFG_TX_BUSY BIT(31)
+
+#define MT_WLAN_MTC_CTRL 0x010148
+#define MT_WLAN_MTC_CTRL_MTCMOS_PWR_UP BIT(0)
+#define MT_WLAN_MTC_CTRL_PWR_ACK BIT(12)
+#define MT_WLAN_MTC_CTRL_PWR_ACK_S BIT(13)
+#define MT_WLAN_MTC_CTRL_BBP_MEM_PD GENMASK(19, 16)
+#define MT_WLAN_MTC_CTRL_PBF_MEM_PD BIT(20)
+#define MT_WLAN_MTC_CTRL_FCE_MEM_PD BIT(21)
+#define MT_WLAN_MTC_CTRL_TSO_MEM_PD BIT(22)
+#define MT_WLAN_MTC_CTRL_BBP_MEM_RB BIT(24)
+#define MT_WLAN_MTC_CTRL_PBF_MEM_RB BIT(25)
+#define MT_WLAN_MTC_CTRL_FCE_MEM_RB BIT(26)
+#define MT_WLAN_MTC_CTRL_TSO_MEM_RB BIT(27)
+#define MT_WLAN_MTC_CTRL_STATE_UP BIT(28)
+
+#define MT_INT_SOURCE_CSR 0x0200
+#define MT_INT_MASK_CSR 0x0204
+
+#define MT_INT_RX_DONE(n) BIT(n)
+#define MT_INT_RX_DONE_ALL GENMASK(1, 0)
+#define MT_INT_TX_DONE_ALL GENMASK(13, 4)
+#define MT_INT_TX_DONE(n) BIT((n) + 4)
+#define MT_INT_RX_COHERENT BIT(16)
+#define MT_INT_TX_COHERENT BIT(17)
+#define MT_INT_ANY_COHERENT BIT(18)
+#define MT_INT_MCU_CMD BIT(19)
+#define MT_INT_TBTT BIT(20)
+#define MT_INT_PRE_TBTT BIT(21)
+#define MT_INT_TX_STAT BIT(22)
+#define MT_INT_AUTO_WAKEUP BIT(23)
+#define MT_INT_GPTIMER BIT(24)
+#define MT_INT_RXDELAYINT BIT(26)
+#define MT_INT_TXDELAYINT BIT(27)
+
+#define MT_WPDMA_GLO_CFG 0x0208
+#define MT_WPDMA_GLO_CFG_TX_DMA_EN BIT(0)
+#define MT_WPDMA_GLO_CFG_TX_DMA_BUSY BIT(1)
+#define MT_WPDMA_GLO_CFG_RX_DMA_EN BIT(2)
+#define MT_WPDMA_GLO_CFG_RX_DMA_BUSY BIT(3)
+#define MT_WPDMA_GLO_CFG_DMA_BURST_SIZE GENMASK(5, 4)
+#define MT_WPDMA_GLO_CFG_TX_WRITEBACK_DONE BIT(6)
+#define MT_WPDMA_GLO_CFG_BIG_ENDIAN BIT(7)
+#define MT_WPDMA_GLO_CFG_HDR_SEG_LEN GENMASK(15, 8)
+#define MT_WPDMA_GLO_CFG_CLK_GATE_DIS BIT(30)
+#define MT_WPDMA_GLO_CFG_RX_2B_OFFSET BIT(31)
+
+#define MT_WPDMA_RST_IDX 0x020c
+
+#define MT_WPDMA_DELAY_INT_CFG 0x0210
+
+#define MT_WMM_AIFSN 0x0214
+#define MT_WMM_AIFSN_MASK GENMASK(3, 0)
+#define MT_WMM_AIFSN_SHIFT(n) ((n) * 4)
+
+#define MT_WMM_CWMIN 0x0218
+#define MT_WMM_CWMIN_MASK GENMASK(3, 0)
+#define MT_WMM_CWMIN_SHIFT(n) ((n) * 4)
+
+#define MT_WMM_CWMAX 0x021c
+#define MT_WMM_CWMAX_MASK GENMASK(3, 0)
+#define MT_WMM_CWMAX_SHIFT(n) ((n) * 4)
+
+#define MT_WMM_TXOP_BASE 0x0220
+#define MT_WMM_TXOP(n) (MT_WMM_TXOP_BASE + (((n) / 2) << 2))
+#define MT_WMM_TXOP_SHIFT(n) (((n) & 1) * 16)
+#define MT_WMM_TXOP_MASK GENMASK(15, 0)
+
+#define MT_FCE_DMA_ADDR 0x0230
+#define MT_FCE_DMA_LEN 0x0234
+#define MT_USB_DMA_CFG 0x0238
+
+#define MT_TSO_CTRL 0x0250
+#define MT_HEADER_TRANS_CTRL_REG 0x0260
+
+#define MT_US_CYC_CFG 0x02a4
+#define MT_US_CYC_CNT GENMASK(7, 0)
+
+#define MT_TX_RING_BASE 0x0300
+#define MT_RX_RING_BASE 0x03c0
+
+#define MT_PBF_SYS_CTRL 0x0400
+#define MT_PBF_SYS_CTRL_MCU_RESET BIT(0)
+#define MT_PBF_SYS_CTRL_DMA_RESET BIT(1)
+#define MT_PBF_SYS_CTRL_MAC_RESET BIT(2)
+#define MT_PBF_SYS_CTRL_PBF_RESET BIT(3)
+#define MT_PBF_SYS_CTRL_ASY_RESET BIT(4)
+
+#define MT_PBF_CFG 0x0404
+#define MT_PBF_CFG_TX0Q_EN BIT(0)
+#define MT_PBF_CFG_TX1Q_EN BIT(1)
+#define MT_PBF_CFG_TX2Q_EN BIT(2)
+#define MT_PBF_CFG_TX3Q_EN BIT(3)
+#define MT_PBF_CFG_RX0Q_EN BIT(4)
+#define MT_PBF_CFG_RX_DROP_EN BIT(8)
+
+#define MT_PBF_TX_MAX_PCNT 0x0408
+#define MT_PBF_RX_MAX_PCNT 0x040c
+
+#define MT_BCN_OFFSET_BASE 0x041c
+#define MT_BCN_OFFSET(n) (MT_BCN_OFFSET_BASE + ((n) << 2))
+
+#define MT_RXQ_STA 0x0430
+#define MT_TXQ_STA 0x0434
+#define MT_RF_CSR_CFG 0x0500
+#define MT_RF_CSR_CFG_DATA GENMASK(7, 0)
+#define MT_RF_CSR_CFG_REG_ID GENMASK(14, 8)
+#define MT_RF_CSR_CFG_REG_BANK GENMASK(17, 15)
+#define MT_RF_CSR_CFG_WR BIT(30)
+#define MT_RF_CSR_CFG_KICK BIT(31)
+
+#define MT_RF_BYPASS_0 0x0504
+#define MT_RF_BYPASS_1 0x0508
+#define MT_RF_SETTING_0 0x050c
+
+#define MT_RF_MISC 0x0518
+#define MT_RF_DATA_WRITE 0x0524
+
+#define MT_RF_CTRL 0x0528
+#define MT_RF_CTRL_ADDR GENMASK(11, 0)
+#define MT_RF_CTRL_WRITE BIT(12)
+#define MT_RF_CTRL_BUSY BIT(13)
+#define MT_RF_CTRL_IDX BIT(16)
+
+#define MT_RF_DATA_READ 0x052c
+
+#define MT_COM_REG0 0x0730
+#define MT_COM_REG1 0x0734
+#define MT_COM_REG2 0x0738
+#define MT_COM_REG3 0x073c
+
+#define MT_LED_CTRL 0x0770
+#define MT_LED_CTRL_REPLAY(n) BIT(0 + (8 * (n)))
+#define MT_LED_CTRL_POLARITY(n) BIT(1 + (8 * (n)))
+#define MT_LED_CTRL_TX_BLINK_MODE(n) BIT(2 + (8 * (n)))
+#define MT_LED_CTRL_KICK(n) BIT(7 + (8 * (n)))
+
+#define MT_LED_TX_BLINK_0 0x0774
+#define MT_LED_TX_BLINK_1 0x0778
+
+#define MT_LED_S0_BASE 0x077c
+#define MT_LED_S0(n) (MT_LED_S0_BASE + 8 * (n))
+#define MT_LED_S1_BASE 0x0780
+#define MT_LED_S1(n) (MT_LED_S1_BASE + 8 * (n))
+#define MT_LED_STATUS_OFF GENMASK(31, 24)
+#define MT_LED_STATUS_ON GENMASK(23, 16)
+#define MT_LED_STATUS_DURATION GENMASK(15, 8)
+
+#define MT_FCE_PSE_CTRL 0x0800
+#define MT_FCE_PARAMETERS 0x0804
+#define MT_FCE_CSO 0x0808
+
+#define MT_FCE_L2_STUFF 0x080c
+#define MT_FCE_L2_STUFF_HT_L2_EN BIT(0)
+#define MT_FCE_L2_STUFF_QOS_L2_EN BIT(1)
+#define MT_FCE_L2_STUFF_RX_STUFF_EN BIT(2)
+#define MT_FCE_L2_STUFF_TX_STUFF_EN BIT(3)
+#define MT_FCE_L2_STUFF_WR_MPDU_LEN_EN BIT(4)
+#define MT_FCE_L2_STUFF_MVINV_BSWAP BIT(5)
+#define MT_FCE_L2_STUFF_TS_CMD_QSEL_EN GENMASK(15, 8)
+#define MT_FCE_L2_STUFF_TS_LEN_EN GENMASK(23, 16)
+#define MT_FCE_L2_STUFF_OTHER_PORT GENMASK(25, 24)
+
+#define MT_FCE_WLAN_FLOW_CONTROL1 0x0824
+
+#define MT_TX_CPU_FROM_FCE_BASE_PTR 0x09a0
+#define MT_TX_CPU_FROM_FCE_MAX_COUNT 0x09a4
+#define MT_TX_CPU_FROM_FCE_CPU_DESC_IDX 0x09a8
+#define MT_FCE_PDMA_GLOBAL_CONF 0x09c4
+#define MT_FCE_SKIP_FS 0x0a6c
+
+#define MT_PAUSE_ENABLE_CONTROL1 0x0a38
+
+#define MT_MAC_CSR0 0x1000
+
+#define MT_MAC_SYS_CTRL 0x1004
+#define MT_MAC_SYS_CTRL_RESET_CSR BIT(0)
+#define MT_MAC_SYS_CTRL_RESET_BBP BIT(1)
+#define MT_MAC_SYS_CTRL_ENABLE_TX BIT(2)
+#define MT_MAC_SYS_CTRL_ENABLE_RX BIT(3)
+
+#define MT_MAC_ADDR_DW0 0x1008
+#define MT_MAC_ADDR_DW1 0x100c
+#define MT_MAC_ADDR_DW1_U2ME_MASK GENMASK(23, 16)
+
+#define MT_MAC_BSSID_DW0 0x1010
+#define MT_MAC_BSSID_DW1 0x1014
+#define MT_MAC_BSSID_DW1_ADDR GENMASK(15, 0)
+#define MT_MAC_BSSID_DW1_MBSS_MODE GENMASK(17, 16)
+#define MT_MAC_BSSID_DW1_MBEACON_N GENMASK(20, 18)
+#define MT_MAC_BSSID_DW1_MBSS_LOCAL_BIT BIT(21)
+#define MT_MAC_BSSID_DW1_MBSS_MODE_B2 BIT(22)
+#define MT_MAC_BSSID_DW1_MBEACON_N_B3 BIT(23)
+#define MT_MAC_BSSID_DW1_MBSS_IDX_BYTE GENMASK(26, 24)
+
+#define MT_MAX_LEN_CFG 0x1018
+#define MT_MAX_LEN_CFG_AMPDU GENMASK(13, 12)
+
+#define MT_LED_CFG 0x102c
+
+#define MT_AMPDU_MAX_LEN_20M1S 0x1030
+#define MT_AMPDU_MAX_LEN_20M2S 0x1034
+#define MT_AMPDU_MAX_LEN_40M1S 0x1038
+#define MT_AMPDU_MAX_LEN_40M2S 0x103c
+#define MT_AMPDU_MAX_LEN 0x1040
+
+#define MT_WCID_DROP_BASE 0x106c
+#define MT_WCID_DROP(n) (MT_WCID_DROP_BASE + ((n) >> 5) * 4)
+#define MT_WCID_DROP_MASK(n) BIT((n) % 32)
+
+#define MT_BCN_BYPASS_MASK 0x108c
+
+#define MT_MAC_APC_BSSID_BASE 0x1090
+#define MT_MAC_APC_BSSID_L(n) (MT_MAC_APC_BSSID_BASE + ((n) * 8))
+#define MT_MAC_APC_BSSID_H(n) (MT_MAC_APC_BSSID_BASE + ((n) * 8 + 4))
+#define MT_MAC_APC_BSSID_H_ADDR GENMASK(15, 0)
+#define MT_MAC_APC_BSSID0_H_EN BIT(16)
+
+#define MT_XIFS_TIME_CFG 0x1100
+#define MT_XIFS_TIME_CFG_CCK_SIFS GENMASK(7, 0)
+#define MT_XIFS_TIME_CFG_OFDM_SIFS GENMASK(15, 8)
+#define MT_XIFS_TIME_CFG_OFDM_XIFS GENMASK(19, 16)
+#define MT_XIFS_TIME_CFG_EIFS GENMASK(28, 20)
+#define MT_XIFS_TIME_CFG_BB_RXEND_EN BIT(29)
+
+#define MT_BKOFF_SLOT_CFG 0x1104
+#define MT_BKOFF_SLOT_CFG_SLOTTIME GENMASK(7, 0)
+#define MT_BKOFF_SLOT_CFG_CC_DELAY GENMASK(11, 8)
+
+#define MT_CH_TIME_CFG 0x110c
+#define MT_CH_TIME_CFG_TIMER_EN BIT(0)
+#define MT_CH_TIME_CFG_TX_AS_BUSY BIT(1)
+#define MT_CH_TIME_CFG_RX_AS_BUSY BIT(2)
+#define MT_CH_TIME_CFG_NAV_AS_BUSY BIT(3)
+#define MT_CH_TIME_CFG_EIFS_AS_BUSY BIT(4)
+#define MT_CH_TIME_CFG_MDRDY_CNT_EN BIT(5)
+#define MT_CH_CCA_RC_EN BIT(6)
+#define MT_CH_TIME_CFG_CH_TIMER_CLR GENMASK(9, 8)
+#define MT_CH_TIME_CFG_MDRDY_CLR GENMASK(11, 10)
+
+#define MT_PBF_LIFE_TIMER 0x1110
+
+#define MT_BEACON_TIME_CFG 0x1114
+#define MT_BEACON_TIME_CFG_INTVAL GENMASK(15, 0)
+#define MT_BEACON_TIME_CFG_TIMER_EN BIT(16)
+#define MT_BEACON_TIME_CFG_SYNC_MODE GENMASK(18, 17)
+#define MT_BEACON_TIME_CFG_TBTT_EN BIT(19)
+#define MT_BEACON_TIME_CFG_BEACON_TX BIT(20)
+#define MT_BEACON_TIME_CFG_TSF_COMP GENMASK(31, 24)
+
+#define MT_TBTT_SYNC_CFG 0x1118
+#define MT_TSF_TIMER_DW0 0x111c
+#define MT_TSF_TIMER_DW1 0x1120
+#define MT_TBTT_TIMER 0x1124
+#define MT_TBTT_TIMER_VAL GENMASK(16, 0)
+
+#define MT_INT_TIMER_CFG 0x1128
+#define MT_INT_TIMER_CFG_PRE_TBTT GENMASK(15, 0)
+#define MT_INT_TIMER_CFG_GP_TIMER GENMASK(31, 16)
+
+#define MT_INT_TIMER_EN 0x112c
+#define MT_INT_TIMER_EN_PRE_TBTT_EN BIT(0)
+#define MT_INT_TIMER_EN_GP_TIMER_EN BIT(1)
+
+#define MT_CH_IDLE 0x1130
+#define MT_CH_BUSY 0x1134
+#define MT_EXT_CH_BUSY 0x1138
+#define MT_ED_CCA_TIMER 0x1140
+
+#define MT_MAC_STATUS 0x1200
+#define MT_MAC_STATUS_TX BIT(0)
+#define MT_MAC_STATUS_RX BIT(1)
+
+#define MT_PWR_PIN_CFG 0x1204
+#define MT_AUX_CLK_CFG 0x120c
+
+#define MT_BB_PA_MODE_CFG0 0x1214
+#define MT_BB_PA_MODE_CFG1 0x1218
+#define MT_RF_PA_MODE_CFG0 0x121c
+#define MT_RF_PA_MODE_CFG1 0x1220
+
+#define MT_RF_PA_MODE_ADJ0 0x1228
+#define MT_RF_PA_MODE_ADJ1 0x122c
+
+#define MT_DACCLK_EN_DLY_CFG 0x1264
+
+#define MT_EDCA_CFG_BASE 0x1300
+#define MT_EDCA_CFG_AC(n) (MT_EDCA_CFG_BASE + ((n) << 2))
+#define MT_EDCA_CFG_TXOP GENMASK(7, 0)
+#define MT_EDCA_CFG_AIFSN GENMASK(11, 8)
+#define MT_EDCA_CFG_CWMIN GENMASK(15, 12)
+#define MT_EDCA_CFG_CWMAX GENMASK(19, 16)
+
+#define MT_TX_PWR_CFG_0 0x1314
+#define MT_TX_PWR_CFG_1 0x1318
+#define MT_TX_PWR_CFG_2 0x131c
+#define MT_TX_PWR_CFG_3 0x1320
+#define MT_TX_PWR_CFG_4 0x1324
+#define MT_TX_PIN_CFG 0x1328
+#define MT_TX_PIN_CFG_TXANT GENMASK(3, 0)
+#define MT_TX_PIN_CFG_RXANT GENMASK(11, 8)
+#define MT_TX_PIN_RFTR_EN BIT(16)
+#define MT_TX_PIN_TRSW_EN BIT(18)
+
+#define MT_TX_BAND_CFG 0x132c
+#define MT_TX_BAND_CFG_UPPER_40M BIT(0)
+#define MT_TX_BAND_CFG_5G BIT(1)
+#define MT_TX_BAND_CFG_2G BIT(2)
+
+#define MT_HT_FBK_TO_LEGACY 0x1384
+#define MT_TX_MPDU_ADJ_INT 0x1388
+
+#define MT_TX_PWR_CFG_7 0x13d4
+#define MT_TX_PWR_CFG_8 0x13d8
+#define MT_TX_PWR_CFG_9 0x13dc
+
+#define MT_TX_SW_CFG0 0x1330
+#define MT_TX_SW_CFG1 0x1334
+#define MT_TX_SW_CFG2 0x1338
+
+#define MT_TXOP_CTRL_CFG 0x1340
+#define MT_TXOP_TRUN_EN GENMASK(5, 0)
+#define MT_TXOP_EXT_CCA_DLY GENMASK(15, 8)
+#define MT_TXOP_ED_CCA_EN BIT(20)
+
+#define MT_TX_RTS_CFG 0x1344
+#define MT_TX_RTS_CFG_RETRY_LIMIT GENMASK(7, 0)
+#define MT_TX_RTS_CFG_THRESH GENMASK(23, 8)
+#define MT_TX_RTS_FALLBACK BIT(24)
+
+#define MT_TX_TIMEOUT_CFG 0x1348
+#define MT_TX_TIMEOUT_CFG_ACKTO GENMASK(15, 8)
+
+#define MT_TX_RETRY_CFG 0x134c
+#define MT_TX_LINK_CFG 0x1350
+#define MT_TX_CFACK_EN BIT(12)
+#define MT_VHT_HT_FBK_CFG0 0x1354
+#define MT_VHT_HT_FBK_CFG1 0x1358
+#define MT_LG_FBK_CFG0 0x135c
+#define MT_LG_FBK_CFG1 0x1360
+
+#define MT_PROT_CFG_RATE GENMASK(15, 0)
+#define MT_PROT_CFG_CTRL GENMASK(17, 16)
+#define MT_PROT_CFG_NAV GENMASK(19, 18)
+#define MT_PROT_CFG_TXOP_ALLOW GENMASK(25, 20)
+#define MT_PROT_CFG_RTS_THRESH BIT(26)
+
+#define MT_CCK_PROT_CFG 0x1364
+#define MT_OFDM_PROT_CFG 0x1368
+#define MT_MM20_PROT_CFG 0x136c
+#define MT_MM40_PROT_CFG 0x1370
+#define MT_GF20_PROT_CFG 0x1374
+#define MT_GF40_PROT_CFG 0x1378
+
+#define MT_PROT_RATE GENMASK(15, 0)
+#define MT_PROT_CTRL_RTS_CTS BIT(16)
+#define MT_PROT_CTRL_CTS2SELF BIT(17)
+#define MT_PROT_NAV_SHORT BIT(18)
+#define MT_PROT_NAV_LONG BIT(19)
+#define MT_PROT_TXOP_ALLOW_CCK BIT(20)
+#define MT_PROT_TXOP_ALLOW_OFDM BIT(21)
+#define MT_PROT_TXOP_ALLOW_MM20 BIT(22)
+#define MT_PROT_TXOP_ALLOW_MM40 BIT(23)
+#define MT_PROT_TXOP_ALLOW_GF20 BIT(24)
+#define MT_PROT_TXOP_ALLOW_GF40 BIT(25)
+#define MT_PROT_RTS_THR_EN BIT(26)
+#define MT_PROT_RATE_CCK_11 0x0003
+#define MT_PROT_RATE_OFDM_6 0x2000
+#define MT_PROT_RATE_OFDM_24 0x2004
+#define MT_PROT_RATE_DUP_OFDM_24 0x2084
+#define MT_PROT_RATE_SGI_OFDM_24 0x2104
+#define MT_PROT_TXOP_ALLOW_ALL GENMASK(25, 20)
+#define MT_PROT_TXOP_ALLOW_BW20 (MT_PROT_TXOP_ALLOW_ALL & \
+	~MT_PROT_TXOP_ALLOW_MM40 & \
+	~MT_PROT_TXOP_ALLOW_GF40)
+
+#define MT_EXP_ACK_TIME 0x1380
+
+#define MT_TX_PWR_CFG_0_EXT 0x1390
+#define MT_TX_PWR_CFG_1_EXT 0x1394
+
+#define MT_TX_FBK_LIMIT 0x1398
+#define MT_TX_FBK_LIMIT_MPDU_FBK GENMASK(7, 0)
+#define MT_TX_FBK_LIMIT_AMPDU_FBK GENMASK(15, 8)
+#define MT_TX_FBK_LIMIT_MPDU_UP_CLEAR BIT(16)
+#define MT_TX_FBK_LIMIT_AMPDU_UP_CLEAR BIT(17)
+#define MT_TX_FBK_LIMIT_RATE_LUT BIT(18)
+
+#define MT_TX0_RF_GAIN_CORR 0x13a0
+#define MT_TX1_RF_GAIN_CORR 0x13a4
+#define MT_TX0_RF_GAIN_ATTEN 0x13a8
+
+#define MT_TX_ALC_CFG_0 0x13b0
+#define MT_TX_ALC_CFG_0_CH_INIT_0 GENMASK(5, 0)
+#define MT_TX_ALC_CFG_0_CH_INIT_1 GENMASK(13, 8)
+#define MT_TX_ALC_CFG_0_LIMIT_0 GENMASK(21, 16)
+#define MT_TX_ALC_CFG_0_LIMIT_1 GENMASK(29, 24)
+
+#define MT_TX_ALC_CFG_1 0x13b4
+#define MT_TX_ALC_CFG_1_TEMP_COMP GENMASK(5, 0)
+
+#define MT_TX_ALC_CFG_2 0x13a8
+#define MT_TX_ALC_CFG_2_TEMP_COMP GENMASK(5, 0)
+
+#define MT_TX_ALC_CFG_3 0x13ac
+#define MT_TX_ALC_CFG_4 0x13c0
+#define MT_TX_ALC_CFG_4_LOWGAIN_CH_EN BIT(31)
+
+#define MT_TX_ALC_VGA3 0x13c8
+
+#define MT_TX_PROT_CFG6 0x13e0
+#define MT_TX_PROT_CFG7 0x13e4
+#define MT_TX_PROT_CFG8 0x13e8
+
+#define MT_PIFS_TX_CFG 0x13ec
+
+#define MT_RX_FILTR_CFG 0x1400
+
+#define MT_RX_FILTR_CFG_CRC_ERR BIT(0)
+#define MT_RX_FILTR_CFG_PHY_ERR BIT(1)
+#define MT_RX_FILTR_CFG_PROMISC BIT(2)
+#define MT_RX_FILTR_CFG_OTHER_BSS BIT(3)
+#define MT_RX_FILTR_CFG_VER_ERR BIT(4)
+#define MT_RX_FILTR_CFG_MCAST BIT(5)
+#define MT_RX_FILTR_CFG_BCAST BIT(6)
+#define MT_RX_FILTR_CFG_DUP BIT(7)
+#define MT_RX_FILTR_CFG_CFACK BIT(8)
+#define MT_RX_FILTR_CFG_CFEND BIT(9)
+#define MT_RX_FILTR_CFG_ACK BIT(10)
+#define MT_RX_FILTR_CFG_CTS BIT(11)
+#define MT_RX_FILTR_CFG_RTS BIT(12)
+#define MT_RX_FILTR_CFG_PSPOLL BIT(13)
+#define MT_RX_FILTR_CFG_BA BIT(14)
+#define MT_RX_FILTR_CFG_BAR BIT(15)
+#define MT_RX_FILTR_CFG_CTRL_RSV BIT(16)
+
+#define MT_AUTO_RSP_CFG 0x1404
+#define MT_AUTO_RSP_EN BIT(0)
+#define MT_AUTO_RSP_PREAMB_SHORT BIT(4)
+#define MT_LEGACY_BASIC_RATE 0x1408
+#define MT_HT_BASIC_RATE 0x140c
+
+#define MT_HT_CTRL_CFG 0x1410
+#define MT_RX_PARSER_CFG 0x1418
+#define MT_RX_PARSER_RX_SET_NAV_ALL BIT(0)
+
+#define MT_EXT_CCA_CFG 0x141c
+#define MT_EXT_CCA_CFG_CCA0 GENMASK(1, 0)
+#define MT_EXT_CCA_CFG_CCA1 GENMASK(3, 2)
+#define MT_EXT_CCA_CFG_CCA2 GENMASK(5, 4)
+#define MT_EXT_CCA_CFG_CCA3 GENMASK(7, 6)
+#define MT_EXT_CCA_CFG_CCA_MASK GENMASK(11, 8)
+#define MT_EXT_CCA_CFG_ED_CCA_MASK GENMASK(15, 12)
+
+#define MT_TX_SW_CFG3 0x1478
+
+#define MT_PN_PAD_MODE 0x150c
+
+#define MT_TXOP_HLDR_ET 0x1608
+#define MT_TXOP_HLDR_TX40M_BLK_EN BIT(1)
+
+#define MT_PROT_AUTO_TX_CFG 0x1648
+#define MT_PROT_AUTO_TX_CFG_PROT_PADJ GENMASK(11, 8)
+#define MT_PROT_AUTO_TX_CFG_AUTO_PADJ GENMASK(27, 24)
+
+#define MT_RX_STAT_0 0x1700
+#define MT_RX_STAT_0_CRC_ERRORS GENMASK(15, 0)
+#define MT_RX_STAT_0_PHY_ERRORS GENMASK(31, 16)
+
+#define MT_RX_STAT_1 0x1704
+#define MT_RX_STAT_1_CCA_ERRORS GENMASK(15, 0)
+#define MT_RX_STAT_1_PLCP_ERRORS GENMASK(31, 16)
+
+#define MT_RX_STAT_2 0x1708
+#define MT_RX_STAT_2_DUP_ERRORS GENMASK(15, 0)
+#define MT_RX_STAT_2_OVERFLOW_ERRORS GENMASK(31, 16)
+
+#define MT_TX_STA_0 0x170c
+#define MT_TX_STA_1 0x1710
+#define MT_TX_STA_2 0x1714
+
+#define MT_TX_STAT_FIFO 0x1718
+#define MT_TX_STAT_FIFO_VALID BIT(0)
+#define MT_TX_STAT_FIFO_SUCCESS BIT(5)
+#define MT_TX_STAT_FIFO_AGGR BIT(6)
+#define MT_TX_STAT_FIFO_ACKREQ BIT(7)
+#define MT_TX_STAT_FIFO_WCID GENMASK(15, 8)
+#define MT_TX_STAT_FIFO_RATE GENMASK(31, 16)
+
+#define MT_TX_AGG_STAT 0x171c
+
+#define MT_TX_AGG_CNT_BASE0 0x1720
+#define MT_MPDU_DENSITY_CNT 0x1740
+#define MT_TX_AGG_CNT_BASE1 0x174c
+
+#define MT_TX_STAT_FIFO_EXT 0x1798
+#define MT_TX_STAT_FIFO_EXT_RETRY GENMASK(7, 0)
+#define MT_TX_STAT_FIFO_EXT_PKTID GENMASK(15, 8)
+
+#define MT_WCID_TX_RATE_BASE 0x1c00
+#define MT_WCID_TX_RATE(i) (MT_WCID_TX_RATE_BASE + ((i) << 3))
+
+#define MT_BBP_CORE_BASE 0x2000
+#define MT_BBP_IBI_BASE 0x2100
+#define MT_BBP_AGC_BASE 0x2300
+#define MT_BBP_TXC_BASE 0x2400
+#define MT_BBP_RXC_BASE 0x2500
+#define MT_BBP_TXO_BASE 0x2600
+#define MT_BBP_TXBE_BASE 0x2700
+#define MT_BBP_RXFE_BASE 0x2800
+#define MT_BBP_RXO_BASE 0x2900
+#define MT_BBP_DFS_BASE 0x2a00
+#define MT_BBP_TR_BASE 0x2b00
+#define MT_BBP_CAL_BASE 0x2c00
+#define MT_BBP_DSC_BASE 0x2e00
+#define MT_BBP_PFMU_BASE 0x2f00
+
+#define MT_BBP(type, n) (MT_BBP_##type##_BASE + ((n) << 2))
+
+#define MT_BBP_CORE_R1_BW GENMASK(4, 3)
+
+#define MT_BBP_AGC_R0_CTRL_CHAN GENMASK(9, 8)
+#define MT_BBP_AGC_R0_BW GENMASK(14, 12)
+
+/* AGC, R4/R5 */
+#define MT_BBP_AGC_LNA_HIGH_GAIN GENMASK(21, 16)
+#define MT_BBP_AGC_LNA_MID_GAIN GENMASK(13, 8)
+#define MT_BBP_AGC_LNA_LOW_GAIN GENMASK(5, 0)
+
+/* AGC, R6/R7 */
+#define MT_BBP_AGC_LNA_ULOW_GAIN GENMASK(5, 0)
+
+/* AGC, R8/R9 */
+#define MT_BBP_AGC_LNA_GAIN_MODE GENMASK(7, 6)
+#define MT_BBP_AGC_GAIN GENMASK(14, 8)
+
+#define MT_BBP_AGC20_RSSI0 GENMASK(7, 0)
+#define MT_BBP_AGC20_RSSI1 GENMASK(15, 8)
+
+#define MT_BBP_TXBE_R0_CTRL_CHAN GENMASK(1, 0)
+
+#define MT_WCID_ADDR_BASE 0x1800
+#define MT_WCID_ADDR(n) (MT_WCID_ADDR_BASE + (n) * 8)
+
+#define MT_SRAM_BASE 0x4000
+
+#define MT_WCID_KEY_BASE 0x8000
+#define MT_WCID_KEY(n) (MT_WCID_KEY_BASE + (n) * 32)
+
+#define MT_WCID_IV_BASE 0xa000
+#define MT_WCID_IV(n) (MT_WCID_IV_BASE + (n) * 8)
+
+#define MT_WCID_ATTR_BASE 0xa800
+#define MT_WCID_ATTR(n) (MT_WCID_ATTR_BASE + (n) * 4)
+
+#define MT_WCID_ATTR_PAIRWISE BIT(0)
+#define MT_WCID_ATTR_PKEY_MODE GENMASK(3, 1)
+#define MT_WCID_ATTR_BSS_IDX GENMASK(6, 4)
+#define MT_WCID_ATTR_RXWI_UDF GENMASK(9, 7)
+#define MT_WCID_ATTR_PKEY_MODE_EXT BIT(10)
+#define MT_WCID_ATTR_BSS_IDX_EXT BIT(11)
+#define MT_WCID_ATTR_WAPI_MCBC BIT(15)
+#define MT_WCID_ATTR_WAPI_KEYID GENMASK(31, 24)
+
+#define MT_SKEY_BASE_0 0xac00
+#define MT_SKEY_BASE_1 0xb400
+#define MT_SKEY_0(bss, idx) (MT_SKEY_BASE_0 + (4 * (bss) + (idx)) * 32)
+#define MT_SKEY_1(bss, idx) (MT_SKEY_BASE_1 + (4 * ((bss) & 7) + (idx)) * 32)
+
+#define MT_SKEY_MODE_BASE_0 0xb000
+#define MT_SKEY_MODE_BASE_1 0xb3f0
+#define MT_SKEY_MODE_0(bss) (MT_SKEY_MODE_BASE_0 + (((bss) / 2) << 2))
+#define MT_SKEY_MODE_1(bss) (MT_SKEY_MODE_BASE_1 + ((((bss) & 7) / 2) << 2))
+#define MT_SKEY_MODE_MASK GENMASK(3, 0)
+#define MT_SKEY_MODE_SHIFT(bss, idx) (4 * ((idx) + 4 * ((bss) & 1)))
+
+#define MT_BEACON_BASE 0xc000
+
+#define MT_TEMP_SENSOR 0x01d000
+#define MT_TEMP_SENSOR_VAL GENMASK(6, 0)
+
+#define MT_MCU_RESET_CTL 0x070c
+#define MT_MCU_INT_LEVEL 0x0718
+#define MT_MCU_COM_REG0 0x0730
+#define MT_MCU_COM_REG1 0x0734
+#define MT_MCU_COM_REG2 0x0738
+#define MT_MCU_COM_REG3 0x073c
+
+#define MT_MCU_MEMMAP_WLAN 0x410000
+
+#define MT_TXD_INFO_LEN GENMASK(15, 0)
+#define MT_TXD_INFO_NEXT_VLD BIT(16)
+#define MT_TXD_INFO_TX_BURST BIT(17)
+#define MT_TXD_INFO_80211 BIT(19)
+#define MT_TXD_INFO_TSO BIT(20)
+#define MT_TXD_INFO_CSO BIT(21)
+#define MT_TXD_INFO_WIV BIT(24)
+#define MT_TXD_INFO_QSEL GENMASK(26, 25)
+#define MT_TXD_INFO_DPORT GENMASK(29, 27)
+#define MT_TXD_INFO_TYPE GENMASK(31, 30)
+
+#define MT_RX_FCE_INFO_LEN GENMASK(13, 0)
+#define MT_RX_FCE_INFO_SELF_GEN BIT(15)
+#define MT_RX_FCE_INFO_CMD_SEQ GENMASK(19, 16)
+#define MT_RX_FCE_INFO_EVT_TYPE GENMASK(23, 20)
+#define MT_RX_FCE_INFO_PCIE_INTR BIT(24)
+#define MT_RX_FCE_INFO_QSEL GENMASK(26, 25)
+#define MT_RX_FCE_INFO_D_PORT GENMASK(29, 27)
+#define MT_RX_FCE_INFO_TYPE GENMASK(31, 30)
+
+#define MT_MCU_MSG_LEN GENMASK(15, 0)
+#define MT_MCU_MSG_CMD_SEQ GENMASK(19, 16)
+#define MT_MCU_MSG_CMD_TYPE GENMASK(26, 20)
+#define MT_MCU_MSG_PORT GENMASK(29, 27)
+#define MT_MCU_MSG_TYPE GENMASK(31, 30)
+#define MT_MCU_MSG_TYPE_CMD BIT(30)
+
+#define MT_FCE_DMA_ADDR 0x0230
+#define MT_FCE_DMA_LEN 0x0234
+
+#define MT_TX_CPU_FROM_FCE_CPU_DESC_IDX 0x09a8
+
+#define MT_PKTID_RATE GENMASK(4, 0)
+#define MT_PKTID_AC GENMASK(6, 5)
+
+#define MT_RXINFO_BA BIT(0)
+#define MT_RXINFO_DATA BIT(1)
+#define MT_RXINFO_NULL BIT(2)
+#define MT_RXINFO_FRAG BIT(3)
+#define MT_RXINFO_UNICAST BIT(4)
+#define MT_RXINFO_MULTICAST BIT(5)
+#define MT_RXINFO_BROADCAST BIT(6)
+#define MT_RXINFO_MYBSS BIT(7)
+#define MT_RXINFO_CRCERR BIT(8)
+#define MT_RXINFO_ICVERR BIT(9)
+#define MT_RXINFO_MICERR BIT(10)
+#define MT_RXINFO_AMSDU BIT(11)
+#define MT_RXINFO_HTC BIT(12)
+#define MT_RXINFO_RSSI BIT(13)
+#define MT_RXINFO_L2PAD BIT(14)
+#define MT_RXINFO_AMPDU BIT(15)
+#define MT_RXINFO_DECRYPT BIT(16)
+#define MT_RXINFO_BSSIDX3 BIT(17)
+#define MT_RXINFO_WAPI_KEY BIT(18)
+#define MT_RXINFO_PN_LEN GENMASK(21, 19)
+#define MT_RXINFO_SW_FTYPE0 BIT(22)
+#define MT_RXINFO_SW_FTYPE1 BIT(23)
+#define MT_RXINFO_PROBE_RESP BIT(24)
+#define MT_RXINFO_BEACON BIT(25)
+#define MT_RXINFO_DISASSOC BIT(26)
+#define MT_RXINFO_DEAUTH BIT(27)
+#define MT_RXINFO_ACTION BIT(28)
+#define MT_RXINFO_TCP_SUM_ERR BIT(30)
+#define MT_RXINFO_IP_SUM_ERR BIT(31)
+
+#define MT_RXWI_CTL_WCID GENMASK(7, 0)
+#define MT_RXWI_CTL_KEY_IDX GENMASK(9, 8)
+#define MT_RXWI_CTL_BSS_IDX GENMASK(12, 10)
+#define MT_RXWI_CTL_UDF GENMASK(15, 13)
+#define MT_RXWI_CTL_MPDU_LEN GENMASK(29, 16)
+#define MT_RXWI_CTL_EOF BIT(31)
+
+#define MT_RXWI_TID GENMASK(3, 0)
+#define MT_RXWI_SN GENMASK(15, 4)
+
+#define MT_RXWI_RATE_INDEX GENMASK(5, 0)
+#define MT_RXWI_RATE_LDPC BIT(6)
+#define MT_RXWI_RATE_BW GENMASK(8, 7)
+#define MT_RXWI_RATE_SGI BIT(9)
+#define MT_RXWI_RATE_STBC BIT(10)
+#define MT_RXWI_RATE_LDPC_EXSYM BIT(11)
+#define MT_RXWI_RATE_PHY GENMASK(15, 13)
+
+#define MT_RATE_INDEX_VHT_IDX GENMASK(3, 0)
+#define MT_RATE_INDEX_VHT_NSS GENMASK(5, 4)
+
+#define MT_TX_PWR_ADJ GENMASK(3, 0)
+
+#define MT_TXWI_FLAGS_FRAG BIT(0)
+#define MT_TXWI_FLAGS_MMPS BIT(1)
+#define MT_TXWI_FLAGS_CFACK BIT(2)
+#define MT_TXWI_FLAGS_TS BIT(3)
+#define MT_TXWI_FLAGS_AMPDU BIT(4)
+#define MT_TXWI_FLAGS_MPDU_DENSITY GENMASK(7, 5)
+#define MT_TXWI_FLAGS_TXOP GENMASK(9, 8)
+#define MT_TXWI_FLAGS_NDPS BIT(10)
+#define MT_TXWI_FLAGS_RTSBWSIG BIT(11)
+#define MT_TXWI_FLAGS_NDP_BW GENMASK(13, 12)
+#define MT_TXWI_FLAGS_SOUND BIT(14)
+#define MT_TXWI_FLAGS_TX_RATE_LUT BIT(15)
+
+#define MT_TXWI_ACK_CTL_REQ BIT(0)
+#define MT_TXWI_ACK_CTL_NSEQ BIT(1)
+#define MT_TXWI_ACK_CTL_BA_WINDOW GENMASK(7, 2)
+
+#define MT_EE_ANTENNA_DUAL BIT(15)
+
+#define MT_EE_NIC_CONF_0_RX_PATH GENMASK(3, 0)
+#define MT_EE_NIC_CONF_0_TX_PATH GENMASK(7, 4)
+#define MT_EE_NIC_CONF_0_PA_TYPE GENMASK(9, 8)
+#define MT_EE_NIC_CONF_0_PA_INT_2G BIT(8)
+#define MT_EE_NIC_CONF_0_PA_INT_5G BIT(9)
+#define MT_EE_NIC_CONF_0_PA_IO_CURRENT BIT(10)
+#define MT_EE_NIC_CONF_0_BOARD_TYPE GENMASK(13, 12)
+
+#define MT_EE_NIC_CONF_1_HW_RF_CTRL BIT(0)
+#define MT_EE_NIC_CONF_1_TEMP_TX_ALC BIT(1)
+#define MT_EE_NIC_CONF_1_LNA_EXT_2G BIT(2)
+#define MT_EE_NIC_CONF_1_LNA_EXT_5G BIT(3)
+#define MT_EE_NIC_CONF_1_TX_ALC_EN BIT(13)
+
+#define MT_EE_NIC_CONF_2_ANT_OPT BIT(3)
+#define MT_EE_NIC_CONF_2_ANT_DIV BIT(4)
+#define MT_EE_NIC_CONF_2_XTAL_OPTION GENMASK(10, 9)
+
+#define MT_VEND_TYPE_CFG BIT(30)
+
+#define MT_CMD_HDR_LEN 4
+
+enum mt76_vendor_req {
+	MT_VEND_DEV_MODE = 0x01,
+	MT_VEND_WRITE = 0x02,
+	MT_VEND_POWER_ON = 0x04,
+	MT_VEND_MULTI_WRITE = 0x06,
+	MT_VEND_MULTI_READ = 0x07,
+	MT_VEND_READ_EEPROM = 0x09,
+	MT_VEND_WRITE_FCE = 0x42,
+	MT_VEND_WRITE_CFG = 0x46,
+	MT_VEND_READ_CFG = 0x47,
+	MT_VEND_READ_EXT = 0x63,
+	MT_VEND_WRITE_EXT = 0x66,
+	MT_VEND_FEATURE_SET = 0x91,
+};
+
+enum mt76_dma_msg_port {
+	MT_WLAN_PORT,
+	MT_CPU_RX_PORT,
+	MT_CPU_TX_PORT,
+	MT_HOST_PORT,
+	MT_VIRTUAL_CPU_RX_PORT,
+	MT_VIRTUAL_CPU_TX_PORT,
+	MT_DISCARD,
+};
+
+enum mt76_mcu_cmd {
+	MT_CMD_FUN_SET_OP = 1,
+	MT_CMD_LOAD_CR = 2,
+	MT_CMD_INIT_GAIN_OP = 3,
+	MT_CMD_DYNC_VGA_OP = 6,
+	MT_CMD_TDLS_CH_SW = 7,
+	MT_CMD_BURST_WRITE = 8,
+	MT_CMD_READ_MODIFY_WRITE = 9,
+	MT_CMD_RANDOM_READ = 10,
+	MT_CMD_BURST_READ = 11,
+	MT_CMD_RANDOM_WRITE = 12,
+	MT_CMD_LED_MODE_OP = 16,
+	MT_CMD_POWER_SAVING_OP = 20,
+	MT_CMD_WOW_CONFIG = 21,
+	MT_CMD_WOW_QUERY = 22,
+	MT_CMD_WOW_FEATURE = 24,
+	MT_CMD_CARRIER_DETECT_OP = 28,
+	MT_CMD_RADOR_DETECT_OP = 29,
+	MT_CMD_SWITCH_CHANNEL_OP = 30,
+	MT_CMD_CALIBRATION_OP = 31,
+	MT_CMD_BEACON_OP = 32,
+	MT_CMD_ANTENNA_OP = 33,
+};
+
+enum mt76_mcu_function {
+	MT_Q_SELECT = 1,
+	MT_BW_SETTING = 2,
+	MT_USB2_SW_DISCONNECT = 2,
+	MT_USB3_SW_DISCONNECT = 3,
+	MT_LOG_FW_DEBUG_MSG = 4,
+	MT_GET_FW_VERSION = 5,
+};
+
+enum mt76_mcu_cr_mode {
+	MT_RF_CR,
+	MT_BBP_CR,
+	MT_RF_BBP_CR,
+	MT_HL_TEMP_CR_UPDATE,
+};
+
+enum mt76_mcu_power_mode {
+	MT_RADIO_OFF = 0x30,
+	MT_RADIO_ON = 0x31,
+	MT_RADIO_OFF_AUTO_WAKEUP = 0x32,
+	MT_RADIO_OFF_ADVANCE = 0x33,
+	MT_RADIO_ON_ADVANCE = 0x34,
+};
+
+enum mt76_mcu_calibration {
+	MT_MCU_CAL_R = 1,
+	MT_MCU_CAL_TEMP_SENSOR,
+	MT_MCU_CAL_RXDCOC,
+	MT_MCU_CAL_RC,
+	MT_MCU_CAL_SX_LOGEN,
+	MT_MCU_CAL_LC,
+	MT_MCU_CAL_TX_LOFT,
+	MT_MCU_CAL_TXIQ,
+	MT_MCU_CAL_TSSI,
+	MT_MCU_CAL_TSSI_COMP,
+	MT_MCU_CAL_DPD,
+	MT_MCU_CAL_RXIQC_FI,
+	MT_MCU_CAL_RXIQC_FD,
+	MT_MCU_CAL_PWRON,
+	MT_MCU_CAL_TX_SHAPING,
+};
+
+enum mt76_eeprom_mode {
+	MT_EE_READ,
+	MT_EE_PHYSICAL_READ,
+};
+
+enum mt76_eeprom_field {
+	MT_EE_CHIP_ID = 0x0000,
+	MT_EE_VERSION = 0x0002,
+	MT_EE_MAC_ADDR = 0x0004,
+	MT_EE_PCI_ID = 0x000a,
+	MT_EE_ANTENNA = 0x0022,
+	MT_EE_CFG1_INIT = 0x0024,
+	MT_EE_NIC_CONF_0 = 0x0034,
+	MT_EE_NIC_CONF_1 = 0x0036,
+	MT_EE_COUNTRY_REGION_5GHZ = 0x0038,
+	MT_EE_COUNTRY_REGION_2GHZ = 0x0039,
+	MT_EE_FREQ_OFFSET = 0x003a,
+	MT_EE_NIC_CONF_2 = 0x0042,
+
+	MT_EE_XTAL_TRIM_1 = 0x003a,
+	MT_EE_XTAL_TRIM_2 = 0x009e,
+
+	MT_EE_LNA_GAIN = 0x0044,
+	MT_EE_RSSI_OFFSET_2G_0 = 0x0046,
+	MT_EE_RSSI_OFFSET_2G_1 = 0x0048,
+	MT_EE_LNA_GAIN_5GHZ_1 = 0x0049,
+	MT_EE_RSSI_OFFSET_5G_0 = 0x004a,
+	MT_EE_RSSI_OFFSET_5G_1 = 0x004c,
+	MT_EE_LNA_GAIN_5GHZ_2 = 0x004d,
+
+	MT_EE_TX_POWER_DELTA_BW40 = 0x0050,
+	MT_EE_TX_POWER_DELTA_BW80 = 0x0052,
+
+	MT_EE_TX_POWER_EXT_PA_5G = 0x0054,
+
+	MT_EE_TX_POWER_0_START_2G = 0x0056,
+	MT_EE_TX_POWER_1_START_2G = 0x005c,
+
+#define MT_TX_POWER_GROUP_SIZE_5G 5
+#define MT_TX_POWER_GROUPS_5G 6
+	MT_EE_TX_POWER_0_START_5G = 0x0062,
+	MT_EE_TSSI_SLOPE_2G = 0x006e,
+
+	MT_EE_TX_POWER_0_GRP3_TX_POWER_DELTA = 0x0074,
+	MT_EE_TX_POWER_0_GRP4_TSSI_SLOPE = 0x0076,
+
+	MT_EE_TX_POWER_1_START_5G = 0x0080,
+
+	MT_EE_TX_POWER_CCK = 0x00a0,
+	MT_EE_TX_POWER_OFDM_2G_6M = 0x00a2,
+	MT_EE_TX_POWER_OFDM_2G_24M = 0x00a4,
+	MT_EE_TX_POWER_OFDM_5G_6M = 0x00b2,
+	MT_EE_TX_POWER_OFDM_5G_24M = 0x00b4,
+	MT_EE_TX_POWER_HT_MCS0 = 0x00a6,
+	MT_EE_TX_POWER_HT_MCS4 = 0x00a8,
+	MT_EE_TX_POWER_HT_MCS8 = 0x00aa,
+	MT_EE_TX_POWER_HT_MCS12 = 0x00ac,
+	MT_EE_TX_POWER_VHT_MCS0 = 0x00ba,
+	MT_EE_TX_POWER_VHT_MCS4 = 0x00bc,
+	MT_EE_TX_POWER_VHT_MCS8 = 0x00be,
+
+	MT_EE_2G_TARGET_POWER = 0x00d0,
+	MT_EE_TEMP_OFFSET = 0x00d1,
+	MT_EE_5G_TARGET_POWER = 0x00d2,
+	MT_EE_TSSI_BOUND1 = 0x00d4,
+	MT_EE_TSSI_BOUND2 = 0x00d6,
+	MT_EE_TSSI_BOUND3 = 0x00d8,
+	MT_EE_TSSI_BOUND4 = 0x00da,
+	MT_EE_FREQ_OFFSET_COMPENSATION = 0x00db,
+	MT_EE_TSSI_BOUND5 = 0x00dc,
+	MT_EE_TX_POWER_BYRATE_BASE = 0x00de,
+
+	MT_EE_TSSI_SLOPE_5G = 0x00f0,
+	MT_EE_RF_TEMP_COMP_SLOPE_5G = 0x00f2,
+	MT_EE_RF_TEMP_COMP_SLOPE_2G = 0x00f4,
+
+	MT_EE_RF_2G_TSSI_OFF_TXPOWER = 0x00f6,
+	MT_EE_RF_2G_RX_HIGH_GAIN = 0x00f8,
+	MT_EE_RF_5G_GRP0_1_RX_HIGH_GAIN = 0x00fa,
+	MT_EE_RF_5G_GRP2_3_RX_HIGH_GAIN = 0x00fc,
+	MT_EE_RF_5G_GRP4_5_RX_HIGH_GAIN = 0x00fe,
+
+	MT_EE_BT_RCAL_RESULT = 0x0138,
+	MT_EE_BT_VCDL_CALIBRATION = 0x013c,
+	MT_EE_BT_PMUCFG = 0x013e,
+
+	MT_EE_USAGE_MAP_START = 0x01e0,
+	MT_EE_USAGE_MAP_END = 0x01fc,
+};
+
+enum mt76_phy_type {
+	MT_PHY_TYPE_CCK,
+	MT_PHY_TYPE_OFDM,
+	MT_PHY_TYPE_HT,
+	MT_PHY_TYPE_HT_GF,
+	MT_PHY_TYPE_VHT,
+	MT_PHY_TYPE_HE_SU = 8,
+	MT_PHY_TYPE_HE_EXT_SU,
+	MT_PHY_TYPE_HE_TB,
+	MT_PHY_TYPE_HE_MU,
+};
+
+enum mt76_phy_bandwidth {
+	MT_PHY_BW_20,
+	MT_PHY_BW_40,
+	MT_PHY_BW_80,
+};
+
+enum mt76_cal_channel_group {
+	MT_CH_5G_JAPAN,
+	MT_CH_5G_UNII_1,
+	MT_CH_5G_UNII_2,
+	MT_CH_5G_UNII_2E_1,
+	MT_CH_5G_UNII_2E_2,
+	MT_CH_5G_UNII_3,
+};
+
+enum mt76_qsel {
+	MT_QSEL_MGMT,
+	MT_QSEL_HCCA,
+	MT_QSEL_EDCA,
+	MT_QSEL_EDCA_2,
+};
+
+enum mt76_cipher_type {
+	MT_CIPHER_NONE,
+	MT_CIPHER_WEP40,
+	MT_CIPHER_WEP104,
+	MT_CIPHER_TKIP,
+	MT_CIPHER_AES_CCMP,
+	MT_CIPHER_CKIP40,
+	MT_CIPHER_CKIP104,
+	MT_CIPHER_CKIP128,
+	MT_CIPHER_WAPI,
+};
+
+struct mt76_fw_header {
+	__le32 ilm_len;
+	__le32 dlm_len;
+	__le16 build_ver;
+	__le16 fw_ver;
+	u8 pad[4];
+	char build_time[16];
+} __packed;
+
+struct mt76_rxwi {
+	__le32 rxinfo;
+	__le32 ctl;
+	__le16 tid_sn;
+	__le16 rate;
+	u8 rssi[4];
+	__le32 bbp_rxinfo[4];
+} __packed;
+
+struct mt76_txwi {
+	__le16 flags;
+	__le16 rate;
+	u8 ack_ctl;
+	u8 wcid;
+	__le16 len_ctl;
+	__le32 iv;
+	__le32 eiv;
+	u8 aid;
+	u8 txstream;
+	u8 ctl2;
+	u8 pktid;
+} __packed;
# ----------------------------------------
# Module: xpadneo
# Version: a16acb03e7be
# ----------------------------------------
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/Makefile b/drivers/custom/xpadneo/hid-xpadneo/src/Makefile
new file mode 100644
index 000000000000..cd0ea4866cdf
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for the HID driver
+#
+ccflags-y += -DVERSION=$(VERSION)
+obj-m += hid-xpadneo.o
+
+#FIXME(kakra) Work-around, cleanup after source code split
+hid-xpadneo-y += xpadneo.o
+$(obj)/xpadneo.c: $(src)/hid-xpadneo.c
+	cp $< $@
+
+hid-xpadneo-y += xpadneo/core.o xpadneo/consumer.o xpadneo/keyboard.o
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/hid-ids.h b/drivers/custom/xpadneo/hid-xpadneo/src/hid-ids.h
new file mode 100644
index 000000000000..33fcc7a779ad
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/hid-ids.h
@@ -0,0 +1,6 @@
+#ifndef HID_IDS_H_FILE
+#define HID_IDS_H_FILE
+
+#define USB_VENDOR_ID_MICROSOFT 0x045e
+
+#endif
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/hid-xpadneo.c b/drivers/custom/xpadneo/hid-xpadneo/src/hid-xpadneo.c
new file mode 100644
index 000000000000..ac3e135f7eb7
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/hid-xpadneo.c
@@ -0,0 +1,1434 @@
+/*
+ * Force feedback support for XBOX ONE S and X gamepads via Bluetooth
+ *
+ * This driver was developed for a student project at fortiss GmbH in Munich.
+ * Copyright (c) 2017 Florian Dollinger <dollinger.florian@gmx.de>
+ *
+ * Additional features and code redesign
+ * Copyright (c) 2020 Kai Krakow <kai@kaishome.de>
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+
+#include "xpadneo.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Florian Dollinger <dollinger.florian@gmx.de>");
+MODULE_AUTHOR("Kai Krakow <kai@kaishome.de>");
+MODULE_DESCRIPTION("Linux kernel driver for Xbox ONE S+ gamepads (BT), incl. FF");
+MODULE_VERSION(XPADNEO_VERSION);
+
+static u8 param_trigger_rumble_mode = 0;
+module_param_named(trigger_rumble_mode, param_trigger_rumble_mode, byte, 0644);
+MODULE_PARM_DESC(trigger_rumble_mode, "(u8) Trigger rumble mode. 0: pressure, 2: disable.");
+
+static u8 param_rumble_attenuation[2];
+module_param_array_named(rumble_attenuation, param_rumble_attenuation, byte, NULL, 0644);
+MODULE_PARM_DESC(rumble_attenuation,
+		 "(u8) Attenuate the rumble strength: all[,triggers] "
+		 "0 (none, full rumble) to 100 (max, no rumble).");
+
+static bool param_ff_connect_notify = 1;
+module_param_named(ff_connect_notify, param_ff_connect_notify, bool, 0644);
+MODULE_PARM_DESC(ff_connect_notify,
+		 "(bool) Connection notification using force feedback. 1: enable, 0: disable.");
+
+static bool param_gamepad_compliance = 1;
+module_param_named(gamepad_compliance, param_gamepad_compliance, bool, 0444);
+MODULE_PARM_DESC(gamepad_compliance,
+		 "(bool) Adhere to Linux Gamepad Specification by using signed axis values. "
+		 "1: enable, 0: disable.");
+
+static bool param_disable_deadzones = 0;
+module_param_named(disable_deadzones, param_disable_deadzones, bool, 0444);
+MODULE_PARM_DESC(disable_deadzones,
+		 "(bool) Disable dead zone handling for raw processing by Wine/Proton, confuses joydev. "
+		 "0: disable, 1: enable.");
+
+static bool param_enable_rolling_axis = 0;
+module_param_named(enable_rolling_axis, param_enable_rolling_axis, bool, 0444);
+MODULE_PARM_DESC(enable_rolling_axis,
+		 "(bool) Enable rolling axis by combining both triggers, out of spec for many games. (deprecated) "
+		 "0: disable, 1: enable.");
+
+static bool param_disable_shift_mode = 0;
+module_param_named(disable_shift_mode, param_disable_shift_mode, bool, 0644);
+MODULE_PARM_DESC(disable_shift_mode,
+		 "(bool) Disable use Xbox logo button as shift. Will prohibit profile switching when enabled. "
+		 "0: disable, 1: enable.");
+
+static bool param_debug_hid = 0;
+module_param_named(debug_hid, param_debug_hid, bool, 0644);
+MODULE_PARM_DESC(debug_hid, "(u8) Debug HID reports. 0: disable, 1: enable.");
+
+static struct {
+	char *args[17];
+	unsigned int nargs;
+} param_quirks;
+module_param_array_named(quirks, param_quirks.args, charp, &param_quirks.nargs, 0644);
+MODULE_PARM_DESC(quirks,
+		 "(string) Override or change device quirks, specify as: \"MAC1{:,+,-}quirks1[,...16]\""
+		 ", MAC format = 11:22:33:44:55:66"
+		 ", no pulse parameters = " __stringify(XPADNEO_QUIRK_NO_PULSE)
+		 ", no trigger rumble = " __stringify(XPADNEO_QUIRK_NO_TRIGGER_RUMBLE)
+		 ", no motor masking = " __stringify(XPADNEO_QUIRK_NO_MOTOR_MASK)
+		 ", use Linux button mappings = " __stringify(XPADNEO_QUIRK_LINUX_BUTTONS)
+		 ", use Nintendo mappings = " __stringify(XPADNEO_QUIRK_NINTENDO)
+		 ", use Share button mappings = " __stringify(XPADNEO_QUIRK_SHARE_BUTTON)
+		 ", reversed motor masking = " __stringify(XPADNEO_QUIRK_REVERSE_MASK)
+		 ", swapped motor masking = " __stringify(XPADNEO_QUIRK_SWAPPED_MASK)
+		 ", apply no heuristics = " __stringify(XPADNEO_QUIRK_NO_HEURISTICS));
+
+static DEFINE_IDA(xpadneo_device_id_allocator);
+
+static enum power_supply_property xpadneo_battery_props[] = {
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_MODEL_NAME,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_SCOPE,
+	POWER_SUPPLY_PROP_STATUS,
+};
+
+#define DEVICE_NAME_QUIRK(n, f) \
+	{ .name_match = (n), .name_len = sizeof(n) - 1, .flags = (f) }
+#define DEVICE_OUI_QUIRK(o, f) \
+	{ .oui_match = (o), .flags = (f) }
+
+struct quirk {
+	char *name_match;
+	char *oui_match;
+	u16 name_len;
+	u32 flags;
+};
+
+static const struct quirk xpadneo_quirks[] = {
+	DEVICE_OUI_QUIRK("28:EA:0B", XPADNEO_QUIRK_NO_HEURISTICS),
+	DEVICE_OUI_QUIRK("3C:FA:06", XPADNEO_QUIRK_NO_HEURISTICS),
+	DEVICE_OUI_QUIRK("68:6C:E6", XPADNEO_QUIRK_NO_HEURISTICS),
+	DEVICE_OUI_QUIRK("98:B6:EA",
+			 XPADNEO_QUIRK_NO_PULSE | XPADNEO_QUIRK_NO_TRIGGER_RUMBLE |
+			 XPADNEO_QUIRK_REVERSE_MASK),
+	DEVICE_OUI_QUIRK("98:B6:EC",
+			 XPADNEO_QUIRK_SIMPLE_CLONE | XPADNEO_QUIRK_SWAPPED_MASK),
+	DEVICE_OUI_QUIRK("A0:5A:5D", XPADNEO_QUIRK_NO_HAPTICS),
+	DEVICE_OUI_QUIRK("A8:8C:3E", XPADNEO_QUIRK_NO_HEURISTICS),
+	DEVICE_OUI_QUIRK("AC:8E:BD", XPADNEO_QUIRK_NO_HEURISTICS),
+	DEVICE_OUI_QUIRK("E4:17:D8", XPADNEO_QUIRK_SIMPLE_CLONE),
+	DEVICE_OUI_QUIRK("EC:83:50", XPADNEO_QUIRK_NO_HEURISTICS),
+};
+
+struct usage_map {
+	u32 usage;
+	enum {
+		MAP_IGNORE = -1,	/* Completely ignore this field */
+		MAP_AUTO,	/* Do not really map it, let hid-core decide */
+		MAP_STATIC	/* Map to the values given */
+	} behaviour;
+	struct {
+		u8 event_type;	/* input event (EV_KEY, EV_ABS, ...) */
+		u16 input_code;	/* input code (BTN_A, ABS_X, ...) */
+	} ev;
+};
+
+#define USAGE_MAP(u, b, e, i) \
+	{ .usage = (u), .behaviour = (b), .ev = { .event_type = (e), .input_code = (i) } }
+#define USAGE_IGN(u) USAGE_MAP(u, MAP_IGNORE, 0, 0)
+
+static const struct usage_map xpadneo_usage_maps[] = {
+	/* fixup buttons to Linux codes */
+	USAGE_MAP(0x90001, MAP_STATIC, EV_KEY, BTN_A),	/* A */
+	USAGE_MAP(0x90002, MAP_STATIC, EV_KEY, BTN_B),	/* B */
+	USAGE_MAP(0x90003, MAP_STATIC, EV_KEY, BTN_X),	/* X */
+	USAGE_MAP(0x90004, MAP_STATIC, EV_KEY, BTN_Y),	/* Y */
+	USAGE_MAP(0x90005, MAP_STATIC, EV_KEY, BTN_TL),	/* LB */
+	USAGE_MAP(0x90006, MAP_STATIC, EV_KEY, BTN_TR),	/* RB */
+	USAGE_MAP(0x90007, MAP_STATIC, EV_KEY, BTN_SELECT),	/* Back */
+	USAGE_MAP(0x90008, MAP_STATIC, EV_KEY, BTN_START),	/* Menu */
+	USAGE_MAP(0x90009, MAP_STATIC, EV_KEY, BTN_THUMBL),	/* LS */
+	USAGE_MAP(0x9000A, MAP_STATIC, EV_KEY, BTN_THUMBR),	/* RS */
+
+	/* fixup the Xbox logo button */
+	USAGE_MAP(0x9000B, MAP_STATIC, EV_KEY, BTN_XBOX),	/* Xbox */
+
+	/* fixup the Share button */
+	USAGE_MAP(0x9000C, MAP_STATIC, EV_KEY, BTN_SHARE),	/* Share */
+
+	/* fixup code "Sys Main Menu" from Windows report descriptor */
+	USAGE_MAP(0x10085, MAP_STATIC, EV_KEY, BTN_XBOX),
+
+	/* fixup code "AC Home" from Linux report descriptor */
+	USAGE_MAP(0xC0223, MAP_STATIC, EV_KEY, BTN_XBOX),
+
+	/* fixup code "AC Back" from Linux report descriptor */
+	USAGE_MAP(0xC0224, MAP_STATIC, EV_KEY, BTN_SELECT),
+
+	/* map special buttons without HID bitmaps, corrected in event handler */
+	USAGE_MAP(0xC0081, MAP_STATIC, EV_KEY, BTN_PADDLES(0)),	/* Four paddles */
+
+	/* hardware features handled at the raw report level */
+	USAGE_IGN(0xC0085),	/* Profile switcher */
+	USAGE_IGN(0xC0099),	/* Trigger scale switches */
+
+	/* XBE2: Disable "dial", which is a redundant representation of the D-Pad */
+	USAGE_IGN(0x10037),
+
+	/* XBE2: Disable duplicate report fields of broken v1 packet format */
+	USAGE_IGN(0x10040),	/* Vx, copy of X axis */
+	USAGE_IGN(0x10041),	/* Vy, copy of Y axis */
+	USAGE_IGN(0x10042),	/* Vz, copy of Z axis */
+	USAGE_IGN(0x10043),	/* Vbrx, copy of Rx */
+	USAGE_IGN(0x10044),	/* Vbry, copy of Ry */
+	USAGE_IGN(0x10045),	/* Vbrz, copy of Rz */
+	USAGE_IGN(0x90010),	/* copy of A */
+	USAGE_IGN(0x90011),	/* copy of B */
+	USAGE_IGN(0x90013),	/* copy of X */
+	USAGE_IGN(0x90014),	/* copy of Y */
+	USAGE_IGN(0x90016),	/* copy of LB */
+	USAGE_IGN(0x90017),	/* copy of RB */
+	USAGE_IGN(0x9001B),	/* copy of Start */
+	USAGE_IGN(0x9001D),	/* copy of LS */
+	USAGE_IGN(0x9001E),	/* copy of RS */
+	USAGE_IGN(0xC0082),	/* copy of Select button */
+
+	/* XBE2: Disable unused buttons */
+	USAGE_IGN(0x90012),	/* 6 "TRIGGER_HAPPY" buttons */
+	USAGE_IGN(0x90015),
+	USAGE_IGN(0x90018),
+	USAGE_IGN(0x90019),
+	USAGE_IGN(0x9001A),
+	USAGE_IGN(0x9001C),
+	USAGE_IGN(0xC00B9),	/* KEY_SHUFFLE button */
+};
+
+static struct workqueue_struct *xpadneo_rumble_wq;
+
+static int xpadneo_output_report(struct hid_device *hdev, __u8 *buf, size_t len)
+{
+	struct ff_report *r = (struct ff_report *)buf;
+
+	if (unlikely(param_debug_hid && (len > 0))) {
+		switch (buf[0]) {
+		case 0x03:
+			if (len >= sizeof(*r)) {
+				hid_info(hdev,
+					 "HID debug: len %ld rumble cmd 0x%02x "
+					 "motors left %d right %d strong %d weak %d "
+					 "magnitude left %d right %d strong %d weak %d "
+					 "pulse sustain %dms release %dms loop %d\n",
+					 len, r->report_id,
+					 !!(r->ff.enable & FF_RUMBLE_LEFT),
+					 !!(r->ff.enable & FF_RUMBLE_RIGHT),
+					 !!(r->ff.enable & FF_RUMBLE_STRONG),
+					 !!(r->ff.enable & FF_RUMBLE_WEAK),
+					 r->ff.magnitude_left, r->ff.magnitude_right,
+					 r->ff.magnitude_strong, r->ff.magnitude_weak,
+					 r->ff.pulse_sustain_10ms * 10,
+					 r->ff.pulse_release_10ms * 10, r->ff.loop_count);
+			} else {
+				hid_info(hdev, "HID debug: len %ld malformed cmd 0x%02x\n", len,
+					 buf[0]);
+			}
+			break;
+		default:
+			hid_info(hdev, "HID debug: len %ld unhandled cmd 0x%02x\n", len, buf[0]);
+		}
+	}
+	return hid_hw_output_report(hdev, buf, len);
+}
+
+static void xpadneo_ff_worker(struct work_struct *work)
+{
+	struct xpadneo_devdata *xdata =
+	    container_of(to_delayed_work(work), struct xpadneo_devdata, ff_worker);
+	struct hid_device *hdev = xdata->hdev;
+	struct ff_report *r = xdata->output_report_dmabuf;
+	int ret;
+	unsigned long flags;
+
+	memset(r, 0, sizeof(*r));
+	r->report_id = XPADNEO_XB1S_FF_REPORT;
+	r->ff.enable = FF_RUMBLE_ALL;
+
+	/*
+	 * if pulse is not supported, we do not have to care about explicitly
+	 * stopping the effect, the kernel will do this for us as part of its
+	 * ff-memless emulation
+	 */
+	if (likely((xdata->quirks & XPADNEO_QUIRK_NO_PULSE) == 0)) {
+		/*
+		 * ff-memless has a time resolution of 50ms but we pulse the
+		 * motors for 60 minutes as the Windows driver does. To work
+		 * around a potential firmware crash, we filter out repeated
+		 * motor programming further below.
+		 */
+		r->ff.pulse_sustain_10ms = 0xFF;
+		r->ff.loop_count = 0xEB;
+	}
+
+	spin_lock_irqsave(&xdata->ff_lock, flags);
+
+	/* let our scheduler know we've been called */
+	xdata->ff_scheduled = false;
+
+	if (unlikely(xdata->quirks & XPADNEO_QUIRK_NO_TRIGGER_RUMBLE)) {
+		/* do not send these bits if not supported */
+		r->ff.enable &= ~FF_RUMBLE_TRIGGERS;
+	} else {
+		/* trigger motors */
+		r->ff.magnitude_left = xdata->ff.magnitude_left;
+		r->ff.magnitude_right = xdata->ff.magnitude_right;
+	}
+
+	/* main motors */
+	r->ff.magnitude_strong = xdata->ff.magnitude_strong;
+	r->ff.magnitude_weak = xdata->ff.magnitude_weak;
+
+	/* do not reprogram motors that have not changed */
+	if (unlikely(xdata->ff_shadow.magnitude_strong == r->ff.magnitude_strong))
+		r->ff.enable &= ~FF_RUMBLE_STRONG;
+	if (unlikely(xdata->ff_shadow.magnitude_weak == r->ff.magnitude_weak))
+		r->ff.enable &= ~FF_RUMBLE_WEAK;
+	if (likely(xdata->ff_shadow.magnitude_left == r->ff.magnitude_left))
+		r->ff.enable &= ~FF_RUMBLE_LEFT;
+	if (likely(xdata->ff_shadow.magnitude_right == r->ff.magnitude_right))
+		r->ff.enable &= ~FF_RUMBLE_RIGHT;
+
+	/* do not send a report if nothing changed */
+	if (unlikely(r->ff.enable == FF_RUMBLE_NONE)) {
+		spin_unlock_irqrestore(&xdata->ff_lock, flags);
+		return;
+	}
+
+	/* shadow our current rumble values for the next cycle */
+	memcpy(&xdata->ff_shadow, &xdata->ff, sizeof(xdata->ff));
+
+	/* clear the magnitudes to properly accumulate the maximum values */
+	xdata->ff.magnitude_left = 0;
+	xdata->ff.magnitude_right = 0;
+	xdata->ff.magnitude_weak = 0;
+	xdata->ff.magnitude_strong = 0;
+
+	/*
+	 * throttle next command submission, the firmware doesn't like us to
+	 * send rumble data any faster
+	 */
+	xdata->ff_throttle_until = XPADNEO_RUMBLE_THROTTLE_JIFFIES;
+
+	spin_unlock_irqrestore(&xdata->ff_lock, flags);
+
+	/* set all bits if not supported (some clones require these set) */
+	if (unlikely(xdata->quirks & XPADNEO_QUIRK_NO_MOTOR_MASK))
+		r->ff.enable = FF_RUMBLE_ALL;
+
+	/* reverse the bits for trigger and main motors */
+	if (unlikely(xdata->quirks & XPADNEO_QUIRK_REVERSE_MASK))
+		r->ff.enable = SWAP_BITS(SWAP_BITS(r->ff.enable, 1, 2), 0, 3);
+
+	/* swap the bits of trigger and main motors */
+	if (unlikely(xdata->quirks & XPADNEO_QUIRK_SWAPPED_MASK))
+		r->ff.enable = SWAP_BITS(SWAP_BITS(r->ff.enable, 0, 2), 1, 3);
+
+	ret = xpadneo_output_report(hdev, (__u8 *) r, sizeof(*r));
+	if (ret < 0)
+		hid_warn(hdev, "failed to send FF report: %d\n", ret);
+}
+
+#define update_magnitude(m, v) m = (v) > 0 ? max(m, v) : 0
+static int xpadneo_ff_play(struct input_dev *dev, void *data, struct ff_effect *effect)
+{
+	unsigned long flags, ff_run_at, ff_throttle_until;
+	long delay_work;
+	int fraction_TL, fraction_TR, fraction_MAIN, percent_TRIGGERS, percent_MAIN;
+	s32 weak, strong, max_main;
+
+	struct hid_device *hdev = input_get_drvdata(dev);
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	if (effect->type != FF_RUMBLE)
+		return 0;
+
+	/* copy data from effect structure at the very beginning */
+	weak = effect->u.rumble.weak_magnitude;
+	strong = effect->u.rumble.strong_magnitude;
+
+	/* calculate the rumble attenuation */
+	percent_MAIN = 100 - param_rumble_attenuation[0];
+	percent_MAIN = clamp(percent_MAIN, 0, 100);
+
+	percent_TRIGGERS = 100 - param_rumble_attenuation[1];
+	percent_TRIGGERS = clamp(percent_TRIGGERS, 0, 100);
+	percent_TRIGGERS = percent_TRIGGERS * percent_MAIN / 100;
+
+	switch (param_trigger_rumble_mode) {
+	case PARAM_TRIGGER_RUMBLE_DISABLE:
+		fraction_MAIN = percent_MAIN;
+		fraction_TL = 0;
+		fraction_TR = 0;
+		break;
+	case PARAM_TRIGGER_RUMBLE_PRESSURE:
+	default:
+		fraction_MAIN = percent_MAIN;
+		fraction_TL = (xdata->last_abs_z * percent_TRIGGERS + 511) / 1023;
+		fraction_TR = (xdata->last_abs_rz * percent_TRIGGERS + 511) / 1023;
+		break;
+	}
+
+	/*
+	 * we want to keep the rumbling at the triggers at the maximum
+	 * of the weak and strong main rumble
+	 */
+	max_main = max(weak, strong);
+
+	spin_lock_irqsave(&xdata->ff_lock, flags);
+
+	/* calculate the physical magnitudes, scale from 16 bit to 0..100 */
+	update_magnitude(xdata->ff.magnitude_strong,
+			 (u8)((strong * fraction_MAIN + S16_MAX) / U16_MAX));
+	update_magnitude(xdata->ff.magnitude_weak,
+			 (u8)((weak * fraction_MAIN + S16_MAX) / U16_MAX));
+
+	/* calculate the physical magnitudes, scale from 16 bit to 0..100 */
+	update_magnitude(xdata->ff.magnitude_left,
+			 (u8)((max_main * fraction_TL + S16_MAX) / U16_MAX));
+	update_magnitude(xdata->ff.magnitude_right,
+			 (u8)((max_main * fraction_TR + S16_MAX) / U16_MAX));
+
+	/* synchronize: is our worker still scheduled? */
+	if (xdata->ff_scheduled) {
+		/* the worker is still guarding rumble programming */
+		hid_notice_once(hdev, "throttling rumble reprogramming\n");
+		goto unlock_and_return;
+	}
+
+	/* we want to run now but may be throttled */
+	ff_run_at = jiffies;
+	ff_throttle_until = xdata->ff_throttle_until;
+	if (time_before(ff_run_at, ff_throttle_until)) {
+		/* last rumble was recently executed */
+		delay_work = (long)ff_throttle_until - (long)ff_run_at;
+		delay_work = clamp(delay_work, 0L, (long)HZ);
+	} else {
+		/* the firmware is ready */
+		delay_work = 0;
+	}
+
+	/* schedule writing a rumble report to the controller */
+	if (queue_delayed_work(xpadneo_rumble_wq, &xdata->ff_worker, delay_work))
+		xdata->ff_scheduled = true;
+	else
+		hid_err(hdev, "lost rumble packet\n");
+
+unlock_and_return:
+	spin_unlock_irqrestore(&xdata->ff_lock, flags);
+	return 0;
+}
+
+static void xpadneo_test_rumble(char *which, struct xpadneo_devdata *xdata, struct ff_report pck)
+{
+	enum xpadneo_rumble_motors enabled = pck.ff.enable;
+
+	hid_info(xdata->hdev, "testing %s: sustain %dms release %dms loop %d wait 30ms\n", which,
+		 pck.ff.pulse_sustain_10ms * 10, pck.ff.pulse_release_10ms * 10, pck.ff.loop_count);
+
+	/*
+	 * XPADNEO_QUIRK_NO_MOTOR_MASK:
+	 * The controller does not support motor masking so we set all bits, and set the magnitude to 0 instead.
+	 */
+	if (xdata->quirks & XPADNEO_QUIRK_NO_MOTOR_MASK) {
+		pck.ff.enable = FF_RUMBLE_ALL;
+		if (!(enabled & FF_RUMBLE_WEAK))
+			pck.ff.magnitude_weak = 0;
+		if (!(enabled & FF_RUMBLE_STRONG))
+			pck.ff.magnitude_strong = 0;
+		if (!(enabled & FF_RUMBLE_RIGHT))
+			pck.ff.magnitude_right = 0;
+		if (!(enabled & FF_RUMBLE_LEFT))
+			pck.ff.magnitude_left = 0;
+	}
+
+	/*
+	 * XPADNEO_QUIRK_NO_TRIGGER_RUMBLE:
+	 * The controller does not support trigger rumble, so filter for the main motors only if we enabled all
+	 * before.
+	 */
+	if (xdata->quirks & XPADNEO_QUIRK_NO_TRIGGER_RUMBLE)
+		pck.ff.enable &= FF_RUMBLE_MAIN;
+
+	/*
+	 * XPADNEO_QUIRK_REVERSE_MASK:
+	 * The controller firmware reverses the order of the motor masking bits, so we swap the bits to reverse it.
+	 */
+	if (xdata->quirks & XPADNEO_QUIRK_REVERSE_MASK)
+		pck.ff.enable = SWAP_BITS(SWAP_BITS(pck.ff.enable, 1, 2), 0, 3);
+
+	/*
+	 * XPADNEO_QUIRK_SWAPPED_MASK:
+	 * The controller firmware swaps the bit masks for the trigger motors with those for the main motors.
+	 */
+	if (xdata->quirks & XPADNEO_QUIRK_SWAPPED_MASK)
+		pck.ff.enable = SWAP_BITS(SWAP_BITS(pck.ff.enable, 0, 2), 1, 3);
+
+	xpadneo_output_report(xdata->hdev, (u8 *)&pck, sizeof(pck));
+	mdelay(300);
+
+	/*
+	 * XPADNEO_QUIRK_NO_PULSE:
+	 * The controller doesn't support timing parameters of the rumble command, so we manually stop the motors.
+	 */
+	if (xdata->quirks & XPADNEO_QUIRK_NO_PULSE) {
+		if (enabled & FF_RUMBLE_WEAK)
+			pck.ff.magnitude_weak = 0;
+		if (enabled & FF_RUMBLE_STRONG)
+			pck.ff.magnitude_strong = 0;
+		if (enabled & FF_RUMBLE_RIGHT)
+			pck.ff.magnitude_right = 0;
+		if (enabled & FF_RUMBLE_LEFT)
+			pck.ff.magnitude_left = 0;
+		xpadneo_output_report(xdata->hdev, (u8 *)&pck, sizeof(pck));
+	}
+	mdelay(30);
+}
+
+static void xpadneo_welcome_rumble(struct hid_device *hdev)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+	struct ff_report ff_pck = { };
+
+	ff_pck.report_id = XPADNEO_XB1S_FF_REPORT;
+
+	/*
+	 * Initialize the motor magnitudes here, the test command will individually zero masked magnitudes if
+	 * needed.
+	 */
+	ff_pck.ff.magnitude_weak = 40;
+	ff_pck.ff.magnitude_strong = 20;
+	ff_pck.ff.magnitude_right = 10;
+	ff_pck.ff.magnitude_left = 10;
+
+	/*
+	 * XPADNEO_QUIRK_NO_PULSE:
+	 * If the controller doesn't support timing parameters of the rumble command, don't set them. Otherwise we
+	 * may miss controllers that actually do support the parameters.
+	 */
+	if (!(xdata->quirks & XPADNEO_QUIRK_NO_PULSE)) {
+		ff_pck.ff.pulse_sustain_10ms = 5;
+		ff_pck.ff.pulse_release_10ms = 5;
+		ff_pck.ff.loop_count = 2;
+	}
+
+	ff_pck.ff.enable = FF_RUMBLE_WEAK;
+	xpadneo_test_rumble("weak motor", xdata, ff_pck);
+
+	ff_pck.ff.enable = FF_RUMBLE_STRONG;
+	xpadneo_test_rumble("strong motor", xdata, ff_pck);
+
+	if (!(xdata->quirks & XPADNEO_QUIRK_NO_TRIGGER_RUMBLE)) {
+		ff_pck.ff.enable = FF_RUMBLE_TRIGGERS;
+		xpadneo_test_rumble("trigger motors", xdata, ff_pck);
+	}
+}
+
+static int xpadneo_init_ff(struct hid_device *hdev)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+	struct input_dev *gamepad = xdata->gamepad;
+
+	INIT_DELAYED_WORK(&xdata->ff_worker, xpadneo_ff_worker);
+	xdata->output_report_dmabuf = devm_kzalloc(&hdev->dev,
+						   sizeof(struct ff_report), GFP_KERNEL);
+	if (xdata->output_report_dmabuf == NULL)
+		return -ENOMEM;
+
+	if (param_trigger_rumble_mode == PARAM_TRIGGER_RUMBLE_DISABLE)
+		xdata->quirks |= XPADNEO_QUIRK_NO_TRIGGER_RUMBLE;
+
+	if (param_ff_connect_notify) {
+		xpadneo_benchmark_start(xpadneo_welcome_rumble);
+		xpadneo_welcome_rumble(hdev);
+		xpadneo_benchmark_stop(xpadneo_welcome_rumble);
+	}
+
+	/* initialize our rumble command throttle */
+	xdata->ff_throttle_until = XPADNEO_RUMBLE_THROTTLE_JIFFIES;
+
+	input_set_capability(gamepad, EV_FF, FF_RUMBLE);
+	return input_ff_create_memless(gamepad, NULL, xpadneo_ff_play);
+}
+
+#define XPADNEO_PSY_ONLINE(data)     ((data&0x80)>0)
+#define XPADNEO_PSY_MODE(data)       ((data&0x0C)>>2)
+
+#define XPADNEO_POWER_USB(data)      (XPADNEO_PSY_MODE(data)==0)
+#define XPADNEO_POWER_BATTERY(data)  (XPADNEO_PSY_MODE(data)==1)
+#define XPADNEO_POWER_PNC(data)      (XPADNEO_PSY_MODE(data)==2)
+
+#define XPADNEO_BATTERY_ONLINE(data)         ((data&0x0C)>0)
+#define XPADNEO_BATTERY_CHARGING(data)       ((data&0x10)>0)
+#define XPADNEO_BATTERY_CAPACITY_LEVEL(data) (data&0x03)
+
+static int xpadneo_get_psy_property(struct power_supply *psy,
+				    enum power_supply_property property,
+				    union power_supply_propval *val)
+{
+	struct xpadneo_devdata *xdata = power_supply_get_drvdata(psy);
+	int ret = 0;
+
+	static int capacity_level_map[] = {
+		[0] = POWER_SUPPLY_CAPACITY_LEVEL_LOW,
+		[1] = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL,
+		[2] = POWER_SUPPLY_CAPACITY_LEVEL_HIGH,
+		[3] = POWER_SUPPLY_CAPACITY_LEVEL_FULL,
+	};
+
+	u8 flags = xdata->battery.flags;
+	u8 level = min(3, XPADNEO_BATTERY_CAPACITY_LEVEL(flags));
+	bool online = XPADNEO_PSY_ONLINE(flags);
+	bool charging = XPADNEO_BATTERY_CHARGING(flags);
+
+	switch (property) {
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		if (online && XPADNEO_BATTERY_ONLINE(flags))
+			val->intval = capacity_level_map[level];
+		else
+			val->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;
+		break;
+
+	case POWER_SUPPLY_PROP_MODEL_NAME:
+		if (online && XPADNEO_POWER_PNC(flags))
+			val->strval = xdata->battery.name_pnc;
+		else
+			val->strval = xdata->battery.name;
+		break;
+
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = online && XPADNEO_BATTERY_ONLINE(flags);
+		break;
+
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = online && (XPADNEO_BATTERY_ONLINE(flags) || charging);
+		break;
+
+	case POWER_SUPPLY_PROP_SCOPE:
+		val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+		break;
+
+	case POWER_SUPPLY_PROP_STATUS:
+		if (online && charging)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else if (online && !charging && XPADNEO_POWER_USB(flags))
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else if (online && XPADNEO_BATTERY_ONLINE(flags))
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int xpadneo_setup_psy(struct hid_device *hdev)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+	struct power_supply_config ps_config = {
+		.drv_data = xdata
+	};
+	int ret;
+
+	/* already registered */
+	if (xdata->battery.psy)
+		return 0;
+
+	xdata->battery.desc.name = kasprintf(GFP_KERNEL, "xpadneo_battery_%i", xdata->id);
+	if (!xdata->battery.desc.name)
+		return -ENOMEM;
+
+	xdata->battery.desc.properties = xpadneo_battery_props;
+	xdata->battery.desc.num_properties = ARRAY_SIZE(xpadneo_battery_props);
+	xdata->battery.desc.use_for_apm = 0;
+	xdata->battery.desc.get_property = xpadneo_get_psy_property;
+	xdata->battery.desc.type = POWER_SUPPLY_TYPE_BATTERY;
+
+	/* register battery via device manager */
+	xdata->battery.psy =
+	    devm_power_supply_register(&hdev->dev, &xdata->battery.desc, &ps_config);
+	if (IS_ERR(xdata->battery.psy)) {
+		ret = PTR_ERR(xdata->battery.psy);
+		hid_err(hdev, "battery registration failed\n");
+		goto err_free_name;
+	} else {
+		hid_info(hdev, "battery registered\n");
+	}
+
+	power_supply_powers(xdata->battery.psy, &xdata->hdev->dev);
+
+	return 0;
+
+err_free_name:
+	kfree(xdata->battery.desc.name);
+	xdata->battery.desc.name = NULL;
+
+	return ret;
+}
+
+static void xpadneo_update_psy(struct xpadneo_devdata *xdata, u8 value)
+{
+	int old_value = xdata->battery.flags;
+
+	if (!xdata->battery.initialized && XPADNEO_PSY_ONLINE(value)) {
+		xdata->battery.initialized = true;
+		xpadneo_setup_psy(xdata->hdev);
+	}
+
+	if (!xdata->battery.psy)
+		return;
+
+	xdata->battery.flags = value;
+	if (old_value != value) {
+		if (!XPADNEO_PSY_ONLINE(value))
+			hid_info(xdata->hdev, "shutting down\n");
+		power_supply_changed(xdata->battery.psy);
+	}
+}
+
+#define xpadneo_map_usage_clear(ev) hid_map_usage_clear(hi, usage, bit, max, (ev).event_type, (ev).input_code)
+static int xpadneo_input_mapping(struct hid_device *hdev, struct hid_input *hi,
+				 struct hid_field *field,
+				 struct hid_usage *usage, unsigned long **bit, int *max)
+{
+	int i = 0;
+
+	if (usage->hid == HID_DC_BATTERYSTRENGTH) {
+		struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+		xdata->battery.report_id = field->report->id;
+		hid_info(hdev, "battery detected\n");
+
+		return MAP_IGNORE;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xpadneo_usage_maps); i++) {
+		const struct usage_map *entry = &xpadneo_usage_maps[i];
+
+		if (entry->usage == usage->hid) {
+			if (entry->behaviour == MAP_STATIC)
+				xpadneo_map_usage_clear(entry->ev);
+			return entry->behaviour;
+		}
+	}
+
+	/* let HID handle this */
+	return MAP_AUTO;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,12,0)
+static u8 *xpadneo_report_fixup(struct hid_device *hdev, u8 *rdesc, unsigned int *rsize)
+#else
+static const __u8 *xpadneo_report_fixup(struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize)
+#endif
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	xdata->original_rsize = *rsize;
+	hid_info(hdev, "report descriptor size: %d bytes\n", *rsize);
+
+	/* fixup trailing NUL byte */
+	if (rdesc[*rsize - 2] == 0xC0 && rdesc[*rsize - 1] == 0x00) {
+		hid_notice(hdev, "fixing up report descriptor size\n");
+		*rsize -= 1;
+	}
+
+	/* fixup reported axes for Xbox One S */
+	if (*rsize >= 81) {
+		if (rdesc[34] == 0x09 && rdesc[35] == 0x32) {
+			hid_notice(hdev, "fixing up Rx axis\n");
+			rdesc[35] = 0x33;	/* Z --> Rx */
+		}
+		if (rdesc[36] == 0x09 && rdesc[37] == 0x35) {
+			hid_notice(hdev, "fixing up Ry axis\n");
+			rdesc[37] = 0x34;	/* Rz --> Ry */
+		}
+		if (rdesc[52] == 0x05 && rdesc[53] == 0x02 &&
+		    rdesc[54] == 0x09 && rdesc[55] == 0xC5) {
+			hid_notice(hdev, "fixing up Z axis\n");
+			rdesc[53] = 0x01;	/* Simulation -> Gendesk */
+			rdesc[55] = 0x32;	/* Brake -> Z */
+		}
+		if (rdesc[77] == 0x05 && rdesc[78] == 0x02 &&
+		    rdesc[79] == 0x09 && rdesc[80] == 0xC4) {
+			hid_notice(hdev, "fixing up Rz axis\n");
+			rdesc[78] = 0x01;	/* Simulation -> Gendesk */
+			rdesc[80] = 0x35;	/* Accelerator -> Rz */
+		}
+	}
+
+	/* fixup reported button count for Xbox controllers in Linux mode */
+	if (*rsize >= 164) {
+		/*
+		 * 12 buttons instead of 10: properly remap the
+		 * Xbox button (button 11)
+		 * Share button (button 12)
+		 */
+		if (rdesc[140] == 0x05 && rdesc[141] == 0x09 &&
+		    rdesc[144] == 0x29 && rdesc[145] == 0x0F &&
+		    rdesc[152] == 0x95 && rdesc[153] == 0x0F &&
+		    rdesc[162] == 0x95 && rdesc[163] == 0x01) {
+			hid_notice(hdev, "fixing up button mapping\n");
+			xdata->quirks |= XPADNEO_QUIRK_LINUX_BUTTONS;
+			rdesc[145] = 0x0C;	/* 15 buttons -> 12 buttons */
+			rdesc[153] = 0x0C;	/* 15 bits -> 12 bits buttons */
+			rdesc[163] = 0x04;	/* 1 bit -> 4 bits constants */
+		}
+	}
+
+	return rdesc;
+}
+
+static void xpadneo_toggle_mouse(struct xpadneo_devdata *xdata)
+{
+	if (xdata->mouse_mode) {
+		xdata->mouse_mode = false;
+		hid_info(xdata->hdev, "mouse mode disabled\n");
+	} else {
+		xdata->mouse_mode = true;
+		hid_info(xdata->hdev, "mouse mode enabled\n");
+	}
+
+	/* Indicate that a request was made */
+	xdata->profile_switched = true;
+}
+
+static void xpadneo_switch_profile(struct xpadneo_devdata *xdata, const u8 profile,
+				   const bool emulated)
+{
+	if (xdata->profile != profile) {
+		hid_info(xdata->hdev, "switching profile to %d\n", profile);
+		xdata->profile = profile;
+	}
+
+	/* Indicate to profile emulation that a request was made */
+	xdata->profile_switched = emulated;
+}
+
+static void xpadneo_switch_triggers(struct xpadneo_devdata *xdata, const u8 mode)
+{
+	char *name[XBOX_TRIGGER_SCALE_NUM] = {
+		[XBOX_TRIGGER_SCALE_FULL] = "full range",
+		[XBOX_TRIGGER_SCALE_HALF] = "half range",
+		[XBOX_TRIGGER_SCALE_DIGITAL] = "digital",
+	};
+
+	enum xpadneo_trigger_scale left = (mode >> 0) & 0x03;
+	enum xpadneo_trigger_scale right = (mode >> 2) & 0x03;
+
+	if ((xdata->trigger_scale.left != left) && (left < XBOX_TRIGGER_SCALE_NUM)) {
+		hid_info(xdata->hdev, "switching left trigger to %s mode\n", name[left]);
+		xdata->trigger_scale.left = left;
+	}
+
+	if ((xdata->trigger_scale.right != right) && (right < XBOX_TRIGGER_SCALE_NUM)) {
+		hid_info(xdata->hdev, "switching right trigger to %s mode\n", name[right]);
+		xdata->trigger_scale.right = right;
+	}
+}
+
+static int xpadneo_raw_event(struct hid_device *hdev, struct hid_report *report,
+			     u8 *data, int reportsize)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	/* the controller spams reports multiple times */
+	if (likely(report->id == 0x01)) {
+		int size = min(reportsize, (int)XPADNEO_REPORT_0x01_LENGTH);
+		if (likely(memcmp(&xdata->input_report_0x01, data, size) == 0))
+			return -1;
+		memcpy(&xdata->input_report_0x01, data, size);
+	}
+
+	/* reset the count at the beginning of the frame */
+	xdata->count_abs_z_rz = 0;
+
+	/* we are taking care of the battery report ourselves */
+	if (xdata->battery.report_id && report->id == xdata->battery.report_id && reportsize == 2) {
+		xpadneo_update_psy(xdata, data[1]);
+		return -1;
+	}
+
+	/* correct button mapping of Xbox controllers in Linux mode */
+	if ((xdata->quirks & XPADNEO_QUIRK_LINUX_BUTTONS) && report->id == 1 && reportsize >= 17) {
+		u16 bits = 0;
+
+		bits |= (data[14] & (BIT(0) | BIT(1))) >> 0;	/* A, B */
+		bits |= (data[14] & (BIT(3) | BIT(4))) >> 1;	/* X, Y */
+		bits |= (data[14] & (BIT(6) | BIT(7))) >> 2;	/* LB, RB */
+		if (xdata->quirks & XPADNEO_QUIRK_SHARE_BUTTON)
+			bits |= (data[15] & BIT(2)) << 4;	/* Back */
+		else
+			bits |= (data[16] & BIT(0)) << 6;	/* Back */
+		bits |= (data[15] & BIT(3)) << 4;	/* Menu */
+		bits |= (data[15] & BIT(5)) << 3;	/* LS */
+		bits |= (data[15] & BIT(6)) << 3;	/* RS */
+		bits |= (data[15] & BIT(4)) << 6;	/* Xbox */
+		if (xdata->quirks & XPADNEO_QUIRK_SHARE_BUTTON)
+			bits |= (data[16] & BIT(0)) << 11;	/* Share */
+		data[14] = (u8)((bits >> 0) & 0xFF);
+		data[15] = (u8)((bits >> 8) & 0xFF);
+		data[16] = 0;
+	}
+
+	/* swap button A with B and X with Y for Nintendo style controllers */
+	if ((xdata->quirks & XPADNEO_QUIRK_NINTENDO) && report->id == 1 && reportsize >= 15) {
+		data[14] = SWAP_BITS(data[14], 0, 1);
+		data[14] = SWAP_BITS(data[14], 2, 3);
+	}
+
+	/* XBE2: track the current controller settings */
+	if (report->id == 1 && reportsize >= 20) {
+		if (!(xdata->quirks & XPADNEO_QUIRK_USE_HW_PROFILES)) {
+			hid_info(hdev, "mapping profiles detected\n");
+			xdata->quirks |= XPADNEO_QUIRK_USE_HW_PROFILES;
+		}
+		if (reportsize == 55) {
+			hid_notice_once(hdev,
+					"detected broken XBE2 v1 packet format, please update the firmware");
+			xpadneo_switch_profile(xdata, data[35] & 0x03, false);
+			xpadneo_switch_triggers(xdata, data[36] & 0x0F);
+		} else if (reportsize >= 21) {
+			/* firmware 4.x style packet */
+			xpadneo_switch_profile(xdata, data[19] & 0x03, false);
+			xpadneo_switch_triggers(xdata, data[20] & 0x0F);
+		} else {
+			/* firmware 5.x style packet */
+			xpadneo_switch_profile(xdata, data[17] & 0x03, false);
+			xpadneo_switch_triggers(xdata, data[18] & 0x0F);
+		}
+	}
+
+	return 0;
+}
+
+static int xpadneo_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+	int deadzone = 3072, abs_min = 0, abs_max = 65535;
+
+	switch (hi->application) {
+	case HID_GD_GAMEPAD:
+		hid_info(hdev, "gamepad detected\n");
+		xdata->gamepad = hi->input;
+		break;
+	case HID_GD_KEYBOARD:
+		hid_info(hdev, "keyboard detected\n");
+		xdata->keyboard = hi->input;
+
+		/* do not report bogus keys as part of the keyboard */
+		__clear_bit(KEY_UNKNOWN, xdata->keyboard->keybit);
+
+		return 0;
+	case HID_CP_CONSUMER_CONTROL:
+		hid_info(hdev, "consumer control detected\n");
+		xdata->consumer = hi->input;
+		return 0;
+	case 0xFF000005:
+		/* FIXME: this is no longer in the current firmware */
+		hid_info(hdev, "mapping profiles detected\n");
+		xdata->quirks |= XPADNEO_QUIRK_USE_HW_PROFILES;
+		return 0;
+	default:
+		hid_warn(hdev, "unhandled input application 0x%x\n", hi->application);
+	}
+
+	if (param_disable_deadzones) {
+		hid_warn(hdev, "disabling dead zones\n");
+		deadzone = 0;
+	}
+
+	if (param_gamepad_compliance) {
+		hid_info(hdev, "enabling compliance with Linux Gamepad Specification\n");
+		abs_min = -32768;
+		abs_max = 32767;
+	}
+
+	input_set_abs_params(xdata->gamepad, ABS_X, abs_min, abs_max, 32, deadzone);
+	input_set_abs_params(xdata->gamepad, ABS_Y, abs_min, abs_max, 32, deadzone);
+	input_set_abs_params(xdata->gamepad, ABS_RX, abs_min, abs_max, 32, deadzone);
+	input_set_abs_params(xdata->gamepad, ABS_RY, abs_min, abs_max, 32, deadzone);
+
+	input_set_abs_params(xdata->gamepad, ABS_Z, 0, 1023, 4, 0);
+	input_set_abs_params(xdata->gamepad, ABS_RZ, 0, 1023, 4, 0);
+
+	/* combine triggers to form a rudder, use ABS_MISC to order after dpad */
+	if (param_enable_rolling_axis) {
+		hid_info(hdev, "enabling rolling axis is deprecated\n");
+		input_set_abs_params(xdata->gamepad, ABS_MISC, -1023, 1023, 3, 63);
+	}
+
+	/* do not report the keyboard buttons as part of the gamepad */
+	__clear_bit(BTN_SHARE, xdata->gamepad->keybit);
+	__clear_bit(KEY_RECORD, xdata->gamepad->keybit);
+	__clear_bit(KEY_UNKNOWN, xdata->gamepad->keybit);
+
+	/* ensure all four paddles exist as part of the gamepad */
+	if (test_bit(BTN_PADDLES(0), xdata->gamepad->keybit)) {
+		__set_bit(BTN_PADDLES(1), xdata->gamepad->keybit);
+		__set_bit(BTN_PADDLES(2), xdata->gamepad->keybit);
+		__set_bit(BTN_PADDLES(3), xdata->gamepad->keybit);
+	}
+
+	return 0;
+}
+
+static int xpadneo_event(struct hid_device *hdev, struct hid_field *field,
+			 struct hid_usage *usage, __s32 value)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+	struct input_dev *gamepad = xdata->gamepad;
+	struct input_dev *keyboard = xdata->keyboard;
+
+	if ((usage->type == EV_KEY) && (usage->code == BTN_PADDLES(0))) {
+		if (gamepad && xdata->profile == 0) {
+			/* report the paddles individually */
+			input_report_key(gamepad, BTN_PADDLES(0), (value & 1) ? 1 : 0);
+			input_report_key(gamepad, BTN_PADDLES(1), (value & 2) ? 1 : 0);
+			input_report_key(gamepad, BTN_PADDLES(2), (value & 4) ? 1 : 0);
+			input_report_key(gamepad, BTN_PADDLES(3), (value & 8) ? 1 : 0);
+			xdata->gamepad_sync = true;
+		}
+		goto stop_processing;
+	} else if (usage->type == EV_ABS) {
+		switch (usage->code) {
+		case ABS_X:
+		case ABS_Y:
+		case ABS_RX:
+		case ABS_RY:
+			/* Linux Gamepad Specification */
+			if (param_gamepad_compliance) {
+				input_report_abs(gamepad, usage->code, value - 32768);
+				xdata->gamepad_sync = true;
+				goto stop_processing;
+			}
+			break;
+		case ABS_Z:
+			xdata->last_abs_z = value;
+			goto combine_z_axes;
+		case ABS_RZ:
+			xdata->last_abs_rz = value;
+			goto combine_z_axes;
+		}
+	} else if (!param_disable_shift_mode && (usage->type == EV_KEY)
+		   && (usage->code == BTN_XBOX)) {
+		/*
+		 * Handle the Xbox logo button: We want to cache the button
+		 * down event to allow for profile switching. The button will
+		 * act as a shift key and only send the input events when
+		 * released without pressing an additional button.
+		 */
+		if (!xdata->xbox_button_down && (value == 1)) {
+			/* cache this event */
+			xdata->xbox_button_down = true;
+		} else if (xdata->xbox_button_down && (value == 0)) {
+			xdata->xbox_button_down = false;
+			if (xdata->profile_switched) {
+				xdata->profile_switched = false;
+			} else {
+				/* replay cached event */
+				input_report_key(gamepad, BTN_XBOX, 1);
+				input_sync(gamepad);
+				/* synthesize the release to remove the scan code */
+				input_report_key(gamepad, BTN_XBOX, 0);
+				input_sync(gamepad);
+			}
+		}
+		goto stop_processing;
+	} else if ((usage->type == EV_KEY) && (usage->code == BTN_SHARE)) {
+		/* move the Share button to the keyboard device */
+		if (!keyboard)
+			goto keyboard_missing;
+		input_report_key(keyboard, BTN_SHARE, value);
+		xdata->keyboard_sync = true;
+		goto stop_processing;
+	} else if (xdata->xbox_button_down && (usage->type == EV_KEY)) {
+		if (!(xdata->quirks & XPADNEO_QUIRK_USE_HW_PROFILES)) {
+			switch (usage->code) {
+			case BTN_A:
+				if (value == 1)
+					xpadneo_switch_profile(xdata, 0, true);
+				goto stop_processing;
+			case BTN_B:
+				if (value == 1)
+					xpadneo_switch_profile(xdata, 1, true);
+				goto stop_processing;
+			case BTN_X:
+				if (value == 1)
+					xpadneo_switch_profile(xdata, 2, true);
+				goto stop_processing;
+			case BTN_Y:
+				if (value == 1)
+					xpadneo_switch_profile(xdata, 3, true);
+				goto stop_processing;
+			case BTN_SELECT:
+				if (value == 1)
+					xpadneo_toggle_mouse(xdata);
+				goto stop_processing;
+			}
+		}
+	}
+
+	/* Let hid-core handle the event */
+	xdata->gamepad_sync = true;
+	return 0;
+
+combine_z_axes:
+	if (++xdata->count_abs_z_rz == 2) {
+		xdata->count_abs_z_rz = 0;
+		if (param_enable_rolling_axis) {
+			input_report_abs(gamepad, ABS_MISC, xdata->last_abs_rz - xdata->last_abs_z);
+			xdata->gamepad_sync = true;
+		}
+	}
+	return 0;
+
+keyboard_missing:
+	xpadneo_core_missing(xdata, XPADNEO_MISSING_KEYBOARD);
+
+stop_processing:
+	return 1;
+}
+
+static int xpadneo_init_hw(struct hid_device *hdev)
+{
+	int i, ret;
+	u8 oui_byte;
+	u32 quirks_set = 0, quirks_unset = 0, quirks_override = U32_MAX;
+	char oui[3] = { };
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	if (!xdata->gamepad) {
+		xpadneo_core_missing(xdata, XPADNEO_MISSING_GAMEPAD);
+		return -EINVAL;
+	}
+
+	xdata->battery.name =
+	    kasprintf(GFP_KERNEL, "%s [%s]", xdata->gamepad->name, xdata->gamepad->uniq);
+	if (!xdata->battery.name) {
+		ret = -ENOMEM;
+		goto err_free_name;
+	}
+
+	xdata->battery.name_pnc =
+	    kasprintf(GFP_KERNEL, "%s [%s] Play'n Charge Kit", xdata->gamepad->name,
+		      xdata->gamepad->uniq);
+	if (!xdata->battery.name_pnc) {
+		ret = -ENOMEM;
+		goto err_free_name;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xpadneo_quirks); i++) {
+		const struct quirk *q = &xpadneo_quirks[i];
+
+		if (q->name_match
+		    && (strncmp(q->name_match, xdata->gamepad->name, q->name_len) == 0))
+			xdata->quirks |= q->flags;
+
+		if (q->oui_match && (strncasecmp(q->oui_match, xdata->gamepad->uniq, 8) == 0))
+			xdata->quirks |= q->flags;
+	}
+
+	kernel_param_lock(THIS_MODULE);
+	for (i = 0; i < param_quirks.nargs; i++) {
+		int offset = strnlen(xdata->gamepad->uniq, 18);
+		if ((strncasecmp(xdata->gamepad->uniq, param_quirks.args[i], offset) == 0)
+		    && ((param_quirks.args[i][offset] == ':')
+			|| (param_quirks.args[i][offset] == '+')
+			|| (param_quirks.args[i][offset] == '-'))) {
+			char *quirks_arg = &param_quirks.args[i][offset + 1];
+			u32 quirks = 0;
+			ret = kstrtou32(quirks_arg, 0, &quirks);
+			if (ret) {
+				hid_err(hdev, "quirks override invalid: %s\n", quirks_arg);
+				goto err_free_name;
+			} else if (param_quirks.args[i][offset] == ':') {
+				quirks_override = quirks;
+			} else if (param_quirks.args[i][offset] == '-') {
+				quirks_unset = quirks;
+			} else {
+				quirks_set = quirks;
+			}
+			break;
+		}
+	}
+	kernel_param_unlock(THIS_MODULE);
+
+	/* handle quirk flags which override a behavior before heuristics */
+	if (quirks_override != U32_MAX) {
+		hid_info(hdev, "quirks override: %s\n", xdata->gamepad->uniq);
+		xdata->quirks = quirks_override;
+	}
+
+	/* handle quirk flags which add a behavior before heuristics */
+	if (quirks_set > 0) {
+		hid_info(hdev, "quirks added: %s flags 0x%08X\n", xdata->gamepad->uniq, quirks_set);
+		xdata->quirks |= quirks_set;
+	}
+
+	/*
+	 * copy the first two characters from the uniq ID (MAC address) and
+	 * expect it being too big to copy, then `kstrtou8()` converts the
+	 * uniq ID "aa:bb:cc:dd:ee:ff" to u8, so we get the first OUI byte
+	 */
+	if ((xdata->original_rsize == 283)
+	    && ((xdata->quirks & XPADNEO_QUIRK_NO_HEURISTICS) == 0)
+	    && ((xdata->quirks & XPADNEO_QUIRK_SIMPLE_CLONE) == 0)
+	    && (strscpy(oui, xdata->gamepad->uniq, sizeof(oui)) == -E2BIG)
+	    && (kstrtou8(oui, 16, &oui_byte) == 0)
+	    && XPADNEO_OUI_MASK(oui_byte, XPADNEO_OUI_MASK_GAMESIR_NOVA)) {
+		hid_info(hdev, "enabling heuristic GameSir Nova quirks\n");
+		xdata->quirks |= XPADNEO_QUIRK_SIMPLE_CLONE;
+	}
+
+	/* handle quirk flags which remove a behavior after heuristics */
+	if (quirks_unset > 0) {
+		hid_info(hdev, "quirks removed: %s flag 0x%08X\n", xdata->gamepad->uniq,
+			 quirks_unset);
+		xdata->quirks &= ~quirks_unset;
+	}
+
+	if (xdata->quirks > 0)
+		hid_info(hdev, "controller quirks: 0x%08x\n", xdata->quirks);
+
+	return 0;
+
+err_free_name:
+	kfree(xdata->battery.name);
+	xdata->battery.name = NULL;
+
+	kfree(xdata->battery.name_pnc);
+	xdata->battery.name_pnc = NULL;
+
+	return ret;
+}
+
+static int xpadneo_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	int ret;
+	struct xpadneo_devdata *xdata;
+
+	xdata = devm_kzalloc(&hdev->dev, sizeof(*xdata), GFP_KERNEL);
+	if (xdata == NULL)
+		return -ENOMEM;
+
+	xdata->id = ida_simple_get(&xpadneo_device_id_allocator, 0, 0, GFP_KERNEL);
+	xdata->quirks = id->driver_data;
+
+	xdata->hdev = hdev;
+	hdev->quirks |= HID_QUIRK_INPUT_PER_APP;
+	hdev->quirks |= HID_QUIRK_NO_INPUT_SYNC;
+	hid_set_drvdata(hdev, xdata);
+
+	if (hdev->version == 0x00000903)
+		hid_warn(hdev, "buggy firmware detected, please upgrade to the latest version\n");
+	else if (hdev->version < 0x00000500)
+		hid_warn(hdev,
+			 "classic Bluetooth firmware version %x.%02x, please upgrade for better stability\n",
+			 hdev->version >> 8, (u8)hdev->version);
+	else if (hdev->version < 0x00000512)
+		hid_warn(hdev,
+			 "BLE firmware version %x.%02x, please upgrade for better stability\n",
+			 hdev->version >> 8, (u8)hdev->version);
+	else
+		hid_info(hdev, "BLE firmware version %x.%02x\n",
+			 hdev->version >> 8, (u8)hdev->version);
+
+	/*
+	 * Pretend that we are in Windows pairing mode as we are actually
+	 * exposing the Windows mapping. This prevents SDL and other layers
+	 * (probably browser game controller APIs) from treating our driver
+	 * unnecessarily with button and axis mapping fixups, and it seems
+	 * this is actually a firmware mode meant for Android usage only:
+	 *
+	 * Xbox One S:
+	 * 0x2E0 wireless Windows mode (non-Android mode)
+	 * 0x2EA USB Windows and Linux mode
+	 * 0x2FD wireless Linux mode (Android mode)
+	 *
+	 * Xbox Elite 2:
+	 * 0xB00 USB Windows and Linux mode
+	 * 0xB05 wireless Linux mode (Android mode)
+	 *
+	 * Xbox Series X|S:
+	 * 0xB12 Dongle, USB Windows and USB Linux mode
+	 * 0xB13 wireless Linux mode (Android mode)
+	 *
+	 * Xbox Controller BLE mode:
+	 * 0xB20 wireless BLE mode
+	 *
+	 * TODO: We should find a better way of doing this so SDL2 could
+	 * still detect our driver as the correct model. Currently this
+	 * maps all controllers to the same model.
+	 */
+	xdata->original_product = hdev->product;
+	xdata->original_version = hdev->version;
+	hdev->product = 0x028E;
+	hdev->version = 0x00001130;
+
+	if (hdev->product != xdata->original_product)
+		hid_info(hdev,
+			 "pretending XB1S Windows wireless mode "
+			 "(changed PID from 0x%04X to 0x%04X)\n", xdata->original_product,
+			 hdev->product);
+
+	if (hdev->version != xdata->original_version)
+		hid_info(hdev,
+			 "working around wrong SDL2 mappings "
+			 "(changed version from 0x%08X to 0x%08X)\n", xdata->original_version,
+			 hdev->version);
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "parse failed\n");
+		return ret;
+	}
+
+	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (ret) {
+		hid_err(hdev, "hw start failed\n");
+		return ret;
+	}
+
+	ret = xpadneo_init_consumer(xdata);
+	if (ret)
+		return ret;
+
+	ret = xpadneo_init_keyboard(xdata);
+	if (ret)
+		return ret;
+
+	ret = xpadneo_init_hw(hdev);
+	if (ret) {
+		hid_err(hdev, "hw init failed: %d\n", ret);
+		hid_hw_stop(hdev);
+		return ret;
+	}
+
+	ret = xpadneo_init_ff(hdev);
+	if (ret)
+		hid_err(hdev, "could not initialize ff, continuing anyway\n");
+
+	hid_info(hdev, "%s connected\n", xdata->battery.name);
+
+	return 0;
+}
+
+static void xpadneo_release_device_id(struct xpadneo_devdata *xdata)
+{
+	if (xdata->id >= 0) {
+		ida_simple_remove(&xpadneo_device_id_allocator, xdata->id);
+		xdata->id = -1;
+	}
+}
+
+static void xpadneo_remove(struct hid_device *hdev)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	hid_hw_close(hdev);
+
+	if (hdev->version != xdata->original_version) {
+		hid_info(hdev,
+			 "reverting to original version "
+			 "(changed version from 0x%08X to 0x%08X)\n",
+			 hdev->version, xdata->original_version);
+		hdev->version = xdata->original_version;
+	}
+
+	if (hdev->product != xdata->original_product) {
+		hid_info(hdev,
+			 "reverting to original product "
+			 "(changed PID from 0x%04X to 0x%04X)\n",
+			 hdev->product, xdata->original_product);
+		hdev->product = xdata->original_product;
+	}
+
+	cancel_delayed_work_sync(&xdata->ff_worker);
+
+	kfree(xdata->battery.name);
+	xdata->battery.name = NULL;
+
+	kfree(xdata->battery.name_pnc);
+	xdata->battery.name_pnc = NULL;
+
+	xpadneo_release_device_id(xdata);
+	hid_hw_stop(hdev);
+}
+
+static const struct hid_device_id xpadneo_devices[] = {
+	/* XBOX ONE S / X */
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x02E0) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x02FD) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x0B20),
+	 .driver_data = XPADNEO_QUIRK_SHARE_BUTTON },
+
+	/* XBOX ONE Elite Series 2 */
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x0B05) },
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x0B22),
+	 .driver_data = XPADNEO_QUIRK_SHARE_BUTTON },
+
+	/* XBOX Series X|S / Xbox Wireless Controller (BLE) */
+	{ HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_MICROSOFT, 0x0B13),
+	 .driver_data = XPADNEO_QUIRK_SHARE_BUTTON },
+
+	/* SENTINEL VALUE, indicates the end */
+	{ }
+};
+
+MODULE_DEVICE_TABLE(hid, xpadneo_devices);
+
+static struct hid_driver xpadneo_driver = {
+	.name = "xpadneo",
+	.id_table = xpadneo_devices,
+	.input_mapping = xpadneo_input_mapping,
+	.input_configured = xpadneo_input_configured,
+	.probe = xpadneo_probe,
+	.remove = xpadneo_remove,
+	.report = xpadneo_report,
+	.report_fixup = xpadneo_report_fixup,
+	.raw_event = xpadneo_raw_event,
+	.event = xpadneo_event,
+};
+
+static int __init xpadneo_init(void)
+{
+	pr_info("loaded hid-xpadneo %s\n", XPADNEO_VERSION);
+	dbg_hid("xpadneo:%s\n", __func__);
+
+	if (param_trigger_rumble_mode == 1)
+		pr_warn("hid-xpadneo trigger_rumble_mode=1 is unknown, defaulting to 0\n");
+
+	xpadneo_rumble_wq = alloc_ordered_workqueue("xpadneo/rumbled", WQ_HIGHPRI);
+	if (xpadneo_rumble_wq) {
+		int ret = hid_register_driver(&xpadneo_driver);
+		if (ret != 0) {
+			destroy_workqueue(xpadneo_rumble_wq);
+			xpadneo_rumble_wq = NULL;
+		}
+		return ret;
+	}
+	return -EINVAL;
+}
+
+static void __exit xpadneo_exit(void)
+{
+	dbg_hid("xpadneo:%s\n", __func__);
+	hid_unregister_driver(&xpadneo_driver);
+	ida_destroy(&xpadneo_device_id_allocator);
+	destroy_workqueue(xpadneo_rumble_wq);
+}
+
+module_init(xpadneo_init);
+module_exit(xpadneo_exit);
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo.h b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo.h
new file mode 100644
index 000000000000..1577cb97bdad
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo.h
@@ -0,0 +1,207 @@
+/*
+ * Force feedback support for XBOX ONE S and X gamepads via Bluetooth
+ *
+ * This driver was developed for a student project at fortiss GmbH in Munich.
+ * Copyright (c) 2017 Florian Dollinger <dollinger.florian@gmx.de>
+ *
+ * Additional features and code redesign
+ * Copyright (c) 2020 Kai Krakow <kai@kaishome.de>
+ */
+
+#ifndef XPADNEO_H_FILE
+#define XPADNEO_H_FILE
+
+#include <linux/hid.h>
+#include <linux/version.h>
+
+#include "hid-ids.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,18,0)
+#error "kernel version 4.18.0+ required for HID_QUIRK_INPUT_PER_APP"
+#endif
+
+#ifndef VERSION
+#error "xpadneo version not defined"
+#endif
+
+#define XPADNEO_VERSION __stringify(VERSION)
+
+/* helper for printing a notice only once */
+#ifndef hid_notice_once
+#define hid_notice_once(hid, fmt, ...)					\
+do {									\
+	static bool __print_once __read_mostly;				\
+	if (!__print_once) {						\
+		__print_once = true;					\
+		hid_notice(hid, fmt, ##__VA_ARGS__);			\
+	}								\
+} while (0)
+#endif
+
+/* benchmark helper */
+#define xpadneo_benchmark_start(name) \
+do { \
+	unsigned long __##name_jiffies = jiffies; \
+	pr_info("xpadneo " #name " start\n")
+#define xpadneo_benchmark_stop(name) \
+	pr_info("xpadneo " #name " took %ums\n", jiffies_to_msecs(jiffies - __##name_jiffies)); \
+} while (0)
+
+/* button aliases */
+#define BTN_PADDLES(b) (BTN_TRIGGER_HAPPY5+(b))
+#define BTN_SHARE      KEY_F12
+#define BTN_XBOX       BTN_MODE
+
+/* module parameter "trigger_rumble_mode" */
+#define PARAM_TRIGGER_RUMBLE_PRESSURE 0
+#define PARAM_TRIGGER_RUMBLE_RESERVED 1
+#define PARAM_TRIGGER_RUMBLE_DISABLE  2
+
+/* module parameter "quirks" */
+#define XPADNEO_QUIRK_NO_PULSE          1
+#define XPADNEO_QUIRK_NO_TRIGGER_RUMBLE 2
+#define XPADNEO_QUIRK_NO_MOTOR_MASK     4
+#define XPADNEO_QUIRK_USE_HW_PROFILES   8
+#define XPADNEO_QUIRK_LINUX_BUTTONS     16
+#define XPADNEO_QUIRK_NINTENDO          32
+#define XPADNEO_QUIRK_SHARE_BUTTON      64
+#define XPADNEO_QUIRK_REVERSE_MASK      128
+#define XPADNEO_QUIRK_SWAPPED_MASK      256
+#define XPADNEO_QUIRK_NO_HEURISTICS	512
+
+#define XPADNEO_QUIRK_NO_HAPTICS        (XPADNEO_QUIRK_NO_PULSE|XPADNEO_QUIRK_NO_MOTOR_MASK)
+#define XPADNEO_QUIRK_SIMPLE_CLONE      (XPADNEO_QUIRK_NO_HAPTICS|XPADNEO_QUIRK_NO_TRIGGER_RUMBLE)
+
+/* MAC OUI masks */
+#define XPADNEO_OUI_MASK(oui,mask)    (((oui)&(mask))==(mask))
+#define XPADNEO_OUI_MASK_GAMESIR_NOVA 0x28
+
+/* timing of rumble commands to work around firmware crashes */
+#define XPADNEO_RUMBLE_THROTTLE_DELAY   msecs_to_jiffies(50)
+#define XPADNEO_RUMBLE_THROTTLE_JIFFIES (jiffies + XPADNEO_RUMBLE_THROTTLE_DELAY)
+
+/* helpers */
+#define SWAP_BITS(v,b1,b2) \
+	(((v)>>(b1)&1)==((v)>>(b2)&1)?(v):(v^(1ULL<<(b1))^(1ULL<<(b2))))
+
+/* rumble motors enable bits */
+enum xpadneo_rumble_motors {
+	FF_RUMBLE_NONE = 0x00,
+	FF_RUMBLE_WEAK = 0x01,
+	FF_RUMBLE_STRONG = 0x02,
+	FF_RUMBLE_MAIN = FF_RUMBLE_WEAK | FF_RUMBLE_STRONG,
+	FF_RUMBLE_RIGHT = 0x04,
+	FF_RUMBLE_LEFT = 0x08,
+	FF_RUMBLE_TRIGGERS = FF_RUMBLE_LEFT | FF_RUMBLE_RIGHT,
+	FF_RUMBLE_ALL = 0x0F
+} __packed;
+
+/* rumble packet structure */
+struct ff_data {
+	enum xpadneo_rumble_motors enable;
+	u8 magnitude_left;
+	u8 magnitude_right;
+	u8 magnitude_strong;
+	u8 magnitude_weak;
+	u8 pulse_sustain_10ms;
+	u8 pulse_release_10ms;
+	u8 loop_count;
+} __packed;
+#ifdef static_assert
+static_assert(sizeof(struct ff_data) == 8);
+#endif
+
+/* report number for rumble commands */
+#define XPADNEO_XB1S_FF_REPORT 0x03
+
+/* maximum length of report 0x01 for duplicate packet filtering */
+#define XPADNEO_REPORT_0x01_LENGTH (55+1)
+
+/* HID packet for rumble commands */
+struct ff_report {
+	u8 report_id;
+	struct ff_data ff;
+} __packed;
+#ifdef static_assert
+static_assert(sizeof(struct ff_report) == 9);
+#endif
+
+/* trigger range limits implemented in XBE2 controllers */
+enum xpadneo_trigger_scale {
+	XBOX_TRIGGER_SCALE_FULL,
+	XBOX_TRIGGER_SCALE_HALF,
+	XBOX_TRIGGER_SCALE_DIGITAL,
+	XBOX_TRIGGER_SCALE_NUM
+} __packed;
+
+#define XPADNEO_MISSING_CONSUMER 1
+#define XPADNEO_MISSING_GAMEPAD  2
+#define XPADNEO_MISSING_KEYBOARD 4
+
+/* private driver instance data */
+struct xpadneo_devdata {
+	/* unique physical device id (randomly assigned) */
+	int id;
+
+	/* logical device interfaces */
+	struct hid_device *hdev;
+	struct input_dev *consumer, *gamepad, *keyboard;
+	bool consumer_sync, gamepad_sync, keyboard_sync;
+	short int missing_reported;
+
+	/* revert fixups on removal */
+	u16 original_product;
+	u32 original_version;
+
+	/* quirk flags */
+	unsigned int original_rsize;
+	u32 quirks;
+
+	/* profile switching */
+	bool xbox_button_down, profile_switched;
+	u8 profile;
+
+	/* mouse mode */
+	bool mouse_mode;
+
+	/* trigger scale */
+	struct {
+		u8 left, right;
+	} trigger_scale;
+
+	/* battery information */
+	struct {
+		bool initialized;
+		struct power_supply *psy;
+		struct power_supply_desc desc;
+		char *name;
+		char *name_pnc;
+		u8 report_id;
+		u8 flags;
+	} battery;
+
+	/* duplicate report buffers */
+	u8 input_report_0x01[XPADNEO_REPORT_0x01_LENGTH];
+
+	/* axis states */
+	u8 count_abs_z_rz;
+	s32 last_abs_z;
+	s32 last_abs_rz;
+
+	/* buffer for ff_worker */
+	spinlock_t ff_lock;
+	struct delayed_work ff_worker;
+	unsigned long ff_throttle_until;
+	bool ff_scheduled;
+	struct ff_data ff;
+	struct ff_data ff_shadow;
+	void *output_report_dmabuf;
+};
+
+extern int xpadneo_init_consumer(struct xpadneo_devdata *);
+extern int xpadneo_init_keyboard(struct xpadneo_devdata *);
+extern int xpadneo_init_synthetic(struct xpadneo_devdata *, char *, struct input_dev **);
+extern void xpadneo_report(struct hid_device *, struct hid_report *);
+extern void xpadneo_core_missing(struct xpadneo_devdata *, u32);
+
+#endif
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/consumer.c b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/consumer.c
new file mode 100644
index 000000000000..95c1818cde82
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/consumer.c
@@ -0,0 +1,32 @@
+/*
+ * xpadneo consumer control driver
+ *
+ * Copyright (c) 2021 Kai Krakow <kai@kaishome.de>
+ */
+
+#include "../xpadneo.h"
+
+extern int xpadneo_init_consumer(struct xpadneo_devdata *xdata)
+{
+	struct hid_device *hdev = xdata->hdev;
+	int ret, synth = 0;
+
+	if (!xdata->consumer) {
+		synth = 1;
+		ret = xpadneo_init_synthetic(xdata, "Consumer Control", &xdata->consumer);
+		if (ret || !xdata->consumer)
+			return ret;
+	}
+
+	if (synth) {
+		ret = input_register_device(xdata->consumer);
+		if (ret) {
+			hid_err(hdev, "failed to register consumer control\n");
+			return ret;
+		}
+
+		hid_info(hdev, "consumer control added\n");
+	}
+
+	return 0;
+}
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/core.c b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/core.c
new file mode 100644
index 000000000000..bb61d828da09
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/core.c
@@ -0,0 +1,77 @@
+/*
+ * xpadneo driver core
+ *
+ * Copyright (c) 2021 Kai Krakow <kai@kaishome.de>
+ */
+
+#include "../xpadneo.h"
+
+extern int xpadneo_init_synthetic(struct xpadneo_devdata *xdata, char *suffix,
+				  struct input_dev **devp)
+{
+	struct hid_device *hdev = xdata->hdev;
+	struct input_dev *input_dev = devm_input_allocate_device(&hdev->dev);
+	size_t suffix_len, name_len;
+
+	if (!input_dev)
+		return -ENOMEM;
+
+	name_len = strlen(hdev->name);
+	suffix_len = strlen(suffix);
+	if ((name_len < suffix_len) || strcmp(hdev->name + name_len - suffix_len, suffix)) {
+		input_dev->name = kasprintf(GFP_KERNEL, "%s %s", hdev->name, suffix);
+		if (!input_dev->name)
+			return -ENOMEM;
+	}
+
+	dev_set_drvdata(&input_dev->dev, xdata);
+	input_dev->phys = hdev->phys;
+	input_dev->uniq = hdev->uniq;
+	input_dev->id.bustype = hdev->bus;
+	input_dev->id.vendor = hdev->vendor;
+	input_dev->id.product = hdev->product;
+	input_dev->id.version = hdev->version;
+
+	*devp = input_dev;
+	return 0;
+}
+
+extern void xpadneo_report(struct hid_device *hdev, struct hid_report *report)
+{
+	struct xpadneo_devdata *xdata = hid_get_drvdata(hdev);
+
+	if (xdata->consumer && xdata->consumer_sync) {
+		xdata->consumer_sync = false;
+		input_sync(xdata->consumer);
+	}
+
+	if (xdata->gamepad && xdata->gamepad_sync) {
+		xdata->gamepad_sync = false;
+		input_sync(xdata->gamepad);
+	}
+
+	if (xdata->keyboard && xdata->keyboard_sync) {
+		xdata->keyboard_sync = false;
+		input_sync(xdata->keyboard);
+	}
+}
+
+extern void xpadneo_core_missing(struct xpadneo_devdata *xdata, u32 flag)
+{
+	struct hid_device *hdev = xdata->hdev;
+
+	if ((xdata->missing_reported & flag) == 0) {
+		xdata->missing_reported |= flag;
+		switch (flag) {
+		case XPADNEO_MISSING_GAMEPAD:
+			hid_err(hdev, "gamepad not detected\n");
+			break;
+		case XPADNEO_MISSING_KEYBOARD:
+			hid_err(hdev, "keyboard not detected\n");
+			break;
+		default:
+			hid_err(hdev, "unexpected subdevice missing: %d\n", flag);
+		}
+	}
+
+}
diff --git a/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/keyboard.c b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/keyboard.c
new file mode 100644
index 000000000000..d554143ccea3
--- /dev/null
+++ b/drivers/custom/xpadneo/hid-xpadneo/src/xpadneo/keyboard.c
@@ -0,0 +1,35 @@
+/*
+ * xpadneo keyboard driver
+ *
+ * Copyright (c) 2021 Kai Krakow <kai@kaishome.de>
+ */
+
+#include "../xpadneo.h"
+
+extern int xpadneo_init_keyboard(struct xpadneo_devdata *xdata)
+{
+	struct hid_device *hdev = xdata->hdev;
+	int ret, synth = 0;
+
+	if (!xdata->keyboard) {
+		synth = 1;
+		ret = xpadneo_init_synthetic(xdata, "Keyboard", &xdata->keyboard);
+		if (ret || !xdata->keyboard)
+			return ret;
+	}
+
+	/* enable key events for keyboard */
+	input_set_capability(xdata->keyboard, EV_KEY, BTN_SHARE);
+
+	if (synth) {
+		ret = input_register_device(xdata->keyboard);
+		if (ret) {
+			hid_err(hdev, "failed to register keyboard\n");
+			return ret;
+		}
+
+		hid_info(hdev, "keyboard added\n");
+	}
+
+	return 0;
+}
# ----------------------------------------
# Module: kvfm
# Version: fddcb7f2d43e
# ----------------------------------------
diff --git a/drivers/custom/kvfm/module/Makefile b/drivers/custom/kvfm/module/Makefile
new file mode 100644
index 000000000000..f0b086238ac7
--- /dev/null
+++ b/drivers/custom/kvfm/module/Makefile
@@ -0,0 +1,22 @@
+obj-m += kvmfr.o
+USER  := $(shell whoami)
+KVER ?= $(shell uname -r)
+KDIR ?= /lib/modules/$(KVER)/build
+
+all:
+	make -C $(KDIR) M=$(PWD) modules
+
+clean:
+	make -C $(KDIR) M=$(PWD) clean
+
+test:
+	gcc test.c -Wall -Werror -g -Og -o test	
+
+load: all
+	grep -q '^uio'   /proc/modules || sudo modprobe uio
+	grep -q '^kvmfr' /proc/modules && sudo rmmod kvmfr || true
+	sudo insmod ./kvmfr.ko
+	sudo chown $(USER) /dev/uio0
+	sudo chown $(USER) /dev/kvmfr0
+
+.PHONY: test
diff --git a/drivers/custom/kvfm/module/kvmfr.c b/drivers/custom/kvfm/module/kvmfr.c
new file mode 100644
index 000000000000..9bcff378b485
--- /dev/null
+++ b/drivers/custom/kvfm/module/kvmfr.c
@@ -0,0 +1,662 @@
+/**
+ * Looking Glass
+ * Copyright  2017-2025 The Looking Glass Authors
+ * https://looking-glass.io
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#define PCI_KVMFR_VENDOR_ID 0x1af4 //Red Hat Inc,
+#define PCI_KVMFR_DEVICE_ID 0x1110 //Inter-VM shared memory
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/dma-buf.h>
+#include <linux/highmem.h>
+#include <linux/memremap.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+
+#include <asm/io.h>
+
+#ifdef CONFIG_AMD_MEM_ENCRYPT
+#include <asm/mem_encrypt.h>
+#endif
+
+#include "kvmfr.h"
+
+DEFINE_MUTEX(minor_lock);
+DEFINE_IDR(kvmfr_idr);
+
+#define KVMFR_DEV_NAME    "kvmfr"
+#define KVMFR_MAX_DEVICES 10
+
+static int static_size_mb[KVMFR_MAX_DEVICES];
+static int static_count;
+module_param_array(static_size_mb, int, &static_count, 0000);
+MODULE_PARM_DESC(static_size_mb, "List of static devices to create in MiB");
+
+struct kvmfr_info
+{
+  int             major;
+  struct class  * pClass;
+};
+
+static struct kvmfr_info *kvmfr;
+
+enum kvmfr_type
+{
+  KVMFR_TYPE_PCI,
+  KVMFR_TYPE_STATIC,
+};
+
+struct kvmfr_dev
+{
+  unsigned long        size;
+  int                  minor;
+  dev_t                devNo;
+  struct device      * pDev;
+  struct dev_pagemap   pgmap;
+  void               * addr;
+  enum kvmfr_type      type;
+};
+
+struct kvmfrbuf
+{
+  struct kvmfr_dev    * kdev;
+  pgoff_t               pagecount;
+  unsigned long         offset;
+  struct page        ** pages;
+};
+
+static vm_fault_t kvmfr_vm_fault(struct vm_fault *vmf)
+{
+  struct vm_area_struct *vma = vmf->vma;
+  struct kvmfrbuf *kbuf = (struct kvmfrbuf *)vma->vm_private_data;
+  pgoff_t pgoff = vmf->pgoff;
+
+  if (pgoff >= kbuf->pagecount)
+    return VM_FAULT_SIGBUS;
+
+  vmf->page = kbuf->pages[pgoff];
+  get_page(vmf->page);
+  return 0;
+}
+
+static const struct vm_operations_struct kvmfr_vm_ops =
+{
+  .fault = kvmfr_vm_fault
+};
+
+static struct sg_table * map_kvmfrbuf(struct dma_buf_attachment *at,
+    enum dma_data_direction direction)
+{
+  struct kvmfrbuf *kbuf = at->dmabuf->priv;
+  struct sg_table *sg;
+  int ret;
+
+  sg = kzalloc(sizeof(*sg), GFP_KERNEL);
+  if (!sg)
+    return ERR_PTR(-ENOMEM);
+
+  ret = sg_alloc_table_from_pages(sg, kbuf->pages, kbuf->pagecount,
+      0, kbuf->pagecount << PAGE_SHIFT, GFP_KERNEL);
+  if (ret < 0)
+    goto err;
+
+  if (!dma_map_sg(at->dev, sg->sgl, sg->nents, direction))
+  {
+    ret = -EINVAL;
+    goto err;
+  }
+
+  return sg;
+
+err:
+  sg_free_table(sg);
+  kfree(sg);
+  return ERR_PTR(ret);
+}
+
+static void unmap_kvmfrbuf(struct dma_buf_attachment * at, struct sg_table * sg,
+    enum dma_data_direction direction)
+{
+  dma_unmap_sg(at->dev, sg->sgl, sg->nents, direction);
+  sg_free_table(sg);
+  kfree(sg);
+}
+
+static void release_kvmfrbuf(struct dma_buf * buf)
+{
+  struct kvmfrbuf *kbuf = (struct kvmfrbuf *)buf->priv;
+  kfree(kbuf->pages);
+  kfree(kbuf);
+}
+
+static int mmap_kvmfrbuf(struct dma_buf * buf, struct vm_area_struct * vma)
+{
+  struct kvmfrbuf * kbuf = (struct kvmfrbuf *)buf->priv;
+  unsigned long size = vma->vm_end - vma->vm_start;
+  unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+
+  if ((offset + size > (kbuf->pagecount << PAGE_SHIFT))
+      || (offset + size < offset))
+    return -EINVAL;
+
+  if ((vma->vm_flags & (VM_SHARED | VM_MAYSHARE)) == 0)
+    return -EINVAL;
+
+  switch (kbuf->kdev->type)
+  {
+    case KVMFR_TYPE_PCI:
+      vma->vm_ops          = &kvmfr_vm_ops;
+      vma->vm_private_data = buf->priv;
+      return 0;
+
+    case KVMFR_TYPE_STATIC:
+      return remap_vmalloc_range(vma, kbuf->kdev->addr + kbuf->offset,
+          vma->vm_pgoff);
+
+    default:
+      return -EINVAL;
+  }
+}
+
+static const struct dma_buf_ops kvmfrbuf_ops =
+{
+  .map_dma_buf   = map_kvmfrbuf,
+  .unmap_dma_buf = unmap_kvmfrbuf,
+  .release       = release_kvmfrbuf,
+  .mmap          = mmap_kvmfrbuf
+};
+
+static long kvmfr_dmabuf_create(struct kvmfr_dev * kdev, struct file * filp,
+    unsigned long arg)
+{
+  struct kvmfr_dmabuf_create create;
+  DEFINE_DMA_BUF_EXPORT_INFO(exp_kdev);
+  struct kvmfrbuf * kbuf;
+  struct dma_buf  * buf;
+  u32 i;
+  u8 *p;
+  int ret = -EINVAL;
+
+  if (copy_from_user(&create, (void __user *)arg,
+        sizeof(create)))
+      return -EFAULT;
+
+  if (!IS_ALIGNED(create.offset, PAGE_SIZE) ||
+      !IS_ALIGNED(create.size  , PAGE_SIZE))
+  {
+    printk("kvmfr: buffer not aligned to 0x%lx bytes", PAGE_SIZE);
+    return -EINVAL;
+  }
+
+  if ((create.offset + create.size > kdev->size) ||
+      (create.offset + create.size < create.offset))
+    return -EINVAL;
+
+  kbuf = kzalloc(sizeof(struct kvmfrbuf), GFP_KERNEL);
+  if (!kbuf)
+    return -ENOMEM;
+
+  kbuf->kdev      = kdev;
+  kbuf->pagecount = create.size >> PAGE_SHIFT;
+  kbuf->offset    = create.offset;
+  kbuf->pages     = kmalloc_array(kbuf->pagecount, sizeof(*kbuf->pages),
+      GFP_KERNEL);
+  if (!kbuf->pages)
+  {
+    ret = -ENOMEM;
+    goto err;
+  }
+
+  p = ((u8*)kdev->addr) + create.offset;
+
+  switch (kdev->type)
+  {
+    case KVMFR_TYPE_PCI:
+      for (i = 0; i < kbuf->pagecount; ++i)
+      {
+        kbuf->pages[i] = virt_to_page(p);
+        p += PAGE_SIZE;
+      }
+      break;
+
+    case KVMFR_TYPE_STATIC:
+      for (i = 0; i < kbuf->pagecount; ++i)
+      {
+        kbuf->pages[i] = vmalloc_to_page(p);
+        p += PAGE_SIZE;
+      }
+      break;
+  }
+
+  exp_kdev.ops   = &kvmfrbuf_ops;
+  exp_kdev.size  = create.size;
+  exp_kdev.priv  = kbuf;
+  exp_kdev.flags = O_RDWR;
+
+  buf = dma_buf_export(&exp_kdev);
+  if (IS_ERR(buf))
+  {
+    ret = PTR_ERR(buf);
+    goto err;
+  }
+
+  printk("kvmfr_dmabuf_create with size %llu offset: %llu",
+      create.size, create.offset);
+  return dma_buf_fd(buf, create.flags & KVMFR_DMABUF_FLAG_CLOEXEC ? O_CLOEXEC : 0);
+
+err:
+  kfree(kbuf->pages);
+  kfree(kbuf);
+  return ret;
+}
+
+static long device_ioctl(struct file * filp, unsigned int ioctl,
+    unsigned long arg)
+{
+  struct kvmfr_dev * kdev;
+  long ret;
+
+  kdev = (struct kvmfr_dev *)idr_find(&kvmfr_idr, iminor(filp->f_inode));
+  if (!kdev)
+    return -EINVAL;
+
+  switch(ioctl)
+  {
+    case KVMFR_DMABUF_CREATE:
+      ret = kvmfr_dmabuf_create(kdev, filp, arg);
+      break;
+
+    case KVMFR_DMABUF_GETSIZE:
+      ret = kdev->size;
+      break;
+
+    default:
+      return -ENOTTY;
+  }
+
+  return ret;
+}
+
+static vm_fault_t pci_mmap_fault(struct vm_fault *vmf)
+{
+  struct vm_area_struct * vma = vmf->vma;
+  struct kvmfr_dev * kdev = (struct kvmfr_dev *)vma->vm_private_data;
+
+  vmf->page = virt_to_page(kdev->addr + (vmf->pgoff << PAGE_SHIFT));
+  get_page(vmf->page);
+  return 0;
+}
+
+static const struct vm_operations_struct pci_mmap_ops =
+{
+  .fault = pci_mmap_fault
+};
+
+static int device_mmap(struct file * filp, struct vm_area_struct * vma)
+{
+  struct kvmfr_dev * kdev;
+  unsigned long size = vma->vm_end - vma->vm_start;
+  unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+
+  kdev = (struct kvmfr_dev *)idr_find(&kvmfr_idr, iminor(filp->f_inode));
+  if (!kdev)
+    return -EINVAL;
+
+  if ((offset + size > kdev->size) || (offset + size < offset))
+    return -EINVAL;
+
+  printk(KERN_INFO "mmap kvmfr%d: %lx-%lx with size %lu offset %lu\n",
+      kdev->minor, vma->vm_start, vma->vm_end, size, offset);
+
+  switch (kdev->type)
+  {
+    case KVMFR_TYPE_PCI:
+#ifdef CONFIG_AMD_MEM_ENCRYPT
+      /* Clear C-bit for ivshmem when mapped
+       * as normal memory to the userspace
+       *
+       * devm_memremap below will "hotplug" the ivshmem as normal mem,
+       * when sev and/or sev-snp is effective,
+       * ivshmem will be encrypted and private memory.
+       *
+       * However, this is not the intention of ivshmem, as it
+       * is meant to be shared with other VMs and the hypervisor.
+       *
+       * Mapping ivshmem as iomem could resolve the sev/sev-snp issue,
+       * but it then will not be cached and the performance is low.
+       *
+       * To maintain high performance yet make it shared, we should
+       * clear the C-bit for ivshmem.
+       */
+      vma->vm_page_prot.pgprot &= ~(sme_me_mask);
+#endif
+      vma->vm_ops          = &pci_mmap_ops;
+      vma->vm_private_data = kdev;
+      return 0;
+
+    case KVMFR_TYPE_STATIC:
+      return remap_vmalloc_range(vma, kdev->addr, vma->vm_pgoff);
+
+    default:
+      return -ENODEV;
+  }
+}
+
+static struct file_operations fops =
+{
+  .owner          = THIS_MODULE,
+  .unlocked_ioctl = device_ioctl,
+  .mmap           = device_mmap,
+};
+
+static int kvmfr_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+  struct kvmfr_dev *kdev;
+
+  kdev = kzalloc(sizeof(struct kvmfr_dev), GFP_KERNEL);
+  if (!kdev)
+  {
+    printk(KERN_INFO "kvmfr: kvmfr_pci_probe: failed to allocate memory!\n");
+    return -ENOMEM;
+  }
+
+  if (pci_enable_device(dev))
+  {
+    printk(KERN_INFO "kvmfr: kvmfr_pci_probe: failed to enable device!\n");
+    goto out_free;
+  }
+
+  if (pci_request_regions(dev, KVMFR_DEV_NAME))
+  {
+    printk(KERN_INFO "kvmfr: kvmfr_pci_probe: failed to request regions!\n");
+    goto out_disable;
+  }
+
+  kdev->size = pci_resource_len(dev, 2);
+  kdev->type = KVMFR_TYPE_PCI;
+
+  mutex_lock(&minor_lock);
+  kdev->minor = idr_alloc(&kvmfr_idr, kdev, 0, KVMFR_MAX_DEVICES, GFP_KERNEL);
+  if (kdev->minor < 0)
+  {
+    printk(KERN_INFO "kvmfr: kvmfr_pci_probe: failed to allocate ID!\n");
+    mutex_unlock(&minor_lock);
+    goto out_release;
+  }
+  mutex_unlock(&minor_lock);
+
+  kdev->devNo = MKDEV(kvmfr->major, kdev->minor);
+  kdev->pDev  = device_create(kvmfr->pClass, NULL, kdev->devNo, NULL,
+      KVMFR_DEV_NAME "%d", kdev->minor);
+  if (IS_ERR(kdev->pDev))
+  {
+    printk(
+        KERN_INFO "kvmfr: kvmfr_pci_probe: failed to create /dev/%s%d device!\n",
+        KVMFR_DEV_NAME,
+        kdev->minor);
+    goto out_unminor;
+  }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+  kdev->pgmap.res.start = pci_resource_start(dev, 2);
+  kdev->pgmap.res.end   = pci_resource_end  (dev, 2);
+  kdev->pgmap.res.flags = pci_resource_flags(dev, 2);
+#else
+  kdev->pgmap.range.start = pci_resource_start(dev, 2);
+  kdev->pgmap.range.end   = pci_resource_end  (dev, 2);
+  kdev->pgmap.nr_range    = 1;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+  kdev->pgmap.type = MEMORY_DEVICE_DEVDAX;
+#else
+  kdev->pgmap.type = MEMORY_DEVICE_GENERIC;
+#endif
+
+  kdev->addr = devm_memremap_pages(&dev->dev, &kdev->pgmap);
+  if (IS_ERR(kdev->addr))
+  {
+    printk(
+        KERN_INFO "kvmfr: kvmfr_pci_probe: failed to remap pages! ret = %ld\n",
+        PTR_ERR(kdev->addr));
+    goto out_destroy;
+  }
+
+  pci_set_drvdata(dev, kdev);
+  printk(
+      KERN_INFO "kvmfr: kvmfr_pci_probe: /dev/%s%d created\n",
+      KVMFR_DEV_NAME,
+      kdev->minor);
+  return 0;
+
+out_destroy:
+  device_destroy(kvmfr->pClass, kdev->devNo);
+out_unminor:
+  mutex_lock(&minor_lock);
+  idr_remove(&kvmfr_idr, kdev->minor);
+  mutex_unlock(&minor_lock);
+out_release:
+  pci_release_regions(dev);
+out_disable:
+  pci_disable_device(dev);
+out_free:
+  kfree(kdev);
+  return -ENODEV;
+}
+
+static void kvmfr_pci_remove(struct pci_dev *dev)
+{
+  struct kvmfr_dev *kdev = pci_get_drvdata(dev);
+
+  devm_memunmap_pages(&dev->dev, &kdev->pgmap);
+  device_destroy(kvmfr->pClass, kdev->devNo);
+
+  mutex_lock(&minor_lock);
+  idr_remove(&kvmfr_idr, kdev->minor);
+  mutex_unlock(&minor_lock);
+
+  pci_release_regions(dev);
+  pci_disable_device(dev);
+
+  kfree(kdev);
+}
+
+static struct pci_device_id kvmfr_pci_ids[] =
+{
+  {
+    .vendor    = PCI_KVMFR_VENDOR_ID,
+    .device    = PCI_KVMFR_DEVICE_ID,
+    .subvendor = PCI_ANY_ID,
+    .subdevice = PCI_ANY_ID
+  },
+  { 0, }
+};
+
+static struct pci_driver kvmfr_pci_driver =
+{
+  .name     = KVMFR_DEV_NAME,
+  .id_table = kvmfr_pci_ids,
+  .probe    = kvmfr_pci_probe,
+  .remove   = kvmfr_pci_remove
+};
+
+static int create_static_device_unlocked(int size_mb)
+{
+  struct kvmfr_dev * kdev;
+  int ret = -ENODEV;
+
+  kdev = kzalloc(sizeof(struct kvmfr_dev), GFP_KERNEL);
+  if (!kdev)
+    return -ENOMEM;
+
+  kdev->size = size_mb * 1024 * 1024;
+  kdev->type = KVMFR_TYPE_STATIC;
+  kdev->addr = vmalloc_user(kdev->size);
+  if (!kdev->addr)
+  {
+    printk(
+        KERN_ERR "kvmfr: failed to allocate memory for static device: %d MiB\n",
+        size_mb);
+    ret = -ENOMEM;
+    goto out_free;
+  }
+
+  kdev->minor = idr_alloc(&kvmfr_idr, kdev, 0, KVMFR_MAX_DEVICES, GFP_KERNEL);
+  if (kdev->minor < 0)
+    goto out_release;
+
+  kdev->devNo = MKDEV(kvmfr->major, kdev->minor);
+  kdev->pDev  = device_create(kvmfr->pClass, NULL, kdev->devNo, NULL,
+      KVMFR_DEV_NAME "%d", kdev->minor);
+  if (IS_ERR(kdev->pDev))
+    goto out_unminor;
+
+  return 0;
+
+out_unminor:
+  idr_remove(&kvmfr_idr, kdev->minor);
+out_release:
+  vfree(kdev->addr);
+out_free:
+  kfree(kdev);
+  return ret;
+}
+
+static void free_static_device_unlocked(struct kvmfr_dev * kdev)
+{
+  device_destroy(kvmfr->pClass, kdev->devNo);
+  idr_remove(&kvmfr_idr, kdev->minor);
+  vfree(kdev->addr);
+  kfree(kdev);
+}
+
+static void free_static_devices(void)
+{
+  int id;
+  struct kvmfr_dev * kdev;
+
+  mutex_lock(&minor_lock);
+  idr_for_each_entry(&kvmfr_idr, kdev, id)
+    free_static_device_unlocked(kdev);
+  mutex_unlock(&minor_lock);
+}
+
+static int create_static_devices(void)
+{
+  int i;
+  int ret = 0;
+
+  mutex_lock(&minor_lock);
+  printk(KERN_INFO "kvmfr: creating %d static devices\n", static_count);
+  for (i = 0; i < static_count; ++i)
+  {
+    ret = create_static_device_unlocked(static_size_mb[i]);
+    if (ret < 0)
+      break;
+  }
+  mutex_unlock(&minor_lock);
+
+  if (ret < 0)
+    free_static_devices();
+  return ret;
+}
+
+static int __init kvmfr_module_init(void)
+{
+  int ret;
+
+  kvmfr = kzalloc(sizeof(struct kvmfr_info), GFP_KERNEL);
+  if (!kvmfr) {
+    printk(KERN_INFO "kvmfr: kvmfr_module_init: failed to allocate memory!\n");
+    return -ENOMEM;
+  }
+
+  kvmfr->major = register_chrdev(0, KVMFR_DEV_NAME, &fops);
+  if (kvmfr->major < 0) {
+    printk(
+        KERN_INFO "kvmfr: kvmfr_module_init: failed to register char device!\n");
+    goto out_free;
+  }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
+  kvmfr->pClass = class_create(THIS_MODULE, KVMFR_DEV_NAME);
+#else
+  kvmfr->pClass = class_create(KVMFR_DEV_NAME);
+#endif
+  if (IS_ERR(kvmfr->pClass)) {
+    printk(KERN_INFO "kvmfr: kvmfr_module_init: failed to create class!\n");
+    goto out_unreg;
+  }
+
+  ret = create_static_devices();
+  if (ret < 0) {
+    printk(
+        KERN_INFO "kvmfr: kvmfr_module_init: failed to create static devices!\n");
+    goto out_class_destroy;
+  }
+
+  ret = pci_register_driver(&kvmfr_pci_driver);
+  if (ret < 0) {
+    printk(
+        KERN_INFO "kvmfr: kvmfr_module_init: failed to register pci driver!\n");
+    goto out_free_static;
+  }
+
+  printk(KERN_INFO "kvmfr: kvmfr_module_init: module loaded\n");
+  return 0;
+
+out_free_static:
+  free_static_devices();
+out_class_destroy:
+  class_destroy(kvmfr->pClass);
+out_unreg:
+  unregister_chrdev(kvmfr->major, KVMFR_DEV_NAME);
+out_free:
+  kfree(kvmfr);
+
+  kvmfr = NULL;
+  return -ENODEV;
+}
+
+static void __exit kvmfr_module_exit(void)
+{
+  pci_unregister_driver(&kvmfr_pci_driver);
+  free_static_devices();
+  class_destroy(kvmfr->pClass);
+  unregister_chrdev(kvmfr->major, KVMFR_DEV_NAME);
+  kfree(kvmfr);
+  kvmfr = NULL;
+}
+
+module_init(kvmfr_module_init);
+module_exit(kvmfr_module_exit);
+
+MODULE_DEVICE_TABLE(pci, kvmfr_pci_ids);
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Geoffrey McRae <geoff@hostfission.com>");
+MODULE_AUTHOR("Guanzhong Chen <quantum2048@gmail.com>");
+MODULE_VERSION("0.0.12");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,13,0)
+MODULE_IMPORT_NS("DMA_BUF");
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5,16,0)
+MODULE_IMPORT_NS(DMA_BUF);
+#endif
diff --git a/drivers/custom/kvfm/module/kvmfr.h b/drivers/custom/kvfm/module/kvmfr.h
new file mode 100644
index 000000000000..23c01e359a28
--- /dev/null
+++ b/drivers/custom/kvfm/module/kvmfr.h
@@ -0,0 +1,38 @@
+/**
+ * Looking Glass
+ * Copyright  2017-2025 The Looking Glass Authors
+ * https://looking-glass.io
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef _KVMFR_H
+#define _KVMFR_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define KVMFR_DMABUF_FLAG_CLOEXEC 0x1
+
+struct kvmfr_dmabuf_create {
+  __u8  flags;
+  __u64 offset;
+  __u64 size;
+};
+
+#define KVMFR_DMABUF_GETSIZE _IO('u', 0x44)
+#define KVMFR_DMABUF_CREATE  _IOW('u', 0x42, struct kvmfr_dmabuf_create)
+
+#endif
\ No newline at end of file
diff --git a/drivers/custom/kvfm/module/test.c b/drivers/custom/kvfm/module/test.c
new file mode 100644
index 000000000000..8833977edd35
--- /dev/null
+++ b/drivers/custom/kvfm/module/test.c
@@ -0,0 +1,138 @@
+/**
+ * Looking Glass
+ * Copyright  2017-2025 The Looking Glass Authors
+ * https://looking-glass.io
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+
+#include "kvmfr.h"
+
+int main(void)
+{
+  int page_size = getpagesize();
+
+  int fd = open("/dev/kvmfr0", O_RDWR);
+  if (fd < 0)
+  {
+    perror("open");
+    return -1;
+  }
+
+  unsigned long size      = ioctl(fd, KVMFR_DMABUF_GETSIZE , 0);
+  printf("Size: %lu MiB\n", size / 1024 / 1024);
+
+  // mmaping 0-offset dmabuf with 0 offset
+  struct kvmfr_dmabuf_create create =
+  {
+    .flags  = KVMFR_DMABUF_FLAG_CLOEXEC,
+    .offset = 0x0,
+    .size   = size,
+  };
+  int dmaFd = ioctl(fd, KVMFR_DMABUF_CREATE, &create);
+  if (dmaFd < 0)
+  {
+    perror("ioctl");
+    return -1;
+  }
+
+  void * mem = mmap(NULL, create.size, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0);
+  if (mem == MAP_FAILED)
+  {
+    perror("mmap on dmabuf with no offset");
+    return -1;
+  }
+  memset(mem, 0xAA, create.size);
+  strcpy(mem + page_size, "Hello, world!");
+  munmap(mem, create.size);
+
+  // mmaping 0-offset dmabuf with 1 page offset
+  mem = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, page_size);
+  if (mem == MAP_FAILED)
+  {
+    perror("mmap on dmabuf with offset");
+    return -1;
+  }
+  printf("Read string: %s\n", (char *) mem);
+  munmap(mem, page_size);
+
+  close(dmaFd);
+
+  // mmaping page-offset dmabuf with 0 offset
+  create.offset = page_size;
+  create.size   = 2 * page_size;
+  dmaFd = ioctl(fd, KVMFR_DMABUF_CREATE, &create);
+  mem = mmap(NULL, create.size, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0);
+  if (mem == MAP_FAILED)
+  {
+    perror("mmap on offset dmabuf with no offset");
+    return -1;
+  }
+  printf("Read string: %s\n", (char *) mem);
+  munmap(mem, create.size);
+
+  // mmaping page-offset dmabuf with 1 page offset
+  char *bytes = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, page_size);
+  if (bytes == MAP_FAILED)
+  {
+    perror("mmap on offset dmabuf with offset");
+    return -1;
+  }
+  for (int i = 0; i < page_size; i++)
+    if (bytes[i] != (char) 0xAA)
+      printf("Index: %d: 0x%02x\n", i, (unsigned) bytes[i]);
+  munmap(mem, page_size);
+
+  close(dmaFd);
+
+  // mmaping device with 0 offset
+  mem = mmap(NULL, page_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, page_size);
+  if (mem == MAP_FAILED)
+  {
+    perror("mmap on file with offset");
+    return -1;
+  }
+  printf("Read string: %s\n", (char *) mem);
+  munmap(mem, page_size);
+
+  // mmaping device with 0 offset
+  uint32_t *data = mmap(NULL, create.size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+  if (data == MAP_FAILED)
+  {
+    perror("mmap on file with no offset");
+    return -1;
+  }
+  for (size_t i = 0; i < create.size / sizeof(uint32_t); i++)
+  {
+    if (data[i] != 0xAAAAAAAA)
+      printf("Index %lu: 0x%08" PRIx32 "\n", i, data[i]);
+  }
+  munmap(data, create.size);
+
+  close(fd);
+  return 0;
+}
# ----------------------------------------
# Module: razer
# Version: 0663c556e527
# ----------------------------------------
diff --git a/drivers/custom/razer/driver/Makefile b/drivers/custom/razer/driver/Makefile
new file mode 100644
index 000000000000..5d7c515f232a
--- /dev/null
+++ b/drivers/custom/razer/driver/Makefile
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+obj-m := razerkbd.o razermouse.o razerkraken.o razeraccessory.o
+
+razerkbd-y := razerkbd_driver.o razercommon.o razerchromacommon.o
+razermouse-y := razermouse_driver.o razercommon.o razerchromacommon.o
+razerkraken-y := razerkraken_driver.o razercommon.o
+razeraccessory-y := razeraccessory_driver.o razercommon.o razerchromacommon.o
+
+ccflags-y := -std=gnu99 -Wno-declaration-after-statement
+KERNEL_SOURCE_DIR := /lib/modules/$(shell uname -r)/build
+
+all:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" modules
+
+clean:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" clean
diff --git a/drivers/custom/razer/driver/razeraccessory_driver.c b/drivers/custom/razer/driver/razeraccessory_driver.c
new file mode 100644
index 000000000000..6120bdccd07f
--- /dev/null
+++ b/drivers/custom/razer/driver/razeraccessory_driver.c
@@ -0,0 +1,2574 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+#include <linux/random.h>
+
+#include "razeraccessory_driver.h"
+#include "razercommon.h"
+#include "razerchromacommon.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_DESC "Razer Accessory Device Driver"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+/**
+ * Send report to the device
+ */
+static int razer_get_report(struct usb_device *usb_dev, struct razer_report *request, struct razer_report *response)
+{
+    switch (usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        return razer_get_usb_response(usb_dev, 0x00, request, 0x00, response, RAZER_NEW_DEVICE_WAIT_MIN_US, RAZER_NEW_DEVICE_WAIT_MAX_US);
+        break;
+
+    default:
+        return razer_get_usb_response(usb_dev, 0x00, request, 0x00, response, RAZER_ACCESSORY_WAIT_MIN_US, RAZER_ACCESSORY_WAIT_MAX_US);
+    }
+}
+
+/**
+ * Function to send to device, get response, and actually check the response
+ */
+static int razer_send_payload(struct razer_accessory_device *device, struct razer_report *request, struct razer_report *response)
+{
+    int err;
+
+    request->crc = razer_calculate_crc(request);
+
+    mutex_lock(&device->lock);
+    err = razer_get_report(device->usb_dev, request, response);
+    mutex_unlock(&device->lock);
+    if (err) {
+        print_erroneous_report(response, "razeraccessory", "Invalid Report Length");
+        return err;
+    }
+
+    /* Check the packet number, class and command are the same */
+    if (response->remaining_packets != request->remaining_packets ||
+        response->command_class != request->command_class ||
+        response->command_id.id != request->command_id.id) {
+        print_erroneous_report(response, "razeraccessory", "Response doesn't match request");
+        return -EIO;
+    }
+
+    switch (response->status) {
+    case RAZER_CMD_BUSY:
+        // TODO: Check if this should be an error.
+        // print_erroneous_report(&response, "razeraccessory", "Device is busy");
+        break;
+    case RAZER_CMD_FAILURE:
+        print_erroneous_report(response, "razeraccessory", "Command failed");
+        return -EIO;
+    case RAZER_CMD_NOT_SUPPORTED:
+        print_erroneous_report(response, "razeraccessory", "Command not supported");
+        return -EIO;
+    case RAZER_CMD_TIMEOUT:
+        print_erroneous_report(response, "razeraccessory", "Command timed out");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/**
+ * Device mode function
+ */
+static void razer_set_device_mode(struct razer_accessory_device *device, unsigned char mode, unsigned char param)
+{
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_set_device_mode(mode, param);
+    request.transaction_id.id = 0x3F;
+
+    razer_send_payload(device, &request, &response);
+}
+
+/**
+ * Read device file "version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", DRIVER_VERSION);
+}
+
+/**
+ * Read device file "device_type"
+ *
+ * Returns friendly string of device type
+ */
+static ssize_t razer_attr_read_device_type(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+
+    char *device_type;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+        device_type = "Razer Firefly\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        device_type = "Razer Firefly V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        device_type = "Razer Firefly Hyperflux\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        device_type = "Razer Goliathus\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        device_type = "Razer Goliathus Extended\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        device_type = "Razer Goliathus Chroma 3XL\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CORE:
+        device_type = "Razer Core\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        device_type = "Razer Core X Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        device_type = "Razer Laptop Stand Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        device_type = "Razer Chroma Mug Holder\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        device_type = "Razer Chroma HDK\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        device_type = "Razer Base Station Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        device_type = "Razer Base Station V2 Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        device_type = "Razer Nommo Pro\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        device_type = "Razer Nommo Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        device_type = "Razer Kraken Kitty Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        device_type = "Razer Mouse Bungee V3 Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        device_type = "Razer Charging Pad Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+        device_type = "Razer Mouse Dock\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        device_type = "Razer Thunderbolt 4 Dock Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        device_type = "Razer Raptor 27\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        device_type = "Razer Chroma Addressable RGB Controller\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        device_type = "Razer Laptop Stand Chroma V2\n";
+        break;
+
+    default:
+        device_type = "Unknown Device\n";
+        break;
+    }
+
+    return sprintf(buf, device_type);
+}
+
+/**
+ * Write device file "test"
+ *
+ * Does nothing
+ */
+static ssize_t razer_attr_write_test(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;
+}
+
+/**
+ * Read device file "test"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_test(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "\n");
+}
+
+/**
+ * Write device file "mode_spectrum"
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_matrix_effect_spectrum();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Must be in normal mode for hardware effects
+        razer_set_device_mode(device, 0x00, 0x00);
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_reactive"
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char speed;
+
+    if (count != 4) {
+        printk(KERN_WARNING "razeraccessory: Reactive only accepts Speed, RGB (4byte)\n");
+        return -EINVAL;
+    }
+
+    speed = (unsigned char)buf[0];
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, ZERO_LED, speed, (struct razer_rgb *)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        request = razer_chroma_standard_matrix_effect_reactive(speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_reactive_trigger"
+ *
+ * It triggers the mouse pad when written to
+ */
+static ssize_t razer_attr_write_matrix_reactive_trigger(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    struct razer_rgb rgb = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        // TODO: Fix reactive trigger for Goliathus
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, ZERO_LED, 0, &rgb);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+        // TODO: Issue zeroed out razer_chroma_standard_matrix_effect_reactive report
+        request = razer_chroma_misc_matrix_reactive_trigger();
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_none"
+ *
+ * None effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_matrix_effect_none();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Must be in normal mode for hardware effects
+        razer_set_device_mode(device, 0x00, 0x00);
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_blinking"
+ *
+ * Blinking effect mode is activated whenever the file is written to with 3 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_blinking(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razeraccessory: Blinking mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_standard_set_led_rgb(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+    request.transaction_id.id = 0x3F;
+
+    razer_send_payload(device, &request, &response);
+
+    msleep(5);
+
+    request = razer_chroma_standard_set_led_effect(VARSTORE, BACKLIGHT_LED, CLASSIC_EFFECT_BLINKING);
+    request.transaction_id.id = 0x3F;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_custom"
+ *
+ * Sets the device to custom mode whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_custom(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_static"
+ *
+ * Static effect mode is activated whenever the file is written to with 3 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razeraccessory: Static mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_matrix_effect_static((struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, ZERO_LED, (struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, ZERO_LED, (struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Must be in normal mode for hardware effects
+        razer_set_device_mode(device, 0x00, 0x00);
+        /**
+            * Mode switcher required after setting static color effect once and before setting a second time.
+            * Similar to Naga Trinity?
+            *
+            * If the color is not set twice with the mode switch in-between, each subsequent
+            * setting of the static effect actually sets the previous color...
+            */
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, ZERO_LED, (struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x1F;
+
+        razer_send_payload(device, &request, &response);
+
+        request = get_razer_report(0x0f, 0x02, 0x06);
+        request.arguments[0] = 0x00;
+        request.arguments[1] = 0x00;
+        request.arguments[2] = 0x08;
+        request.arguments[3] = 0x00;
+        request.arguments[4] = 0x00;
+        request.arguments[5] = 0x00;
+        request.transaction_id.id = 0x1F;
+
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, ZERO_LED, (struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_wave"
+ *
+ * When 1 is written (as a character, 0x31) the wave effect is displayed moving anti clockwise
+ * if 2 is written (0x32) then the wave effect goes clockwise
+ */
+static ssize_t razer_attr_write_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_matrix_effect_wave(direction);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, ZERO_LED, direction);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, ZERO_LED, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Must be in normal mode for hardware effects
+        razer_set_device_mode(device, 0x00, 0x00);
+        fallthrough;
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        // Direction values are flipped compared to other devices
+        direction ^= ((1<<0) | (1<<1));
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, ZERO_LED, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_breath"
+ *
+ * Breathing effect mode is activated whenever the file is written to with 1, 3, or 6 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0], (struct razer_rgb *)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, ZERO_LED);
+            break;
+        }
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0], (struct razer_rgb *)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, ZERO_LED);
+            break;
+        }
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Must be in normal mode for hardware effects
+        razer_set_device_mode(device, 0x00, 0x00);
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, ZERO_LED, (struct razer_rgb *)&buf[0], (struct razer_rgb *)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, ZERO_LED);
+            break;
+        }
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_single((struct razer_rgb*)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_dual((struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_random();
+            break;
+        }
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+static ssize_t razer_attr_write_matrix_effect_starlight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char speed = 0;
+
+    if (count != 1 && count != 4 && count != 7) {
+        printk(KERN_WARNING "razeraccessory: Starlight accepts only 1, 4 or 7 bytes input (speed, [RGB], [RGB])\n");
+        return -EINVAL;
+    }
+    speed = buf[0];
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        switch(count) {
+        case 4: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, ZERO_LED, speed, (struct razer_rgb *)&buf[1]);
+            break;
+
+        case 7: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_starlight_dual(VARSTORE, ZERO_LED, speed, (struct razer_rgb *)&buf[1], (struct razer_rgb *)&buf[4]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_starlight_random(VARSTORE, ZERO_LED, speed);
+            break;
+        }
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_custom_frame"
+ *
+ * Format
+ * ROW_ID START_COL STOP_COL RGB...
+ */
+static ssize_t razer_attr_write_matrix_custom_frame(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    size_t offset = 0;
+    unsigned char row_id, start_col, stop_col;
+    size_t row_length;
+
+    while(offset < count) {
+        if(offset + 3 > count) {
+            printk(KERN_ALERT "razeraccessory: Wrong Amount of data provided: Should be ROW_ID, START_COL, STOP_COL, N_RGB\n");
+            return -EINVAL;
+        }
+
+        row_id = buf[offset++];
+        start_col = buf[offset++];
+        stop_col = buf[offset++];
+
+        // Validate parameters
+        if(start_col > stop_col) {
+            printk(KERN_ALERT "razeraccessory: Start column (%u) is greater than end column (%u)\n", start_col, stop_col);
+            return -EINVAL;
+        }
+
+        row_length = ((stop_col + 1) - start_col) * 3;
+
+        if(count < offset + row_length) {
+            printk(KERN_ALERT "razeraccessory: Not enough RGB to fill row (expecting %lu bytes of RGB data, got %lu)\n", row_length, (count - 3));
+            return -EINVAL;
+        }
+
+        // printk(KERN_INFO "razeraccessory: Row ID: %u, Start: %u, Stop: %u, row length: %lu\n", row_id, start_col, stop_col, row_length);
+
+        switch (device->usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CORE:
+            request = razer_chroma_standard_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0xFF;
+            break;
+
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+            request = razer_chroma_misc_one_row_set_custom_frame(start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0xFF;
+            break;
+
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x3F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+            request = razer_chroma_extended_matrix_set_custom_frame2(row_id, start_col, stop_col, (unsigned char*)&buf[offset], 0);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+            // Must be in driver mode for custom effects
+            razer_set_device_mode(device, 0x03, 0x00);
+            request = razer_chroma_extended_matrix_set_custom_frame2(row_id, start_col, stop_col, (unsigned char*)&buf[offset], 0);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+            razer_send_argb_msg(device->usb_dev, row_id, (stop_col - start_col) + 1, (unsigned char*)&buf[offset]);
+            return count;
+
+        default:
+            printk(KERN_WARNING "razeraccessory: Unknown device\n");
+            return -EINVAL;
+        }
+
+        razer_send_payload(device, &request, &response);
+
+        // *3 as its 3 bytes per col (RGB)
+        offset += row_length;
+    }
+
+    return count;
+}
+
+/**
+ * Read device file "serial", doesn't have a proper one so one is generated
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_serial(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    char serial_string[51];
+
+    request = razer_chroma_standard_get_serial();
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        strncpy(&serial_string[0], &device->serial[0], sizeof(serial_string));
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        strncpy(&serial_string[0], &response.arguments[0], 22);
+        serial_string[22] = '\0';
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request.transaction_id.id = 0x1F;
+        razer_send_payload(device, &request, &response);
+        strncpy(&serial_string[0], &response.arguments[0], 22);
+        serial_string[22] = '\0';
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    return sprintf(buf, "%s\n", &serial_string[0]);
+}
+
+/**
+ * Read device file "get_firmware_version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_firmware_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_firmware_version();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        request.transaction_id.id = 0x3F;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "v%u.%u\n", response.arguments[0], response.arguments[1]);
+}
+
+/**
+ * Write device file "device_mode"
+ */
+static ssize_t razer_attr_write_device_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 2) {
+        printk(KERN_WARNING "razeraccessory: Device mode only takes 2 bytes.\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_standard_set_device_mode(buf[0], buf[1]);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+static ssize_t razer_attr_read_is_mug_present(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = get_razer_report(0x02, 0x81, 0x02);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%u\n", response.arguments[1]);
+}
+
+/**
+ * Read device file "device_mode"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_device_mode();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    buf[0] = response.arguments[0];
+    buf[1] = response.arguments[1];
+
+    return 2;
+}
+
+/**
+ * Write device file "set_brightness"
+ *
+ * Sets the brightness to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_matrix_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = 0;
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count < 1) {
+        printk(KERN_WARNING "razeraccessory: Brightness takes an ascii number\n");
+        return -EINVAL;
+    }
+
+    brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        device->saved_brightness = brightness;
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x1F;
+        device->saved_brightness = brightness;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        request = razer_chroma_standard_set_led_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        /* Set the brightness for all channels to the requested value */
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_1_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_2_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_3_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_4_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_5_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ARGB_CH_6_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "set_brightness"
+ *
+ * Returns brightness or -1 if the initial brightness is not known
+ */
+static ssize_t razer_attr_read_matrix_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report response = {0};
+    struct razer_report request = {0};
+    unsigned char brightness = 0;
+    size_t sum = 0;
+    size_t i;
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        brightness = device->saved_brightness;
+        break;
+
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        /* Get the average brightness of all channels */
+        for (i = ARGB_CH_1_LED; i <= ARGB_CH_6_LED; i++) {
+            request = razer_chroma_extended_matrix_get_brightness(VARSTORE, i);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            sum += response.arguments[2];
+        }
+        brightness = sum / 6;
+        break;
+
+    default:
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        brightness = response.arguments[2];
+        break;
+    }
+
+    return sprintf(buf, "%d\n", brightness);
+}
+
+/**
+ * Write charge brightness device files
+ *
+ * Sets the brightness to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_set_charge_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = 0;
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count < 1) {
+        printk(KERN_WARNING "razeraccessory: Brightness takes an ascii number\n");
+        return -EINVAL;
+    }
+
+    brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, led, brightness);
+        request.transaction_id.id = 0x1F;
+        device->saved_brightness = brightness;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read charge brightness device files
+ *
+ * Returns brightness or -1 if the initial brightness is not known
+ */
+static ssize_t razer_attr_read_set_charge_brightness(struct device *dev, struct device_attribute *attr, char *buf, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char brightness = 0;
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        brightness = device->saved_brightness;
+        break;
+
+    default:
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, led);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        brightness = response.arguments[2];
+        break;
+    }
+
+    return sprintf(buf, "%d\n", brightness);
+}
+
+/**
+ * Read device file "charging_led_brightness"
+ */
+static ssize_t razer_attr_read_charging_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_set_charge_brightness(dev, attr, buf, CHARGING_LED);
+}
+
+/**
+ * Write device file "charging_led_brightness"
+ */
+static ssize_t razer_attr_write_charging_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_set_charge_brightness(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Read device file "fast_charging_led_brightness"
+ */
+static ssize_t razer_attr_read_fast_charging_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_set_charge_brightness(dev, attr, buf, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_led_brightness"
+ */
+static ssize_t razer_attr_write_fast_charging_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_set_charge_brightness(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Read device file "fully_charged_led_brightness"
+ */
+static ssize_t razer_attr_read_fully_charged_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_set_charge_brightness(dev, attr, buf, FULLY_CHARGED_LED);
+}
+
+/**
+ * Write device file "fully_charged_led_brightness"
+ */
+static ssize_t razer_attr_write_fully_charged_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_set_charge_brightness(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+/**
+ * Write device file "mode_spectrum"
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_charge_mode_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, led);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charging_mode_spectrum"
+ */
+static ssize_t razer_attr_write_charging_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_charge_mode_spectrum(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_mode_spectrum"
+ */
+static ssize_t razer_attr_write_fast_charging_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_charge_mode_spectrum(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fully_charged_mode_spectrum"
+ */
+static ssize_t razer_attr_write_fully_charged_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_charge_mode_spectrum(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+static ssize_t razer_attr_write_matrix_effect_none_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, led);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charging_mode_none"
+ */
+static ssize_t razer_attr_write_charging_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_mode_none"
+ */
+static ssize_t razer_attr_write_fast_charging_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fully_charged_mode_none"
+ */
+static ssize_t razer_attr_write_fully_charged_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+static ssize_t razer_attr_write_matrix_effect_static_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razeraccessory: Static mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, led, (struct razer_rgb*) & buf[0]);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charging_mode_static"
+ */
+static ssize_t razer_attr_write_charging_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_mode_static"
+ */
+static ssize_t razer_attr_write_fast_charging_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fully_charged_mode_static"
+ */
+static ssize_t razer_attr_write_fully_charged_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+static ssize_t razer_attr_write_matrix_effect_wave_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        // Direction values are flipped compared to other devices
+        direction ^= ((1<<0) | (1<<1));
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, led, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charging_mode_wave"
+ */
+static ssize_t razer_attr_write_charging_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_mode_wave"
+ */
+static ssize_t razer_attr_write_fast_charging_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fully_charged_mode_wave"
+ */
+static ssize_t razer_attr_write_fully_charged_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+static ssize_t razer_attr_write_matrix_effect_breath_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, int led)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, led, (struct razer_rgb *)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, led, (struct razer_rgb *)&buf[0], (struct razer_rgb *)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, led);
+            break;
+        }
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razeraccessory: Unknown device\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charging_mode_breath"
+ */
+static ssize_t razer_attr_write_charging_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, CHARGING_LED);
+}
+
+/**
+ * Write device file "fast_charging_mode_breath"
+ */
+static ssize_t razer_attr_write_fast_charging_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, FAST_CHARGING_LED);
+}
+
+/**
+ * Write device file "fully_charged_mode_breath"
+ */
+static ssize_t razer_attr_write_fully_charged_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, FULLY_CHARGED_LED);
+}
+
+/**
+ * Sets the brightness to the ASCII number
+ */
+static ssize_t razer_attr_write_channel_led_brightness(unsigned char led, struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = 0;
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count < 1) {
+        printk(KERN_WARNING "razeraccessory: Brightness takes an ascii number\n");
+        return -EINVAL;
+    }
+
+    brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    request = razer_chroma_extended_matrix_brightness(VARSTORE, led, brightness);
+    request.transaction_id.id = 0x3F;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+static ssize_t razer_attr_write_channel1_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_1_LED, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel2_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_2_LED, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel3_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_3_LED, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel4_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_4_LED, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel5_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_5_LED, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel6_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_led_brightness(ARGB_CH_6_LED, dev, attr, buf, count);
+}
+
+/**
+ * Read device file "channelX_size"
+ */
+static ssize_t razer_attr_read_channel_size(unsigned int channel, struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = get_razer_report(0x0f, 0x88, 0x0d);
+    request.transaction_id.id = 0x1F;
+    request.arguments[0] = 0x06;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[channel * 2]);
+}
+
+static ssize_t razer_attr_read_channel1_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(1, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel2_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(2, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel3_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(3, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel4_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(4, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel5_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(5, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel6_size(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_size(6, dev, attr, buf);
+}
+
+/**
+ * Write device file "channelX_size"
+ */
+static ssize_t razer_attr_write_channel_size(unsigned int channel, struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    unsigned char sz;
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    struct razer_accessory_device *device;
+
+    if (count < 1) {
+        printk(KERN_WARNING "razeraccessory: Size takes an ascii number\n");
+        return -EINVAL;
+    }
+
+    device = dev_get_drvdata(dev);
+
+    /* Get existing sizes */
+    request = get_razer_report(0x0f, 0x88, 0x0d);
+    request.transaction_id.id = 0x1F;
+    request.arguments[0] = 0x06;
+
+    razer_send_payload(device, &request, &response);
+
+    /* Set new sizes */
+    sz = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    request = get_razer_report(0x0f, 0x08, 0x0d);
+    request.transaction_id.id = 0xFF;
+    request.arguments[0] = 0x06;
+    request.arguments[1] = 0x01;
+    request.arguments[2] = channel == 1 ? sz : response.arguments[2];
+    request.arguments[3] = 0x02;
+    request.arguments[4] = channel == 2 ? sz : response.arguments[4];
+    request.arguments[5] = 0x03;
+    request.arguments[6] = channel == 3 ? sz : response.arguments[6];
+    request.arguments[7] = 0x04;
+    request.arguments[8] = channel == 4 ? sz : response.arguments[8];
+    request.arguments[9] = 0x05;
+    request.arguments[10] = channel == 5 ? sz : response.arguments[10];
+    request.arguments[11] = 0x06;
+    request.arguments[12] = channel == 6 ? sz : response.arguments[12];
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+static ssize_t razer_attr_write_channel1_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(1, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel2_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(2, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel3_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(3, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel4_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(4, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel5_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(5, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_channel6_size(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_channel_size(6, dev, attr, buf, count);
+}
+
+static ssize_t razer_attr_write_reset_channels(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+
+    /* Get existing sizes */
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned int i;
+
+    for (i = 0; i < 6; i++) {
+        request = get_razer_report(0x0f, 0x04, 0x03);
+        request.transaction_id.id = 0x1F;
+        request.arguments[0] = 0x01;
+        request.arguments[1] = ARGB_CH_1_LED + i;
+        request.arguments[2] = 0xff;
+
+        razer_send_payload(device, &request, &response);
+    }
+
+    request = get_razer_report(0x00, 0xb7, 0x01);
+    request.transaction_id.id = 0x1F;
+    request.arguments[0] = 0x00;
+    razer_send_payload(device, &request, &response);
+
+    request = get_razer_report(0x00, 0x36, 0x01);
+    request.transaction_id.id = 0x1F;
+    request.arguments[0] = 0x01;
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "channelX_led_brightness"
+ *
+ * Returns brightness or -1 if the initial brightness is not known
+ */
+static ssize_t razer_attr_read_channel_led_brightness(unsigned char led, struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_accessory_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char brightness = 0;
+
+    request = razer_chroma_extended_matrix_get_brightness(VARSTORE, led);
+    request.transaction_id.id = 0x3F;
+
+    razer_send_payload(device, &request, &response);
+    brightness = response.arguments[2];
+
+    return sprintf(buf, "%d\n", brightness);
+}
+
+static ssize_t razer_attr_read_channel1_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_1_LED, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel2_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_2_LED, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel3_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_3_LED, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel4_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_4_LED, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel5_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_5_LED, dev, attr, buf);
+}
+
+static ssize_t razer_attr_read_channel6_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_channel_led_brightness(ARGB_CH_6_LED, dev, attr, buf);
+}
+
+/**
+ * Set up the device driver files
+
+ *
+ * Read only is 0444
+ * Write only is 0220
+ * Read and write is 0664
+ */
+
+static DEVICE_ATTR(test,                                    0660, razer_attr_read_test,                           razer_attr_write_test);
+static DEVICE_ATTR(version,                                 0440, razer_attr_read_version,                        NULL);
+static DEVICE_ATTR(device_type,                             0440, razer_attr_read_device_type,                    NULL);
+static DEVICE_ATTR(device_mode,                             0660, razer_attr_read_device_mode,                    razer_attr_write_device_mode);
+static DEVICE_ATTR(device_serial,                           0440, razer_attr_read_device_serial,                  NULL);
+static DEVICE_ATTR(firmware_version,                        0440, razer_attr_read_firmware_version,               NULL);
+
+static DEVICE_ATTR(matrix_effect_none,                      0220, NULL,                                           razer_attr_write_matrix_effect_none);
+static DEVICE_ATTR(matrix_effect_spectrum,                  0220, NULL,                                           razer_attr_write_matrix_effect_spectrum);
+static DEVICE_ATTR(matrix_effect_static,                    0220, NULL,                                           razer_attr_write_matrix_effect_static);
+static DEVICE_ATTR(matrix_effect_reactive,                  0220, NULL,                                           razer_attr_write_matrix_effect_reactive);
+static DEVICE_ATTR(matrix_effect_breath,                    0220, NULL,                                           razer_attr_write_matrix_effect_breath);
+static DEVICE_ATTR(matrix_effect_custom,                    0220, NULL,                                           razer_attr_write_matrix_effect_custom);
+static DEVICE_ATTR(matrix_effect_wave,                      0220, NULL,                                           razer_attr_write_matrix_effect_wave);
+static DEVICE_ATTR(matrix_effect_blinking,                  0220, NULL,                                           razer_attr_write_matrix_effect_blinking);
+static DEVICE_ATTR(matrix_effect_starlight,                 0220, NULL,                                           razer_attr_write_matrix_effect_starlight);
+static DEVICE_ATTR(matrix_brightness,                       0660, razer_attr_read_matrix_brightness,              razer_attr_write_matrix_brightness);
+static DEVICE_ATTR(matrix_custom_frame,                     0220, NULL,                                           razer_attr_write_matrix_custom_frame);
+static DEVICE_ATTR(matrix_reactive_trigger,                 0220, NULL,                                           razer_attr_write_matrix_reactive_trigger);
+
+static DEVICE_ATTR(charging_led_brightness,                 0660, razer_attr_read_charging_led_brightness,        razer_attr_write_charging_led_brightness);
+static DEVICE_ATTR(charging_matrix_effect_wave,             0220, NULL,                                           razer_attr_write_charging_matrix_effect_wave);
+static DEVICE_ATTR(charging_matrix_effect_spectrum,         0220, NULL,                                           razer_attr_write_charging_matrix_effect_spectrum);
+static DEVICE_ATTR(charging_matrix_effect_breath,           0220, NULL,                                           razer_attr_write_charging_matrix_effect_breath);
+static DEVICE_ATTR(charging_matrix_effect_static,           0220, NULL,                                           razer_attr_write_charging_matrix_effect_static);
+static DEVICE_ATTR(charging_matrix_effect_none,             0220, NULL,                                           razer_attr_write_charging_matrix_effect_none);
+
+static DEVICE_ATTR(fast_charging_led_brightness,            0660, razer_attr_read_fast_charging_led_brightness,   razer_attr_write_fast_charging_led_brightness);
+static DEVICE_ATTR(fast_charging_matrix_effect_wave,        0220, NULL,                                           razer_attr_write_fast_charging_matrix_effect_wave);
+static DEVICE_ATTR(fast_charging_matrix_effect_spectrum,    0220, NULL,                                           razer_attr_write_fast_charging_matrix_effect_spectrum);
+static DEVICE_ATTR(fast_charging_matrix_effect_breath,      0220, NULL,                                           razer_attr_write_fast_charging_matrix_effect_breath);
+static DEVICE_ATTR(fast_charging_matrix_effect_static,      0220, NULL,                                           razer_attr_write_fast_charging_matrix_effect_static);
+static DEVICE_ATTR(fast_charging_matrix_effect_none,        0220, NULL,                                           razer_attr_write_fast_charging_matrix_effect_none);
+
+static DEVICE_ATTR(fully_charged_led_brightness,            0660, razer_attr_read_fully_charged_led_brightness,   razer_attr_write_fully_charged_led_brightness);
+static DEVICE_ATTR(fully_charged_matrix_effect_wave,        0220, NULL,                                           razer_attr_write_fully_charged_matrix_effect_wave);
+static DEVICE_ATTR(fully_charged_matrix_effect_spectrum,    0220, NULL,                                           razer_attr_write_fully_charged_matrix_effect_spectrum);
+static DEVICE_ATTR(fully_charged_matrix_effect_breath,      0220, NULL,                                           razer_attr_write_fully_charged_matrix_effect_breath);
+static DEVICE_ATTR(fully_charged_matrix_effect_static,      0220, NULL,                                           razer_attr_write_fully_charged_matrix_effect_static);
+static DEVICE_ATTR(fully_charged_matrix_effect_none,        0220, NULL,                                           razer_attr_write_fully_charged_matrix_effect_none);
+
+static DEVICE_ATTR(reset_channels,                          0220, NULL,                                           razer_attr_write_reset_channels);
+static DEVICE_ATTR(channel1_size,                           0660, razer_attr_read_channel1_size,                  razer_attr_write_channel1_size);
+static DEVICE_ATTR(channel2_size,                           0660, razer_attr_read_channel2_size,                  razer_attr_write_channel2_size);
+static DEVICE_ATTR(channel3_size,                           0660, razer_attr_read_channel3_size,                  razer_attr_write_channel3_size);
+static DEVICE_ATTR(channel4_size,                           0660, razer_attr_read_channel4_size,                  razer_attr_write_channel4_size);
+static DEVICE_ATTR(channel5_size,                           0660, razer_attr_read_channel5_size,                  razer_attr_write_channel5_size);
+static DEVICE_ATTR(channel6_size,                           0660, razer_attr_read_channel6_size,                  razer_attr_write_channel6_size);
+static DEVICE_ATTR(channel1_led_brightness,                 0660, razer_attr_read_channel1_led_brightness,        razer_attr_write_channel1_led_brightness);
+static DEVICE_ATTR(channel2_led_brightness,                 0660, razer_attr_read_channel2_led_brightness,        razer_attr_write_channel2_led_brightness);
+static DEVICE_ATTR(channel3_led_brightness,                 0660, razer_attr_read_channel3_led_brightness,        razer_attr_write_channel3_led_brightness);
+static DEVICE_ATTR(channel4_led_brightness,                 0660, razer_attr_read_channel4_led_brightness,        razer_attr_write_channel4_led_brightness);
+static DEVICE_ATTR(channel5_led_brightness,                 0660, razer_attr_read_channel5_led_brightness,        razer_attr_write_channel5_led_brightness);
+static DEVICE_ATTR(channel6_led_brightness,                 0660, razer_attr_read_channel6_led_brightness,        razer_attr_write_channel6_led_brightness);
+
+static DEVICE_ATTR(is_mug_present,                          0440, razer_attr_read_is_mug_present,                 NULL);
+
+static void razer_accessory_init(struct razer_accessory_device *dev, struct usb_interface *intf, struct hid_device *hdev)
+{
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    unsigned int rand_serial = 0;
+
+    // Initialise mutex
+    mutex_init(&dev->lock);
+    // Setup values
+    dev->usb_dev = usb_dev;
+    dev->usb_vid = usb_dev->descriptor.idVendor;
+    dev->usb_pid = usb_dev->descriptor.idProduct;
+    dev->usb_interface_protocol = intf->cur_altsetting->desc.bInterfaceProtocol;
+
+    // Get a "random" integer
+    get_random_bytes(&rand_serial, sizeof(unsigned int));
+    sprintf(&dev->serial[0], "MUG%012u", rand_serial);
+}
+
+/**
+ * Say that we want to allow EV_KEY events and that we want to allow KEY_PROG1 events specifically
+ */
+static int razer_setup_input(struct input_dev *input, struct hid_device *hdev)
+{
+    __set_bit(EV_KEY, input->evbit);
+    __set_bit(KEY_PROG1, input->keybit);
+
+    return 0;
+}
+
+/**
+ * Setup the input device now that its been added to our struct
+ */
+static int razer_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+    struct razer_accessory_device *device = hid_get_drvdata(hdev);
+    int ret;
+
+    ret = razer_setup_input(device->input, hdev);
+    if (ret) {
+        hid_err(hdev, "magicmouse setup input failed (%d)\n", ret);
+        /* clean msc->input to notify probe() of the failure */
+        device->input = NULL;
+        return ret;
+    }
+
+    return 0;
+}
+
+/**
+ * Basically map a hid input to our structure
+ */
+static int razer_input_mapping(struct hid_device *hdev, struct hid_input *hi, struct hid_field *field,    struct hid_usage *usage, unsigned long **bit, int *max)
+{
+    struct razer_accessory_device *device = hid_get_drvdata(hdev);
+
+    if (!device->input)
+        device->input = hi->input;
+
+    return 0;
+}
+
+/**
+ * Match method checks whether this driver should be used for a given HID device
+ */
+static bool razer_accessory_match(struct hid_device *hdev, bool ignore_special_driver)
+{
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+
+    switch (usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        if (intf->cur_altsetting->desc.bInterfaceNumber != 0) {
+            dev_info(&intf->dev, "skipping secondary interface\n");
+            return false;
+        }
+    }
+
+    return true;
+}
+
+/**
+ * Probe method is ran whenever a device is binded to the driver
+ */
+static int razer_accessory_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+    int retval = 0;
+    unsigned char expected_protocol = USB_INTERFACE_PROTOCOL_MOUSE;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    struct razer_accessory_device *dev = NULL;
+
+    dev = kzalloc(sizeof(struct razer_accessory_device), GFP_KERNEL);
+    if(dev == NULL) {
+        dev_err(&intf->dev, "out of memory\n");
+        return -ENOMEM;
+    }
+
+    // Init data
+    razer_accessory_init(dev, intf, hdev);
+
+    switch(usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        expected_protocol = 0;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        expected_protocol = USB_INTERFACE_PROTOCOL_MOUSE;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        expected_protocol = USB_INTERFACE_PROTOCOL_KEYBOARD;
+        break;
+    }
+
+    if(dev->usb_interface_protocol == expected_protocol) {
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_version);                               // Get driver version
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_test);                                  // Test mode
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_mode);                           // Get string of device mode
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_serial);                         // Get string of device serial
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_firmware_version);                      // Get string of device fw version
+
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);                   // Custom effect frame
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);                    // No effect
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);                  // Static effect
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);                  // Breathing effect
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);                  // Custom effect
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);                     // Brightness
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+            // Razer has also added a "Fast Wave" effect for at least this device
+            // which uses the same effect command but a speed parameter of 0x10.
+            // It has not been implemented.
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_led_brightness);           // Charging effects
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charging_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fast_charging_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fully_charged_matrix_effect_none);
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+            // Device initial brightness is always 100% anyway
+            dev->saved_brightness = 0xFF;
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+        case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);            // Spectrum effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);                // Wave effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);            // Reactive
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_reactive_trigger);           // Reactive trigger
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_is_mug_present);                    // Is cup present
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_blinking);            // Blinking effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_reset_channels);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel1_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel2_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel3_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel4_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel5_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel6_size);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel1_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel2_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel3_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel4_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel5_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_channel6_led_brightness);
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        // Needs to be in "Normal" mode for idle effects to function properly
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+            break;
+
+        default:
+            // Needs to be in "Driver" mode just to function
+            razer_set_device_mode(dev, 0x03, 0x00);
+            break;
+        }
+    }
+
+    hid_set_drvdata(hdev, dev);
+    dev_set_drvdata(&hdev->dev, dev);
+
+    if(hid_parse(hdev)) {
+        hid_err(hdev, "parse failed\n");
+        goto exit_free;
+    }
+
+    if (hid_hw_start(hdev, HID_CONNECT_DEFAULT)) {
+        hid_err(hdev, "hw start failed\n");
+        goto exit_free;
+    }
+
+    usb_disable_autosuspend(usb_dev);
+
+    return 0;
+
+exit_free:
+    kfree(dev);
+    return retval;
+}
+
+/**
+ * Unbind function
+ */
+static void razer_accessory_disconnect(struct hid_device *hdev)
+{
+    unsigned char expected_protocol = USB_INTERFACE_PROTOCOL_MOUSE;
+    struct razer_accessory_device *dev;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+
+    dev = hid_get_drvdata(hdev);
+
+    switch(usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_CORE:
+    case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+    case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+    case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+    case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+    case USB_DEVICE_ID_RAZER_RAPTOR_27:
+    case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        expected_protocol = 0;
+        break;
+
+    case USB_DEVICE_ID_RAZER_FIREFLY:
+    case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+    case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+    case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+    case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+    case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+    case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+        expected_protocol = USB_INTERFACE_PROTOCOL_MOUSE;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+    case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+    case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        expected_protocol = USB_INTERFACE_PROTOCOL_KEYBOARD;
+        break;
+    }
+
+    if(dev->usb_interface_protocol == expected_protocol) {
+        device_remove_file(&hdev->dev, &dev_attr_version);                               // Get driver version
+        device_remove_file(&hdev->dev, &dev_attr_test);                                  // Test mode
+        device_remove_file(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        device_remove_file(&hdev->dev, &dev_attr_device_mode);                           // Get string of device mode
+        device_remove_file(&hdev->dev, &dev_attr_device_serial);                         // Get string of device serial
+        device_remove_file(&hdev->dev, &dev_attr_firmware_version);                      // Get string of device fw version
+
+        device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);                   // Custom effect frame
+        device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);                    // No effect
+        device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);                  // Static effect
+        device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);                  // Breathing effect
+        device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);                  // Custom effect
+        device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);                     // Brightness
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_charging_led_brightness);           // Charging effects
+            device_remove_file(&hdev->dev, &dev_attr_charging_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_charging_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_charging_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_charging_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_charging_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_fast_charging_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_fully_charged_matrix_effect_none);
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        case USB_DEVICE_ID_RAZER_MOUSE_DOCK:
+        case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);            // Spectrum effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+        case USB_DEVICE_ID_RAZER_CHROMA_HDK:
+        case USB_DEVICE_ID_RAZER_CHROMA_BASE:
+        case USB_DEVICE_ID_RAZER_NOMMO_PRO:
+        case USB_DEVICE_ID_RAZER_NOMMO_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+        case USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA:
+        case USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA:
+        case USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA:
+        case USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA:
+        case USB_DEVICE_ID_RAZER_RAPTOR_27:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);                // Wave effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX:
+        case USB_DEVICE_ID_RAZER_FIREFLY_V2:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED:
+        case USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL:
+        case USB_DEVICE_ID_RAZER_FIREFLY:
+        case USB_DEVICE_ID_RAZER_CORE:
+        case USB_DEVICE_ID_RAZER_CORE_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);            // Reactive
+            device_remove_file(&hdev->dev, &dev_attr_matrix_reactive_trigger);           // Reactive trigger
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHROMA_MUG:
+            device_remove_file(&hdev->dev, &dev_attr_is_mug_present);                    // Is cup present
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_blinking);            // Blinking effect
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);
+            break;
+        }
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER:
+            device_remove_file(&hdev->dev, &dev_attr_reset_channels);
+            device_remove_file(&hdev->dev, &dev_attr_channel1_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel2_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel3_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel4_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel5_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel6_size);
+            device_remove_file(&hdev->dev, &dev_attr_channel1_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_channel2_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_channel3_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_channel4_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_channel5_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_channel6_led_brightness);
+            break;
+        }
+    }
+
+    hid_hw_stop(hdev);
+
+    kfree(dev);
+    dev_info(&intf->dev, "Razer Device disconnected\n");
+}
+
+/**
+ * Converts interrupt event into PROG1 keypress
+ *
+ * Checks if we get the event were after.
+ * Creates a keypress event of KEY_PROG1
+ *
+ * input_report_key generates an event
+ * input_sync says were finished, all events are complete. Is useful when setting up other events as they might take multiple statements to complete an event like relative events
+ *
+ * data[1] == 0xa0 if mug is present
+ */
+static int razer_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)
+{
+    struct razer_accessory_device *device = hid_get_drvdata(hdev);
+
+    if(size == 16 && data[0] == 0x04) {
+        input_report_key(device->input, KEY_PROG1, 0x01);
+        input_report_key(device->input, KEY_PROG1, 0x00);
+        input_sync(device->input);
+        return 1;
+    }
+
+    return 0;
+}
+
+/**
+ * Device ID mapping table
+ */
+static const struct hid_device_id razer_devices[] = {
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_FIREFLY) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_FIREFLY_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CORE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CORE_X_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CHROMA_MUG) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CHROMA_HDK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CHROMA_BASE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NOMMO_PRO) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NOMMO_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MOUSE_DOCK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_RAPTOR_27) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2) },
+    { 0 }
+};
+
+MODULE_DEVICE_TABLE(hid, razer_devices);
+
+/**
+ * Describes the contents of the driver
+ */
+static struct hid_driver razer_accessory_driver = {
+    .name = "razeraccessory",
+    .id_table = razer_devices,
+    .match = razer_accessory_match,
+    .probe = razer_accessory_probe,
+    .remove = razer_accessory_disconnect,
+    .raw_event = razer_raw_event,
+    .input_mapping = razer_input_mapping,
+    .input_configured = razer_input_configured
+};
+
+module_hid_driver(razer_accessory_driver);
diff --git a/drivers/custom/razer/driver/razeraccessory_driver.h b/drivers/custom/razer/driver/razeraccessory_driver.h
new file mode 100644
index 000000000000..55d339692de7
--- /dev/null
+++ b/drivers/custom/razer/driver/razeraccessory_driver.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef __HID_RAZER_ACCESSORY_H
+#define __HID_RAZER_ACCESSORY_H
+
+#define USB_DEVICE_ID_RAZER_FIREFLY_HYPERFLUX 0x0068
+#define USB_DEVICE_ID_RAZER_MOUSE_DOCK 0x007E
+#define USB_DEVICE_ID_RAZER_CORE 0x0215
+#define USB_DEVICE_ID_RAZER_NOMMO_CHROMA 0x0517
+#define USB_DEVICE_ID_RAZER_NOMMO_PRO 0x0518
+#define USB_DEVICE_ID_RAZER_FIREFLY 0x0C00
+#define USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA 0x0C01
+#define USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_EXTENDED 0x0C02
+#define USB_DEVICE_ID_RAZER_FIREFLY_V2 0x0C04
+#define USB_DEVICE_ID_RAZER_GOLIATHUS_CHROMA_3XL 0x0C06
+#define USB_DEVICE_ID_RAZER_CHROMA_MUG 0x0F07
+#define USB_DEVICE_ID_RAZER_CHROMA_BASE 0x0F08
+#define USB_DEVICE_ID_RAZER_CHROMA_HDK 0x0F09
+#define USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA 0x0F0D
+#define USB_DEVICE_ID_RAZER_RAPTOR_27 0x0F12
+#define USB_DEVICE_ID_RAZER_KRAKEN_KITTY_EDITION 0x0F19
+#define USB_DEVICE_ID_RAZER_CORE_X_CHROMA 0x0F1A
+#define USB_DEVICE_ID_RAZER_MOUSE_BUNGEE_V3_CHROMA 0x0F1D
+#define USB_DEVICE_ID_RAZER_CHROMA_ADDRESSABLE_RGB_CONTROLLER 0x0F1F
+#define USB_DEVICE_ID_RAZER_BASE_STATION_V2_CHROMA 0x0F20
+#define USB_DEVICE_ID_RAZER_THUNDERBOLT_4_DOCK_CHROMA 0x0F21
+#define USB_DEVICE_ID_RAZER_CHARGING_PAD_CHROMA 0x0F26
+#define USB_DEVICE_ID_RAZER_LAPTOP_STAND_CHROMA_V2 0x0F2B
+
+#define RAZER_ACCESSORY_WAIT_MIN_US 600
+#define RAZER_ACCESSORY_WAIT_MAX_US 1000
+
+#define RAZER_NEW_DEVICE_WAIT_MIN_US 31000
+#define RAZER_NEW_DEVICE_WAIT_MAX_US 31100
+
+struct razer_accessory_device {
+    struct usb_device *usb_dev;
+    struct input_dev *input;
+    struct mutex lock;
+    unsigned char usb_interface_protocol;
+
+    unsigned short usb_vid;
+    unsigned short usb_pid;
+
+    unsigned char saved_brightness;
+
+    char serial[23];
+};
+
+/*
+ * USB INTERRUPT
+ *
+ * */
+
+#endif
diff --git a/drivers/custom/razer/driver/razerchromacommon.c b/drivers/custom/razer/driver/razerchromacommon.c
new file mode 100644
index 000000000000..ad8dabbf60fa
--- /dev/null
+++ b/drivers/custom/razer/driver/razerchromacommon.c
@@ -0,0 +1,1590 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include "razerchromacommon.h"
+
+static unsigned char orochi2011_led[]  = { 0x01, 0x00, 0x00, 0x06, 0x48, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x05, 0x06, 0x06, 0x10, 0x10, 0x10, 0x10, 0x24, 0x24, 0x4c, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x01, 0x01, 0x03, 0x03, 0x04, 0x01, 0x04, 0x04, 0x01, 0x01, 0x05, 0x05, 0x01, 0x01, 0x06, 0x31, 0x88, 0x00, 0x07, 0x31, 0x87, 0x00, 0x08, 0x08, 0x01, 0x01, 0x09, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x01 };
+static unsigned char orochi2011_dpi[] = { 0x01, 0x00, 0x00, 0x05, 0x05, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x4c, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };
+
+/*
+ * Standard Device Functions
+ */
+
+/**
+ * Set what mode the device will operate in.
+ *
+ * Currently known modes
+ * 0x00, 0x00: Normal Mode
+ * 0x02, 0x00: Unknown Mode
+ * 0x03, 0x00: Driver Mode
+ *
+ * 0x02, 0x00 Will make M1-5 and FN emit normal keystrokes. Some sort of factory test mode. Not recommended to be used.
+ */
+struct razer_report razer_chroma_standard_set_device_mode(unsigned char mode, unsigned char param)
+{
+    struct razer_report report = get_razer_report(0x00, 0x04, 0x02);
+
+    if(mode != 0x00 && mode != 0x03) { // Explicitly blocking the 0x02 mode
+        mode = 0x00;
+    }
+    // Only allow 0x00 as param
+    param = 0x00;
+
+    report.arguments[0] = mode;
+    report.arguments[1] = param;
+
+    return report;
+}
+
+/**
+ * Get what mode the device is operating in.
+ *
+ * Currently known modes
+ * 0x00, 0x00: Normal Mode
+ * 0x02, 0x00: Unknown Mode
+ * 0x03, 0x00: Driver Mode
+ *
+ * 0x02, 0x00 Will make M1-5 and FN emit normal keystrokes. Some sort of factory test mode. Not recommended to be used.
+ */
+struct razer_report razer_chroma_standard_get_device_mode(void)
+{
+    return get_razer_report(0x00, 0x84, 0x02);
+}
+
+/**
+ * Get serial from device
+ */
+struct razer_report razer_chroma_standard_get_serial(void)
+{
+    return get_razer_report(0x00, 0x82, 0x16);
+}
+
+/**
+ * Get firmware version from device
+ */
+struct razer_report razer_chroma_standard_get_firmware_version(void)
+{
+    return get_razer_report(0x00, 0x81, 0x02);
+}
+
+/*
+ * Standard Functions
+ */
+
+/**
+ * Set the state of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    03       03    00  010801                     | SET LED STATE (VARSTR, GAMEMODE, ON)
+ * 00     3f    0000   00    03       03    00  010800                     | SET LED STATE (VARSTR, GAMEMODE, OFF)
+ */
+struct razer_report razer_chroma_standard_set_led_state(unsigned char variable_storage, unsigned char led_id, unsigned char led_state)
+{
+    struct razer_report report = get_razer_report(0x03, 0x00, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = clamp_u8(led_state, 0x00, 0x01);
+
+    return report;
+}
+
+struct razer_report razer_chroma_standard_set_led_blinking(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x04, 0x04);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = 0x05;
+    report.arguments[3] = 0x05;
+
+    return report;
+}
+
+/**
+ * Get the state of an LED on the device
+ */
+struct razer_report razer_chroma_standard_get_led_state(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x80, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+
+    return report;
+}
+
+/**
+ * Set LED RGB parameters
+ */
+struct razer_report razer_chroma_standard_set_led_rgb(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1)
+{
+    struct razer_report report = get_razer_report(0x03, 0x01, 0x05);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = rgb1->r;
+    report.arguments[3] = rgb1->g;
+    report.arguments[4] = rgb1->b;
+
+    return report;
+}
+
+/**
+ * Get LED RGB parameters
+ */
+struct razer_report razer_chroma_standard_get_led_rgb(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x81, 0x05);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    return report;
+}
+
+/**
+ * Set the effect of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_set_led_effect(unsigned char variable_storage, unsigned char led_id, unsigned char led_effect)
+{
+    struct razer_report report = get_razer_report(0x03, 0x02, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = clamp_u8(led_effect, 0x00, 0x05);
+
+    return report;
+}
+
+/**
+ * Get the effect of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_get_led_effect(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x82, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+
+    return report;
+}
+
+/**
+ * Set the brightness of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_set_led_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness)
+{
+    struct razer_report report = get_razer_report(0x03, 0x03, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = brightness;
+
+    return report;
+}
+
+/**
+ * Get the brightness of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_get_led_brightness(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x83, 0x03);
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+
+    return report;
+}
+
+/*
+ * Standard Matrix Effects Functions
+ */
+
+static struct razer_report razer_chroma_standard_matrix_effect_base(unsigned char arg_size, unsigned char effect_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x0A, arg_size);
+    report.arguments[0] = effect_id;
+    return report;
+}
+
+/**
+ * Set the effect of the LED matrix to None
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_none(void)
+{
+    return razer_chroma_standard_matrix_effect_base(0x01, MATRIX_EFFECT_OFF);
+}
+
+/**
+ * Set the effect of the LED matrix to Wave
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_wave(unsigned char wave_direction)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x02, MATRIX_EFFECT_WAVE);
+    report.arguments[1] = clamp_u8(wave_direction, 0x01, 0x02);
+
+    return report;
+}
+
+/**
+ * Set the effect of the LED matrix to Spectrum
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_spectrum(void)
+{
+    return razer_chroma_standard_matrix_effect_base(0x01, MATRIX_EFFECT_SPECTRUM);
+}
+
+/**
+ * Set the effect of the LED matrix to Reactive
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_reactive(unsigned char speed, struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x05, MATRIX_EFFECT_REACTIVE);
+    report.arguments[1] = clamp_u8(speed, 0x01, 0x04); // Time
+    report.arguments[2] = rgb1->r; /*rgb color definition*/
+    report.arguments[3] = rgb1->g;
+    report.arguments[4] = rgb1->b;
+
+    return report;
+}
+
+/**
+ * Set the effect of the LED matrix to Static
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_static(struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x04, MATRIX_EFFECT_STATIC);
+    report.arguments[1] = rgb1->r; /*rgb color definition*/
+    report.arguments[2] = rgb1->g;
+    report.arguments[3] = rgb1->b;
+
+    return report;
+}
+
+/**
+ * Set the effect of the LED matrix to Starlight
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_starlight_single(unsigned char speed, struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x01, MATRIX_EFFECT_STARLIGHT);
+
+    report.arguments[1] = 0x01; // Type one color
+    report.arguments[2] = clamp_u8(speed, 0x01, 0x03); // Speed
+
+    report.arguments[3] = rgb1->r; // Red 1
+    report.arguments[4] = rgb1->g; // Green 1
+    report.arguments[5] = rgb1->b; // Blue 1
+
+    // For now haven't seen any chroma using this, seen the extended version
+    report.arguments[6] = 0x00; // Red 2
+    report.arguments[7] = 0x00; // Green 2
+    report.arguments[8] = 0x00; // Blue 2
+
+    return report;
+}
+
+/**
+ * Set the effect of the LED matrix to Starlight
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_standard_matrix_effect_starlight_dual(unsigned char speed, struct razer_rgb *rgb1, struct razer_rgb *rgb2)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x01, MATRIX_EFFECT_STARLIGHT);
+
+    report.arguments[1] = 0x02; // Type two color
+    report.arguments[2] = clamp_u8(speed, 0x01, 0x03); // Speed
+
+    report.arguments[3] = rgb1->r; // Red 1
+    report.arguments[4] = rgb1->g; // Green 1
+    report.arguments[5] = rgb1->b; // Blue 1
+
+    report.arguments[6] = rgb2->r; // Red 2
+    report.arguments[7] = rgb2->g; // Green 2
+    report.arguments[8] = rgb2->b; // Blue 2
+
+    return report;
+}
+
+struct razer_report razer_chroma_standard_matrix_effect_starlight_random(unsigned char speed)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x01, MATRIX_EFFECT_STARLIGHT);
+
+    report.arguments[1] = 0x03; // Type random color
+    report.arguments[2] = clamp_u8(speed, 0x01, 0x03); // Speed
+
+    return report;
+}
+
+/**
+ * Set the device to "Breathing" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ??
+ * ??
+ * ??
+ */
+struct razer_report razer_chroma_standard_matrix_effect_breathing_random(void)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x08, MATRIX_EFFECT_BREATHING);
+    report.arguments[1] = 0x03; // Breathing type
+
+    return report;
+}
+struct razer_report razer_chroma_standard_matrix_effect_breathing_single(struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x08, MATRIX_EFFECT_BREATHING);
+    report.arguments[1] = 0x01; // Breathing type
+    report.arguments[2] = rgb1->r;
+    report.arguments[3] = rgb1->g;
+    report.arguments[4] = rgb1->b;
+
+    return report;
+}
+struct razer_report razer_chroma_standard_matrix_effect_breathing_dual(struct razer_rgb *rgb1, struct razer_rgb *rgb2)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x08, MATRIX_EFFECT_BREATHING);
+    report.arguments[1] = 0x02; // Breathing type
+    report.arguments[2] = rgb1->r;
+    report.arguments[3] = rgb1->g;
+    report.arguments[4] = rgb1->b;
+    report.arguments[5] = rgb2->r;
+    report.arguments[6] = rgb2->g;
+    report.arguments[7] = rgb2->b;
+
+    return report;
+}
+
+/**
+ * Set the device to "Custom" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ??
+ *
+ * Apparently Ultimate2016, Stealth and Stealth2016 need frame id to be 0x00, I don't think it's needed (depending on set_custom_frame)
+ */
+struct razer_report razer_chroma_standard_matrix_effect_custom_frame(unsigned char variable_storage)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x02, MATRIX_EFFECT_CUSTOMFRAME);
+    report.arguments[1] = variable_storage; // Data frame ID
+
+    return report;
+}
+
+/**
+ * Set the RGB or a row
+ *
+ * Start and stop columns are inclusive
+ *
+ * This sets the colour of a row on the keyboard. Takes in an array of RGB bytes.
+ * The mappings below are correct for the BlackWidow Chroma. The BlackWidow Ultimate 2016
+ * contains LEDs under the spacebar and the FN key so there will be changes once I get the
+ * hardware.
+ *
+ * Row 0:
+ *  0      Unused
+ *  1      ESC
+ *  2      Unused
+ *  3-14   F1-F12
+ *  15-17  PrtScr, ScrLk, Pause
+ *  18-19  Unused
+ *  20     Razer Logo
+ *  21     Unused
+ *
+ * Row 1:
+ *  0-21   M1 -> NP Minus
+ *
+ * Row 2:
+ *  0-13   M2 -> Right Square Bracket ]
+ *  14 Unused
+ *  15-21 Delete -> NP Plus
+ *
+ * Row 3:
+ *  0-14   M3 -> Return
+ *  15-17  Unused
+ *  18-20  NP4 -> NP6
+ *
+ * Row 4:
+ *  0-12   M4 -> Forward Slash /
+ *  13     Unused
+ *  14     Right Shift
+ *  15     Unused
+ *  16     Up Arrow Key
+ *  17     Unused
+ *  18-21  NP1 -> NP Enter
+ *
+ * Row 5:
+ *  0-3    M5 -> Alt
+ *  4-10   Unused
+ *  11     Alt GR
+ *  12     Unused
+ *  13-17  Context Menu Key -> Right Arrow Key
+ *  18     Unused
+ *  19-20  NP0 -> NP.
+ *  21     Unused
+ */
+struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)
+{
+    const size_t start_arg_offset = 4;
+    struct razer_report report = {0};
+    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
+
+    if (row_length > sizeof(report.arguments) - start_arg_offset) {
+        printk(KERN_ALERT "razerchroma: RGB data too long\n");
+        row_length = 0;
+    }
+
+    report = get_razer_report(0x03, 0x0B, 0x46); // In theory should be able to leave data size at max as we have start/stop
+
+    // printk(KERN_ALERT "razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\n", row_index, start_col, stop_col, (unsigned char)row_length);
+
+    report.arguments[0] = 0xFF; // Frame ID
+    report.arguments[1] = row_index;
+    report.arguments[2] = start_col;
+    report.arguments[3] = stop_col;
+    memcpy(&report.arguments[4], rgb_data, row_length);
+
+    return report;
+}
+
+/*
+ * Extended Matrix Effects
+ */
+
+/**
+ * Sets up the extended matrix effect payload
+ */
+static struct razer_report razer_chroma_extended_matrix_effect_base(unsigned char arg_size, unsigned char variable_storage, unsigned char led_id, unsigned char effect_id)
+{
+    struct razer_report report = get_razer_report(0x0F, 0x02, arg_size);
+
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = effect_id; // Effect ID
+
+    return report;
+}
+
+/**
+ * Set the device to "None" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    06       0f    02  010500000000  | SET LED MATRIX Effect (VARSTR, Backlight, None 0x00, 0x000000)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_none(unsigned char variable_storage, unsigned char led_id)
+{
+    return razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x00);
+}
+
+/**
+ * Set the device to "Static" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    09       0f    02  010501000001ff0000 | SET LED MATRIX Effect (VARSTR, Backlight, Static 0x01, ? 0x000001, RGB 0xFF0000)
+ * 00     3f    0000   00    09       0f    02  01050100000100ff00 | SET LED MATRIX Effect (VARSTR, Backlight, Static 0x01, ? 0x000001, RGB 0x00FF00)
+ * 00     3f    0000   00    09       0f    02  010501000001008000 | SET LED MATRIX Effect (VARSTR, Backlight, Static 0x01, ? 0x000001, RGB 0x008000)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_static(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x09, variable_storage, led_id, 0x01);
+
+    report.arguments[5] = 0x01;
+    report.arguments[6] = rgb->r;
+    report.arguments[7] = rgb->g;
+    report.arguments[8] = rgb->b;
+    return report;
+}
+
+/**
+ * Set the device to "Wave" effect
+ *
+ * Seems like direction is now 0x00, 0x01 for Left/Right, used to be 0x01, 0x02
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    06       0f    02  010504002800 | SET LED MATRIX Effect (VARSTR, Backlight, Wave 0x04, Dir 0x00, ? 0x2800)
+ * 00     3f    0000   00    06       0f    02  010504012800 | SET LED MATRIX Effect (VARSTR, Backlight, Wave 0x04, Dir 0x01, ? 0x2800)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_wave(unsigned char variable_storage, unsigned char led_id, unsigned char direction)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x04);
+
+    // Some devices use values 0x00, 0x01
+    // Others use values 0x01, 0x02
+    direction = clamp_u8(direction, 0x00, 0x02);
+
+    // Razer has also added a "Fast Wave" effect for at least one device
+    // which uses the same effect command but a speed parameter of 0x10
+    report.arguments[3] = direction;
+    report.arguments[4] = 0x28; // Speed, lower values are faster
+    return report;
+}
+
+/**
+ * Set the device to "Starlight" effect
+ *
+ * Speed is 0x01 - 0x03
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    06       0f    02  010507000100             | SET LED MATRIX Effect (VARSTR, Backlight, Starlight 0x07, ? 0x00, Speed 0x01, Colours 0x00)
+ * 00     3f    0000   00    06       0f    02  010507000200             | SET LED MATRIX Effect (VARSTR, Backlight, Starlight 0x07, ? 0x00, Speed 0x02, Colours 0x00)
+ * 00     3f    0000   00    06       0f    02  010507000300             | SET LED MATRIX Effect (VARSTR, Backlight, Starlight 0x07, ? 0x00, Speed 0x03, Colours 0x00)
+ * 00     3f    0000   00    09       0f    02  010507000301ff0000       | SET LED MATRIX Effect (VARSTR, Backlight, Starlight 0x07, ? 0x00, Speed 0x03, Colours 0x01, RGB 0xFF0000)
+ * 00     3f    0000   00    0c       0f    02  010507000302ff000000ff00 | SET LED MATRIX Effect (VARSTR, Backlight, Starlight 0x07, ? 0x00, Speed 0x03, Colours 0x02, RGB 0xFF0000, RGB 0x00FF00)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_starlight_random(unsigned char variable_storage, unsigned char led_id, unsigned char speed)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x07);
+
+    speed = clamp_u8(speed, 0x01, 0x03);
+
+    report.arguments[4] = speed;
+    return report;
+}
+struct razer_report razer_chroma_extended_matrix_effect_starlight_single(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x09, variable_storage, led_id, 0x07);
+
+    speed = clamp_u8(speed, 0x01, 0x03);
+
+    report.arguments[4] = speed;
+    report.arguments[5] = 0x01;
+    report.arguments[6] = rgb1->r;
+    report.arguments[7] = rgb1->g;
+    report.arguments[8] = rgb1->b;
+
+    return report;
+}
+struct razer_report razer_chroma_extended_matrix_effect_starlight_dual(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1, struct razer_rgb *rgb2)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x0C, variable_storage, led_id, 0x07);
+
+    speed = clamp_u8(speed, 0x01, 0x03);
+
+    report.arguments[4] = speed;
+    report.arguments[5] = 0x02;
+    report.arguments[6] = rgb1->r;
+    report.arguments[7] = rgb1->g;
+    report.arguments[8] = rgb1->b;
+    report.arguments[9] = rgb2->r;
+    report.arguments[10] = rgb2->g;
+    report.arguments[11] = rgb2->b;
+
+    return report;
+}
+
+/**
+ * Set the device to "Spectrum" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    06       0f    02  010503000000 | SET LED MATRIX Effect (VARSTR, Backlight, Spectrum 0x03, 0x000000)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_spectrum(unsigned char variable_storage, unsigned char led_id)
+{
+    return razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x03);
+}
+
+/**
+ * Set the device to "Wheel" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    06       0f    02  01050a022800 | SET LED MATRIX Effect (VARSTR, Backlight, Wheel 0x0A, Dir 0x02, Speed 0x28, ? 0x00)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_wheel(unsigned char variable_storage, unsigned char led_id, unsigned char direction)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x0a);
+
+    // BlackWidow V4 Pro uses 0x01 and 0x02 for directions
+    // Commands with direction 0x00 seem to be ignored
+    direction = clamp_u8(direction, 0x01, 0x02);
+
+    report.arguments[3] = direction;
+    report.arguments[4] = 0x28; // Speed, lower values are faster
+
+    return report;
+}
+
+/**
+ * Set the device to "Reactive" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    09       0f    02  010505000101ffff00 | SET LED MATRIX Effect (VARSTR, Backlight, Reactive 0x05, ? 0x00, Speed 0x01, Colours 0x01, RGB 0xFFFF00)
+ * 00     3f    0000   00    09       0f    02  010505000101ff0000 | SET LED MATRIX Effect (VARSTR, Backlight, Reactive 0x05, ? 0x00, Speed 0x02, Colours 0x01, RGB 0xFF0000)
+ * 00     3f    0000   00    09       0f    02  010505000301ff0000 | SET LED MATRIX Effect (VARSTR, Backlight, Reactive 0x05, ? 0x00, Speed 0x03, Colours 0x01, RGB 0xFF0000)
+ * 00     3f    0000   00    09       0f    02  010505000401ff0000 | SET LED MATRIX Effect (VARSTR, Backlight, Reactive 0x05, ? 0x00, Speed 0x04, Colours 0x01, RGB 0xFF0000)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_reactive(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x09, variable_storage, led_id, 0x05);
+
+    speed = clamp_u8(speed, 0x01, 0x04);
+
+    report.arguments[4] = speed;
+    report.arguments[5] = 0x01;
+    report.arguments[6] = rgb->r;
+    report.arguments[7] = rgb->g;
+    report.arguments[8] = rgb->b;
+
+    return report;
+}
+
+/**
+ * Set the device to "Breathing" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    09       0f    02  01050201000100ff00       | SET LED MATRIX Effect (VARSTR, Backlight, Breathing 0x02, Colours 0x01, ? 0x00, Colours 0x01, RGB 0x00FF00)
+ * 00     3f    0000   00    0c       0f    02  01050202000200ff00ff0000 | SET LED MATRIX Effect (VARSTR, Backlight, Breathing 0x02, Colours 0x02, ? 0x00, Colours 0x02, RGB 0x00FF00, RGB 0xFF0000)
+ * 00     3f    0000   00    06       0f    02  010502000000             | SET LED MATRIX Effect (VARSTR, Backlight, Breathing 0x02, Colours 0x00, ? 0x0000)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_breathing_random(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x02);
+    return report;
+}
+struct razer_report razer_chroma_extended_matrix_effect_breathing_single(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x09, variable_storage, led_id, 0x02);
+
+    report.arguments[3] = 0x01;
+    report.arguments[5] = 0x01;
+
+    report.arguments[6] = rgb1->r;
+    report.arguments[7] = rgb1->g;
+    report.arguments[8] = rgb1->b;
+
+    return report;
+}
+struct razer_report razer_chroma_extended_matrix_effect_breathing_dual(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1, struct razer_rgb *rgb2)
+{
+    struct razer_report report = razer_chroma_extended_matrix_effect_base(0x0C, variable_storage, led_id, 0x02);
+
+    report.arguments[3] = 0x02;
+    report.arguments[5] = 0x02;
+
+    report.arguments[6] = rgb1->r;
+    report.arguments[7] = rgb1->g;
+    report.arguments[8] = rgb1->b;
+    report.arguments[9] = rgb2->r;
+    report.arguments[10] = rgb2->g;
+    report.arguments[11] = rgb2->b;
+
+    return report;
+}
+
+/**
+ * Set the device to "Custom" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    0c       0f    02  000008000000000000000000   | DRAW LED MATRIX Frame
+ */
+struct razer_report razer_chroma_extended_matrix_effect_custom_frame(void)
+{
+    return razer_chroma_extended_matrix_effect_base(0x0C, 0x00, 0x00, 0x08);
+}
+
+/**
+ * Set the device brightness
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    03       0f    04  0104b7
+ */
+struct razer_report razer_chroma_extended_matrix_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness)
+{
+    struct razer_report report = get_razer_report(0x0F, 0x04, 0x03);
+
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = brightness;
+
+    return report;
+}
+
+/**
+ * Get the device brightness
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    03       0f    84  0104
+ */
+struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
+
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+
+    return report;
+}
+
+/**
+ * Set the RGB or a row
+ *
+ * Start and stop columns are inclusive
+ */
+struct razer_report razer_chroma_extended_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data)
+{
+    return razer_chroma_extended_matrix_set_custom_frame2(row_index, start_col, stop_col, rgb_data, 0x47);
+}
+
+struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength)
+{
+    const size_t start_arg_offset = 5;
+    size_t data_length = 0;
+    struct razer_report report = {0};
+    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
+
+    if (row_length > sizeof(report.arguments) - start_arg_offset) {
+        printk(KERN_ALERT "razerchroma: RGB data too long\n");
+        row_length = 0;
+    }
+
+    // Some devices need a specific packet length, most devices are happy with 0x47
+    // e.g. the Mamba Elite needs a "row_length + 5" packet length
+    data_length = (packetLength != 0) ? packetLength : row_length + 5;
+    report = get_razer_report(0x0F, 0x03, data_length);
+
+    // printk(KERN_ALERT "razerkbd: Row ID: %d, Start: %d, Stop: %d, row length: %d\n", row_index, start_col, stop_col, (unsigned char)row_length);
+
+    report.arguments[2] = row_index;
+    report.arguments[3] = start_col;
+    report.arguments[4] = stop_col;
+    memcpy(&report.arguments[5], rgb_data, row_length);
+
+    return report;
+}
+
+/*
+ * Extended Matrix Effects (Mouse)
+ */
+/**
+ * Sets up the extended matrix effect payload for mouse devices
+ */
+static struct razer_report razer_chroma_mouse_extended_matrix_effect_base(unsigned char arg_size, unsigned char variable_storage, unsigned char led_id, unsigned char effect_id)
+{
+    struct razer_report report = get_razer_report(0x03, 0x0D, arg_size);
+
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = led_id;
+    report.arguments[2] = effect_id; // Effect ID
+
+    return report;
+}
+
+/**
+ * Set the device to "None" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ *  * 00     3f    0000   00    03       03    0d  010100 | SET Extended Matrix Effect (VARSTORE, LOGO_LED, OFF)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_none(unsigned char variable_storage, unsigned char led_id)
+{
+    return razer_chroma_mouse_extended_matrix_effect_base(0x03, variable_storage, led_id, 0x00);
+}
+
+/**
+ * Set the device to "Static" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    06       03    0d  010106 00ff00 | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL, STATIC, RGB)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_static(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb)
+{
+    struct razer_report report = razer_chroma_mouse_extended_matrix_effect_base(0x06, variable_storage, led_id, 0x06);
+
+    report.arguments[3] = rgb->r;
+    report.arguments[4] = rgb->g;
+    report.arguments[5] = rgb->b;
+    return report;
+}
+
+/**
+ * Set the device to "Spectrum" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    03       03    0d  010104 | SET Extended Matrix Effect (VARSTORE, LOGO_LED, SPECTRUM)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_spectrum(unsigned char variable_storage, unsigned char led_id)
+{
+    return razer_chroma_mouse_extended_matrix_effect_base(0x03, variable_storage, led_id, 0x04);
+}
+
+/**
+ * Set the device to "Reactive" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    07       03    0d  010102 0300ff00            | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL,  REACTIVE, TIME, RGB)
+ * 00     3f    0000   00    07       03    0d  010102 0200ff00            | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL,  REACTIVE, TIME, RGB)
+ * 00     3f    0000   00    07       03    0d  010102 0100ff00            | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL,  REACTIVE, TIME, RGB)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_reactive(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb)
+{
+    struct razer_report report = razer_chroma_mouse_extended_matrix_effect_base(0x07, variable_storage, led_id, 0x02);
+
+    speed = clamp_u8(speed, 0x01, 0x04);
+
+    report.arguments[3] = speed;
+    report.arguments[4] = rgb->r;
+    report.arguments[5] = rgb->g;
+    report.arguments[6] = rgb->b;
+
+    return report;
+}
+
+/**
+ * Set the device to "Breathing" effect
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     3f    0000   00    0a       03    0d  010103 0100ff00000000      | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL, BREATHING, single, RGB, RGB-none)
+ * 00     3f    0000   00    0a       03    0d  010103 0200ff00ff0000      | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL, BREATHING, dual, RGB, RGB)
+ * 00     3f    0000   00    0a       03    0d  010103 03000000000000      | SET Extended Matrix Effect (VARSTORE, SCROLL_WHEEL, BREATHING, random, RGB-none, RGB-none)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_random(unsigned char variable_storage, unsigned char led_id)
+{
+    struct razer_report report = razer_chroma_mouse_extended_matrix_effect_base(0x0A, variable_storage, led_id, 0x03);
+
+    report.arguments[3] = 0x03;
+
+    return report;
+}
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_single(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1)
+{
+    struct razer_report report = razer_chroma_mouse_extended_matrix_effect_base(0x0A, variable_storage, led_id, 0x03);
+
+    report.arguments[3] = 0x01;
+
+    report.arguments[4] = rgb1->r;
+    report.arguments[5] = rgb1->g;
+    report.arguments[6] = rgb1->b;
+
+    return report;
+}
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_dual(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1, struct razer_rgb *rgb2)
+{
+    struct razer_report report = razer_chroma_mouse_extended_matrix_effect_base(0x0A, variable_storage, led_id, 0x03);
+
+    report.arguments[3] = 0x02;
+
+    report.arguments[4] = rgb1->r;
+    report.arguments[5] = rgb1->g;
+    report.arguments[6] = rgb1->b;
+
+    report.arguments[7] = rgb2->r;
+    report.arguments[8] = rgb2->g;
+    report.arguments[9] = rgb2->b;
+
+    return report;
+}
+
+/*
+ * Misc Functions
+ */
+/**
+ * Toggled whether F1-12 act as F1-12 or if they act as the function options (without Fn pressed)
+ *
+ * If 0 should mean that the F-keys work as normal F-keys
+ * If 1 should mean that the F-keys act as if the FN key is held
+ */
+struct razer_report razer_chroma_misc_fn_key_toggle(unsigned char state)
+{
+    struct razer_report report = get_razer_report(0x02, 0x06, 0x02);
+    report.arguments[0] = 0x00; // ?? Variable storage maybe
+    report.arguments[1] = clamp_u8(state, 0x00, 0x01); // State
+
+    return report;
+}
+
+/**
+ * Set the keyswitch optimization on the device (first of two commands)
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    04       02    02  001400280000               | SET KEY OPTIMIZATION STATE (TYPING SET)
+ * 00     1f    0000   00    04       02    02  000000000000               | SET KEY OPTIMIZATION STATE (GAMING SET)
+ */
+struct razer_report razer_chroma_misc_set_keyswitch_optimization_command1(unsigned char optimization_mode)
+{
+    struct razer_report report = get_razer_report(0x02, 0x02, 0x04); // class, id, data size
+
+    // 0x00 -> Typing (Set)
+    // 0x01 -> Gaming (Set) - Same report, doesn't include any arguments
+    if(optimization_mode == 0x00) {
+        report.arguments[0] = 0x00;
+        report.arguments[1] = 0x14;
+        report.arguments[2] = 0x00;
+        report.arguments[3] = 0x28;
+        report.arguments[4] = 0x00;
+    }
+
+    return report;
+}
+
+/**
+* Set the keyswitch optimization on the device (second of two commands)
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    05       02    15  010014002800               | SET KEY OPTIMIZATION STATE (TYPING VARSTORE) ????
+ * 00     1f    0000   00    05       02    15  010000000000               | SET KEY OPTIMIZATION STATE (GAMING VARSTORE) ????
+ */
+struct razer_report razer_chroma_misc_set_keyswitch_optimization_command2(unsigned char optimization_mode)
+{
+    struct razer_report report = get_razer_report(0x02, 0x15, 0x05); // class, id, data size
+
+    // 0x00 -> Typing (Store)
+    // 0x01 -> Gaming (Store)
+    switch(optimization_mode) {
+    case 0x00:
+        report.arguments[0] = 0x01;
+        report.arguments[1] = 0x00;
+        report.arguments[2] = 0x14;
+        report.arguments[3] = 0x00;
+        report.arguments[4] = 0x28;
+        report.arguments[5] = 0x00;
+        break;
+    case 0x01:
+        report.arguments[0] = 0x01;
+        break;
+    }
+
+    return report;
+}
+
+/**
+ * Get the keyswitch optimization on the device
+ *
+ * Identifiers in arg[1] and arg[3]
+ *
+ * 0x00<->0x14 is in arg[1]
+ * 0x00<->0x28 is in arg[3]
+ */
+struct razer_report razer_chroma_misc_get_keyswitch_optimization(void)
+{
+    struct razer_report report = get_razer_report(0x02, 0x82, 0x04); // class, id, data size
+
+    return report;
+}
+
+/**
+ * Set the brightness of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_misc_set_blade_brightness(unsigned char brightness)
+{
+    struct razer_report report = get_razer_report(0x0E, 0x04, 0x02);
+    report.arguments[0] = 0x01;
+    report.arguments[1] = brightness;
+
+    return report;
+}
+
+/**
+ * Get the brightness of an LED on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * ? TODO fill this
+ */
+struct razer_report razer_chroma_misc_get_blade_brightness(void)
+{
+    struct razer_report report = get_razer_report(0x0E, 0x84, 0x02);
+    report.arguments[0] = 0x01;
+
+    return report;
+}
+
+/**
+ * Sets custom frame for the firefly
+ */
+struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex
+{
+    const size_t start_arg_offset = 2;
+    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);
+    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);
+
+    if (row_length > sizeof(report.arguments) - start_arg_offset) {
+        printk(KERN_ALERT "razerchroma: RGB data too long\n");
+        row_length = 0;
+    }
+
+    report.arguments[0] = start_col;
+    report.arguments[1] = stop_col;
+
+    memcpy(&report.arguments[2], rgb_data, row_length);
+
+    return report;
+}
+
+/**
+ * Trigger reactive on Firefly
+ */
+struct razer_report razer_chroma_misc_matrix_reactive_trigger(void)
+{
+    struct razer_report report = razer_chroma_standard_matrix_effect_base(0x05, MATRIX_EFFECT_REACTIVE);
+    report.arguments[1] = 0; // this speed triggers reactive
+    report.arguments[2] = 0;
+    report.arguments[3] = 0;
+    report.arguments[4] = 0;
+
+    return report;
+}
+
+/**
+ * Gets battery level
+ *
+ * 0->255 is in arg[1]
+ */
+struct razer_report razer_chroma_misc_get_battery_level(void)
+{
+    return get_razer_report(0x07, 0x80, 0x02);
+}
+
+/**
+ * Gets charging status
+ *
+ * 0->1 is in arg[1]
+ */
+struct razer_report razer_chroma_misc_get_charging_status(void)
+{
+    return get_razer_report(0x07, 0x84, 0x02);
+}
+
+/**
+ * Set the charging effect, think if I remember correctly, it's either static colour, or "whatever the mouse was last on"
+ */
+struct razer_report razer_chroma_misc_set_dock_charge_type(unsigned char charge_type)
+{
+    struct razer_report report = get_razer_report(0x03, 0x10, 0x01);
+    report.arguments[0] = clamp_u8(charge_type, 0x00, 0x01);
+
+    return report;
+}
+
+/**
+ * Get the polling rate from the device
+ *
+ * Identifier is in arg[0]
+ *
+ * 0x01 = 1000Hz
+ * 0x02 =  500Hz
+ * 0x08 =  125Hz
+ */
+struct razer_report razer_chroma_misc_get_polling_rate(void)
+{
+    return get_razer_report(0x00, 0x85, 0x01);
+}
+
+/**
+ * Set the polling rate of the device
+ *
+ * 0x01 = 1000Hz
+ * 0x02 =  500Hz
+ * 0x08 =  125Hz
+ */
+struct razer_report razer_chroma_misc_set_polling_rate(unsigned short polling_rate)
+{
+    struct razer_report report = get_razer_report(0x00, 0x05, 0x01);
+
+    switch(polling_rate) {
+    case 1000:
+        report.arguments[0] = 0x01;
+        break;
+    case  500:
+        report.arguments[0] = 0x02;
+        break;
+    case  125:
+        report.arguments[0] = 0x08;
+        break;
+    default: // 500Hz
+        report.arguments[0] = 0x02;
+        break;
+    }
+
+    return report;
+}
+
+/**
+ * Get the polling rate from the device
+ *
+ * Identifier is in arg[1]
+ *
+ * 0x01 = 8000Hz
+ * 0x02 = 4000Hz
+ * 0x04 = 2000Hz
+ * 0x08 = 1000Hz
+ * 0x10 =  500Hz
+ * 0x40 =  125Hz
+ */
+struct razer_report razer_chroma_misc_get_polling_rate2(void)
+{
+    return get_razer_report(0x00, 0xC0, 0x01);
+}
+
+/**
+ * Set the polling rate of the device
+ *
+ * 0x40 =  125 Hz
+ * 0x10 =  500 Hz
+ * 0x08 = 1000 Hz
+ * 0x04 = 2000 Hz
+ * 0x02 = 4000 Hz
+ * 0x01 = 8000 Hz
+ */
+struct razer_report razer_chroma_misc_set_polling_rate2(unsigned short polling_rate, unsigned short argument)
+{
+    struct razer_report report = get_razer_report(0x00, 0x40, 0x02);
+
+    report.arguments[0] = argument; // For some devices Razer sends each request once with 0x00 and once with 0x01 - maybe varstore?
+    switch(polling_rate) {
+    case 8000:
+        report.arguments[1] = 0x01;
+        break;
+    case 4000:
+        report.arguments[1] = 0x02;
+        break;
+    case 2000:
+        report.arguments[1] = 0x04;
+        break;
+    case 1000:
+        report.arguments[1] = 0x08;
+        break;
+    case  500:
+        report.arguments[1] = 0x10;
+        break;
+    case  250:
+        report.arguments[1] = 0x20;
+        break;
+    case  125:
+        report.arguments[1] = 0x40;
+        break;
+    default: // 500Hz
+        report.arguments[1] = 0x10;
+        break;
+    }
+
+    return report;
+}
+
+/**
+ * Get brightness of charging dock
+ */
+struct razer_report razer_chroma_misc_get_dock_brightness(void)
+{
+    return get_razer_report(0x07, 0x82, 0x01);
+
+}
+
+/**
+ * Set brightness of charging dock
+ */
+struct razer_report razer_chroma_misc_set_dock_brightness(unsigned char brightness)
+{
+    struct razer_report report = get_razer_report(0x07, 0x02, 0x01);
+    report.arguments[0] = brightness;
+
+    return report;
+}
+
+/**
+ * Set the DPI of the device
+ */
+struct razer_report razer_chroma_misc_set_dpi_xy(unsigned char variable_storage, unsigned short dpi_x,unsigned short dpi_y)
+{
+    struct razer_report report = get_razer_report(0x04, 0x05, 0x07);
+
+    // Keep the DPI within bounds
+    dpi_x = clamp_u16(dpi_x, 100, 35000);
+    dpi_y = clamp_u16(dpi_y, 100, 35000);
+
+    report.arguments[0] = VARSTORE;
+
+    report.arguments[1] = (dpi_x >> 8) & 0x00FF;
+    report.arguments[2] = dpi_x & 0x00FF;
+    report.arguments[3] = (dpi_y >> 8) & 0x00FF;
+    report.arguments[4] = dpi_y & 0x00FF;
+    report.arguments[5] = 0x00;
+    report.arguments[6] = 0x00;
+
+    return report;
+}
+
+/**
+ * Get the DPI of the device
+ */
+struct razer_report razer_chroma_misc_get_dpi_xy(unsigned char variable_storage)
+{
+    struct razer_report report = get_razer_report(0x04, 0x85, 0x07);
+
+    report.arguments[0] = variable_storage;
+
+    return report;
+}
+
+/**
+ * Set the DPI of the device (Some stupid turd scaled 5600 dpi into a single byte)
+ */
+struct razer_report razer_chroma_misc_set_dpi_xy_byte(unsigned char dpi_x,unsigned char dpi_y)
+{
+    struct razer_report report = get_razer_report(0x04, 0x01, 0x03);
+
+    report.arguments[0] = dpi_x;
+    report.arguments[1] = dpi_y;
+    report.arguments[2] = 0x00;
+
+    return report;
+}
+
+/**
+ * Get the DPI of the device (Some stupid turd scaled 5600 dpi into a single byte)
+ */
+struct razer_report razer_chroma_misc_get_dpi_xy_byte(void)
+{
+    struct razer_report report = get_razer_report(0x04, 0x81, 0x03);
+
+    return report;
+}
+
+/**
+ * Set DPI stages of the device.
+ *
+ * count is the number of stages to set.
+ * active_stage selected stage number.
+ * dpi is an array of size 2 * count containing pairs of dpi x and dpi y
+ * values, one pair for each stage.
+ *
+ * E.g.:
+ *   count = 3
+ *   active_stage = 1
+ *   dpi = [ 800, 800, 1800, 1800, 3200, 3200]
+ *         | stage 1*|  stage 2  |  stage 3  |
+ */
+struct razer_report razer_chroma_misc_set_dpi_stages(unsigned char variable_storage, unsigned char count, unsigned char active_stage, const unsigned short *dpi)
+{
+    struct razer_report report = get_razer_report(0x04, 0x06, 0x26);
+    unsigned int offset;
+    unsigned int i;
+
+    report.arguments[0] = variable_storage;
+    report.arguments[1] = active_stage;
+    report.arguments[2] = count;
+
+    offset = 3;
+    for (i = 0; i < count; i++) {
+        // Stage number
+        report.arguments[offset++] = i;
+
+        // DPI X
+        report.arguments[offset++] = (dpi[0] >> 8) & 0x00FF;
+        report.arguments[offset++] = dpi[0] & 0x00FF;
+
+        // DPI Y
+        report.arguments[offset++] = (dpi[1] >> 8) & 0x00FF;
+        report.arguments[offset++] = dpi[1] & 0x00FF;
+
+        // Reserved
+        report.arguments[offset++] = 0;
+        report.arguments[offset++] = 0;
+
+        dpi += 2;
+    }
+
+    return report;
+}
+
+/**
+ * Get the DPI stages of the device
+ */
+struct razer_report razer_chroma_misc_get_dpi_stages(unsigned char variable_storage)
+{
+    struct razer_report report = get_razer_report(0x04, 0x86, 0x26);
+
+    report.arguments[0] = variable_storage;
+
+    return report;
+}
+
+/**
+ * Get device idle time
+ */
+struct razer_report razer_chroma_misc_get_idle_time(void)
+{
+    return get_razer_report(0x07, 0x83, 0x02);
+}
+
+/**
+ * Set device idle time
+ *
+ * Device will go into powersave after this time.
+ *
+ * Idle time is in seconds, must be between 60sec-900sec
+ */
+struct razer_report razer_chroma_misc_set_idle_time(unsigned short idle_time)
+{
+    struct razer_report report = get_razer_report(0x07, 0x03, 0x02);
+
+    // Keep the idle time within bounds
+    idle_time = clamp_u16(idle_time, 60, 900);
+
+    report.arguments[0] = (idle_time >> 8) & 0x00FF;
+    report.arguments[1] = idle_time & 0x00FF;
+
+    return report;
+}
+
+/**
+ * Get low battery threshold
+ */
+struct razer_report razer_chroma_misc_get_low_battery_threshold(void)
+{
+    return get_razer_report(0x07, 0x81, 0x01);
+}
+
+/**
+ * Set low battery threshold
+ *
+ * 0x3F = 25%
+ * 0x26 = 15%
+ * 0x0C =  5%
+ */
+struct razer_report razer_chroma_misc_set_low_battery_threshold(unsigned char battery_threshold)
+{
+    struct razer_report report = get_razer_report(0x07, 0x01, 0x01);
+
+    // Keep the battery threshold within bounds
+    battery_threshold = clamp_u8(battery_threshold, 0x0C, 0x3F);
+
+    report.arguments[0] = battery_threshold;
+
+    return report;
+}
+
+struct razer_report razer_chroma_misc_set_orochi2011_led(unsigned char led_bitfield)
+{
+    struct razer_report report = {0};
+    memcpy(&report, &orochi2011_led, sizeof(orochi2011_led));
+
+    report.arguments[1] = led_bitfield;
+
+    return report;
+}
+
+struct razer_report razer_chroma_misc_set_orochi2011_poll_dpi(unsigned short poll_rate, unsigned char dpi_x, unsigned char dpi_y)
+{
+    struct razer_report report = {0};
+    memcpy(&report, &orochi2011_dpi, sizeof(orochi2011_dpi));
+
+    switch(poll_rate) {
+    case 1000:
+        poll_rate = 0x01;
+        break;
+    case  500:
+        poll_rate = 0x02;
+        break;
+    case  125:
+        poll_rate = 0x08;
+        break;
+    default: // 500Hz
+        poll_rate = 0x02;
+        break;
+    }
+
+    report.arguments[1] = poll_rate;
+
+    report.arguments[3] = clamp_u8(dpi_x, 0x15, 0x9C);
+    report.arguments[4] = clamp_u8(dpi_y, 0x15, 0x9C);
+
+    return report;
+}
+
+/**
+ * Set the Naga Trinity to "Static" effect
+ */
+struct razer_report razer_naga_trinity_effect_static(struct razer_rgb *rgb)
+{
+    struct razer_report report = get_razer_report(0x0f, 0x03, 0x0e);
+
+    report.arguments[0] = 0x00; // Variable storage
+    report.arguments[1] = 0x00; // LED ID
+    report.arguments[2] = 0x00; // Unknown
+    report.arguments[3] = 0x00; // Unknown
+    report.arguments[4] = 0x02; // Effect ID
+    report.arguments[5] = rgb->r; // RGB 3x
+    report.arguments[6] = rgb->g;
+    report.arguments[7] = rgb->b;
+    report.arguments[8] = rgb->r;
+    report.arguments[9] = rgb->g;
+    report.arguments[10] = rgb->b;
+    report.arguments[11] = rgb->r;
+    report.arguments[12] = rgb->g;
+    report.arguments[13] = rgb->b;
+
+    return report;
+}
+
+/**
+ * Set scroll wheel mode on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    02       02    14  0100    | SET SCROLL WHEEL MODE (VARSTR, TACTILE)
+ * 00     1f    0000   00    02       02    14  0101    | SET SCROLL WHEEL MODE (VARSTR, FREESPIN)
+ */
+struct razer_report razer_chroma_misc_set_scroll_mode(unsigned int scroll_mode)
+{
+    struct razer_report report = get_razer_report(0x02, 0x14, 0x02);
+
+    report.arguments[0] = VARSTORE;
+    report.arguments[1] = scroll_mode;
+
+    return report;
+}
+
+/**
+ * Get scroll wheel mode from the device
+ */
+struct razer_report razer_chroma_misc_get_scroll_mode(void)
+{
+    struct razer_report report = get_razer_report(0x02, 0x94, 0x02);
+
+    report.arguments[0] = VARSTORE;
+
+    return report;
+}
+
+/**
+ * Set scroll wheel acceleration on/off on the device
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    02       02    16  0101    | SET SCROLL WHEEL ACCELERATION (VARSTR, ON)
+ * 00     1f    0000   00    02       02    16  0100    | SET SCROLL WHEEL ACCELERATION (VARSTR, OFF)
+ */
+struct razer_report razer_chroma_misc_set_scroll_acceleration(bool acceleration)
+{
+    struct razer_report report = get_razer_report(0x02, 0x16, 0x02);
+
+    report.arguments[0] = VARSTORE;
+    report.arguments[1] = acceleration;
+
+    return report;
+}
+
+/**
+ * Get scroll wheel acceleration state from the device
+ */
+struct razer_report razer_chroma_misc_get_scroll_acceleration(void)
+{
+    struct razer_report report = get_razer_report(0x02, 0x96, 0x02);
+
+    report.arguments[0] = VARSTORE;
+
+    return report;
+}
+
+/**
+ * Set scroll wheel "smart reel" on/off on the device.
+ * Smart reel automatically changes scroll wheel mode from tactile to free spin and back depending on scroll speed.
+ *
+ * Status Trans Packet Proto DataSize Class CMD Args
+ * 00     1f    0000   00    02       02    17  0101    | SET SCROLL WHEEL SMART REEL (VARSTR, ON)
+ * 00     1f    0000   00    02       02    17  0100    | SET SCROLL WHEEL SMART REEL (VARSTR, OFF)
+ */
+struct razer_report razer_chroma_misc_set_scroll_smart_reel(bool smart_reel)
+{
+    struct razer_report report = get_razer_report(0x02, 0x17, 0x02);
+
+    report.arguments[0] = VARSTORE;
+    report.arguments[1] = smart_reel;
+
+    return report;
+}
+
+/**
+ * Get scroll wheel "smart reel" state from the device
+ */
+struct razer_report razer_chroma_misc_get_scroll_smart_reel(void)
+{
+    struct razer_report report = get_razer_report(0x02, 0x97, 0x02);
+
+    report.arguments[0] = VARSTORE;
+
+    return report;
+}
+
+/**
+ * Set LED mode for HyperPolling Wireless Dongle
+ * 1 = Connection Status
+ * 2 = Battery Status
+ * 3 = Battery Warning Only
+ */
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_indicator_led_mode(unsigned char mode)
+{
+    struct razer_report report = get_razer_report(0x07, 0x10, 0x01);
+
+    if(mode < 0x01 || mode > 0x03) {
+        mode = 0x01;
+    }
+
+    report.arguments[0] = mode;
+
+    return report;
+}
+
+/**
+ * Set pairing mode for HyperPolling Wireless Dongle (step 1 of pairing)
+ */
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step1(unsigned short pid)
+{
+    struct razer_report report;
+
+    report = get_razer_report(0x00, 0x46, 0x01);
+    report.arguments[0] = 0x01;
+
+    return report;
+}
+
+/**
+ * Pair HyperPolling Wireless Dongle with PID (step 2 of pairing)
+ */
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step2(unsigned short pid)
+{
+    struct razer_report report;
+
+    report = get_razer_report(0x00, 0x41, 0x03);
+    report.arguments[0] = 0x01;
+    report.arguments[1] = (pid >> 8) & 0xFF;
+    report.arguments[2] = pid & 0xFF;
+
+    return report;
+}
+
+/**
+ * Set unpairing mode for HyperPolling Wireless Dongle
+ */
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_unpair(unsigned short pid)
+{
+    struct razer_report report = get_razer_report(0x00, 0x42, 0x02);
+
+    report.arguments[0] = (pid >> 8) & 0xFF;
+    report.arguments[1] = pid & 0xFF;
+
+    return report;
+}
diff --git a/drivers/custom/razer/driver/razerchromacommon.h b/drivers/custom/razer/driver/razerchromacommon.h
new file mode 100644
index 000000000000..e17418f98427
--- /dev/null
+++ b/drivers/custom/razer/driver/razerchromacommon.h
@@ -0,0 +1,157 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef DRIVER_RAZERCHROMACOMMON_H_
+#define DRIVER_RAZERCHROMACOMMON_H_
+
+#include "razercommon.h"
+
+/*
+ * Standard Device Functions
+ */
+struct razer_report razer_chroma_standard_set_device_mode(unsigned char mode, unsigned char param);
+struct razer_report razer_chroma_standard_get_device_mode(void);
+
+struct razer_report razer_chroma_standard_get_serial(void);
+
+struct razer_report razer_chroma_standard_get_firmware_version(void);
+
+/*
+ * Standard LED Functions
+ */
+struct razer_report razer_chroma_standard_set_led_state(unsigned char variable_storage, unsigned char led_id, unsigned char led_state);
+struct razer_report razer_chroma_standard_get_led_state(unsigned char variable_storage, unsigned char led_id);
+
+struct razer_report razer_chroma_standard_set_led_blinking(unsigned char variable_storage, unsigned char led_id);
+
+struct razer_report razer_chroma_standard_set_led_rgb(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_standard_get_led_rgb(unsigned char variable_storage, unsigned char led_id);
+
+struct razer_report razer_chroma_standard_set_led_effect(unsigned char variable_storage, unsigned char led_id, unsigned char led_effect);
+struct razer_report razer_chroma_standard_get_led_effect(unsigned char variable_storage, unsigned char led_id);
+
+struct razer_report razer_chroma_standard_set_led_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness);
+struct razer_report razer_chroma_standard_get_led_brightness(unsigned char variable_storage, unsigned char led_id);
+
+/*
+ * Standard Matrix Effects Functions
+ */
+struct razer_report razer_chroma_standard_matrix_effect_none(void);
+struct razer_report razer_chroma_standard_matrix_effect_wave(unsigned char wave_direction);
+struct razer_report razer_chroma_standard_matrix_effect_spectrum(void);
+struct razer_report razer_chroma_standard_matrix_effect_reactive(unsigned char speed, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_standard_matrix_effect_static(struct razer_rgb *rgb1);
+struct razer_report razer_chroma_standard_matrix_effect_starlight_single(unsigned char speed, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_standard_matrix_effect_starlight_dual(unsigned char speed, struct razer_rgb *rgb1, struct razer_rgb *rgb2);
+struct razer_report razer_chroma_standard_matrix_effect_starlight_random(unsigned char speed);
+
+struct razer_report razer_chroma_standard_matrix_effect_breathing_random(void);
+struct razer_report razer_chroma_standard_matrix_effect_breathing_single(struct razer_rgb *rgb1);
+struct razer_report razer_chroma_standard_matrix_effect_breathing_dual(struct razer_rgb *rgb1, struct razer_rgb *rgb2);
+struct razer_report razer_chroma_standard_matrix_effect_custom_frame(unsigned char variable_storage);
+struct razer_report razer_chroma_standard_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data);
+
+/*
+ * Extended Matrix Effects Functions
+ *
+ * Class 0x0F
+ * Trans 0x3F (Dev 0b001 Game Controller 1, Trans 0b11111)
+ */
+struct razer_report razer_chroma_extended_matrix_effect_none(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_extended_matrix_effect_static(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb);
+struct razer_report razer_chroma_extended_matrix_effect_wave(unsigned char variable_storage, unsigned char led_id, unsigned char direction);
+struct razer_report razer_chroma_extended_matrix_effect_starlight_random(unsigned char variable_storage, unsigned char led_id, unsigned char speed);
+struct razer_report razer_chroma_extended_matrix_effect_starlight_single(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_extended_matrix_effect_starlight_dual(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1, struct razer_rgb *rgb2);
+struct razer_report razer_chroma_extended_matrix_effect_spectrum(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_extended_matrix_effect_wheel(unsigned char variable_storage, unsigned char led_id, unsigned char direction);
+struct razer_report razer_chroma_extended_matrix_effect_reactive(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_extended_matrix_effect_breathing_random(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_extended_matrix_effect_breathing_single(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_extended_matrix_effect_breathing_dual(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1, struct razer_rgb *rgb2);
+struct razer_report razer_chroma_extended_matrix_effect_custom_frame(void);
+struct razer_report razer_chroma_extended_matrix_brightness(unsigned char variable_storage, unsigned char led_id, unsigned char brightness);
+struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_extended_matrix_set_custom_frame(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data);
+struct razer_report razer_chroma_extended_matrix_set_custom_frame2(unsigned char row_index, unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data, size_t packetLength);
+
+/*
+ * Extended Matrix Effects (Mouse) Functions
+ *
+ * Class 0x0D
+ * Trans 0x3F (not set) (Dev 0b001 Game Controller 1, Trans 0b11111)
+ */
+struct razer_report razer_chroma_mouse_extended_matrix_effect_none(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_static(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_spectrum(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_reactive(unsigned char variable_storage, unsigned char led_id, unsigned char speed, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_random(unsigned char variable_storage, unsigned char led_id);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_single(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1);
+struct razer_report razer_chroma_mouse_extended_matrix_effect_breathing_dual(unsigned char variable_storage, unsigned char led_id, struct razer_rgb *rgb1, struct razer_rgb *rgb2);
+
+/*
+ * Misc Functions
+ */
+struct razer_report razer_chroma_misc_fn_key_toggle(unsigned char state);
+
+struct razer_report razer_chroma_misc_set_keyswitch_optimization_command1(unsigned char optimization_mode);
+struct razer_report razer_chroma_misc_set_keyswitch_optimization_command2(unsigned char optimization_mode);
+struct razer_report razer_chroma_misc_get_keyswitch_optimization(void);
+
+struct razer_report razer_chroma_misc_set_blade_brightness(unsigned char brightness);
+struct razer_report razer_chroma_misc_get_blade_brightness(void);
+
+struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data);
+struct razer_report razer_chroma_misc_matrix_reactive_trigger(void);
+
+struct razer_report razer_chroma_misc_get_battery_level(void);
+struct razer_report razer_chroma_misc_get_charging_status(void);
+
+struct razer_report razer_chroma_misc_set_dock_charge_type(unsigned char charge_type);
+
+struct razer_report razer_chroma_misc_get_polling_rate(void);
+struct razer_report razer_chroma_misc_set_polling_rate(unsigned short polling_rate);
+
+struct razer_report razer_chroma_misc_get_polling_rate2(void);
+struct razer_report razer_chroma_misc_set_polling_rate2(unsigned short polling_rate, unsigned short argument);
+
+struct razer_report razer_chroma_misc_get_dock_brightness(void);
+struct razer_report razer_chroma_misc_set_dock_brightness(unsigned char brightness);
+
+struct razer_report razer_chroma_misc_set_dpi_xy(unsigned char variable_storage, unsigned short dpi_x,unsigned short dpi_y);
+struct razer_report razer_chroma_misc_get_dpi_xy(unsigned char variable_storage);
+
+struct razer_report razer_chroma_misc_set_dpi_xy_byte(unsigned char dpi_x,unsigned char dpi_y);
+struct razer_report razer_chroma_misc_get_dpi_xy_byte(void);
+
+struct razer_report razer_chroma_misc_set_dpi_stages(unsigned char variable_storage, unsigned char count, unsigned char active_stage, const unsigned short *dpi);
+struct razer_report razer_chroma_misc_get_dpi_stages(unsigned char variable_storage);
+
+struct razer_report razer_chroma_misc_get_idle_time(void);
+struct razer_report razer_chroma_misc_set_idle_time(unsigned short idle_time);
+
+struct razer_report razer_chroma_misc_get_low_battery_threshold(void);
+struct razer_report razer_chroma_misc_set_low_battery_threshold(unsigned char battery_threshold);
+
+struct razer_report razer_chroma_misc_set_orochi2011_led(unsigned char led_bitfield);
+struct razer_report razer_chroma_misc_set_orochi2011_poll_dpi(unsigned short poll_rate, unsigned char dpi_x, unsigned char dpi_y);
+
+struct razer_report razer_naga_trinity_effect_static(struct razer_rgb* rgb);
+
+struct razer_report razer_chroma_misc_set_scroll_mode(unsigned int scroll_mode);
+struct razer_report razer_chroma_misc_get_scroll_mode(void);
+
+struct razer_report razer_chroma_misc_set_scroll_acceleration(bool acceleration);
+struct razer_report razer_chroma_misc_get_scroll_acceleration(void);
+
+struct razer_report razer_chroma_misc_set_scroll_smart_reel(bool smart_reel);
+struct razer_report razer_chroma_misc_get_scroll_smart_reel(void);
+
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_indicator_led_mode(unsigned char mode);
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step1(unsigned short pid);
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step2(unsigned short pid);
+struct razer_report razer_chroma_misc_set_hyperpolling_wireless_dongle_unpair(unsigned short pid);
+
+#endif
diff --git a/drivers/custom/razer/driver/razercommon.c b/drivers/custom/razer/driver/razercommon.c
new file mode 100644
index 000000000000..4e8548ae4d03
--- /dev/null
+++ b/drivers/custom/razer/driver/razercommon.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Tim Theede <pez2001@voyagerproject.de>
+ *               2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/hid.h>
+
+#include "razercommon.h"
+
+/**
+ * Send USB control report to the keyboard
+ * USUALLY index = 0x02
+ * FIREFLY is 0
+ */
+int razer_send_control_msg(struct usb_device *usb_dev,void const *data, uint report_index, ulong wait_min, ulong wait_max)
+{
+    uint request = HID_REQ_SET_REPORT; // 0x09
+    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21
+    uint value = 0x300;
+    uint size = RAZER_USB_REPORT_LEN;
+    char *buf;
+    int len;
+
+    buf = kmemdup(data, size, GFP_KERNEL);
+    if (buf == NULL)
+        return -ENOMEM;
+
+    // Send usb control message
+    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
+                          request,      // Request
+                          request_type, // RequestType
+                          value,        // Value
+                          report_index, // Index
+                          buf,          // Data
+                          size,         // Length
+                          USB_CTRL_SET_TIMEOUT);
+
+    // Wait
+    usleep_range(wait_min, wait_max);
+
+    kfree(buf);
+    if(len!=size)
+        printk(KERN_WARNING "razer driver: Device data transfer failed.\n");
+
+    return ((len < 0) ? len : ((len != size) ? -EIO : 0));
+}
+
+/**
+ * Get a response from the razer device
+ *
+ * Makes a request like normal, this must change a variable in the device as then we
+ * tell it give us data and it gives us a report.
+ *
+ * Supported Devices:
+ *   Razer Chroma
+ *   Razer Mamba
+ *   Razer BlackWidow Ultimate 2013*
+ *   Razer Firefly*
+ *
+ * Request report is the report sent to the device specifying what response we want
+ * Response report will get populated with a response
+ *
+ * Returns 0 when successful, 1 if the report length is invalid.
+ */
+int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)
+{
+    uint request = HID_REQ_GET_REPORT; // 0x01
+    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; // 0xA1
+    uint value = 0x300;
+
+    uint size = RAZER_USB_REPORT_LEN; // 0x90
+    int len;
+    int retval;
+    int result = 0;
+    char *buf;
+
+    if (WARN_ON(request_report->transaction_id.id == 0x00)) {
+        request_report->transaction_id.id = 0xFF;
+    }
+
+    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);
+    if (buf == NULL)
+        return -ENOMEM;
+
+    // Send the request to the device.
+    // TODO look to see if index needs to be different for the request and the response
+    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);
+
+    // Now ask for response
+    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),
+                          request,         // Request
+                          request_type,    // RequestType
+                          value,           // Value
+                          response_index,  // Index
+                          buf,             // Data
+                          size,
+                          USB_CTRL_SET_TIMEOUT);
+
+    memcpy(response_report, buf, sizeof(struct razer_report));
+    kfree(buf);
+
+    // Error if report is wrong length
+    if(len != 90) {
+        printk(KERN_WARNING "razer driver: Invalid USB response. USB Report length: %d\n", len);
+        result = 1;
+    }
+
+    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),
+                  "Field data_size %d in response is bigger than arguments\n",
+                  response_report->data_size)) {
+        /* Sanitize the value since at the moment callers don't respect the return code */
+        response_report->data_size = ARRAY_SIZE(response_report->arguments);
+        return -EINVAL;
+    }
+
+    return result;
+}
+
+/**
+ * Calculate the checksum for the usb message
+ *
+ * Checksum byte is stored in the 2nd last byte in the messages payload.
+ * The checksum is generated by XORing all the bytes in the report starting
+ * at byte number 2 (0 based) and ending at byte 88.
+ */
+unsigned char razer_calculate_crc(struct razer_report *report)
+{
+    /*second to last byte of report is a simple checksum*/
+    /*just xor all bytes up with overflow and you are done*/
+    unsigned char crc = 0;
+    unsigned char *_report = (unsigned char*)report;
+
+    unsigned int i;
+    for(i = 2; i < 88; i++) {
+        crc ^= _report[i];
+    }
+
+    return crc;
+}
+
+/**
+ * Get initialised razer report
+ */
+struct razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size)
+{
+    struct razer_report new_report = {0};
+    memset(&new_report, 0, sizeof(struct razer_report));
+
+    new_report.status = 0x00;
+    new_report.transaction_id.id = 0x00;
+    new_report.remaining_packets = 0x00;
+    new_report.protocol_type = 0x00;
+    new_report.command_class = command_class;
+    new_report.command_id.id = command_id;
+    new_report.data_size = data_size;
+
+    return new_report;
+}
+
+/**
+ * Get empty razer report
+ */
+struct razer_report get_empty_razer_report(void)
+{
+    struct razer_report new_report = {0};
+    memset(&new_report, 0, sizeof(struct razer_report));
+
+    return new_report;
+}
+
+/**
+ * Print report to syslog
+ */
+void print_erroneous_report(struct razer_report* report, char* driver_name, char* message)
+{
+    printk(KERN_WARNING "%s: %s. status: %02x transaction_id.id: %02x remaining_packets: %02x protocol_type: %02x data_size: %02x, command_class: %02x, command_id.id: %02x Params: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x .\n",
+           driver_name,
+           message,
+           report->status,
+           report->transaction_id.id,
+           report->remaining_packets,
+           report->protocol_type,
+           report->data_size,
+           report->command_class,
+           report->command_id.id,
+           report->arguments[0], report->arguments[1], report->arguments[2], report->arguments[3], report->arguments[4], report->arguments[5],
+           report->arguments[6], report->arguments[7], report->arguments[8], report->arguments[9], report->arguments[10], report->arguments[11],
+           report->arguments[12], report->arguments[13], report->arguments[14], report->arguments[15]);
+}
+
+/**
+ * Clamp a value to a min,max
+ */
+unsigned char clamp_u8(unsigned char value, unsigned char min, unsigned char max)
+{
+    if(value > max)
+        return max;
+    if(value < min)
+        return min;
+    return value;
+}
+unsigned short clamp_u16(unsigned short value, unsigned short min, unsigned short max)
+{
+    if(value > max)
+        return max;
+    if(value < min)
+        return min;
+    return value;
+}
+
+int razer_send_control_msg_old_device(struct usb_device *usb_dev,void const *data, uint report_value, uint report_index, uint report_size, ulong wait_min, ulong wait_max)
+{
+    uint request = HID_REQ_SET_REPORT; // 0x09
+    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21
+    char *buf;
+    int len;
+
+    buf = kmemdup(data, report_size, GFP_KERNEL);
+    if (buf == NULL)
+        return -ENOMEM;
+
+    // Send usb control message
+    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
+                          request,      // Request
+                          request_type, // RequestType
+                          report_value, // Value
+                          report_index, // Index
+                          buf,          // Data
+                          report_size,  // Length
+                          USB_CTRL_SET_TIMEOUT);
+
+    // Wait
+    usleep_range(wait_min, wait_max);
+
+    kfree(buf);
+    if(len!=report_size)
+        printk(KERN_WARNING "razer driver: Device data transfer failed.\n");
+
+    return ((len < 0) ? len : ((len != report_size) ? -EIO : 0));
+}
+
+int razer_send_argb_msg(struct usb_device* usb_dev, unsigned char channel, unsigned char size, void const* data)
+{
+    uint request = HID_REQ_SET_REPORT; // 0x09
+    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21
+    uint value = 0x300;
+    int len;
+    char *buf;
+
+    struct razer_argb_report report;
+
+    if (channel < 5) {
+        report.report_id = 0x04;
+    } else {
+        report.report_id = 0x84;
+    }
+
+    report.channel_1 = channel;
+    report.channel_2 = channel;
+
+    report.pad = 0;
+
+    report.last_idx = size - 1;
+
+    if (size * 3 > ARRAY_SIZE(report.color_data)) {
+        printk(KERN_ERR "razer driver: size too big\n");
+        return -EINVAL;
+    }
+
+    memcpy(report.color_data, data, size * 3);
+
+    buf = kmemdup(&report, sizeof(report), GFP_KERNEL);
+
+    // Send usb control message
+    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
+                          request,            // Request
+                          request_type,       // RequestType
+                          value,              // Value
+                          0x01,               // Index
+                          buf,                // Data
+                          sizeof(report),     // Length
+                          USB_CTRL_SET_TIMEOUT);
+
+    if (len != sizeof(report))
+        printk(KERN_WARNING "razer driver: Device data transfer failed. len = %d", len);
+
+    return ((len < 0) ? len : ((len != size) ? -EIO : 0));
+}
diff --git a/drivers/custom/razer/driver/razercommon.h b/drivers/custom/razer/driver/razercommon.h
new file mode 100644
index 000000000000..a1cf644fa01c
--- /dev/null
+++ b/drivers/custom/razer/driver/razercommon.h
@@ -0,0 +1,176 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Tim Theede <pez2001@voyagerproject.de>
+ *               2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef DRIVER_RAZERCOMMON_H_
+#define DRIVER_RAZERCOMMON_H_
+
+#include <linux/usb/input.h>
+
+#define DRIVER_VERSION "3.10.2"
+#define DRIVER_LICENSE "GPL v2"
+#define DRIVER_AUTHOR "Terri Cain <terri@dolphincorp.co.uk>"
+
+// Compatbility for fallthrough pseudo keyword for Linux versions older than v5.4
+// See also https://git.kernel.org/torvalds/c/294f69e
+#ifndef fallthrough
+#if __has_attribute(__fallthrough__)
+# define fallthrough                    __attribute__((__fallthrough__))
+#else
+# define fallthrough                    do {} while (0)  /* fallthrough */
+#endif
+#endif
+
+// Macro to create device files
+#define CREATE_DEVICE_FILE(dev, type) \
+do { \
+    if(device_create_file(dev, type)) { \
+        goto exit_free; \
+    } \
+} while (0)
+
+#define USB_VENDOR_ID_RAZER 0x1532
+
+/* Each USB report has 90 bytes*/
+#define RAZER_USB_REPORT_LEN 0x5A
+
+// LED STATE
+#define OFF 0x00
+#define ON  0x01
+
+// LED STORAGE Options
+#define NOSTORE          0x00
+#define VARSTORE         0x01
+
+// LED definitions
+#define ZERO_LED          0x00
+#define SCROLL_WHEEL_LED  0x01
+#define BATTERY_LED       0x03
+#define LOGO_LED          0x04
+#define BACKLIGHT_LED     0x05
+#define MACRO_LED         0x07
+#define GAME_LED          0x08
+#define RED_PROFILE_LED   0x0C
+#define GREEN_PROFILE_LED 0x0D
+#define BLUE_PROFILE_LED  0x0E
+#define RIGHT_SIDE_LED    0x10
+#define LEFT_SIDE_LED     0x11
+#define ARGB_CH_1_LED     0x1A
+#define ARGB_CH_2_LED     0x1B
+#define ARGB_CH_3_LED     0x1C
+#define ARGB_CH_4_LED     0x1D
+#define ARGB_CH_5_LED     0x1E
+#define ARGB_CH_6_LED     0x1F
+#define CHARGING_LED      0x20
+#define FAST_CHARGING_LED 0x21
+#define FULLY_CHARGED_LED 0x22
+
+// LED Effect definitions
+enum razer_classic_effect_id {
+    CLASSIC_EFFECT_STATIC = 0x00,
+    CLASSIC_EFFECT_BLINKING = 0x01,
+    CLASSIC_EFFECT_BREATHING = 0x02, // also called pulsating
+    CLASSIC_EFFECT_SPECTRUM = 0x04,
+};
+
+enum razer_matrix_effect_id {
+    MATRIX_EFFECT_OFF = 0x00,
+    MATRIX_EFFECT_WAVE = 0x01,
+    MATRIX_EFFECT_REACTIVE = 0x02, // afterglow
+    MATRIX_EFFECT_BREATHING = 0x03,
+    MATRIX_EFFECT_SPECTRUM = 0x04,
+    MATRIX_EFFECT_CUSTOMFRAME = 0x05,
+    MATRIX_EFFECT_STATIC = 0x06,
+    MATRIX_EFFECT_STARLIGHT = 0x19
+};
+
+// Report Responses
+#define RAZER_CMD_BUSY          0x01
+#define RAZER_CMD_SUCCESSFUL    0x02
+#define RAZER_CMD_FAILURE       0x03
+#define RAZER_CMD_TIMEOUT       0x04
+#define RAZER_CMD_NOT_SUPPORTED 0x05
+
+struct razer_report;
+
+struct razer_rgb {
+    unsigned char r,g,b;
+};
+
+union transaction_id_union {
+    unsigned char id;
+    struct transaction_parts {
+        unsigned char device : 3;
+        unsigned char id : 5;
+    } parts;
+};
+
+union command_id_union {
+    unsigned char id;
+    struct command_id_parts {
+        unsigned char direction : 1;
+        unsigned char id : 7;
+    } parts;
+};
+
+/* Status:
+ * 0x00 New Command
+ * 0x01 Command Busy
+ * 0x02 Command Successful
+ * 0x03 Command Failure
+ * 0x04 Command No Response / Command Timeout
+ * 0x05 Command Not Support
+ *
+ * Transaction ID used to group request-response, device useful when multiple devices are on one usb
+ * Remaining Packets is the number of remaining packets in the sequence
+ * Protocol Type is always 0x00
+ * Data Size is the size of payload, cannot be greater than 80. 90 = header (8B) + data + CRC (1B) + Reserved (1B)
+ * Command Class is the type of command being issued
+ * Command ID is the type of command being send. Direction 0 is Host->Device, Direction 1 is Device->Host. AKA Get LED 0x80, Set LED 0x00
+ *
+ * */
+
+struct razer_report {
+    unsigned char status;
+    union transaction_id_union transaction_id; /* */
+    unsigned short remaining_packets; /* Big Endian */
+    unsigned char protocol_type; /*0x0*/
+    unsigned char data_size;
+    unsigned char command_class;
+    union command_id_union command_id;
+    unsigned char arguments[80];
+    unsigned char crc;/*xor'ed bytes of report*/
+    unsigned char reserved; /*0x0*/
+};
+
+struct razer_argb_report {
+    unsigned char report_id;
+    unsigned char channel_1;
+    unsigned char channel_2;
+    unsigned char pad;
+    unsigned char last_idx;
+    unsigned char color_data[315];
+};
+
+struct razer_key_translation {
+    u16 from;
+    u16 to;
+    u8 flags;
+};
+
+int razer_send_control_msg(struct usb_device *usb_dev,void const *data, unsigned int report_index, unsigned long wait_min, unsigned long wait_max);
+int razer_send_control_msg_old_device(struct usb_device *usb_dev,void const *data, uint report_value, uint report_index, uint report_size, ulong wait_min, ulong wait_max);
+int razer_get_usb_response(struct usb_device *usb_dev, unsigned int report_index, struct razer_report* request_report, unsigned int response_index, struct razer_report* response_report, unsigned long wait_min, unsigned long wait_max);
+int razer_send_argb_msg(struct usb_device* usb_dev, unsigned char channel, unsigned char size, void const* data);
+unsigned char razer_calculate_crc(struct razer_report *report);
+struct razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size);
+struct razer_report get_empty_razer_report(void);
+void print_erroneous_report(struct razer_report* report, char* driver_name, char* message);
+
+// Convenience functions
+unsigned char clamp_u8(unsigned char value, unsigned char min, unsigned char max);
+unsigned short clamp_u16(unsigned short value, unsigned short min, unsigned short max);
+
+#endif /* DRIVER_RAZERCOMMON_H_ */
diff --git a/drivers/custom/razer/driver/razerkbd_driver.c b/drivers/custom/razer/driver/razerkbd_driver.c
new file mode 100644
index 000000000000..6cb355f7afc8
--- /dev/null
+++ b/drivers/custom/razer/driver/razerkbd_driver.c
@@ -0,0 +1,5010 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+#include <linux/dmi.h>
+#include <linux/input-event-codes.h>
+
+#include "usb_hid_keys.h"
+
+#include "razerkbd_driver.h"
+#include "razercommon.h"
+#include "razerchromacommon.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_DESC "Razer Keyboard Device Driver"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+// KEY_MACRO* has been added in Linux 5.5, so define ourselves for older kernels.
+// See also https://git.kernel.org/torvalds/c/b5625db
+#ifndef KEY_MACRO1
+#define KEY_MACRO1  0x290
+#define KEY_MACRO2  0x291
+#define KEY_MACRO3  0x292
+#define KEY_MACRO4  0x293
+#define KEY_MACRO5  0x294
+#define KEY_MACRO6  0x295
+#define KEY_MACRO7  0x296
+#define KEY_MACRO8  0x297
+#define KEY_MACRO9  0x298
+#define KEY_MACRO10 0x299
+#define KEY_MACRO11 0x2a0
+#define KEY_MACRO12 0x2a1
+// ...
+#define KEY_MACRO27 0x2aa
+#define KEY_MACRO28 0x2ab
+#define KEY_MACRO29 0x2ac
+#define KEY_MACRO30 0x2ad
+#endif
+
+// These are evdev key codes, not HID key codes.
+// Lower macro key codes are intended for the actual macro keys
+// Higher macro key codes are inteded for Chroma functions
+#define RAZER_MACRO_KEY KEY_MACRO30 // TODO maybe KEY_MACRO_RECORD_START?
+#define RAZER_GAME_KEY KEY_MACRO29 // TODO maybe KEY_GAMES?
+#define RAZER_BRIGHTNESS_DOWN KEY_MACRO28
+#define RAZER_BRIGHTNESS_UP KEY_MACRO27
+
+/**
+ * List of keys to swap
+ */
+static const struct razer_key_translation chroma_keys[] = {
+    { KEY_F1,    KEY_MUTE },
+    { KEY_F2,    KEY_VOLUMEDOWN },
+    { KEY_F3,    KEY_VOLUMEUP },
+
+    { KEY_F5,    KEY_PREVIOUSSONG },
+    { KEY_F6,    KEY_PLAYPAUSE },
+    { KEY_F7,    KEY_NEXTSONG },
+
+    { KEY_F9,   RAZER_MACRO_KEY },
+    { KEY_F10,  RAZER_GAME_KEY },
+    { KEY_F11,  RAZER_BRIGHTNESS_DOWN },
+    { KEY_F12,  RAZER_BRIGHTNESS_UP },
+
+    { KEY_PAUSE, KEY_SLEEP },
+
+    // Custom bind
+    { KEY_KPENTER, KEY_CALC },
+    { 0 }
+};
+
+static const struct razer_key_translation chroma_keys_2[] = {
+    { KEY_F1,    KEY_MUTE },
+    { KEY_F2,    KEY_VOLUMEDOWN },
+    { KEY_F3,    KEY_VOLUMEUP },
+
+    { KEY_F5,    KEY_PLAYPAUSE },
+    { KEY_F6,    KEY_STOPCD },
+    { KEY_F7,    KEY_PREVIOUSSONG },
+    { KEY_F8,    KEY_NEXTSONG },
+    { KEY_F11,   RAZER_GAME_KEY },
+//     { KEY_F12,   RAZER_EFFECT_KEY }, // enable if daemon supports, see #577
+    { KEY_RIGHTALT,    RAZER_MACRO_KEY },
+
+    { KEY_PAUSE, KEY_SLEEP },
+    { 0 }
+};
+
+// Huntsman Mini Fn keys
+static const struct razer_key_translation chroma_keys_3[] = {
+    { KEY_ESC, KEY_GRAVE },
+    { KEY_1, KEY_F1 },
+    { KEY_2, KEY_F2 },
+    { KEY_3, KEY_F3 },
+    { KEY_4, KEY_F4 },
+    { KEY_5, KEY_F5 },
+    { KEY_6, KEY_F6 },
+    { KEY_7, KEY_F7 },
+    { KEY_8, KEY_F8 },
+    { KEY_9, KEY_F9 },
+    { KEY_0, KEY_F10 },
+    { KEY_MINUS, KEY_F11 },
+    { KEY_EQUAL, KEY_F12 },
+    { KEY_BACKSPACE, KEY_DELETE },
+    { KEY_TAB, KEY_MUTE },
+    { KEY_Q, KEY_VOLUMEDOWN },
+    { KEY_W, KEY_VOLUMEUP },
+    { KEY_E, KEY_PREVIOUSSONG },
+    { KEY_R, KEY_PLAYPAUSE },
+    { KEY_T, KEY_NEXTSONG },
+    { KEY_Y, RAZER_MACRO_KEY },
+    { KEY_U, RAZER_GAME_KEY },
+    { KEY_I, KEY_UP },
+    { KEY_O, KEY_SCROLLLOCK },
+    { KEY_P, KEY_SYSRQ },
+    { KEY_LEFTBRACE, KEY_PAGEUP },
+    { KEY_RIGHTBRACE, KEY_HOME },
+    { KEY_G, RAZER_BRIGHTNESS_DOWN },
+    { KEY_H, RAZER_BRIGHTNESS_UP },
+    { KEY_J, KEY_LEFT },
+    { KEY_K, KEY_DOWN },
+    { KEY_L, KEY_RIGHT },
+    { KEY_SEMICOLON, KEY_PAGEDOWN },
+    { KEY_APOSTROPHE, KEY_END },
+    { KEY_Z, KEY_SLEEP },
+    { KEY_DOT, KEY_PAUSE },
+    { KEY_SLASH, KEY_INSERT },
+    { 0 }
+};
+
+// Blackwidow V3 Mini Fn keys
+static const struct razer_key_translation chroma_keys_4[] = {
+    { KEY_ESC, KEY_GRAVE },
+    { KEY_1, KEY_F1 },
+    { KEY_2, KEY_F2 },
+    { KEY_3, KEY_F3 },
+    { KEY_4, KEY_F4 },
+    { KEY_5, KEY_F5 },
+    { KEY_6, KEY_F6 },
+    { KEY_7, KEY_F7 },
+    { KEY_8, KEY_F8 },
+    { KEY_9, KEY_F9 },
+    { KEY_0, KEY_F10 },
+    { KEY_MINUS, KEY_F11 },
+    { KEY_EQUAL, KEY_F12 },
+    { KEY_DELETE, KEY_MACRO1 },
+    { KEY_Y, RAZER_MACRO_KEY },
+    { KEY_U, RAZER_GAME_KEY },
+    { KEY_I, KEY_UP },
+    { KEY_O, KEY_SYSRQ },
+    { KEY_P, KEY_SCROLLLOCK },
+    { KEY_LEFTBRACE, KEY_PAUSE },
+    { KEY_RIGHTBRACE, KEY_SLEEP },
+    { KEY_PAGEUP, KEY_MACRO2 },
+    { KEY_G, RAZER_BRIGHTNESS_DOWN },
+    { KEY_H, RAZER_BRIGHTNESS_UP },
+    { KEY_APOSTROPHE, KEY_HOME },
+    { KEY_PAGEDOWN, KEY_MACRO3 },
+    { KEY_V, KEY_MUTE },
+    { KEY_B, KEY_VOLUMEDOWN },
+    { KEY_N, KEY_VOLUMEUP },
+    { KEY_M, KEY_PREVIOUSSONG },
+    { KEY_COMMA, KEY_PLAYPAUSE },
+    { KEY_DOT, KEY_NEXTSONG },
+    { KEY_SLASH, KEY_END },
+    { KEY_INSERT, KEY_MACRO4 },
+    { KEY_RIGHTALT, KEY_BLUETOOTH },
+    { 0 }
+};
+
+// Razer BlackWidow V3 (Full size)
+static const struct razer_key_translation chroma_keys_5[] = {
+    { KEY_F9, RAZER_MACRO_KEY },
+    { KEY_F10, RAZER_GAME_KEY },
+    { KEY_F11, RAZER_BRIGHTNESS_DOWN },
+    { KEY_F12, RAZER_BRIGHTNESS_UP },
+    { KEY_PAUSE, KEY_SLEEP },
+    // TODO - Add KEY_CONTEXT_MENU when we figure out what it is supposed to be doing
+    { 0 }
+};
+
+// Razer BlackWidow V4 75%
+static const struct razer_key_translation chroma_keys_6[] = {
+    { KEY_F9, RAZER_MACRO_KEY },
+    { KEY_F10, RAZER_GAME_KEY },
+    { KEY_F11, RAZER_BRIGHTNESS_DOWN },
+    { KEY_F12, RAZER_BRIGHTNESS_UP },
+    { KEY_P, KEY_SYSRQ },
+    { KEY_PAGEUP, KEY_HOME },
+    { KEY_PAGEDOWN, KEY_END },
+    { KEY_INSERT, KEY_PAUSE },
+    { KEY_DELETE, KEY_SLEEP },
+    { 0 }
+};
+
+// Razer DeathStalker V2 Pro TKL
+static const struct razer_key_translation chroma_keys_7[] = {
+    { KEY_F9, RAZER_MACRO_KEY },
+    { KEY_F10, RAZER_GAME_KEY },
+    { KEY_F11, RAZER_BRIGHTNESS_DOWN },
+    { KEY_F12, RAZER_BRIGHTNESS_UP },
+    { KEY_INSERT, KEY_SYSRQ },
+    { KEY_HOME, KEY_SCROLLLOCK },
+    { KEY_PAGEUP, KEY_PAUSE },
+    { KEY_PAGEDOWN, KEY_SLEEP },
+    // TODO - Add KEY_CONTEXT_MENU when we figure out what it is supposed to be doing
+    { 0 }
+};
+
+/**
+ * Essentially search through the struct array above.
+ */
+static const struct razer_key_translation *find_translation(const struct razer_key_translation *key_table, u16 from)
+{
+    const struct razer_key_translation *result;
+
+    for (result = key_table; result->from; result++) {
+        if (result->from == from) {
+            return result;
+        }
+    }
+
+    return NULL;
+}
+
+static bool is_blade_laptop(struct razer_kbd_device *device)
+{
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_2018:
+    case USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY:
+    case USB_DEVICE_ID_RAZER_BLADE_2018_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_2019_ADV:
+    case USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY:
+    case USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_QHD:
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD:
+    case USB_DEVICE_ID_RAZER_BLADE_2019_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020:
+    case USB_DEVICE_ID_RAZER_BOOK_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_17_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2024:
+    case USB_DEVICE_ID_RAZER_BLADE_15_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_16_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_18_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_18_2024:
+        return true;
+    }
+    return false;
+}
+
+/**
+ * Get request/response indices and timing parameters for the device
+ */
+static void razer_get_report_params(struct usb_device *usb_dev, uint *report_index, uint *response_index, ulong *wait_min, ulong *wait_max)
+{
+    switch (usb_dev->descriptor.idProduct) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        *report_index = 0x03;
+        *response_index = 0x03;
+        *wait_min = RAZER_BLACKWIDOW_CHROMA_WAIT_MIN_US;
+        *wait_max = RAZER_BLACKWIDOW_CHROMA_WAIT_MAX_US;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+        *report_index = 0x03;
+        *response_index = 0x03;
+        *wait_min = RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MIN_US;
+        *wait_max = RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MAX_US;
+        break;
+    case USB_DEVICE_ID_RAZER_ANANSI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+        *report_index = 0x02;
+        *response_index = 0x02;
+        *wait_min = RAZER_BLACKWIDOW_CHROMA_WAIT_MIN_US;
+        *wait_max = RAZER_BLACKWIDOW_CHROMA_WAIT_MAX_US;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+        *report_index = 0x02;
+        *response_index = 0x02;
+        *wait_min = RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MIN_US;
+        *wait_max = RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MAX_US;
+        break;
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        *report_index = 0x02;
+        *response_index = 0x02;
+        *wait_min = RAZER_DEATHSTALKER_V2_WIRELESS_WAIT_MIN_US;
+        *wait_max = RAZER_DEATHSTALKER_V2_WIRELESS_WAIT_MAX_US;
+        break;
+    default:
+        *report_index = 0x01;
+        *response_index = 0x01;
+        *wait_min = RAZER_BLACKWIDOW_CHROMA_WAIT_MIN_US;
+        *wait_max = RAZER_BLACKWIDOW_CHROMA_WAIT_MAX_US;
+        break;
+    }
+}
+
+/**
+ * Send report to the keyboard
+ */
+static int razer_get_report(struct usb_device *usb_dev, struct razer_report *request, struct razer_report *response)
+{
+    uint report_index, response_index;
+    ulong wait_min, wait_max;
+    razer_get_report_params(usb_dev, &report_index, &response_index, &wait_min, &wait_max);
+    return razer_get_usb_response(usb_dev, report_index, request, response_index, response, wait_min, wait_max);
+}
+
+/**
+ * Send report to the keyboard, but without even reading the response
+ */
+static int razer_send_payload_no_response(struct razer_kbd_device *device, struct razer_report *request)
+{
+    uint report_index, response_index;
+    ulong wait_min, wait_max;
+
+    /* Except the caller to have set the transaction_id */
+    WARN_ON(request->transaction_id.id == 0x00);
+
+    razer_get_report_params(device->usb_dev, &report_index, &response_index, &wait_min, &wait_max);
+    return razer_send_control_msg(device->usb_dev, request, report_index, wait_min, wait_max);
+}
+
+/**
+ * Function to send to device, get response, and actually check the response
+ */
+static int razer_send_payload(struct razer_kbd_device *device, struct razer_report *request, struct razer_report *response)
+{
+    int err;
+
+    request->crc = razer_calculate_crc(request);
+
+    mutex_lock(&device->lock);
+    err = razer_get_report(device->usb_dev, request, response);
+    mutex_unlock(&device->lock);
+    if (err) {
+        print_erroneous_report(response, "razerkbd", "Invalid Report Length");
+        return err;
+    }
+
+    /* Check the packet number, class and command are the same */
+    if (response->remaining_packets != request->remaining_packets ||
+        response->command_class != request->command_class ||
+        response->command_id.id != request->command_id.id) {
+        print_erroneous_report(response, "razerkbd", "Response doesn't match request");
+        return -EIO;
+    }
+
+    switch (response->status) {
+    case RAZER_CMD_BUSY:
+        // TODO: Check if this should be an error.
+        // print_erroneous_report(&response, "razermouse", "Device is busy");
+        break;
+    case RAZER_CMD_FAILURE:
+        print_erroneous_report(response, "razerkbd", "Command failed");
+        return -EIO;
+    case RAZER_CMD_NOT_SUPPORTED:
+        print_erroneous_report(response, "razerkbd", "Command not supported");
+        return -EIO;
+    case RAZER_CMD_TIMEOUT:
+        print_erroneous_report(response, "razerkbd", "Command timed out");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/**
+ * Reads the physical layout of the keyboard.
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_kbd_layout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = get_razer_report(0x00, 0x86, 0x02);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%02x\n", response.arguments[0]);
+}
+
+/**
+ * Device mode function
+ */
+static void razer_set_device_mode(struct razer_kbd_device *device, unsigned char mode, unsigned char param)
+{
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (is_blade_laptop(device)) {
+        return;
+    }
+
+    request = razer_chroma_standard_set_device_mode(mode, param);
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+        request.transaction_id.id = 0x3F;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+        request.transaction_id.id = 0x1F;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request.transaction_id.id = 0x9F;
+        break;
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+}
+
+/**
+ * Read device file "charge_level"
+ *
+ * Returns an integer which needs to be scaled from 0-255 -> 0-100
+ */
+static ssize_t razer_attr_read_charge_level(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_battery_level();
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request.transaction_id.id = 0x1f;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request.transaction_id.id = 0x9f;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        request.transaction_id.id = 0x3f;
+        break;
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Read device file "charge_status"
+ *
+ * Returns 0 when not charging, 1 when charging
+ */
+static ssize_t razer_attr_read_charge_status(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_charging_status();
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request.transaction_id.id = 0x1f;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request.transaction_id.id = 0x9f;
+        break;
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        request.transaction_id.id = 0x3f;
+        break;
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Write device file "charge_effect"
+ *
+ * Sets charging effect.
+ */
+static ssize_t razer_attr_write_charge_effect(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 1) {
+        printk(KERN_WARNING "razerkbd: Incorrect number of bytes for setting the charging effect\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_misc_set_dock_charge_type(buf[0]);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "charge_colour"
+ *
+ * Sets charging colour using 3 RGB bytes
+ */
+static ssize_t razer_attr_write_charge_colour(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    // First enable static charging effect
+    request = razer_chroma_misc_set_dock_charge_type(0x01);
+    request.transaction_id.id = 0xFF;
+    razer_send_payload(device, &request, &response);
+
+    if (count != 3) {
+        printk(KERN_WARNING "razerkbd: Charging colour mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_standard_set_led_rgb(NOSTORE, BATTERY_LED, (struct razer_rgb*)&buf[0]);
+    request.transaction_id.id = 0xFF;
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "charge_low_threshold"
+ */
+static ssize_t razer_attr_read_charge_low_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_low_battery_threshold();
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[0]);
+}
+
+/**
+ * Write device file "charge_low_threshold"
+ *
+ * Sets the low battery blink threshold to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_charge_low_threshold(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char threshold = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_set_low_battery_threshold(threshold);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+    return count;
+}
+
+/**
+ * Write device file "game_led_state"
+ *
+ * When 1 is written (as a character, 0x31) Game mode will be enabled, if 0 is written (0x30)
+ * then game mode will be disabled
+ *
+ * The reason the keyboard appears as 2 keyboard devices is that one of those devices is used by
+ * game mode as that keyboard device is missing a super key. A hacky and over-the-top way to disable
+ * the super key if you ask me.
+ */
+static ssize_t razer_attr_write_game_led_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        request = razer_chroma_standard_set_led_state(NOSTORE, GAME_LED, enabled);
+        request.transaction_id.id = 0x1f;
+        break;
+    default:
+        request = razer_chroma_standard_set_led_state(VARSTORE, GAME_LED, enabled);
+        request.transaction_id.id = 0xFF;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "game_led_state"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_game_led_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        request = razer_chroma_standard_get_led_state(NOSTORE, GAME_LED);
+        request.transaction_id.id = 0x1f;
+        break;
+    default:
+        request = razer_chroma_standard_get_led_state(VARSTORE, GAME_LED);
+        request.transaction_id.id = 0xFF;
+    }
+
+    razer_send_payload(device, &request, &response);
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Write device file "keyswitch_optimization"
+ */
+static ssize_t razer_attr_write_keyswitch_optimization(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char mode = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    // Toggle Keyswitch Optimization
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        request = razer_chroma_misc_set_keyswitch_optimization_command1(mode);
+        request.transaction_id.id = 0x1f;
+        razer_send_payload(device, &request, &response);
+        request = razer_chroma_misc_set_keyswitch_optimization_command2(mode);
+        request.transaction_id.id = 0x1f;
+        razer_send_payload(device, &request, &response);
+        break;
+    default:
+        return -ENOSYS;
+    }
+
+    return count;
+}
+
+/**
+ * Read device file "keyswitch_optimization"
+ */
+static ssize_t razer_attr_read_keyswitch_optimization(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    int state;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        request = razer_chroma_misc_get_keyswitch_optimization();
+        request.transaction_id.id = 0x1f;
+        break;
+    default:
+        request = razer_chroma_misc_get_keyswitch_optimization();
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    if(response.arguments[1] == 0x14) { // Either 0x00 or 0x14
+        state = 0; // Typing
+    } else {
+        state = 1; // Gaming
+    }
+
+    return sprintf(buf, "%d\n", state);
+}
+
+/**
+ * Write device file "macro_led_state"
+ *
+ * When 1 is written (as a character, 0x31) Macro mode will be enabled, if 0 is written (0x30)
+ * then game mode will be disabled
+ */
+static ssize_t razer_attr_write_macro_led_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_set_led_state(VARSTORE, MACRO_LED, enabled);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "macro_led_state"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_macro_led_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_led_state(VARSTORE, MACRO_LED);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Read device file "version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", DRIVER_VERSION);
+}
+
+/**
+ * Read device file "device_type"
+ *
+ * Returns friendly string of device type
+ */
+static ssize_t razer_attr_read_device_type(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    char *device_type;
+
+    switch (device->usb_pid) {
+
+    case USB_DEVICE_ID_RAZER_NOSTROMO:
+        device_type = "Razer Nostromo\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORBWEAVER:
+        device_type = "Razer Orbweaver\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+        device_type = "Razer Orbweaver Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+        device_type = "Razer BlackWidow Stealth\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+        device_type = "Razer BlackWidow Stealth Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+        device_type = "Razer BlackWidow Ultimate 2012\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+        device_type = "Razer BlackWidow Ultimate 2013\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016:
+        device_type = "Razer BlackWidow Ultimate 2016\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE:
+        device_type = "Razer BlackWidow X Ultimate\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        device_type = "Razer BlackWidow Tournament Edition 2014\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH:
+        device_type = "Razer Blade Stealth\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019:
+        device_type = "Razer Blade Stealth (Late 2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020:
+        device_type = "Razer Blade Stealth (Early 2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020:
+        device_type = "Razer Blade Stealth (Late 2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BOOK_2020:
+        device_type = "Razer Book 13 (2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+        device_type = "Razer Blade Stealth (Late 2016)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017:
+        device_type = "Razer Blade Stealth (Mid 2017)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_QHD:
+        device_type = "Razer Blade Stealth (QHD)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+        device_type = "Razer Blade Pro (Late 2016)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_2018:
+        device_type = "Razer Blade 15 (2018)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY:
+        device_type = "Razer Blade 15 (2018) Mercury\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_2018_BASE:
+        device_type = "Razer Blade 15 (2018) Base Model\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_2019_ADV:
+        device_type = "Razer Blade 15 (2019) Advanced\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_2019_BASE:
+        device_type = "Razer Blade 15 (2019) Base Model\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE:
+        device_type = "Razer Blade 15 Base (Early 2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE:
+        device_type = "Razer Blade 15 Base (Late 2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY:
+        device_type = "Razer Blade 15 (Mid 2019) Mercury White\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019:
+        device_type = "Razer Blade 15 Studio Edition (2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+        device_type = "Razer Blade (Late 2016)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017:
+        device_type = "Razer Blade Pro (2017)\n";
+        break;
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD:
+        device_type = "Razer Blade Pro FullHD (2017)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2019:
+        device_type = "Razer Blade Pro (2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019:
+        device_type = "Razer Blade Pro (Late 2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019:
+        device_type = "Razer Blade Advanced (Late 2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020:
+        device_type = "Razer Blade Pro (Early 2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+        device_type = "Razer Blade Stealth (Late 2017)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019:
+        device_type = "Razer Blade Stealth (2019)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020:
+        device_type = "Razer Blade 15 Advanced (2020)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021:
+        device_type = "Razer Blade 15 Advanced (Early 2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021:
+        device_type = "Razer Blade 15 Advanced (Mid 2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021:
+        device_type = "Razer Blade 15 Base (Early 2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+        device_type = "Razer Blade 15 Base (2022)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+        device_type = "Razer Blade 17 Pro (Early 2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021:
+        device_type = "Razer Blade 17 Pro (Mid 2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_14_2021:
+        device_type = "Razer Blade 14 (2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS:
+        device_type = "Razer Tartarus\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        device_type = "Razer Tartarus Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        device_type = "Razer Tartarus V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH:
+        device_type = "Razer BlackWidow Chroma (Overwatch)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA:
+        device_type = "Razer BlackWidow Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL:
+        device_type = "Razer Deathstalker (Essential)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT:
+        device_type = "Razer Deathstalker Expert\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA:
+        device_type = "Razer DeathStalker Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE:
+        device_type = "Razer BlackWidow Chroma Tournament Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA:
+        device_type = "Razer BlackWidow X Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE:
+        device_type = "Razer BlackWidow X Chroma Tournament Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+        device_type = "Razer BlackWidow Lite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+        device_type = "Razer BlackWidow 2019\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+        device_type = "Razer BlackWidow Essential\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA:
+        device_type = "Razer Ornata\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+        device_type = "Razer Ornata Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+        device_type = "Razer Ornata V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+        device_type = "Razer Ornata V3\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+        device_type = "Razer Ornata V3 X\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+        device_type = "Razer Ornata V3 Tenkeyless\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+        device_type = "Razer Huntsman Elite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+        device_type = "Razer Huntsman Tournament Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+        device_type = "Razer BlackWidow Elite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+        device_type = "Razer Huntsman\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+        device_type = "Razer Cynosa Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+        device_type = "Razer Cynosa Chroma Pro\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+        device_type = "Razer Cynosa Lite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        device_type = "Razer BlackWidow Chroma V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ANANSI:
+        device_type = "Razer Anansi\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+        device_type = "Razer Cynosa V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+        device_type = "Razer Huntsman Mini\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+        device_type = "Razer Huntsman Mini (JP)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+        device_type = "Razer BlackWidow V3\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        device_type = "Razer BlackWidow V3 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+        device_type = "Razer BlackWidow V3 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+        device_type = "Razer BlackWidow V3 Tenkeyless\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+        device_type = "Razer Huntsman V2 Tenkeyless\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        device_type = "Razer Huntsman V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+        device_type = "Razer Huntsman V2 Analog\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+        device_type = "Razer Huntsman Mini Analog\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+        device_type = "Razer BlackWidow V3 Mini Hyperspeed (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+        device_type = "Razer BlackWidow V3 Mini Hyperspeed (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_17_2022:
+        device_type = "Razer Blade 17 (2022)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_14_2022:
+        device_type = "Razer Blade 14 (2022)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022:
+        device_type = "Razer Blade 15 Advanced (Early 2022)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_14_2023:
+        device_type = "Razer Blade 14 (2023)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_14_2024:
+        device_type = "Razer Blade 14 (2024)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_15_2023:
+        device_type = "Razer Blade 15 (2023)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+        device_type = "Razer DeathStalker V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+        device_type = "Razer DeathStalker V2 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+        device_type = "Razer DeathStalker V2 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+        device_type = "Razer BlackWidow V4\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+        device_type = "Razer BlackWidow V4 X\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+        device_type = "Razer BlackWidow V4 Pro\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        device_type = "Razer BlackWidow V4 75%\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        device_type = "Razer DeathStalker V2 Pro TKL (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        device_type = "Razer DeathStalker V2 Pro TKL (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_16_2023:
+        device_type = "Razer Blade 16 (2023)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_18_2023:
+        device_type = "Razer Blade 18 (2023)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        device_type = "Razer Huntsman V3 Pro\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_18_2024:
+        device_type = "Razer Blade 18 (2024)\n";
+        break;
+
+    default:
+        device_type = "Unknown Device\n";
+    }
+
+    return sprintf(buf, device_type);
+}
+
+/**
+ * Write device file "macro_led_effect"
+ *
+ * When 1 is written the LED will blink, 0 will static
+ */
+static ssize_t razer_attr_write_macro_led_effect(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+        request = razer_chroma_standard_set_led_effect(NOSTORE, MACRO_LED, enabled);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+        request = razer_chroma_standard_set_led_effect(NOSTORE, MACRO_LED, enabled);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_ANANSI:
+        request = razer_chroma_standard_set_led_effect(NOSTORE, MACRO_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_blinking(NOSTORE, MACRO_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        request = razer_chroma_standard_set_led_effect(VARSTORE, MACRO_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "macro_led_effect"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_macro_led_effect(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_led_effect(VARSTORE, MACRO_LED);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Write device file "matrix_effect_pulsate"
+ *
+ * The brightness oscillates between fully on and fully off generating a pulsing effect
+ */
+static ssize_t razer_attr_write_matrix_effect_pulsate(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        request = razer_chroma_standard_set_led_effect(VARSTORE, LOGO_LED, CLASSIC_EFFECT_BREATHING);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        request = razer_chroma_standard_set_led_effect(VARSTORE, BACKLIGHT_LED, CLASSIC_EFFECT_BREATHING);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "matrix_effect_pulsate"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_matrix_effect_pulsate(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_led_effect(VARSTORE, LOGO_LED);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Read device file "profile_led_red"
+ *
+ * Actually a Yellow LED
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_profile_led_red(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_get_led_state(VARSTORE, BLUE_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_get_led_state(VARSTORE, RED_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Read device file "profile_led_green"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_profile_led_green(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_get_led_state(VARSTORE, RED_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_get_led_state(VARSTORE, GREEN_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Read device file "profile_led_blue"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_profile_led_blue(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_get_led_state(VARSTORE, GREEN_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_get_led_state(VARSTORE, BLUE_PROFILE_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Write device file "profile_led_red"
+ */
+static ssize_t razer_attr_write_profile_led_red(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_set_led_state(VARSTORE, BLUE_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_set_led_state(VARSTORE, RED_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "profile_led_green"
+ */
+static ssize_t razer_attr_write_profile_led_green(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_set_led_state(VARSTORE, RED_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_set_led_state(VARSTORE, GREEN_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+    return count;
+}
+
+/**
+ * Write device file "profile_led_blue"
+ */
+static ssize_t razer_attr_write_profile_led_blue(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+        request = razer_chroma_standard_set_led_state(VARSTORE, GREEN_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    default:
+        request = razer_chroma_standard_set_led_state(VARSTORE, BLUE_PROFILE_LED, enabled);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+    return count;
+}
+
+/**
+ * Read device file "device_serial"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_serial(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    char serial_string[51];
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    /* For Blade laptops we get the serial number from DMI */
+    if (is_blade_laptop(device)) {
+        strncpy(&serial_string[0], dmi_get_system_info(DMI_PRODUCT_SERIAL), 50);
+        goto exit;
+    }
+
+    request = razer_chroma_standard_get_serial();
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    strncpy(&serial_string[0], &response.arguments[0], 22);
+    serial_string[22] = '\0';
+
+exit:
+    return sprintf(buf, "%s\n", &serial_string[0]);
+}
+
+/**
+ * Read device file "firmware_version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_firmware_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_firmware_version();
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "v%d.%d\n", response.arguments[0], response.arguments[1]);
+}
+
+/**
+ * Write device file "matrix_effect_none"
+ *
+ * No keyboard effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_ANANSI:
+        request = razer_chroma_standard_set_led_state(VARSTORE, BACKLIGHT_LED, OFF);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        request = razer_chroma_standard_matrix_effect_none();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        request = razer_chroma_standard_matrix_effect_none();
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_wave"
+ *
+ * When 1 is written (as a character, 0x31) the wave effect is displayed moving left across the keyboard
+ * if 2 is written (0x32) then the wave effect goes right
+ *
+ * For the extended its 0x00 and 0x01
+ */
+static ssize_t razer_attr_write_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, BACKLIGHT_LED, direction);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        request = razer_chroma_standard_matrix_effect_wave(direction);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+        // Direction values are flipped compared to other devices
+        direction ^= ((1<<0) | (1<<1));
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, BACKLIGHT_LED, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, BACKLIGHT_LED, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, BACKLIGHT_LED, direction);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    default:
+        request = razer_chroma_standard_matrix_effect_wave(direction);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_wheel"
+ *
+ * When 1 is written (as a character, 0x31) the wheel effect is turning right
+ * if 2 is written (0x32) then the wheel effect goes left.
+ */
+static ssize_t razer_attr_write_matrix_effect_wheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        request = razer_chroma_extended_matrix_effect_wheel(VARSTORE, BACKLIGHT_LED, direction);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razerkbd: matrix_effect_wheel not supported for this model\n");
+        return -EINVAL;
+    }
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_spectrum"
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_ANANSI:
+        request = razer_chroma_standard_set_led_state(VARSTORE, BACKLIGHT_LED, ON);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        request = razer_chroma_standard_set_led_effect(VARSTORE, BACKLIGHT_LED, CLASSIC_EFFECT_SPECTRUM);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        request = razer_chroma_standard_matrix_effect_spectrum();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        request = razer_chroma_standard_matrix_effect_spectrum();
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_reactive"
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char speed;
+
+    if (count != 4) {
+        printk(KERN_WARNING "razerkbd: Reactive only accepts Speed, RGB (4byte)\n");
+        return -EINVAL;
+    }
+
+    speed = (unsigned char)buf[0];
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, BACKLIGHT_LED, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, BACKLIGHT_LED, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, BACKLIGHT_LED, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        request = razer_chroma_standard_matrix_effect_reactive(speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        break;
+    default:
+        request = razer_chroma_standard_matrix_effect_reactive(speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_static"
+ *
+ * Set the keyboard to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORBWEAVER:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT:
+        request = razer_chroma_standard_set_led_effect(VARSTORE, BACKLIGHT_LED, CLASSIC_EFFECT_STATIC);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013: // Doesn't need any parameters as can only do one type of static
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        request = razer_chroma_standard_set_led_effect(VARSTORE, LOGO_LED, CLASSIC_EFFECT_STATIC);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020:
+    case USB_DEVICE_ID_RAZER_BOOK_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_QHD:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_2018:
+    case USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY:
+    case USB_DEVICE_ID_RAZER_BLADE_2018_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_2019_ADV:
+    case USB_DEVICE_ID_RAZER_BLADE_2019_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE:
+    case USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY:
+    case USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2021:
+    case USB_DEVICE_ID_RAZER_TARTARUS:
+    case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+    case USB_DEVICE_ID_RAZER_BLADE_17_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_15_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_16_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_18_2023:
+    case USB_DEVICE_ID_RAZER_BLADE_14_2024:
+    case USB_DEVICE_ID_RAZER_BLADE_18_2024:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_standard_matrix_effect_static((struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_standard_matrix_effect_static((struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x1F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x9F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_ANANSI:
+        if (count != 3) {
+            printk(KERN_WARNING "razerkbd: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_standard_set_led_state(VARSTORE, BACKLIGHT_LED, ON);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        request = razer_chroma_standard_set_led_effect(VARSTORE, BACKLIGHT_LED, CLASSIC_EFFECT_STATIC);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        request = razer_chroma_standard_set_led_rgb(VARSTORE, BACKLIGHT_LED, (struct razer_rgb *) &buf[0]);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    default:
+        printk(KERN_WARNING "razerkbd: Cannot set static mode for this device\n");
+        return -EINVAL;
+    }
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_starlight"
+ *
+ * Starlight keyboard effect is activated whenever this file is written to (for bw2016)
+ *
+ * Or if an Ornata
+ * 7 bytes, speed, rgb, rgb
+ * 4 bytes, speed, rgb
+ * 1 byte, speed
+ */
+static ssize_t razer_attr_write_matrix_effect_starlight(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_rgb rgb1 = {.r = 0x00, .g = 0xFF, .b = 0x00};
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORNATA:
+        if (count != 4) {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        if(count == 7) {
+            request = razer_chroma_extended_matrix_effect_starlight_dual(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 4) {
+            request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 1) {
+            request = razer_chroma_extended_matrix_effect_starlight_random(VARSTORE, BACKLIGHT_LED, buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        if (count == 7) {
+            request = razer_chroma_extended_matrix_effect_starlight_dual(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+        } else if(count == 4) {
+            request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1]);
+        } else if(count == 1) {
+            request = razer_chroma_extended_matrix_effect_starlight_random(VARSTORE, BACKLIGHT_LED, buf[0]);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        request.transaction_id.id = 0x1F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        if (count == 7) {
+            request = razer_chroma_extended_matrix_effect_starlight_dual(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+        } else if(count == 4) {
+            request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1]);
+        } else if(count == 1) {
+            request = razer_chroma_extended_matrix_effect_starlight_random(VARSTORE, BACKLIGHT_LED, buf[0]);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        request.transaction_id.id = 0x9F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        if(count == 7) {
+            request = razer_chroma_extended_matrix_effect_starlight_dual(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+            request.transaction_id.id = 0x1F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 4) {
+            request = razer_chroma_extended_matrix_effect_starlight_single(VARSTORE, BACKLIGHT_LED, buf[0], (struct razer_rgb*)&buf[1]);
+            request.transaction_id.id = 0x1F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 1) {
+            request = razer_chroma_extended_matrix_effect_starlight_random(VARSTORE, BACKLIGHT_LED, buf[0]);
+            request.transaction_id.id = 0x1F;
+            razer_send_payload(device, &request, &response);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+    case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+        if(count == 7) {
+            request = razer_chroma_standard_matrix_effect_starlight_dual(buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 4) {
+            request = razer_chroma_standard_matrix_effect_starlight_single(buf[0], (struct razer_rgb*)&buf[1]);
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 1) {
+            request = razer_chroma_standard_matrix_effect_starlight_random(buf[0]);
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        if(count == 7) {
+            request = razer_chroma_standard_matrix_effect_starlight_dual(buf[0], (struct razer_rgb*)&buf[1], (struct razer_rgb*)&buf[4]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 4) {
+            request = razer_chroma_standard_matrix_effect_starlight_single(buf[0], (struct razer_rgb*)&buf[1]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else if(count == 1) {
+            request = razer_chroma_standard_matrix_effect_starlight_random(buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+        } else {
+            printk(KERN_WARNING "razerkbd: Starlight only accepts Speed (1byte). Speed, RGB (4byte). Speed, RGB, RGB (7byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    default: // BW2016 can do normal starlight
+        request = razer_chroma_standard_matrix_effect_starlight_single(0x01, &rgb1);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+    }
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_breath"
+ */
+static ssize_t razer_attr_write_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        default:
+            printk(KERN_WARNING "razerkbd: Breathing only accepts '1' (1byte). RGB (3byte). RGB, RGB (6byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        case 1: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, BACKLIGHT_LED);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        default:
+            printk(KERN_WARNING "razerkbd: Breathing only accepts '1' (1byte). RGB (3byte). RGB, RGB (6byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        case 1: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, BACKLIGHT_LED);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        default:
+            printk(KERN_WARNING "razerkbd: Breathing only accepts '1' (1byte). RGB (3byte). RGB, RGB (6byte)\n");
+            return -EINVAL;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        if (count == 3) { // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+        } else if (count == 6) { // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+        } else if (count == 1) { // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, BACKLIGHT_LED);
+        } else {
+            printk(KERN_WARNING "razerkbd: Breathing only accepts '1' (1byte). RGB (3byte). RGB, RGB (6byte)\n");
+            return -EINVAL;
+        }
+        request.transaction_id.id = 0x1F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        if (count == 3) { // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+        } else if (count == 6) { // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+        } else if (count == 1) { // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, BACKLIGHT_LED);
+        } else {
+            printk(KERN_WARNING "razerkbd: Breathing only accepts '1' (1byte). RGB (3byte). RGB, RGB (6byte)\n");
+            return -EINVAL;
+        }
+        request.transaction_id.id = 0x9F;
+        razer_send_payload(device, &request, &response);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_single((struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_dual((struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_random();
+            request.transaction_id.id = 0x3F;
+            razer_send_payload(device, &request, &response);
+            break;
+            // TODO move default to case 1:. Then default: printk(warning). Also remove pointless buffer
+        }
+        break;
+
+    default:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_single((struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_dual((struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_random();
+            request.transaction_id.id = 0xFF;
+            razer_send_payload(device, &request, &response);
+            break;
+            // TODO move default to case 1:. Then default: printk(warning). Also remove pointless buffer
+        }
+        break;
+    }
+
+    return count;
+}
+
+static int has_inverted_led_state(struct device *dev)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+    case USB_DEVICE_ID_RAZER_BLADE_QHD:
+    case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+        return 1;
+    default:
+        return 0;
+    }
+}
+
+/**
+ * Reads device file "logo_led_state"
+ *
+ * Reads the logo lighting state (the ASCII number) written to this file.
+ */
+static ssize_t razer_attr_read_logo_led_state(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    int state;
+
+    request = razer_chroma_standard_get_led_effect(VARSTORE, LOGO_LED);
+    request.transaction_id.id = 0xFF;
+
+    // Blade laptops don't use effect for logo on/off, and mode 2 ("blink") is technically unsupported.
+    if (is_blade_laptop(device)) {
+        request = razer_chroma_standard_get_led_state(VARSTORE, LOGO_LED);
+        request.transaction_id.id = 0xFF;
+    }
+
+    razer_send_payload(device, &request, &response);
+    state = response.arguments[2];
+
+    if (has_inverted_led_state(dev) && (state == 0 || state == 1))
+        state = !state;
+
+    return sprintf(buf, "%d\n", state);
+}
+
+/**
+ * Write device file "logo_led_state"
+ *
+ * Sets the logo lighting state to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_logo_led_state(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char state = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (has_inverted_led_state(dev) && (state == 0 || state == 1))
+        state = !state;
+
+    // Blade laptops are... different. They use state instead of effect.
+    // Note: This does allow setting of mode 2 ("blink"), but this is an undocumented feature.
+    if (is_blade_laptop(device) && (state == 0 || state == 1)) {
+        request = razer_chroma_standard_set_led_state(VARSTORE, LOGO_LED, state);
+        request.transaction_id.id = 0xFF;
+    } else {
+        request = razer_chroma_standard_set_led_effect(VARSTORE, LOGO_LED, state);
+        request.transaction_id.id = 0xFF;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_effect_custom"
+ *
+ * Sets the keyboard to custom mode whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_custom(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    bool want_response = true;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x1F;
+        want_response = false;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+    case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    /* See comment in razer_attr_write_matrix_custom_frame for want_response */
+    if (want_response)
+        razer_send_payload(device, &request, &response);
+    else
+        razer_send_payload_no_response(device, &request);
+
+    return count;
+}
+
+/**
+ * Write device file "fn_toggle"
+ *
+ * Sets the logo lighting state to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_fn_toggle(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char state = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_fn_key_toggle(state);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "test"
+ *
+ * Does nothing
+ */
+static ssize_t razer_attr_write_test(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;
+}
+
+/**
+ * Read device file "test"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_test(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = get_razer_report(0x00, 0x86, 0x02);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    print_erroneous_report(&response, "razerkbd", "Test");
+    return sprintf(buf, "%02x%02x%02x\n", response.arguments[0], response.arguments[1], response.arguments[2]);
+}
+
+/**
+ * Write device file "matrix_brightness"
+ *
+ * Sets the brightness to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_matrix_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        request = razer_chroma_standard_set_led_brightness(VARSTORE, LOGO_LED, brightness);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOSTROMO:
+    default:
+        if (is_blade_laptop(device)) {
+            request = razer_chroma_misc_set_blade_brightness(brightness);
+        } else {
+            request = razer_chroma_standard_set_led_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        }
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "matrix_brightness"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_matrix_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = 0;
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+
+    case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+    case USB_DEVICE_ID_RAZER_ORNATA:
+    case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+    case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+    case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x9F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, LOGO_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NOSTROMO:
+    default:
+        if (is_blade_laptop(device)) {
+            request = razer_chroma_misc_get_blade_brightness();
+        } else {
+            request = razer_chroma_standard_get_led_brightness(VARSTORE, BACKLIGHT_LED);
+        }
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    // Brightness is stored elsewhere for the stealth cmds
+    if (is_blade_laptop(device)) {
+        brightness = response.arguments[1];
+    } else {
+        brightness = response.arguments[2];
+    }
+
+    return sprintf(buf, "%d\n", brightness);
+}
+
+/**
+ * Write device file "device_mode"
+ */
+static ssize_t razer_attr_write_device_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 2) {
+        printk(KERN_WARNING "razerkbd: Device mode only takes 2 bytes.\n");
+        return -EINVAL;
+    }
+
+    // No-op on Blades
+    if (is_blade_laptop(device)) {
+        return count;
+    }
+
+    request = razer_chroma_standard_set_device_mode(buf[0], buf[1]);
+    request.transaction_id.id = 0xFF;
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "device_mode"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_device_mode();
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    buf[0] = response.arguments[0];
+    buf[1] = response.arguments[1];
+
+    return 2;
+}
+
+/**
+ * Write device file "matrix_custom_frame"
+ *
+ * Format
+ * ROW_ID START_COL STOP_COL RGB...
+ */
+static ssize_t razer_attr_write_matrix_custom_frame(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    size_t offset = 0;
+    unsigned char row_id, start_col, stop_col;
+    size_t row_length;
+    bool want_response = true;
+
+    while(offset < count) {
+        if(offset + 3 > count) {
+            printk(KERN_ALERT "razerkbd: Wrong Amount of data provided: Should be ROW_ID, START_COL, STOP_COL, N_RGB\n");
+            return -EINVAL;
+        }
+
+        row_id = buf[offset++];
+        start_col = buf[offset++];
+        stop_col = buf[offset++];
+
+        // Validate parameters
+        if(start_col > stop_col) {
+            printk(KERN_ALERT "razerkbd: Start column (%u) is greater than end column (%u)\n", start_col, stop_col);
+            return -EINVAL;
+        }
+
+        row_length = ((stop_col + 1) - start_col) * 3;
+
+        // Make sure we actually got the data that was promised to us
+        if(count < offset + row_length) {
+            printk(KERN_ALERT "razerkbd: Not enough RGB to fill row (expecting %lu bytes of RGB data, got %lu)\n", row_length, (count - 3));
+            return -EINVAL;
+        }
+
+        // printk(KERN_INFO "razerkbd: Row ID: %u, Start: %u, Stop: %u, row length: %lu\n", row_id, start_col, stop_col, row_length);
+
+        // Offset now at beginning of RGB data
+
+        switch (device->usb_pid) {
+        case USB_DEVICE_ID_RAZER_ORNATA:
+        case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x3F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+        case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+        case USB_DEVICE_ID_RAZER_ORNATA_V2:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x1F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x1F;
+            want_response = false;
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x9F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA:
+            request = razer_chroma_misc_one_row_set_custom_frame(start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0xFF;
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+            request = razer_chroma_standard_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x3F;
+            break;
+
+        default:
+            request = razer_chroma_standard_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0xFF;
+            break;
+        }
+
+        /*
+         * Some devices don't like us asking for responses for custom frame
+         * requests. And in any case it shouldn't be necessary for most devices
+         * but let's keep it enabled by default for now to not potentially
+         * break anything.
+         */
+        if (want_response)
+            razer_send_payload(device, &request, &response);
+        else
+            razer_send_payload_no_response(device, &request);
+
+        // *3 as its 3 bytes per col (RGB)
+        offset += row_length;
+    }
+
+    return count;
+}
+
+/**
+ * Read device file "poll_rate"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_poll_rate(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short polling_rate = 0;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        request = razer_chroma_misc_get_polling_rate2();
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request = razer_chroma_misc_get_polling_rate();
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    switch(response.arguments[1]) {
+    case 0x01:
+        polling_rate = 8000;
+        break;
+    case 0x02:
+        polling_rate = 4000;
+        break;
+    case 0x04:
+        polling_rate = 2000;
+        break;
+    case 0x08:
+        polling_rate = 1000;
+        break;
+    case 0x10:
+        polling_rate = 500;
+        break;
+    case 0x20:
+        polling_rate = 250;
+        break;
+    case 0x40:
+        polling_rate = 125;
+        break;
+    }
+
+    return sprintf(buf, "%d\n", polling_rate);
+}
+
+/**
+ * Write device file "poll_rate"
+ *
+ * Sets the poll rate
+ */
+static ssize_t razer_attr_write_poll_rate(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+    unsigned short polling_rate = (unsigned short)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        request = razer_chroma_misc_set_polling_rate2(polling_rate, 0x00);
+        request.transaction_id.id = 0x1f;
+        break;
+    default:
+        request = razer_chroma_misc_set_polling_rate(polling_rate);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "key_super"
+ */
+static ssize_t razer_attr_write_key_super(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    if (count < 1) {
+        printk(KERN_ALERT "razerkbd: Failed to provide argument\n");
+        return -EINVAL;
+    }
+
+    device->block_keys[0] = buf[0];
+
+    return count;
+}
+
+/**
+ * Read device file "key_super"
+ */
+static ssize_t razer_attr_read_key_super(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    buf[0] = device->block_keys[0];
+
+    return 1;
+}
+
+/**
+ * Write device file "key_alt_tab"
+ */
+static ssize_t razer_attr_write_key_alt_tab(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    if (count < 1) {
+        printk(KERN_ALERT "razerkbd: Failed to provide argument\n");
+        return -EINVAL;
+    }
+
+    printk(KERN_WARNING "razerkbd: Settings block_keys[1] to %u\n", buf[0]);
+    device->block_keys[1] = buf[0];
+
+    return count;
+}
+
+/**
+ * Read device file "read_key_alt_tab"
+ */
+static ssize_t razer_attr_read_key_alt_tab(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    buf[0] = device->block_keys[1];
+
+    return 1;
+}
+
+/**
+ * Write device file "write_key_alt_f4"
+ */
+static ssize_t razer_attr_write_key_alt_f4(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    if (count < 1) {
+        printk(KERN_ALERT "razerkbd: Failed to provide argument\n");
+        return -EINVAL;
+    }
+
+    device->block_keys[2] = buf[0];
+
+    return count;
+}
+
+/**
+ * Read device file "read_key_alt_f4"
+ */
+static ssize_t razer_attr_read_key_alt_f4(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kbd_device *device = dev_get_drvdata(dev);
+
+    buf[0] = device->block_keys[2];
+
+    return 1;
+}
+
+/**
+ * Set up the device driver files
+
+ *
+ * Read only is 0444
+ * Write only is 0220
+ * Read and write is 0664
+ */
+static DEVICE_ATTR(game_led_state,          0660, razer_attr_read_game_led_state,             razer_attr_write_game_led_state);
+static DEVICE_ATTR(macro_led_state,         0660, razer_attr_read_macro_led_state,            razer_attr_write_macro_led_state);
+static DEVICE_ATTR(macro_led_effect,        0660, razer_attr_read_macro_led_effect,           razer_attr_write_macro_led_effect);
+static DEVICE_ATTR(logo_led_state,          0660, razer_attr_read_logo_led_state,             razer_attr_write_logo_led_state);
+static DEVICE_ATTR(profile_led_red,         0660, razer_attr_read_profile_led_red,            razer_attr_write_profile_led_red);
+static DEVICE_ATTR(profile_led_green,       0660, razer_attr_read_profile_led_green,          razer_attr_write_profile_led_green);
+static DEVICE_ATTR(profile_led_blue,        0660, razer_attr_read_profile_led_blue,           razer_attr_write_profile_led_blue);
+
+static DEVICE_ATTR(test,                    0660, razer_attr_read_test,                       razer_attr_write_test);
+static DEVICE_ATTR(version,                 0440, razer_attr_read_version,                    NULL);
+static DEVICE_ATTR(kbd_layout,              0440, razer_attr_read_kbd_layout,                 NULL);
+
+static DEVICE_ATTR(firmware_version,        0440, razer_attr_read_firmware_version,           NULL);
+static DEVICE_ATTR(fn_toggle,               0220, NULL,                                       razer_attr_write_fn_toggle);
+static DEVICE_ATTR(poll_rate,               0660, razer_attr_read_poll_rate,                  razer_attr_write_poll_rate);
+static DEVICE_ATTR(keyswitch_optimization,  0660, razer_attr_read_keyswitch_optimization,     razer_attr_write_keyswitch_optimization);
+
+static DEVICE_ATTR(device_type,             0440, razer_attr_read_device_type,                NULL);
+static DEVICE_ATTR(device_mode,             0660, razer_attr_read_device_mode,                razer_attr_write_device_mode);
+static DEVICE_ATTR(device_serial,           0440, razer_attr_read_device_serial,              NULL);
+
+static DEVICE_ATTR(matrix_effect_none,      0220, NULL,                                       razer_attr_write_matrix_effect_none);
+static DEVICE_ATTR(matrix_effect_wave,      0220, NULL,                                       razer_attr_write_matrix_effect_wave);
+static DEVICE_ATTR(matrix_effect_wheel,     0220, NULL,                                       razer_attr_write_matrix_effect_wheel);
+static DEVICE_ATTR(matrix_effect_spectrum,  0220, NULL,                                       razer_attr_write_matrix_effect_spectrum);
+static DEVICE_ATTR(matrix_effect_reactive,  0220, NULL,                                       razer_attr_write_matrix_effect_reactive);
+static DEVICE_ATTR(matrix_effect_static,    0220, NULL,                                       razer_attr_write_matrix_effect_static);
+static DEVICE_ATTR(matrix_effect_starlight, 0220, NULL,                                       razer_attr_write_matrix_effect_starlight);
+static DEVICE_ATTR(matrix_effect_breath,    0220, NULL,                                       razer_attr_write_matrix_effect_breath);
+static DEVICE_ATTR(matrix_effect_pulsate,   0660, razer_attr_read_matrix_effect_pulsate,      razer_attr_write_matrix_effect_pulsate);
+static DEVICE_ATTR(matrix_brightness,       0660, razer_attr_read_matrix_brightness,          razer_attr_write_matrix_brightness);
+static DEVICE_ATTR(matrix_effect_custom,    0220, NULL,                                       razer_attr_write_matrix_effect_custom);
+static DEVICE_ATTR(matrix_custom_frame,     0220, NULL,                                       razer_attr_write_matrix_custom_frame);
+
+static DEVICE_ATTR(key_super,               0660, razer_attr_read_key_super,                  razer_attr_write_key_super);
+static DEVICE_ATTR(key_alt_tab,             0660, razer_attr_read_key_alt_tab,                razer_attr_write_key_alt_tab);
+static DEVICE_ATTR(key_alt_f4,              0660, razer_attr_read_key_alt_f4,                 razer_attr_write_key_alt_f4);
+
+static DEVICE_ATTR(charge_level,            0440, razer_attr_read_charge_level,               NULL);
+static DEVICE_ATTR(charge_status,           0440, razer_attr_read_charge_status,              NULL);
+static DEVICE_ATTR(charge_effect,           0220, NULL,                                       razer_attr_write_charge_effect);
+static DEVICE_ATTR(charge_colour,           0220, NULL,                                       razer_attr_write_charge_colour);
+static DEVICE_ATTR(charge_low_threshold,    0660, razer_attr_read_charge_low_threshold,       razer_attr_write_charge_low_threshold);
+
+/**
+ * Deal with FN toggle
+ */
+static int razer_event(struct hid_device *hdev, struct hid_field *field, struct hid_usage *usage, __s32 value)
+{
+    struct razer_kbd_device *device = hid_get_drvdata(hdev);
+    const struct razer_key_translation *translation;
+
+    // No translations needed on the Blades
+    if (is_blade_laptop(device)) {
+        return 0;
+    }
+
+    if(device->usb_interface_protocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+        // Skip this if its control (mouse) interface
+        return 0;
+    }
+
+    // Block win key
+    if(device->block_keys[0] && (usage->code == KEY_LEFTMETA || usage->code == KEY_RIGHTMETA)) {
+        return 1;
+    }
+
+    // Store Alt state
+    if(usage->code == KEY_LEFTALT) {
+        device->left_alt_on = value;
+    }
+    // Block Alt-Tab
+    if(device->block_keys[1] && device->left_alt_on && usage->code == KEY_TAB) {
+        return 1;
+    }
+    // Block Alt-F4
+    if(device->block_keys[2] && device->left_alt_on && usage->code == KEY_F4) {
+        return 1;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+        translation = find_translation(chroma_keys_2, usage->code);
+        break;
+
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+        translation = find_translation(chroma_keys_3, usage->code);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+        translation = find_translation(chroma_keys_4, usage->code);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        translation = find_translation(chroma_keys_5, usage->code);
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+        translation = find_translation(chroma_keys_7, usage->code);
+        break;
+
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+        translation = find_translation(chroma_keys_6, usage->code);
+        break;
+
+    default:
+        translation = find_translation(chroma_keys, usage->code);
+        break;
+    }
+
+    if(translation) {
+        if (test_bit(usage->code, device->pressed_fn) || device->fn_on) {
+            if (value) {
+                set_bit(usage->code, device->pressed_fn);
+            } else {
+                clear_bit(usage->code, device->pressed_fn);
+            }
+
+            input_event(field->hidinput->input, usage->type, translation->to, value);
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * Standard raw event function
+ *
+ * Bastard function. Could most probably be done a load better.
+ * Basically it shifts all of the key's in the 04... event to the right 1, and then sets the first 2 bytes to 0x0100. This then allows the keys to be processed with the above normal event function
+ *
+ * Converts M1-M5 into F13-F17. It also blanks out FN keypresses so it acts more like the modifier it should be.
+ * 04012000000000000000 FN is pressed, M1 pressed
+ * 04010000000000000000 M1 is released
+ * goes to
+ * 01000068000000000000 FN is pressed (blanked), M1 pressed (converted to F13)
+ * 01000000000000000000 M1 is released
+ *
+ * Converts Mute/Next/Play/Prev into multimedia keys
+ *   04 00 52 00  ... 00 - Mute key pressed
+ *   04 00 00 00 ... 00 - Mute key released
+ * goes to
+ *   01 00 00 E2 00 ... 00 - Mute pressed (converted to KEY_MEDIA_MUTE)
+ *   01 00 00 00 00 ... 00
+ * they key codes are
+ *   0x52 - Mute
+ *   0x53 - Next song
+ *   0x55 - Play/Pause
+ *   0x54 - Prev song
+ *
+ * HID Usage Table http://www.freebsddiary.org/APC/usb_hid_usages.php
+ */
+static int razer_raw_event_standard(struct hid_device *hdev, struct razer_kbd_device *device, struct usb_interface *intf, struct hid_report *report, u8 *data, int size)
+{
+    // The event were looking for is 16 or 22 bytes long and starts with 0x04.
+    // Newer firmware seems to use 22 bytes.
+    if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD &&
+       ((size == 22) || (size == 16)) && data[0] == 0x04) {
+        // Convert 04... to 0100...
+        int index = size-1; // This way we start at 2nd last value, does subtract 1 from the 15key rollover though (not an issue cmon)
+        int found_fn = 0x00;
+
+        while(--index > 0) {
+            u8 cur_value = data[index];
+            if(cur_value == 0x00) { // Skip 0x00
+                continue;
+            }
+
+            switch(cur_value) {
+            case 0x01: // FN
+                //cur_value = 0x73; // F24
+                cur_value = 0x00;
+                found_fn = 0x01;
+                break;
+            case 0x20: // M1
+                cur_value = USB_HID_KEY_F13; // F13
+                break;
+            case 0x21: // M2
+                cur_value = USB_HID_KEY_F14; // F14
+                break;
+            case 0x22: // M3
+                cur_value = USB_HID_KEY_F15; // F15
+                break;
+            case 0x23: // M4
+                cur_value = USB_HID_KEY_F16; // F16
+                break;
+            case 0x24: // M5
+                cur_value = USB_HID_KEY_F17; // F17
+                break;
+            case 0x25: // BlackWidow V4 (non-Pro) M6
+                cur_value = USB_HID_KEY_F18; // F18
+                break;
+            case 0x50: // Volume Down
+                cur_value = USB_HID_KEY_MEDIA_VOLUMEDOWN; // F17
+                break;
+            case 0x51: // Volume Up
+                cur_value =  USB_HID_KEY_MEDIA_VOLUMEUP; // F17
+                break;
+            case 0x52: // Mute
+                cur_value = USB_HID_KEY_MEDIA_MUTE;
+                break;
+            case 0x53: // Next (song)
+                cur_value = USB_HID_KEY_MEDIA_NEXTSONG;
+                break;
+            case 0x55: // Play/Pause
+                cur_value = USB_HID_KEY_MEDIA_PLAYPAUSE;
+                break;
+            case 0x54: // Prev (song)
+                cur_value = USB_HID_KEY_MEDIA_PREVIOUSSONG;
+                break;
+            case 0x60: // BlackWidow V4 Pro command dial button
+                cur_value = USB_HID_KEY_F24; // F24 (not sure if we want it this way)
+                break;
+            case 0x63: // BlackWidow V4 Pro Side button 1
+                cur_value = USB_HID_KEY_F18; // F18
+                break;
+            case 0x64: // BlackWidow V4 Pro Side button 2
+                cur_value = USB_HID_KEY_F19; // F19
+                break;
+            case 0x65: // BlackWidow V4 Pro Side button 3
+                cur_value = USB_HID_KEY_F20; // F20
+                break;
+            }
+
+            data[index+1] = cur_value;
+        }
+
+        device->fn_on = !!found_fn;
+
+        data[0] = 0x01;
+        data[1] = 0x00;
+
+        // Some reason just by editing data, it generates a normal event above. (Could quite possibly work like that, no clue)
+        //hid_report_raw_event(hdev, HID_INPUT_REPORT, data, size, 0);
+        return 1;
+    }
+
+    return 0;
+}
+
+#define RAW_EVENT_BITFIELD_BYTES (20)
+#define RAW_EVENT_BITFIELD_BITS (RAW_EVENT_BITFIELD_BYTES * BITS_PER_BYTE)
+
+/**
+ * Bitfield raw event function
+ *
+ * Handles raw events very similarly to razer_raw_event_standard, but for size 22, handles the data as a bit field,
+ * instead of an array of values.
+ *
+ * When the rewritten value does not fit the bit field, a key-down and a key-up event is reported separately.
+ */
+static int razer_raw_event_bitfield(struct hid_device *hdev, struct razer_kbd_device *device, struct usb_interface *intf, struct hid_report *report, u8 *data, int size)
+{
+    DECLARE_BITMAP(bitfield, RAW_EVENT_BITFIELD_BITS) = { 0 };
+
+    // The event were looking for is 16 or 22 bytes long and starts with 0x04.
+    // Newer firmware seems to use 22 bytes.
+    if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD &&
+       ((size == 22) || (size == 16)) && data[0] == 0x04) {
+        // Convert 04... to 0100...
+        int index = size-1; // This way we start at 2nd last value, does subtract 1 from the 15key rollover though (not an issue cmon)
+        int found_fn = 0x00;
+
+        while(--index > 0) {
+            bool write_bitfield = true;
+            u8 cur_value = data[index];
+            if(cur_value == 0x00) { // Skip 0x00
+                continue;
+            }
+
+            switch(cur_value) {
+            case 0x01: // FN
+                //cur_value = 0x73; // F24
+                cur_value = 0x00;
+                found_fn = 0x01;
+                write_bitfield = false;
+                break;
+            case 0x20: // M1
+                cur_value = USB_HID_KEY_F13; // F13
+                break;
+            case 0x21: // M2
+                cur_value = USB_HID_KEY_F14; // F14
+                break;
+            case 0x22: // M3
+                cur_value = USB_HID_KEY_F15; // F15
+                break;
+            case 0x23: // M4
+                cur_value = USB_HID_KEY_F16; // F16
+                break;
+            case 0x24: // M5
+                cur_value = USB_HID_KEY_F17; // F17
+                break;
+            case 0x25: // BlackWidow V4 (non-Pro) M6
+                cur_value = USB_HID_KEY_F18; // F18
+                break;
+            case 0x50: // Volume Down
+                cur_value = USB_HID_KEY_MEDIA_VOLUMEDOWN;
+                break;
+            case 0x51: // Volume Up
+                cur_value =  USB_HID_KEY_MEDIA_VOLUMEUP;
+                break;
+            case 0x52: // Mute
+                cur_value = USB_HID_KEY_MEDIA_MUTE;
+                break;
+            case 0x53: // Next (song)
+                cur_value = USB_HID_KEY_MEDIA_NEXTSONG;
+                break;
+            case 0x55: // Play/Pause
+                cur_value = USB_HID_KEY_MEDIA_PLAYPAUSE;
+                break;
+            case 0x54: // Prev (song)
+                cur_value = USB_HID_KEY_MEDIA_PREVIOUSSONG;
+                break;
+            case 0x60: // BlackWidow V4 Pro command dial button
+                cur_value = USB_HID_KEY_F24; // F24 (not sure if we want it this way)
+                break;
+            case 0x63: // BlackWidow V4 Pro Side button 1
+                cur_value = USB_HID_KEY_F18; // F18
+                break;
+            case 0x64: // BlackWidow V4 Pro Side button 2
+                cur_value = USB_HID_KEY_F19; // F19
+                break;
+            case 0x65: // BlackWidow V4 Pro Side button 3
+                cur_value = USB_HID_KEY_F20; // F20
+                break;
+            default:
+                write_bitfield = false;
+            }
+
+            // data of size 22 starting with 0x01 is a bit field so we need to handle that separately
+            if (size == 22) {
+                if (write_bitfield) {
+                    if (cur_value < RAW_EVENT_BITFIELD_BITS) {
+                        // value fits the bit field, so we can use that
+                        bitmap_set(bitfield, cur_value, 1);
+                    } else {
+                        // value does not fit the bit field, so we need extra handling
+                        int report_extra = 1;
+
+                        switch (cur_value) {
+                        case USB_HID_KEY_MEDIA_VOLUMEUP:
+                            cur_value = USB_HID_USAGE_MEDIA_VOLUMEUP;
+                            break;
+                        case USB_HID_KEY_MEDIA_VOLUMEDOWN:
+                            cur_value = USB_HID_USAGE_MEDIA_VOLUMEDOWN;
+                            break;
+                        case USB_HID_KEY_MEDIA_MUTE:
+                            cur_value = USB_HID_USAGE_MEDIA_MUTE;
+                            break;
+                        case USB_HID_KEY_MEDIA_NEXTSONG:
+                            cur_value = USB_HID_USAGE_MEDIA_NEXTSONG;
+                            break;
+                        case USB_HID_KEY_MEDIA_PLAYPAUSE:
+                            cur_value = USB_HID_USAGE_MEDIA_PLAYPAUSE;
+                            break;
+                        case USB_HID_KEY_MEDIA_PREVIOUSSONG:
+                            cur_value = USB_HID_USAGE_MEDIA_PREVIOUSSONG;
+                            break;
+                        default:
+                            report_extra = 0;
+                        }
+
+                        if (report_extra) {
+                            u8 xdata[22] = { 0x02 };
+
+                            // report key down
+                            xdata[1] = cur_value;
+                            hid_report_raw_event(hdev, HID_INPUT_REPORT, xdata, sizeof(xdata), 0);
+
+                            // report key up
+                            xdata[1] = 0x00;
+                            hid_report_raw_event(hdev, HID_INPUT_REPORT, xdata, sizeof(xdata), 0);
+                        }
+                    }
+                }
+            } else { // size 16
+                data[index+1] = cur_value;
+            }
+        }
+
+        device->fn_on = !!found_fn;
+
+        data[0] = 0x01;
+        data[1] = 0x00;
+        if (size == 22) {
+            memcpy(data + 2, bitfield, RAW_EVENT_BITFIELD_BYTES);
+        }
+
+        // Some reason just by editing data, it generates a normal event above. (Could quite possibly work like that, no clue)
+        //hid_report_raw_event(hdev, HID_INPUT_REPORT, data, size, 0);
+        return 1;
+    }
+
+    return 0;
+}
+
+/**
+ * Raw event function
+ *
+ * Handles provided HID reports, branched out for specific keyboard models, since some keyboards need specific handling.
+ */
+static int razer_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)
+{
+    struct razer_kbd_device *device = hid_get_drvdata(hdev);
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+
+    // No translations needed on the Pro...
+    if (is_blade_laptop(device)) {
+        return 0;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+    case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+        return razer_raw_event_bitfield(hdev, device, intf, report, data, size);
+    default:
+        return razer_raw_event_standard(hdev, device, intf, report, data, size);
+    }
+}
+
+/**
+ * Set static hid-events translation map
+ *
+ * Some keyboards generates wheel-events for volume control knob
+ */
+static int razer_kbd_input_mapping(struct hid_device *hdev, struct hid_input *hidinput, struct hid_field *field,
+                                   struct hid_usage *usage, unsigned long **bit, int *max)
+{
+    switch (hdev->product) {
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+    case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+    case USB_DEVICE_ID_RAZER_ORNATA_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+        if (hdev->type == HID_TYPE_USBMOUSE && usage->hid == HID_GD_WHEEL) {
+            hid_map_usage(hidinput, usage, bit, max, EV_ABS, ABS_VOLUME);
+            return 1;
+        }
+        return 0;
+
+    default:
+        return 0;
+    }
+}
+
+static void razer_kbd_init(struct razer_kbd_device *dev, struct usb_interface *intf, struct hid_device *hdev)
+{
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+
+    // Initialise mutex
+    mutex_init(&dev->lock);
+    // Setup values
+    dev->usb_dev = usb_dev;
+    dev->usb_vid = usb_dev->descriptor.idVendor;
+    dev->usb_pid = usb_dev->descriptor.idProduct;
+    dev->usb_interface_protocol = intf->cur_altsetting->desc.bInterfaceProtocol;
+}
+
+/**
+ * Probe method is ran whenever a device is binded to the driver
+ */
+static int razer_kbd_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+    int retval = 0;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    struct razer_kbd_device *dev = NULL;
+
+    dev = kzalloc(sizeof(struct razer_kbd_device), GFP_KERNEL);
+    if(dev == NULL) {
+        dev_err(&intf->dev, "out of memory\n");
+        return -ENOMEM;
+    }
+
+    // Init data
+    razer_kbd_init(dev, intf, hdev);
+
+    // Other interfaces are actual key-emitting devices
+    if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+        // If the currently bound device is the control (mouse) interface
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_version);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_firmware_version);                      // Get the firmware version
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_serial);                         // Get serial number
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);                     // Gets and sets the brightness
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_test);                                  // Test mode
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_mode);                           // Get device mode
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_kbd_layout);                            // Gets the physical layout
+
+        switch(usb_dev->descriptor.idProduct) {
+
+        case USB_DEVICE_ID_RAZER_NOSTROMO:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORBWEAVER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ANANSI:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_2018_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020:
+        case USB_DEVICE_ID_RAZER_BOOK_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_2019_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE:
+        case USB_DEVICE_ID_RAZER_ORNATA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_super);                     // Super Key
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_tab);                   // Alt + Tab
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_f4);                    // Alt + F4
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);                  // Charge level
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);                 // Charge status
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);                     // Poll Rate
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_keyswitch_optimization);        // Keyswitch Optimization
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_super);                     // Super Key
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_tab);                   // Alt + Tab
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_f4);                    // Alt + F4
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+        case USB_DEVICE_ID_RAZER_ORNATA_V2:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORNATA_V3:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wheel);           // Wheel effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wheel);           // Wheel effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);                     // Poll Rate
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);                  // Battery charge level
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);                 // Battery charge status
+            break;
+
+        case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);                  // Charge level
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);                 // Charge status
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);                 // Charge effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);                 // Charge colour
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);          // Charge low threshold
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY:
+        case USB_DEVICE_ID_RAZER_BLADE_2019_ADV:
+        case USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fn_toggle);                     // Sets whether FN is requires for F-Keys
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_QHD:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_fn_toggle);                     // Sets whether FN is requires for F-Keys
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_state);                // Enable/Disable the logo
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+        case USB_DEVICE_ID_RAZER_BLADE_2018:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2017:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD:
+        case USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_15_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_16_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_18_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2024:
+        case USB_DEVICE_ID_RAZER_BLADE_18_2024:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_state);                // Enable/Disable the logo
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+        }
+
+        // Set device to regular mode, not driver mode
+        // When the daemon discovers the device it will instruct it to enter driver mode
+        razer_set_device_mode(dev, 0x00, 0x00);
+    } else if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD) {
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_super);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_tab);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_key_alt_f4);
+    }
+
+    hid_set_drvdata(hdev, dev);
+    dev_set_drvdata(&hdev->dev, dev);
+
+    if(hid_parse(hdev)) {
+        hid_err(hdev, "parse failed\n");
+        goto exit_free;
+    }
+
+    if (hid_hw_start(hdev, HID_CONNECT_DEFAULT)) {
+        hid_err(hdev, "hw start failed\n");
+        goto exit_free;
+    }
+
+    // Leave autosuspend on for laptops
+    if (!is_blade_laptop(dev)) {
+        usb_disable_autosuspend(usb_dev);
+    }
+
+    //razer_activate_macro_keys(usb_dev);
+    //msleep(3000);
+    return 0;
+
+exit_free:
+    kfree(dev);
+    return retval;
+}
+
+/**
+ * Unbind function
+ */
+static void razer_kbd_disconnect(struct hid_device *hdev)
+{
+    struct razer_kbd_device *dev;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+
+    dev = hid_get_drvdata(hdev);
+
+    // Other interfaces are actual key-emitting devices
+    if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+        // If the currently bound device is the control (mouse) interface
+        device_remove_file(&hdev->dev, &dev_attr_version);
+        device_remove_file(&hdev->dev, &dev_attr_firmware_version);                      // Get the firmware version
+        device_remove_file(&hdev->dev, &dev_attr_device_serial);                         // Get serial number
+        device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);                     // Gets and sets the brightness
+        device_remove_file(&hdev->dev, &dev_attr_test);                                  // Test mode
+        device_remove_file(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        device_remove_file(&hdev->dev, &dev_attr_device_mode);                           // Get device mode
+        device_remove_file(&hdev->dev, &dev_attr_kbd_layout);                            // Gets the physical layout
+
+        switch(usb_dev->descriptor.idProduct) {
+
+        case USB_DEVICE_ID_RAZER_NOSTROMO:
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS:
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORBWEAVER:
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ANANSI:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_pulsate);         // Pulsate effect, like breathing
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_2018_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020:
+        case USB_DEVICE_ID_RAZER_BOOK_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_2019_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE:
+        case USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE:
+        case USB_DEVICE_ID_RAZER_ORNATA:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_key_super);                     // Super Key
+            device_remove_file(&hdev->dev, &dev_attr_key_alt_tab);                   // Alt + Tab
+            device_remove_file(&hdev->dev, &dev_attr_key_alt_f4);                    // Alt + F4
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);                  // Charge level
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);                 // Charge status
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);                     // Poll Rate
+            device_remove_file(&hdev->dev, &dev_attr_keyswitch_optimization);        // Keyswitch Optimization
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3:
+        case USB_DEVICE_ID_RAZER_DEATHSTALKER_V2:
+            device_remove_file(&hdev->dev, &dev_attr_key_super);                     // Super Key
+            device_remove_file(&hdev->dev, &dev_attr_key_alt_tab);                   // Alt + Tab
+            device_remove_file(&hdev->dev, &dev_attr_key_alt_f4);                    // Alt + F4
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_ORNATA_CHROMA:
+        case USB_DEVICE_ID_RAZER_ORNATA_V2:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_TE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_2019:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA:
+        case USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2:
+        case USB_DEVICE_ID_RAZER_CYNOSA_V2:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORNATA_V3:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_ALT:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wheel);           // Wheel effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wheel);           // Wheel
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);                     // Poll Rate
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);                  // Battery charge level
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);                 // Battery charge status
+            break;
+
+        case USB_DEVICE_ID_RAZER_CYNOSA_LITE:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);                  // Charge level
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);                 // Charge status
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);                 // Charge effect
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);                 // Charge colour
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);          // Charge low threshold
+            break;
+
+        case USB_DEVICE_ID_RAZER_TARTARUS_V2:
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_red);               // Profile/Macro LED Red
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_green);             // Profile/Macro LED Green
+            device_remove_file(&hdev->dev, &dev_attr_profile_led_blue);              // Profile/Macro LED Blue
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY:
+        case USB_DEVICE_ID_RAZER_BLADE_2019_ADV:
+        case USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_LATE_2016:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_fn_toggle);                     // Sets whether FN is requires for F-Keys
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_QHD:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017:
+        case USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_fn_toggle);                     // Sets whether FN is requires for F-Keys
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_state);                // Enable/Disable the logo
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016:
+        case USB_DEVICE_ID_RAZER_BLADE_2018:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2017:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD:
+        case USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2021:
+        case USB_DEVICE_ID_RAZER_BLADE_17_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_15_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_16_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_18_2023:
+        case USB_DEVICE_ID_RAZER_BLADE_14_2024:
+        case USB_DEVICE_ID_RAZER_BLADE_18_2024:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_state);                // Enable/Disable the logo
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            break;
+
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA:
+        case USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG:
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG:
+        case USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+
+        case USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);            // Wave effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_starlight);       // Starlight effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);        // Reactive effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);           // Set LED matrix
+            device_remove_file(&hdev->dev, &dev_attr_game_led_state);                // Enable game mode & LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_state);               // Enable macro LED
+            device_remove_file(&hdev->dev, &dev_attr_macro_led_effect);              // Change macro LED effect (static, flashing)
+            break;
+        }
+    } else if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD) {
+        device_remove_file(&hdev->dev, &dev_attr_key_super);
+        device_remove_file(&hdev->dev, &dev_attr_key_alt_tab);
+        device_remove_file(&hdev->dev, &dev_attr_key_alt_f4);
+    }
+
+    hid_hw_stop(hdev);
+    kfree(dev);
+    dev_info(&intf->dev, "Razer Device disconnected\n");
+}
+
+/**
+ * Setup input device keybit mask
+ */
+static void razer_setup_key_bits(struct input_dev *input)
+{
+    __set_bit(EV_KEY, input->evbit);
+
+    // Chroma keys
+    __set_bit(RAZER_MACRO_KEY, input->keybit);
+    __set_bit(RAZER_GAME_KEY, input->keybit);
+    __set_bit(RAZER_BRIGHTNESS_DOWN, input->keybit);
+    __set_bit(RAZER_BRIGHTNESS_UP, input->keybit);
+}
+
+/**
+ * Setup the input device now that its been added to our struct
+ */
+static int razer_input_configured(struct hid_device *hdev, struct hid_input *hi)
+{
+    razer_setup_key_bits(hi->input);
+    return 0;
+}
+
+/**
+ * Device ID mapping table
+ */
+static const struct hid_device_id razer_devices[] = {
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORBWEAVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NOSTROMO) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_QHD) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_2018) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_2018_BASE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_2019_ADV) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_2019_BASE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_TARTARUS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_TARTARUS_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_TARTARUS_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V3) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V3_ALT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V3_X) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CYNOSA_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CYNOSA_LITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_CYNOSA_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ORNATA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ANANSI) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_LATE_2016) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_2017) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_TE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_MINI) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BOOK_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_14_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_17_2022) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_14_2022) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_14_2023) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_15_2023) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_14_2024) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V4) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_16_2023) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_18_2023) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BLADE_18_2024) },
+    { 0 }
+};
+
+MODULE_DEVICE_TABLE(hid, razer_devices);
+
+/**
+ * Describes the contents of the driver
+ */
+static struct hid_driver razer_kbd_driver = {
+    .name = "razerkbd",
+    .id_table = razer_devices,
+    .input_mapping = razer_kbd_input_mapping,
+    .probe = razer_kbd_probe,
+    .remove = razer_kbd_disconnect,
+    .event = razer_event,
+    .raw_event = razer_raw_event,
+    .input_configured = razer_input_configured,
+};
+
+module_hid_driver(razer_kbd_driver);
diff --git a/drivers/custom/razer/driver/razerkbd_driver.h b/drivers/custom/razer/driver/razerkbd_driver.h
new file mode 100644
index 000000000000..bd5fd7642bd9
--- /dev/null
+++ b/drivers/custom/razer/driver/razerkbd_driver.h
@@ -0,0 +1,179 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Tim Theede <pez2001@voyagerproject.de>
+ *               2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef __HID_RAZER_KBD_H
+#define __HID_RAZER_KBD_H
+
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2012 0x010D
+// 2011 or so edition, see https://web.archive.org/web/20111113132427/http://store.razerzone.com:80/store/razerusa/en_US/pd/productID.235228400/categoryId.49136200/parentCategoryId.35156900
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH_EDITION 0x010E
+#define USB_DEVICE_ID_RAZER_ANANSI 0x010F
+#define USB_DEVICE_ID_RAZER_NOSTROMO 0x0111
+#define USB_DEVICE_ID_RAZER_ORBWEAVER 0x0113
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_ESSENTIAL 0x0118
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2013 0x011A
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_STEALTH 0x011B
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_TE_2014 0x011C
+#define USB_DEVICE_ID_RAZER_TARTARUS 0x0201
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_EXPERT 0x0202
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA 0x0203
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_CHROMA 0x0204
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH 0x0205
+#define USB_DEVICE_ID_RAZER_ORBWEAVER_CHROMA 0x0207
+#define USB_DEVICE_ID_RAZER_TARTARUS_CHROMA 0x0208
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_TE 0x0209
+#define USB_DEVICE_ID_RAZER_BLADE_QHD 0x020F
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2016 0x0210
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_OVERWATCH 0x0211
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE_2016 0x0214
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA 0x0216
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_X_ULTIMATE 0x0217
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_X_CHROMA_TE 0x021A
+#define USB_DEVICE_ID_RAZER_ORNATA_CHROMA 0x021E
+#define USB_DEVICE_ID_RAZER_ORNATA 0x021F
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2016 0x0220
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_CHROMA_V2 0x0221
+#define USB_DEVICE_ID_RAZER_BLADE_LATE_2016 0x0224
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_2017 0x0225
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_ELITE 0x0226
+#define USB_DEVICE_ID_RAZER_HUNTSMAN 0x0227
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ELITE 0x0228
+#define USB_DEVICE_ID_RAZER_CYNOSA_CHROMA 0x022A
+#define USB_DEVICE_ID_RAZER_TARTARUS_V2 0x022B
+#define USB_DEVICE_ID_RAZER_CYNOSA_CHROMA_PRO 0x022C
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_MID_2017 0x022D
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_2017_FULLHD 0x022F
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2017 0x0232
+#define USB_DEVICE_ID_RAZER_BLADE_2018 0x0233
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_2019 0x0234
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_LITE 0x0235
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ESSENTIAL 0x0237
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_2019 0x0239
+#define USB_DEVICE_ID_RAZER_BLADE_2019_ADV 0x023A
+#define USB_DEVICE_ID_RAZER_BLADE_2018_BASE 0x023B
+#define USB_DEVICE_ID_RAZER_CYNOSA_LITE 0x023F
+#define USB_DEVICE_ID_RAZER_BLADE_2018_MERCURY 0x0240
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_2019 0x0241
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_TE 0x0243
+#define USB_DEVICE_ID_RAZER_BLADE_MID_2019_MERCURY 0x0245
+#define USB_DEVICE_ID_RAZER_BLADE_2019_BASE 0x0246
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2019 0x024A
+#define USB_DEVICE_ID_RAZER_BLADE_ADV_LATE_2019 0x024B
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_LATE_2019 0x024C
+#define USB_DEVICE_ID_RAZER_BLADE_STUDIO_EDITION_2019 0x024D
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3 0x024E
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_EARLY_2020 0x0252
+#define USB_DEVICE_ID_RAZER_BLADE_15_ADV_2020 0x0253
+#define USB_DEVICE_ID_RAZER_BLADE_EARLY_2020_BASE 0x0255
+#define USB_DEVICE_ID_RAZER_BLADE_PRO_EARLY_2020 0x0256
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_MINI 0x0257
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI 0x0258
+#define USB_DEVICE_ID_RAZER_BLADE_STEALTH_LATE_2020 0x0259
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRED 0x025A
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_PRO_WIRELESS 0x025C
+#define USB_DEVICE_ID_RAZER_ORNATA_V2 0x025D
+#define USB_DEVICE_ID_RAZER_CYNOSA_V2 0x025E
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_V2_ANALOG 0x0266
+#define USB_DEVICE_ID_RAZER_BLADE_LATE_2020_BASE 0x0268
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_JP 0x0269
+#define USB_DEVICE_ID_RAZER_BOOK_2020 0x026A
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_V2_TENKEYLESS 0x026B
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_V2 0x026C
+#define USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2021 0x026D
+#define USB_DEVICE_ID_RAZER_BLADE_17_PRO_EARLY_2021 0x026E
+#define USB_DEVICE_ID_RAZER_BLADE_15_BASE_EARLY_2021 0x026F
+#define USB_DEVICE_ID_RAZER_BLADE_14_2021 0x0270
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_MINI_WIRELESS 0x0271
+#define USB_DEVICE_ID_RAZER_BLADE_15_ADV_MID_2021 0x0276
+#define USB_DEVICE_ID_RAZER_BLADE_17_PRO_MID_2021 0x0279
+#define USB_DEVICE_ID_RAZER_BLADE_15_BASE_2022 0x027A
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_MINI_ANALOG 0x0282
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V4 0x0287
+#define USB_DEVICE_ID_RAZER_BLADE_15_ADV_EARLY_2022 0x028A
+#define USB_DEVICE_ID_RAZER_BLADE_17_2022 0x028B
+#define USB_DEVICE_ID_RAZER_BLADE_14_2022 0x028C
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_PRO 0x028D
+#define USB_DEVICE_ID_RAZER_ORNATA_V3_ALT 0x028F
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRELESS 0x0290
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_WIRED 0x0292
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_X 0x0293
+#define USB_DEVICE_ID_RAZER_ORNATA_V3_X 0x0294
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_V2 0x0295
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRELESS 0x0296
+#define USB_DEVICE_ID_RAZER_DEATHSTALKER_V2_PRO_TKL_WIRED 0x0298
+#define USB_DEVICE_ID_RAZER_BLADE_14_2023 0x029D
+#define USB_DEVICE_ID_RAZER_BLADE_15_2023 0x029E
+#define USB_DEVICE_ID_RAZER_BLADE_16_2023 0x029F
+#define USB_DEVICE_ID_RAZER_BLADE_18_2023 0x02A0
+#define USB_DEVICE_ID_RAZER_ORNATA_V3 0x02A1
+#define USB_DEVICE_ID_RAZER_ORNATA_V3_X_ALT 0x02A2
+#define USB_DEVICE_ID_RAZER_ORNATA_V3_TENKEYLESS 0x02A3
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V4_75PCT 0x02A5
+#define USB_DEVICE_ID_RAZER_HUNTSMAN_V3_PRO 0x02A6
+#define USB_DEVICE_ID_RAZER_BLADE_14_2024 0x02B6
+#define USB_DEVICE_ID_RAZER_BLADE_18_2024 0x02B8
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_V3_TK 0x0A24
+
+/* Each keyboard report has 90 bytes*/
+#define RAZER_BLACKWIDOW_REPORT_LEN 0x5A
+
+#define RAZER_BLACKWIDOW_CHROMA_WAVE_DIRECTION_LEFT 2
+#define RAZER_BLACKWIDOW_CHROMA_WAVE_DIRECTION_RIGHT 1
+
+#define RAZER_BLACKWIDOW_CHROMA_CHANGE_EFFECT 0x0A
+
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_NONE 0
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_WAVE 1
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_REACTIVE 2
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_BREATH 3
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_SPECTRUM 4
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_CUSTOM 5 // draw frame
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_STATIC 6
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_CLEAR_ROW 8
+
+#define RAZER_BLACKWIDOW_ULTIMATE_2016_EFFECT_STARLIGHT 0x19
+
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_SET_KEYS 9 //update profile needs to be called after setting keys to reflect changes
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_RESET 10
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_UNKNOWN 11
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_UNKNOWN2 12
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_UNKNOWN3 13
+#define RAZER_BLACKWIDOW_CHROMA_EFFECT_UNKNOWN4 14
+
+#define RAZER_BLACKWIDOW_CHROMA_ROW_LEN 0x16
+#define RAZER_BLACKWIDOW_CHROMA_ROWS_NUM 6
+
+#define RAZER_STEALTH_ROW_LEN 0x10
+#define RAZER_STEALTH_ROWS_NUM 6
+
+#define RAZER_BLACKWIDOW_CHROMA_WAIT_MS 1
+#define RAZER_BLACKWIDOW_CHROMA_WAIT_MIN_US 600
+#define RAZER_BLACKWIDOW_CHROMA_WAIT_MAX_US 800
+
+#define RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MIN_US 4900
+#define RAZER_BLACKWIDOW_V3_WIRELESS_WAIT_MAX_US 5000
+
+#define RAZER_DEATHSTALKER_V2_WIRELESS_WAIT_MIN_US 4900
+#define RAZER_DEATHSTALKER_V2_WIRELESS_WAIT_MAX_US 5000
+
+#define RAZER_FIREFLY_WAIT_MIN_US 900
+#define RAZER_FIREFLY_WAIT_MAX_US 1000
+
+struct razer_kbd_device {
+    struct usb_device *usb_dev;
+    struct mutex lock;
+    unsigned char usb_interface_protocol;
+    unsigned short usb_vid;
+    unsigned short usb_pid;
+
+    unsigned int fn_on;
+    DECLARE_BITMAP(pressed_fn, KEY_CNT);
+
+    unsigned char block_keys[3];
+    unsigned char left_alt_on;
+};
+
+#endif
diff --git a/drivers/custom/razer/driver/razerkraken_driver.c b/drivers/custom/razer/driver/razerkraken_driver.c
new file mode 100644
index 000000000000..0c2177bccf2e
--- /dev/null
+++ b/drivers/custom/razer/driver/razerkraken_driver.c
@@ -0,0 +1,882 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+#include <linux/random.h>
+
+#include "razerkraken_driver.h"
+#include "razercommon.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_DESC "Razer Keyboard Device Driver"
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+/**
+ * Print report to syslog
+ */
+/*
+static void print_erroneous_kraken_request_report(struct razer_kraken_request_report* report, char* driver_name, char* message)
+{
+    printk(KERN_WARNING "%s: %s. Report ID: %02x dest: %02x length: %02x ADDR: %02x%02x Args: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x .\n",
+           driver_name,
+           message,
+           report->report_id,
+           report->destination,
+           report->length,
+           report->addr_h,
+           report->addr_l,
+           report->arguments[0], report->arguments[1], report->arguments[2], report->arguments[3], report->arguments[4], report->arguments[5],
+           report->arguments[6], report->arguments[7], report->arguments[8], report->arguments[9], report->arguments[10], report->arguments[11],
+           report->arguments[12], report->arguments[13], report->arguments[14], report->arguments[15]);
+}
+*/
+
+static int razer_kraken_send_control_msg(struct usb_device *usb_dev,struct razer_kraken_request_report* report, unsigned char skip)
+{
+    uint request = HID_REQ_SET_REPORT; // 0x09
+    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21
+    uint value = 0x0204;
+    uint index = 0x0003;
+    uint size = 37;
+    char *buf;
+    int len;
+
+    buf = kmemdup(report, size, GFP_KERNEL);
+    if (buf == NULL)
+        return -ENOMEM;
+
+    // Send usb control message
+    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),
+                          request,      // Request      U8
+                          request_type, // RequestType  U8
+                          value,        // Value        U16
+                          index,        // Index        U16
+                          buf,          // Data         void* data
+                          size,         // Length       U16
+                          USB_CTRL_SET_TIMEOUT); //     Int
+
+    // Wait
+    if(skip != 1) {
+        msleep(report->length * 15);
+    }
+
+    kfree(buf);
+    if(len!=size)
+        printk(KERN_WARNING "razer driver: Device data transfer failed.\n");
+
+    return ((len < 0) ? len : ((len != size) ? -EIO : 0));
+}
+
+/**
+ * Get a request report
+ *
+ * report_id - The type of report
+ * destination - where data is going (like ram)
+ * length - amount of data
+ * address - where to write data to
+ */
+static struct razer_kraken_request_report get_kraken_request_report(unsigned char report_id, unsigned char destination, unsigned char length, unsigned short address)
+{
+    struct razer_kraken_request_report report;
+    memset(&report, 0, sizeof(struct razer_kraken_request_report));
+
+    report.report_id = report_id;
+    report.destination = destination;
+    report.length = length;
+    report.addr_h = (address >> 8);
+    report.addr_l = (address & 0xFF);
+
+    return report;
+}
+
+/**
+ * Get a union containing the effect bitfield
+ */
+static union razer_kraken_effect_byte get_kraken_effect_byte(void)
+{
+    union razer_kraken_effect_byte effect_byte;
+    memset(&effect_byte, 0, sizeof(union razer_kraken_effect_byte));
+
+    return effect_byte;
+}
+
+/**
+ * Get the current effect
+ */
+static unsigned char get_current_effect(struct device *dev)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x00, 0x01, device->led_mode_address);
+    int is_mutex_locked = mutex_is_locked(&device->lock);
+    unsigned char result = 0;
+
+    // Lock if there isn't already a lock, otherwise skip, essentially emulate a rentrant lock
+    if(is_mutex_locked == 0) {
+        mutex_lock(&device->lock);
+    }
+
+    device->data[0] = 0x00;
+    razer_kraken_send_control_msg(device->usb_dev, &report, 1);
+    msleep(25); // Sleep 20ms
+
+    // Check for actual data
+    if(device->data[0] == 0x05) {
+        result = device->data[1];
+    } else {
+        printk(KERN_CRIT "razerkraken: Did not manage to get report\n");
+    }
+
+    // Unlock if there isn't already a lock (as there would be by now), otherwise skip as reusing existing lock
+    if(is_mutex_locked == 0) {
+        mutex_unlock(&device->lock);
+    }
+
+    return result;
+}
+
+static unsigned int get_rgb_from_addr(struct device *dev, unsigned short address, unsigned char len, char* buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x00, len, address);
+    int is_mutex_locked = mutex_is_locked(&device->lock);
+    unsigned char written = 0;
+
+    // Lock if there isn't already a lock, otherwise skip, essentially emulate a rentrant lock
+    if(is_mutex_locked == 0) {
+        mutex_lock(&device->lock);
+    }
+
+    device->data[0] = 0x00;
+    razer_kraken_send_control_msg(device->usb_dev, &report, 1);
+    msleep(25); // Sleep 20ms
+
+    // Check for actual data
+    if(device->data[0] == 0x05) {
+        //printk(KERN_CRIT "razerkraken: Got %02x%02x%02x %02x\n", device->data[1], device->data[2], device->data[3], device->data[4]);
+        memcpy(&buf[0], &device->data[1], len);
+        written = len;
+    } else {
+        printk(KERN_CRIT "razerkraken: Did not manage to get report\n");
+    }
+
+    // Unlock if there isn't already a lock (as there would be by now), otherwise skip as reusing existing lock
+    if(is_mutex_locked == 0) {
+        mutex_unlock(&device->lock);
+    }
+
+    return written;
+}
+
+/**
+ * Read device file "version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", DRIVER_VERSION);
+}
+
+/**
+ * Read device file "device_type"
+ *
+ * Returns friendly string of device type
+ */
+static ssize_t razer_attr_read_device_type(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+
+    char *device_type;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC:
+    case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT:
+        device_type = "Razer Kraken 7.1\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN:
+        device_type = "Razer Kraken 7.1 Chroma\n"; // Rainie
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+        device_type = "Razer Kraken 7.1 V2\n"; // Kylie
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+        device_type = "Razer Kraken Ultimate\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+        device_type = "Razer Kraken Kitty V2\n";
+        break;
+
+    default:
+        device_type = "Unknown Device\n";
+    }
+
+    return sprintf(buf, device_type);
+}
+
+/**
+ * Write device file "test"
+ *
+ * Does nothing
+ */
+static ssize_t razer_attr_write_test(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;
+}
+
+/**
+ * Read device file "test"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_test(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "\n");
+}
+
+/**
+ * Write device file "mode_spectrum"
+ *
+ * Specrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x40, 0x01, device->led_mode_address);
+    union razer_kraken_effect_byte effect_byte = get_kraken_effect_byte();
+
+    // Spectrum Cycling | ON
+    effect_byte.bits.on_off_static = 1;
+    effect_byte.bits.spectrum_cycling = 1;
+
+    report.arguments[0] = effect_byte.value;
+
+    // Lock access to sending USB as adhering to the razer len*15ms delay
+    mutex_lock(&device->lock);
+    razer_kraken_send_control_msg(device->usb_dev, &report, 0);
+    mutex_unlock(&device->lock);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_none"
+ *
+ * None effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x40, 0x01, device->led_mode_address);
+    union razer_kraken_effect_byte effect_byte = get_kraken_effect_byte();
+
+    // Spectrum Cycling | OFF
+    effect_byte.bits.on_off_static = 0;
+    effect_byte.bits.spectrum_cycling = 0;
+
+    report.arguments[0] = effect_byte.value;
+
+    // Lock access to sending USB as adhering to the razer len*15ms delay
+    mutex_lock(&device->lock);
+    razer_kraken_send_control_msg(device->usb_dev, &report, 0);
+    mutex_unlock(&device->lock);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_static"
+ *
+ * Static effect mode is activated whenever the file is written to with 3 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report rgb_report = get_kraken_request_report(0x04, 0x40, count, device->breathing_address[0]);
+    struct razer_kraken_request_report effect_report = get_kraken_request_report(0x04, 0x40, 0x01, device->led_mode_address);
+    union razer_kraken_effect_byte effect_byte = get_kraken_effect_byte();
+
+    if (count != 3 && count != 4) {
+        printk(KERN_WARNING "razerkraken: Static mode only accepts RGB (3byte) or RGB with intensity (4byte)\n");
+        return -EINVAL;
+    }
+
+    rgb_report.arguments[0] = buf[0];
+    rgb_report.arguments[1] = buf[1];
+    rgb_report.arguments[2] = buf[2];
+
+    if(count == 4) {
+        rgb_report.arguments[3] = buf[3];
+    }
+
+    // ON/Static
+    effect_byte.bits.on_off_static = 1;
+    effect_report.arguments[0] = effect_byte.value;
+
+    // Lock sending of the 2 commands
+    mutex_lock(&device->lock);
+
+    // Basically Kraken Classic doesn't take RGB arguments so only do it for the KrakenV1,V2,Ultimate
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN:
+    case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+    case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report, 0);
+        break;
+    }
+
+    // Send Set static command
+    razer_kraken_send_control_msg(device->usb_dev, &effect_report, 0);
+    mutex_unlock(&device->lock);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_custom"
+ *
+ * Custom effect mode is activated whenever the file is written to with 3 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_custom(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report rgb_report = get_kraken_request_report(0x04, 0x40, count, device->custom_address);
+    struct razer_kraken_request_report effect_report = get_kraken_request_report(0x04, 0x40, 0x01, device->led_mode_address);
+    union razer_kraken_effect_byte effect_byte = get_kraken_effect_byte();
+
+    if(count != 3 && count != 4) {
+        printk(KERN_WARNING "razerkraken: Custom mode only accepts RGB (3byte) or RGB with intensity (4byte)\n");
+        return -EINVAL;
+    }
+
+    rgb_report.arguments[0] = buf[0];
+    rgb_report.arguments[1] = buf[1];
+    rgb_report.arguments[2] = buf[2];
+
+    if(count == 4) {
+        rgb_report.arguments[3] = buf[3];
+    }
+
+    // ON/Static
+    effect_byte.bits.on_off_static = 1;
+    effect_report.arguments[0] = 1; //effect_byte.value;
+
+    // Lock sending of the 2 commands
+    mutex_lock(&device->lock);
+    razer_kraken_send_control_msg(device->usb_dev, &rgb_report, 1);
+
+    razer_kraken_send_control_msg(device->usb_dev, &effect_report, 1);
+    mutex_unlock(&device->lock);
+
+    return count;
+}
+
+/**
+ * Read device file "mode_static"
+ *
+ * Returns 4 bytes for config
+ */
+static ssize_t razer_attr_read_matrix_effect_static(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    return get_rgb_from_addr(dev, device->breathing_address[0], 0x04, buf);
+}
+
+/**
+ * Read device file "mode_custom"
+ *
+ * Returns 4 bytes for config
+ */
+static ssize_t razer_attr_read_matrix_effect_custom(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    return get_rgb_from_addr(dev, device->custom_address, 0x04, buf);
+}
+
+/**
+ * Write device file "mode_breath"
+ *
+ * Breathing effect mode is activated whenever the file is written to with 3,6 or 9 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report effect_report = get_kraken_request_report(0x04, 0x40, 0x01, device->led_mode_address);
+    union razer_kraken_effect_byte effect_byte = get_kraken_effect_byte();
+
+    // Short circuit here as rainie only does breathing1
+    if(device->usb_pid == USB_DEVICE_ID_RAZER_KRAKEN && count != 3) {
+        printk(KERN_WARNING "razerkraken: Breathing mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    if(count == 3) {
+        struct razer_kraken_request_report rgb_report = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[0]);
+
+        rgb_report.arguments[0] = buf[0];
+        rgb_report.arguments[1] = buf[1];
+        rgb_report.arguments[2] = buf[2];
+
+        // ON/Static
+        effect_byte.bits.on_off_static = 1;
+        effect_byte.bits.single_colour_breathing = 1;
+        effect_byte.bits.sync = 1;
+        effect_report.arguments[0] = effect_byte.value;
+
+        // Lock sending of the 2 commands
+        mutex_lock(&device->lock);
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &effect_report, 0);
+        mutex_unlock(&device->lock);
+    } else if(count == 6) {
+        struct razer_kraken_request_report rgb_report  = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[1]);
+        struct razer_kraken_request_report rgb_report2 = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[1]+4); // Address the 2nd set of colours
+
+        rgb_report.arguments[0] = buf[0];
+        rgb_report.arguments[1] = buf[1];
+        rgb_report.arguments[2] = buf[2];
+        rgb_report2.arguments[0] = buf[3];
+        rgb_report2.arguments[1] = buf[4];
+        rgb_report2.arguments[2] = buf[5];
+
+        // ON/Static
+        effect_byte.bits.on_off_static = 1;
+        effect_byte.bits.two_colour_breathing = 1;
+        effect_byte.bits.sync = 1;
+        effect_report.arguments[0] = effect_byte.value;
+
+        // Lock sending of the 2 commands
+        mutex_lock(&device->lock);
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report2, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &effect_report, 0);
+        mutex_unlock(&device->lock);
+
+    } else if(count == 9) {
+        struct razer_kraken_request_report rgb_report  = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[2]);
+        struct razer_kraken_request_report rgb_report2 = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[2]+4); // Address the 2nd set of colours
+        struct razer_kraken_request_report rgb_report3 = get_kraken_request_report(0x04, 0x40, 0x03, device->breathing_address[2]+8); // Address the 3rd set of colours
+
+        rgb_report.arguments[0] = buf[0];
+        rgb_report.arguments[1] = buf[1];
+        rgb_report.arguments[2] = buf[2];
+        rgb_report2.arguments[0] = buf[3];
+        rgb_report2.arguments[1] = buf[4];
+        rgb_report2.arguments[2] = buf[5];
+        rgb_report3.arguments[0] = buf[6];
+        rgb_report3.arguments[1] = buf[7];
+        rgb_report3.arguments[2] = buf[8];
+
+        // ON/Static
+        effect_byte.bits.on_off_static = 1;
+        effect_byte.bits.three_colour_breathing = 1;
+        effect_byte.bits.sync = 1;
+        effect_report.arguments[0] = effect_byte.value;
+
+        // Lock sending of the 2 commands
+        mutex_lock(&device->lock);
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report2, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &rgb_report3, 0);
+
+        razer_kraken_send_control_msg(device->usb_dev, &effect_report, 0);
+        mutex_unlock(&device->lock);
+
+    } else {
+        printk(KERN_WARNING "razerkraken: Breathing mode only accepts RGB (3byte), RGB RGB (6byte) or RGB RGB RGB (9byte)\n");
+        return -EINVAL;
+    }
+
+    return count;
+}
+
+/**
+ * Read device file "mode_breath"
+ *
+ * Returns 4, 8, 12 bytes for config
+ */
+static ssize_t razer_attr_read_matrix_effect_breath(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    union razer_kraken_effect_byte effect_byte;
+    unsigned char num_colours = 1;
+
+    effect_byte.value = get_current_effect(dev);
+
+    if(effect_byte.bits.two_colour_breathing == 1) {
+        num_colours = 2;
+    } else if(effect_byte.bits.three_colour_breathing == 1) {
+        num_colours = 3;
+    }
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+    case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+        switch(num_colours) {
+        case 3:
+            return get_rgb_from_addr(dev, device->breathing_address[2], 0x0C, buf);
+            break;
+        case 2:
+            return get_rgb_from_addr(dev, device->breathing_address[1], 0x08, buf);
+            break;
+        default:
+            return get_rgb_from_addr(dev, device->breathing_address[0], 0x04, buf);
+            break;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_KRAKEN:
+    default:
+        return get_rgb_from_addr(dev, device->breathing_address[0], 0x04, buf);
+        break;
+    }
+}
+
+/**
+ * Read device file "serial"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_serial(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x20, 0x16, 0x7f00);
+
+    // Basically some simple caching
+    // Also skips going to device if it doesn't contain the serial
+    if(device->serial[0] == '\0') {
+
+        mutex_lock(&device->lock);
+        device->data[0] = 0x00;
+        razer_kraken_send_control_msg(device->usb_dev, &report, 1);
+        msleep(25); // Sleep 20ms
+
+        // Check for actual data
+        if(device->data[0] == 0x05) {
+            // Serial is present
+            memcpy(&device->serial[0], &device->data[1], 22);
+            device->serial[22] = '\0';
+        } else {
+            printk(KERN_CRIT "razerkraken: Did not manage to get serial from device, using XX01 instead\n");
+            device->serial[0] = 'X';
+            device->serial[1] = 'X';
+            device->serial[2] = '0';
+            device->serial[3] = '1';
+            device->serial[4] = '\0';
+        }
+        mutex_unlock(&device->lock);
+
+    }
+
+    return sprintf(buf, "%s\n", &device->serial[0]);
+}
+
+/**
+ * Read device file "get_firmware_version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_firmware_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(dev);
+    struct razer_kraken_request_report report = get_kraken_request_report(0x04, 0x20, 0x02, 0x0030);
+
+    // Basically some simple caching
+    if(device->firmware_version[0] != 1) {
+
+        mutex_lock(&device->lock);
+        device->data[0] = 0x00;
+        razer_kraken_send_control_msg(device->usb_dev, &report, 1);
+        msleep(25); // Sleep 20ms
+
+        // Check for actual data
+        if(device->data[0] == 0x05) {
+            // Serial is present
+            device->firmware_version[0] = 1;
+            device->firmware_version[1] = device->data[1];
+            device->firmware_version[2] = device->data[2];
+        } else {
+            printk(KERN_CRIT "razerkraken: Did not manage to get firmware version from device, using v9.99 instead\n");
+            device->firmware_version[0] = 1;
+            device->firmware_version[1] = 0x09;
+            device->firmware_version[2] = 0x99;
+        }
+        mutex_unlock(&device->lock);
+    }
+
+    return sprintf(buf, "v%x.%x\n", device->firmware_version[1], device->firmware_version[2]);
+}
+
+/**
+ * Read device file "matrix_current_effect"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_matrix_current_effect(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    unsigned char current_effect = get_current_effect(dev);
+
+    return sprintf(buf, "%02x\n", current_effect);
+}
+
+/**
+ * Write device file "device_mode"
+ */
+static ssize_t razer_attr_write_device_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return count;
+}
+
+/**
+ * Read device file "device_mode"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    buf[0] = 0x00;
+    buf[1] = 0x00;
+
+    return 2;
+}
+
+/**
+ * Set up the device driver files
+
+ *
+ * Read only is 0444
+ * Write only is 0220
+ * Read and write is 0664
+ */
+
+static DEVICE_ATTR(test,                    0660, razer_attr_read_test,                       razer_attr_write_test);
+static DEVICE_ATTR(version,                 0440, razer_attr_read_version,                    NULL);
+static DEVICE_ATTR(device_type,             0440, razer_attr_read_device_type,                NULL);
+static DEVICE_ATTR(device_serial,           0440, razer_attr_read_device_serial,              NULL);
+static DEVICE_ATTR(device_mode,             0660, razer_attr_read_device_mode,                razer_attr_write_device_mode);
+static DEVICE_ATTR(firmware_version,        0440, razer_attr_read_firmware_version,           NULL);
+
+static DEVICE_ATTR(matrix_current_effect,   0440, razer_attr_read_matrix_current_effect,      NULL);
+static DEVICE_ATTR(matrix_effect_none,      0220, NULL,                                       razer_attr_write_matrix_effect_none);
+static DEVICE_ATTR(matrix_effect_spectrum,  0220, NULL,                                       razer_attr_write_matrix_effect_spectrum);
+static DEVICE_ATTR(matrix_effect_static,    0660, razer_attr_read_matrix_effect_static,       razer_attr_write_matrix_effect_static);
+static DEVICE_ATTR(matrix_effect_custom,    0660, razer_attr_read_matrix_effect_custom,       razer_attr_write_matrix_effect_custom);
+static DEVICE_ATTR(matrix_effect_breath,    0660, razer_attr_read_matrix_effect_breath,       razer_attr_write_matrix_effect_breath);
+
+static void razer_kraken_init(struct razer_kraken_device *dev, struct usb_interface *intf)
+{
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    unsigned int rand_serial = 0;
+
+    // Initialise mutex
+    mutex_init(&dev->lock);
+    // Setup values
+    dev->usb_dev = usb_dev;
+    dev->usb_interface_protocol = intf->cur_altsetting->desc.bInterfaceProtocol;
+    dev->usb_vid = usb_dev->descriptor.idVendor;
+    dev->usb_pid = usb_dev->descriptor.idProduct;
+
+    switch(dev->usb_pid) {
+    case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+    case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+    case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+        dev->led_mode_address = KYLIE_SET_LED_ADDRESS;
+        dev->custom_address = KYLIE_CUSTOM_ADDRESS_START;
+        dev->breathing_address[0] = KYLIE_BREATHING1_ADDRESS_START;
+        dev->breathing_address[1] = KYLIE_BREATHING2_ADDRESS_START;
+        dev->breathing_address[2] = KYLIE_BREATHING3_ADDRESS_START;
+        break;
+    case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC:
+    case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT:
+    case USB_DEVICE_ID_RAZER_KRAKEN:
+        dev->led_mode_address = RAINIE_SET_LED_ADDRESS;
+        dev->custom_address = RAINIE_CUSTOM_ADDRESS_START;
+        dev->breathing_address[0] = RAINIE_BREATHING1_ADDRESS_START;
+
+        // Get a "random" integer
+        get_random_bytes(&rand_serial, sizeof(unsigned int));
+        sprintf(&dev->serial[0], "HN%015u", rand_serial);
+        break;
+    }
+}
+
+/**
+ * Probe method is ran whenever a device is binded to the driver
+ */
+static int razer_kraken_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+    int retval = 0;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    struct razer_kraken_device *dev = NULL;
+
+    dev = kzalloc(sizeof(struct razer_kraken_device), GFP_KERNEL);
+    if(dev == NULL) {
+        dev_err(&intf->dev, "out of memory\n");
+        return -ENOMEM;
+    }
+
+    // Init data
+    razer_kraken_init(dev, intf);
+
+    if(dev->usb_interface_protocol == USB_INTERFACE_PROTOCOL_NONE) {
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_version);                               // Get driver version
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_test);                                  // Test mode
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_serial);                         // Get string of device serial
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_firmware_version);                      // Get string of device fw version
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_mode);                           // Get device mode
+
+        switch(dev->usb_pid) {
+        case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC:
+        case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_current_effect);         // Get current effect
+            break;
+        case USB_DEVICE_ID_RAZER_KRAKEN:
+        case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+        case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_current_effect);         // Get current effect
+            break;
+        }
+    }
+
+    dev_set_drvdata(&hdev->dev, dev);
+
+    if(hid_parse(hdev)) {
+        hid_err(hdev, "parse failed\n");
+        goto exit_free;
+    }
+
+    if (hid_hw_start(hdev, HID_CONNECT_DEFAULT)) {
+        hid_err(hdev, "hw start failed\n");
+        goto exit_free;
+    }
+
+    usb_disable_autosuspend(usb_dev);
+
+    return 0;
+
+exit_free:
+    kfree(dev);
+    return retval;
+}
+
+/**
+ * Unbind function
+ */
+static void razer_kraken_disconnect(struct hid_device *hdev)
+{
+    struct razer_kraken_device *dev;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+
+    dev = hid_get_drvdata(hdev);
+
+    if(dev->usb_interface_protocol == USB_INTERFACE_PROTOCOL_NONE) {
+        device_remove_file(&hdev->dev, &dev_attr_version);                               // Get driver version
+        device_remove_file(&hdev->dev, &dev_attr_test);                                  // Test mode
+        device_remove_file(&hdev->dev, &dev_attr_device_type);                           // Get string of device type
+        device_remove_file(&hdev->dev, &dev_attr_device_serial);                         // Get string of device serial
+        device_remove_file(&hdev->dev, &dev_attr_firmware_version);                      // Get string of device fw version
+        device_remove_file(&hdev->dev, &dev_attr_device_mode);                           // Get device mode
+
+        switch(dev->usb_pid) {
+        case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC:
+        case USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_current_effect);         // Get current effect
+            break;
+
+        case USB_DEVICE_ID_RAZER_KRAKEN:
+        case USB_DEVICE_ID_RAZER_KRAKEN_V2:
+        case USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE:
+        case USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);            // No effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);        // Spectrum effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);          // Static effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);          // Custom effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);          // Breathing effect
+            device_remove_file(&hdev->dev, &dev_attr_matrix_current_effect);         // Get current effect
+            break;
+        }
+    }
+
+    hid_hw_stop(hdev);
+    kfree(dev);
+    dev_info(&intf->dev, "Razer Device disconnected\n");
+}
+
+static int razer_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)
+{
+    struct razer_kraken_device *device = dev_get_drvdata(&hdev->dev);
+
+    //printk(KERN_WARNING "razerkraken: Got raw message %d\n", size);
+
+    if(size == 33) { // Should be a response to a Control packet
+        memcpy(&device->data[0], &data[0], size);
+
+    } else {
+        printk(KERN_WARNING "razerkraken: Got raw message, length: %d\n", size);
+    }
+
+    return 0;
+}
+
+/**
+ * Device ID mapping table
+ */
+static const struct hid_device_id razer_devices[] = {
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2) },
+    { 0 }
+};
+
+MODULE_DEVICE_TABLE(hid, razer_devices);
+
+/**
+ * Describes the contents of the driver
+ */
+static struct hid_driver razer_kraken_driver = {
+    .name = "razerkraken",
+    .id_table = razer_devices,
+    .probe = razer_kraken_probe,
+    .remove = razer_kraken_disconnect,
+    .raw_event = razer_raw_event
+};
+
+module_hid_driver(razer_kraken_driver);
diff --git a/drivers/custom/razer/driver/razerkraken_driver.h b/drivers/custom/razer/driver/razerkraken_driver.h
new file mode 100644
index 000000000000..30865bf950bf
--- /dev/null
+++ b/drivers/custom/razer/driver/razerkraken_driver.h
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef __HID_RAZER_KRAKEN_H
+#define __HID_RAZER_KRAKEN_H
+
+#define USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC 0x0501
+#define USB_DEVICE_ID_RAZER_KRAKEN 0x0504 // Codename Rainie
+#define USB_DEVICE_ID_RAZER_KRAKEN_CLASSIC_ALT 0x0506
+#define USB_DEVICE_ID_RAZER_KRAKEN_V2 0x0510 // Codename Kylie
+#define USB_DEVICE_ID_RAZER_KRAKEN_ULTIMATE 0x0527
+#define USB_DEVICE_ID_RAZER_KRAKEN_KITTY_V2 0x0560
+
+#define USB_INTERFACE_PROTOCOL_NONE 0
+
+// #define RAZER_KRAKEN_V2_REPORT_LEN ?
+
+struct razer_kraken_device {
+    struct usb_device *usb_dev;
+    struct mutex lock;
+    unsigned char usb_interface_protocol;
+    unsigned short usb_pid;
+    unsigned short usb_vid;
+
+    // Will be set with the correct address for setting LED mode for each device
+    unsigned short led_mode_address;
+    unsigned short custom_address;
+    unsigned short breathing_address[3];
+
+    char serial[23];
+    // 3 Bytes, first byte is whether fw version is collected, 2nd byte is major version, 3rd is minor, should be printed out in hex form as are bcd
+    unsigned char firmware_version[3];
+
+    u8 data[33];
+
+};
+
+union razer_kraken_effect_byte {
+    unsigned char value;
+    struct razer_kraken_effect_byte_bits {
+        unsigned char on_off_static :1;
+        unsigned char single_colour_breathing :1;
+        unsigned char spectrum_cycling :1;
+        unsigned char sync :1;
+        unsigned char two_colour_breathing :1;
+        unsigned char three_colour_breathing :1;
+    } bits;
+};
+
+/*
+ * Should wait 15ms per write to EEPROM
+ *
+ * Report ID:
+ *   0x04 - Output ID for memory access
+ *   0x05 - Input ID for memory access result
+ *
+ * Destination:
+ *   0x20 - Read data from EEPROM
+ *   0x40 - Write data to RAM
+ *   0x00 - Read data from RAM
+ *
+ * Address:
+ *   RAM - Both
+ *   0x1189 - Custom effect Colour1 Red
+ *   0x118A - Custom effect Colour1 Green
+ *   0x118B - Custom effect Colour1 Blue
+ *   0x118C - Custom effect Colour1 Intensity
+ *
+ *   RAM - Kylie
+ *   0x172D - Set LED Effect, see note 1
+ *   0x1741 - Static/Breathing1 Colour1 Red
+ *   0x1742 - Static/Breathing1 Colour1 Green
+ *   0x1743 - Static/Breathing1 Colour1 Blue
+ *   0x1744 - Static/Breathing1 Colour1 Intensity
+ *
+ *   0x1745 - Breathing2 Colour1 Red
+ *   0x1746 - Breathing2 Colour1 Green
+ *   0x1747 - Breathing2 Colour1 Blue
+ *   0x1748 - Breathing2 Colour1 Intensity
+ *   0x1749 - Breathing2 Colour2 Red
+ *   0x174A - Breathing2 Colour2 Green
+ *   0x174B - Breathing2 Colour2 Blue
+ *   0x174C - Breathing2 Colour2 Intensity
+ *
+ *   0x174D - Breathing3 Colour1 Red
+ *   0x174E - Breathing3 Colour1 Green
+ *   0x174F - Breathing3 Colour1 Blue
+ *   0x1750 - Breathing3 Colour1 Intensity
+ *   0x1751 - Breathing3 Colour2 Red
+ *   0x1752 - Breathing3 Colour2 Green
+ *   0x1753 - Breathing3 Colour2 Blue
+ *   0x1754 - Breathing3 Colour2 Intensity
+ *   0x1755 - Breathing3 Colour3 Red
+ *   0x1756 - Breathing3 Colour3 Green
+ *   0x1757 - Breathing3 Colour3 Blue
+ *   0x1758 - Breathing3 Colour3 Intensity
+ *
+ *   RAM - Rainie
+ *   0x1008 - Set LED Effect, see note 1
+ *   0x15DE - Static/Breathing1 Colour1 Red
+ *   0x15DF - Static/Breathing1 Colour1 Green
+ *   0x15E0 - Static/Breathing1 Colour1 Blue
+ *   0x15E1 - Static/Breathing1 Colour1 Intensity
+ *
+ *   EEPROM
+ *   0x0030 - Firmware version, 2 byted BCD
+ *   0x7f00 - Serial Number - 22 Bytes
+ *
+ *
+ * Note 1:
+ *   Takes one byte which is a bitfield (0 being the rightmost byte 76543210)
+ *     - Bit 0 = LED ON/OFF = 1/0 Static
+ *     - Bit 1 = Single Colour Breathing ON/OFF, 1/0
+ *     - Bit 2 = Spectrum Cycling
+ *     - Bit 3 = Sync = 1
+ *     - Bit 4 = 2 Colour breathing ON/OFF = 1/0
+ *     - Bit 5 = 3 Colour breathing ON/OFF = 1/0
+ *   E.g.
+ *    7   6  5  4  3  2  1  0
+ *    128 64 32 16 8  4  2  1
+ *    =====================================================
+ *    0   0  0  0  0  1  0  1 0x05 Spectrum Cycling on
+ *
+ * Note 2:
+ *   Razer Kraken Classic uses 0x1008 for Logo LED on off.
+ * */
+
+#define KYLIE_SET_LED_ADDRESS 0x172D
+#define RAINIE_SET_LED_ADDRESS 0x1008
+
+#define KYLIE_CUSTOM_ADDRESS_START 0x1189
+#define RAINIE_CUSTOM_ADDRESS_START 0x1189
+
+#define KYLIE_BREATHING1_ADDRESS_START 0x1741
+#define RAINIE_BREATHING1_ADDRESS_START 0x15DE
+
+#define KYLIE_BREATHING2_ADDRESS_START 0x1745
+#define KYLIE_BREATHING3_ADDRESS_START 0x174D
+
+struct razer_kraken_request_report {
+    unsigned char report_id;
+    unsigned char destination;
+    unsigned char length;
+    unsigned char addr_h;
+    unsigned char addr_l;
+    unsigned char arguments[32];
+};
+
+struct razer_kraken_response_report {
+    unsigned char report_id;
+    unsigned char arguments[36];
+};
+
+#endif
diff --git a/drivers/custom/razer/driver/razermouse_driver.c b/drivers/custom/razer/driver/razermouse_driver.c
new file mode 100644
index 000000000000..33b13fdc731d
--- /dev/null
+++ b/drivers/custom/razer/driver/razermouse_driver.c
@@ -0,0 +1,7211 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb/input.h>
+#include <linux/hid.h>
+#include <linux/hrtimer.h>
+#include <linux/random.h>
+#include <linux/version.h>
+
+#include "razermouse_driver.h"
+#include "razercommon.h"
+#include "razerchromacommon.h"
+
+/*
+ * Version Information
+ */
+#define DRIVER_DESC "Razer Mouse Device Driver"
+
+/* REL_HWHEEL_HI_RES was added in Linux 5.0, so define ourselves for older kernels
+ * See also https://git.kernel.org/torvalds/c/52ea899 */
+#ifndef REL_HWHEEL_HI_RES
+#define REL_HWHEEL_HI_RES 0x0c
+#endif
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE(DRIVER_LICENSE);
+
+/**
+ * Send report to the mouse
+ */
+static int razer_get_report(struct usb_device *usb_dev, struct razer_report *request, struct razer_report *response)
+{
+    unsigned int index = 0;
+    switch (usb_dev->descriptor.idProduct) {
+    // These devices require longer waits to read their firmware, serial, and other setting values
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+        return razer_get_usb_response(usb_dev, index, request, index, response, RAZER_NEW_MOUSE_RECEIVER_WAIT_MIN_US, RAZER_NEW_MOUSE_RECEIVER_WAIT_MAX_US);
+        break;
+
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+        return razer_get_usb_response(usb_dev, index, request, index, response, RAZER_ATHERIS_RECEIVER_WAIT_MIN_US, RAZER_ATHERIS_RECEIVER_WAIT_MAX_US);
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        return razer_get_usb_response(usb_dev, index, request, index, response, RAZER_VIPER_MOUSE_RECEIVER_WAIT_MIN_US, RAZER_VIPER_MOUSE_RECEIVER_WAIT_MAX_US);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+        index = 0x03;
+        return razer_get_usb_response(usb_dev, index, request, index, response, RAZER_MOUSE_WAIT_MIN_US, RAZER_MOUSE_WAIT_MAX_US);
+        break;
+
+    default:
+        return razer_get_usb_response(usb_dev, index, request, index, response, RAZER_MOUSE_WAIT_MIN_US, RAZER_MOUSE_WAIT_MAX_US);
+    }
+}
+
+/**
+ * Function to send to device, get response, and actually check the response
+ */
+static int razer_send_payload(struct razer_mouse_device *device, struct razer_report *request, struct razer_report *response)
+{
+    int err;
+
+    request->crc = razer_calculate_crc(request);
+
+    mutex_lock(&device->lock);
+    err = razer_get_report(device->usb_dev, request, response);
+    mutex_unlock(&device->lock);
+    if (err) {
+        print_erroneous_report(response, "razermouse", "Invalid Report Length");
+        return err;
+    }
+
+    /* Check the packet number, class and command are the same */
+    if (response->remaining_packets != request->remaining_packets ||
+        response->command_class != request->command_class ||
+        response->command_id.id != request->command_id.id) {
+        print_erroneous_report(response, "razermouse", "Response doesn't match request");
+        return -EIO;
+    }
+
+    switch (response->status) {
+    case RAZER_CMD_BUSY:
+        // TODO: Check if this should be an error.
+        // print_erroneous_report(&response, "razermouse", "Device is busy");
+        break;
+    case RAZER_CMD_FAILURE:
+        print_erroneous_report(response, "razermouse", "Command failed");
+        return -EIO;
+    case RAZER_CMD_NOT_SUPPORTED:
+        print_erroneous_report(response, "razermouse", "Command not supported");
+        return -EIO;
+    case RAZER_CMD_TIMEOUT:
+        print_erroneous_report(response, "razermouse", "Command timed out");
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/*
+ * Specific functions for ancient devices
+ *
+ */
+static int deathadder3_5g_set_led_state(struct razer_mouse_device *device, unsigned char led_id, bool enabled)
+{
+    switch (led_id) {
+    case SCROLL_WHEEL_LED:
+        if (enabled) {
+            device->da3_5g.leds |= 0x02;
+        } else {
+            device->da3_5g.leds &= ~(0x02);
+        }
+        break;
+
+    case LOGO_LED:
+        if (enabled) {
+            device->da3_5g.leds |= 0x01;
+        } else {
+            device->da3_5g.leds &= ~(0x01);
+        }
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: Invalid led_id on DeathAdder 3.5G\n");
+        return -EINVAL;
+    }
+
+    mutex_lock(&device->lock);
+    razer_send_control_msg_old_device(device->usb_dev, &device->da3_5g, 0x10, 0x00, 4, 3000, 3000);
+    mutex_unlock(&device->lock);
+
+    return 0;
+}
+
+static void deathadder3_5g_set_poll_rate(struct razer_mouse_device *device, unsigned short poll_rate)
+{
+    switch(poll_rate) {
+    case 1000:
+        device->da3_5g.poll = 1;
+        break;
+    case 500:
+        device->da3_5g.poll = 2;
+        break;
+    case 125:
+        device->da3_5g.poll = 3;
+        break;
+    default: // 500
+        device->da3_5g.poll = 2;
+        break;
+    }
+
+    mutex_lock(&device->lock);
+    razer_send_control_msg_old_device(device->usb_dev, &device->da3_5g, 0x10, 0x00, 4, 3000, 3000);
+    mutex_unlock(&device->lock);
+}
+
+static void deathadder3_5g_set_dpi(struct razer_mouse_device *device, unsigned short dpi)
+{
+    switch(dpi) {
+    case 450:
+        device->da3_5g.dpi = 4;
+        break;
+    case 900:
+        device->da3_5g.dpi = 3;
+        break;
+    case 1800:
+        device->da3_5g.dpi = 2;
+        break;
+    case 3500:
+    default:
+        device->da3_5g.dpi = 1;
+        break;
+    }
+
+    mutex_lock(&device->lock);
+    razer_send_control_msg_old_device(device->usb_dev, &device->da3_5g, 0x10, 0x00, 4, 3000, 3000);
+    mutex_unlock(&device->lock);
+}
+
+static int orochi_2011_set_led_state(struct razer_mouse_device *device, unsigned char led_id, bool enabled)
+{
+    switch (led_id) {
+    case SCROLL_WHEEL_LED:
+        if (enabled) {
+            device->orochi2011.led |= 0b00000001;
+        } else {
+            device->orochi2011.led &= 0b11111110;
+        }
+        break;
+    case LOGO_LED:
+        if (enabled) {
+            device->orochi2011.led |= 0b00000010;
+        } else {
+            device->orochi2011.led &= 0b11111101;
+        }
+        break;
+    default:
+        printk(KERN_WARNING "razermouse: Invalid led_id on Orochi 2011\n");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*
+ * New functions
+ */
+
+/**
+ * Read device file "version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", DRIVER_VERSION);
+}
+
+/**
+ * Read device file "device_type"
+ *
+ * Returns friendly string of device type
+ */
+static ssize_t razer_attr_read_device_type(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+
+    char *device_type;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+        device_type = "Razer DeathAdder 3.5G\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        device_type = "Razer DeathAdder 3.5G Black\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+        device_type = "Razer Mamba 2012 (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+        device_type = "Razer Mamba 2012 (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+        device_type = "Razer Mamba (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+        device_type = "Razer Mamba (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+        device_type = "Razer Mamba Tournament Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS:
+        device_type = "Razer Abyssus 2014\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+        device_type = "Razer Abyssus 1800\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_2000:
+        device_type = "Razer Abyssus 2000\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_IMPERATOR:
+        device_type = "Razer Imperator 2012\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OUROBOROS:
+        device_type = "Razer Ouroboros\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        device_type = "Razer Orochi 2011\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+        device_type = "Razer DeathAdder 2013\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2013:
+        device_type = "Razer Orochi 2013\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+        device_type = "Razer Orochi (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+        device_type = "Razer DeathAdder Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+        device_type = "Razer Naga Hex (Red)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX:
+        device_type = "Razer Naga Hex\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA:
+        device_type = "Razer Naga\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_2012:
+        device_type = "Razer Naga 2012\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+        device_type = "Razer Naga Epic\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_2014:
+        device_type = "Razer Naga 2014\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_TAIPAN:
+        device_type = "Razer Taipan\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        device_type = "Razer Naga Hex V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+        device_type = "Razer Naga Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+        device_type = "Razer Naga X\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+        device_type = "Razer DeathAdder Elite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+        device_type = "Razer Abyssus V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        device_type = "Razer Diamondback Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+        device_type = "Razer DeathAdder 3500\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+        device_type = "Razer Lancehead (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+        device_type = "Razer Lancehead (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+        device_type = "Razer Lancehead Tournament Edition\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+        device_type = "Razer Mamba Elite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+        device_type = "Razer DeathAdder Essential\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+        device_type = "Razer DeathAdder Essential (2021)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+        device_type = "Razer Naga Trinity\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+        device_type = "Razer DeathAdder 1800\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+        device_type = "Razer Lancehead Wireless (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+        device_type = "Razer Lancehead Wireless (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+        device_type = "Razer Mamba Wireless (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+        device_type = "Razer Mamba Wireless (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+        device_type = "Razer Abyssus Elite (D.Va Edition)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+        device_type = "Razer Abyssus Essential\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+        device_type = "Razer DeathAdder Essential (White Edition)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER:
+        device_type = "Razer Viper\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+        device_type = "Razer Viper Mini\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+        device_type = "Razer Viper Mini Signature Edition (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+        device_type = "Razer Viper Mini Signature Edition (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+        device_type = "Razer Viper Ultimate (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+        device_type = "Razer Viper Ultimate (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+        device_type = "Razer Viper V2 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+        device_type = "Razer Viper V2 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK:
+        device_type = "Razer Basilisk\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+        device_type = "Razer Basilisk Essential\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+        device_type = "Razer Basilisk Ultimate (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+        device_type = "Razer Basilisk Ultimate (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+        device_type = "Razer Basilisk V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+        device_type = "Razer Basilisk V3\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+        device_type = "Razer DeathAdder V2\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+        device_type = "Razer DeathAdder V2 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+        device_type = "Razer DeathAdder V2 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+        device_type = "Razer DeathAdder V3\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+        device_type = "Razer DeathAdder V3 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+        device_type = "Razer DeathAdder V3 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+        device_type = "Razer DeathAdder V3 HyperSpeed (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+        device_type = "Razer DeathAdder V3 HyperSpeed (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+        device_type = "Razer HyperPolling Wireless Dongle\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+        device_type = "Razer Basilisk V3 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+        device_type = "Razer Basilisk V3 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+        device_type = "Razer Basilisk V3 35K\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+        device_type = "Razer Basilisk V3 Pro 35K (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        device_type = "Razer Basilisk V3 Pro 35K (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        device_type = "Razer DeathAdder V2 Mini\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+        device_type = "Razer DeathAdder 2000\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+        device_type = "Razer DeathAdder V2 X HyperSpeed\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+        device_type = "Razer Atheris (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED:
+        device_type = "Razer Basilisk X HyperSpeed\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+        device_type = "Razer Naga Left-Handed Edition 2020\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+        device_type = "Razer Naga Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+        device_type = "Razer Naga Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+        device_type = "Razer Viper 8KHz\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+        device_type = "Razer Orochi V2 (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+        device_type = "Razer Orochi V2 (Bluetooth)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+        device_type = "Razer Pro Click (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+        device_type = "Razer Pro Click (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+        device_type = "Razer Naga Epic Chroma\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+        device_type = "Razer Naga Epic Chroma Dock\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+        device_type = "Razer Pro Click Mini (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+        device_type = "Razer DeathAdder V2 Lite\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_COBRA:
+        device_type = "Razer Cobra\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+        device_type = "Razer Cobra Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+        device_type = "Razer Cobra Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+        device_type = "Razer Viper V3 HyperSpeed\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+        device_type = "Razer Naga V2 HyperSpeed (Receiver)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        device_type = "Razer Basilisk V3 X HyperSpeed\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+        device_type = "Razer Viper V3 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        device_type = "Razer Viper V3 Pro (Wireless)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+        device_type = "Razer Naga V2 Pro (Wired)\n";
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        device_type = "Razer Naga V2 Pro (Wireless)\n";
+        break;
+
+    default:
+        device_type = "Unknown Device\n";
+    }
+
+    return sprintf(buf, device_type);
+}
+
+/**
+ * Read device file "get_firmware_version"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_firmware_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_firmware_version();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:  // Orochi 2011 doesn't have FW
+        return sprintf(buf, "v%d.%d\n", 9, 99);
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G: // DA don't think supports fw, its proper old
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        return sprintf(buf, "v%d.%d\n", 0x01, 0x00);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "v%d.%d\n", response.arguments[0], response.arguments[1]);
+}
+
+/**
+ * Write device file "test"
+ *
+ * Writes the colour segments on the mouse.
+ */
+static ssize_t razer_attr_write_test(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char enabled = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_set_led_state(VARSTORE, LOGO_LED, enabled);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_none"
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS: // TODO: this is probably wrong?
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED: // TODO: this is probably wrong?
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_standard_matrix_effect_none();
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_none not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_custom"
+ *
+ * Sets the mouse to custom mode whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_custom(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2: // TODO look into this think its extended effects
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_custom_frame();
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0x80;
+        break;
+
+    default:
+        request = razer_chroma_standard_matrix_effect_custom_frame(NOSTORE);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_static"
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razermouse: Static mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+        // Some sort of mode switcher required after initialization and before color switching
+        request = get_razer_report(0x0f, 0x02, 0x06);
+        request.arguments[0] = 0x00;
+        request.arguments[1] = 0x00;
+        request.arguments[2] = 0x08;
+        request.arguments[3] = 0x00;
+        request.arguments[4] = 0x00;
+        request.arguments[5] = 0x00;
+        request.transaction_id.id = 0x1f;
+
+        razer_send_payload(device, &request, &response);
+
+        request = razer_naga_trinity_effect_static((struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, ZERO_LED, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_static not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_wave"
+ *
+ * When 1 is written (as a character, 0x31) the wave effect is displayed moving up the mouse
+ * if 2 is written (0x32) then the wave effect goes down
+ */
+static ssize_t razer_attr_write_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, ZERO_LED, direction);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_wave not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_spectrum"
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_mouse_extended_matrix_effect_spectrum(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_spectrum not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_reactive"
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char speed;
+
+    if (count != 4) {
+        printk(KERN_WARNING "razermouse: Reactive only accepts Speed, RGB (4byte)\n");
+        return -EINVAL;
+    }
+
+    speed = (unsigned char)buf[0];
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_mouse_extended_matrix_effect_reactive(VARSTORE, BACKLIGHT_LED, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_reactive not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "mode_breath"
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_single(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0]);
+            request.transaction_id.id = 0x1f;
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_dual(VARSTORE, BACKLIGHT_LED, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            request.transaction_id.id = 0x1f;
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_random(VARSTORE, BACKLIGHT_LED);
+            request.transaction_id.id = 0x1f;
+            break;
+        }
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_breath not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "get_serial"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_serial(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    char serial_string[23];
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_serial();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED: // Doesn't have proper serial
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+        return sprintf(buf, "%s\n", &device->serial[0]);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+        request.transaction_id.id = 0x08;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+    strncpy(&serial_string[0], &response.arguments[0], 22);
+    serial_string[22] = '\0';
+
+    return sprintf(buf, "%s\n", &serial_string[0]);
+}
+
+/**
+ * Read device file "get_battery"
+ *
+ * Returns an integer which needs to be scaled from 0-255 -> 0-100
+ */
+static ssize_t razer_attr_read_charge_level(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_battery_level();
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Read device file "is_charging"
+ *
+ * Returns 0 when not charging, 1 when charging
+ */
+static ssize_t razer_attr_read_charge_status(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_charging_status();
+
+    switch (device->usb_pid) {
+    // Wireless mice that don't support is_charging
+    // Use AA batteries
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        return sprintf(buf, "0\n");
+        break;
+
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Write device file "set_charging_effect"
+ *
+ * Sets charging effect.
+ */
+static ssize_t razer_attr_write_charge_effect(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 1) {
+        printk(KERN_WARNING "razermouse: Incorrect number of bytes for setting the charging effect\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_misc_set_dock_charge_type(buf[0]);
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "set_charging_colour"
+ *
+ * Sets charging colour using 3 RGB bytes
+ */
+static ssize_t razer_attr_write_charge_colour(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    // First enable static charging effect
+    request = razer_chroma_misc_set_dock_charge_type(0x01);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    if (count != 3) {
+        printk(KERN_WARNING "razermouse: Charging colour mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_standard_set_led_rgb(NOSTORE, BATTERY_LED, (struct razer_rgb*)&buf[0]);
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "poll_rate"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_poll_rate(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short polling_rate = 0;
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        switch(device->da3_5g.poll) {
+        case 0x01:
+            polling_rate = 1000;
+            break;
+        case 0x02:
+            polling_rate = 500;
+            break;
+        case 0x03:
+            polling_rate = 125;
+            break;
+        }
+        return sprintf(buf, "%d\n", polling_rate);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_misc_get_polling_rate();
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+        request = razer_chroma_misc_get_polling_rate();
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request = razer_chroma_misc_get_polling_rate2();
+        request.transaction_id.id = 0x1f;
+
+        razer_send_payload(device, &request, &response);
+
+        switch(response.arguments[1]) {
+        case 0x01:
+            polling_rate = 8000;
+            break;
+        case 0x02:
+            polling_rate = 4000;
+            break;
+        case 0x04:
+            polling_rate = 2000;
+            break;
+        case 0x08:
+            polling_rate = 1000;
+            break;
+        case  0x10:
+            polling_rate = 500;
+            break;
+        case  0x40:
+            polling_rate = 125;
+            break;
+        }
+
+        return sprintf(buf, "%d\n", polling_rate);
+
+    default:
+        request = razer_chroma_misc_get_polling_rate();
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    if(device->usb_pid == USB_DEVICE_ID_RAZER_OROCHI_2011) {
+        response.arguments[0] = device->orochi2011.poll;
+    } else {
+        razer_send_payload(device, &request, &response);
+    }
+
+    switch(response.arguments[0]) {
+    case 0x01:
+        polling_rate = 1000;
+        break;
+    case  0x02:
+        polling_rate = 500;
+        break;
+    case  0x08:
+        polling_rate = 125;
+        break;
+    }
+
+    return sprintf(buf, "%d\n", polling_rate);
+}
+
+/**
+ * Write device file "poll_rate"
+ *
+ * Sets the poll rate
+ */
+static ssize_t razer_attr_write_poll_rate(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned short polling_rate = (unsigned short)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        deathadder3_5g_set_poll_rate(device, polling_rate);
+        return count;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        device->orochi2011.poll = polling_rate;
+        request = razer_chroma_misc_set_orochi2011_poll_dpi(device->orochi2011.poll, device->orochi2011.dpi, device->orochi2011.dpi);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_misc_set_polling_rate(polling_rate);
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+        request = razer_chroma_misc_set_polling_rate(polling_rate);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request = razer_chroma_misc_set_polling_rate2(polling_rate, 0x00);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request = razer_chroma_misc_set_polling_rate(polling_rate);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    // For certain devices, Razer sends each request once with 0x00 and once with 0x01
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+        request = razer_chroma_misc_set_polling_rate2(polling_rate, 0x01);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        break;
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request = razer_chroma_misc_set_polling_rate2(polling_rate, 0x01);
+        request.transaction_id.id = 0x1F;
+        razer_send_payload(device, &request, &response);
+        break;
+    }
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_brightness"
+ *
+ * Sets the brightness to the ASCII number written to this file.
+ */
+
+static ssize_t razer_attr_write_matrix_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+        request = razer_chroma_misc_set_dock_brightness(brightness);
+        request.transaction_id.id = 0xFF;
+        break;
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED: // TODO: Migrate to backlight_led_brightness
+        request = razer_chroma_standard_set_led_brightness(VARSTORE, BACKLIGHT_LED, brightness);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, ZERO_LED, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_brightness not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "matrix_brightness"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_matrix_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char brightness_index = 0x02;
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+        request = razer_chroma_misc_get_dock_brightness();
+        request.transaction_id.id = 0xFF;
+        brightness_index = 0x00;
+        break;
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED: // TODO: Migrate to backlight_led_brightness
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, BACKLIGHT_LED);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x1F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, ZERO_LED);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_brightness not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    if (response.status != RAZER_CMD_SUCCESSFUL) {
+        return 0;
+    }
+    // Brightness is at arg[0] for dock and arg[1] for led_brightness
+    return sprintf(buf, "%d\n", response.arguments[brightness_index]);
+}
+
+/**
+ * Write device file "set_mouse_dpi"
+ *
+ * Sets the mouse DPI to the unsigned short integer written to this file.
+ */
+static ssize_t razer_attr_write_dpi(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short dpi_x;
+    unsigned short dpi_y;
+    unsigned char dpi_x_byte;
+    unsigned char dpi_y_byte;
+    unsigned char varstore;
+
+    // So far I think imperator uses varstore
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        if(count == 2) {
+            dpi_x = (buf[0] << 8) | (buf[1] & 0xFF); // TODO make convenience function
+            deathadder3_5g_set_dpi(device, dpi_x);
+        } else {
+            printk(KERN_WARNING "razermouse: DPI requires 2 bytes\n");
+            return -EINVAL;
+        }
+        return count;
+        break;
+
+    // Damn naga hex only uses 1 byte per x, y dpi
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX:
+    case USB_DEVICE_ID_RAZER_NAGA:
+    case USB_DEVICE_ID_RAZER_NAGA_2012:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+        if(count == 1) {
+            dpi_x_byte = buf[0];
+            dpi_y_byte = buf[0];
+        } else if (count == 2) {
+            dpi_x_byte = buf[0];
+            dpi_y_byte = buf[1];
+        } else {
+            printk(KERN_WARNING "razermouse: DPI requires 1 byte or 2 bytes\n");
+            return -EINVAL;
+        }
+
+        request = razer_chroma_misc_set_dpi_xy_byte(dpi_x_byte, dpi_y_byte);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        return count;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        if(count == 1) {
+            dpi_x_byte = buf[0];
+            dpi_y_byte = buf[0];
+        } else if (count == 2) {
+            dpi_x_byte = buf[0];
+            dpi_y_byte = buf[1];
+        } else {
+            printk(KERN_WARNING "razermouse: DPI requires 1 byte or 2 bytes\n");
+            return -EINVAL;
+        }
+        device->orochi2011.dpi = dpi_x_byte;
+
+        request = razer_chroma_misc_set_orochi2011_poll_dpi(device->orochi2011.poll, dpi_x_byte, dpi_y_byte);
+        request.transaction_id.id = 0xFF;
+        razer_send_payload(device, &request, &response);
+        return count;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_OROCHI_2013:
+    case USB_DEVICE_ID_RAZER_IMPERATOR:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+        varstore = VARSTORE;
+        break;
+
+    default:
+        varstore = NOSTORE;
+        break;
+    }
+
+    if (count != 2 && count != 4) {
+        printk(KERN_WARNING "razermouse: DPI requires 2 bytes or 4 bytes\n");
+        return -EINVAL;
+    }
+
+    if (count == 2) {
+        dpi_x = (buf[0] << 8) | (buf[1] & 0xFF); // TODO make convenience function
+        request = razer_chroma_misc_set_dpi_xy(varstore, dpi_x, dpi_x);
+
+    } else if(count == 4) {
+        dpi_x = (buf[0] << 8) | (buf[1] & 0xFF); // Apparently the char buffer is rubbish, as buf[1] somehow can equal FFFFFF80????
+        dpi_y = (buf[2] << 8) | (buf[3] & 0xFF);
+
+        request = razer_chroma_misc_set_dpi_xy(varstore, dpi_x, dpi_y);
+    }
+
+    switch(device->usb_pid) { // New devices set the device ID properly
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "dpi"
+ *
+ * Gets the mouse DPI to the unsigned short integer written to this file.
+ */
+static ssize_t razer_attr_read_dpi(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short dpi_x;
+    unsigned short dpi_y;
+
+    // So far I think imperator uses varstore
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        switch(device->da3_5g.dpi) {
+        case 0x04:
+            dpi_x = 450;
+            break;
+        case 0x03:
+            dpi_x = 900;
+            break;
+        case 0x02:
+            dpi_x = 1800;
+            break;
+        case 0x01:
+        default:
+            dpi_x = 3500;
+            break;
+        }
+        return sprintf(buf, "%u\n", dpi_x);
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        return sprintf(buf, "%u:%u\n", device->orochi2011.dpi, device->orochi2011.dpi);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX:
+    case USB_DEVICE_ID_RAZER_NAGA:
+    case USB_DEVICE_ID_RAZER_NAGA_2012:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+        request = razer_chroma_misc_get_dpi_xy_byte();
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request = razer_chroma_misc_get_dpi_xy(NOSTORE);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2013:
+    case USB_DEVICE_ID_RAZER_IMPERATOR:
+        request = razer_chroma_misc_get_dpi_xy(VARSTORE);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_misc_get_dpi_xy(NOSTORE);
+        request.transaction_id.id = 0x3f;
+        break;
+
+    default:
+        request = razer_chroma_misc_get_dpi_xy(NOSTORE);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    // Byte, Byte for DPI not Short, Short
+    if (device->usb_pid == USB_DEVICE_ID_RAZER_NAGA_HEX ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_NAGA_HEX_RED ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_NAGA ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_NAGA_2012 ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_DEATHADDER_2013 ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_NAGA_EPIC ||
+        device->usb_pid == USB_DEVICE_ID_RAZER_ABYSSUS_1800) { // NagaHex is crap uses only byte for dpi
+        dpi_x = response.arguments[0];
+        dpi_y = response.arguments[1];
+    } else {
+        dpi_x = (response.arguments[1] << 8) | (response.arguments[2] & 0xFF); // Apparently the char buffer is rubbish, as buf[1] somehow can equal FFFFFF80????
+        dpi_y = (response.arguments[3] << 8) | (response.arguments[4] & 0xFF);
+    }
+
+    return sprintf(buf, "%u:%u\n", dpi_x, dpi_y);
+}
+
+/**
+ * Write device file "scroll_mode"
+ *
+ * Sets the scroll mode of the mouse.
+ */
+static ssize_t razer_attr_write_scroll_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned int scroll_mode;
+
+    if (kstrtouint(buf, 0, &scroll_mode) < 0 || scroll_mode > 1)
+        return -EINVAL;
+
+    request = razer_chroma_misc_set_scroll_mode(scroll_mode);
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "scroll_mode"
+ *
+ * Gets the scroll wheel mode from the mouse.
+ */
+static ssize_t razer_attr_read_scroll_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_scroll_mode();
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Write device file "scroll_acceleration"
+ *
+ * Sets the scroll acceleration mode of the mouse.
+ */
+static ssize_t razer_attr_write_scroll_acceleration(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    bool acceleration;
+
+    if (kstrtobool(buf, &acceleration) < 0)
+        return -EINVAL;
+
+    request = razer_chroma_misc_set_scroll_acceleration(acceleration);
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "scroll_acceleration"
+ *
+ * Gets the scroll acceleration mode of the mouse.
+ */
+static ssize_t razer_attr_read_scroll_acceleration(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_scroll_acceleration();
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+/**
+ * Write device file "scroll_smart_reel"
+ *
+ * Sets the scroll wheel "smart reel" mode of the mouse.
+ */
+static ssize_t razer_attr_write_scroll_smart_reel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    bool smart_reel;
+
+    if (kstrtobool(buf, &smart_reel) < 0)
+        return -EINVAL;
+
+    request = razer_chroma_misc_set_scroll_smart_reel(smart_reel);
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "scroll_smart_reel"
+ *
+ * Gets the scroll wheel "smart reel" state from the mouse.
+ */
+static ssize_t razer_attr_read_scroll_smart_reel(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_scroll_smart_reel();
+    request.transaction_id.id = 0x1f;
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[1]);
+}
+
+static ssize_t razer_attr_write_tilt_hwheel(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned int tilt_hwheel;
+    if (kstrtouint(buf, 0, &tilt_hwheel) < 0)
+        return -EINVAL;
+    device->tilt_hwheel = !!tilt_hwheel;
+    return count;
+}
+
+static ssize_t razer_attr_read_tilt_hwheel(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", device->tilt_hwheel);
+}
+
+static ssize_t razer_attr_write_tilt_repeat(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned int tilt_repeat;
+    if (kstrtouint(buf, 0, &tilt_repeat) < 0)
+        return -EINVAL;
+    device->tilt_repeat = tilt_repeat;
+    return count;
+}
+
+static ssize_t razer_attr_read_tilt_repeat(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", device->tilt_repeat);
+}
+
+static ssize_t razer_attr_write_tilt_repeat_delay(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned int tilt_repeat_delay;
+    if (kstrtouint(buf, 0, &tilt_repeat_delay) < 0)
+        return -EINVAL;
+    device->tilt_repeat_delay = tilt_repeat_delay;
+    return count;
+}
+
+static ssize_t razer_attr_read_tilt_repeat_delay(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    return sprintf(buf, "%u\n", device->tilt_repeat_delay);
+}
+
+/**
+ * Write device file "dpi_stages"
+ *
+ * Sets the mouse DPI stage.
+ * The number of DPI stages is hard limited by RAZER_MOUSE_MAX_DPI_STAGES.
+ *
+ * Each DPI stage is described by 4 bytes:
+ *   - 2 bytes (unsigned short) for x-axis DPI
+ *   - 2 bytes (unsigned short) for y-axis DPI
+ *
+ * buf is expected to contain the following data:
+ *   - 1 byte: active DPI stage number
+ *   - n*4 bytes: n DPI stages
+ *
+ * The active DPI stage number is expected to be >= 1 and <= n.
+ * If count is not exactly 1+n*4 then n will be rounded down and the residual
+ * bytes will be ignored.
+ *
+ * Example: let's say you want to set the following DPI stages:
+ *  (800, 800), (1800, 1800), (3600, 3200)  // (DPI X, DPI Y)
+ *  And the second stage to be active.
+ *
+ * You have to write to this file 1 byte and 6 unsigned shorts (big endian) = 13 bytes:
+ *   Active stage: 2
+ *   DPIs:          | 800 | 800 | 1800 | 1800 | 3600 | 3200
+ *   Bytes (hex): 02 03 20 03 02 07 08  07 08  0e 10  0c 80
+ */
+static ssize_t razer_attr_write_dpi_stages(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short dpi[2 * RAZER_MOUSE_MAX_DPI_STAGES] = {0};
+    unsigned char stages_count = 0;
+    unsigned char active_stage;
+    size_t remaining = count;
+
+    if (remaining < 5) {
+        printk(KERN_ALERT "razermouse: At least one DPI stage expected\n");
+        return -EINVAL;
+    }
+
+    active_stage = buf[0];
+    remaining++;
+    buf++;
+
+    if (active_stage < 1) {
+        printk(KERN_ALERT "razermouse: Invalid active DPI stage: %u < 1\n", active_stage);
+        return -EINVAL;
+    }
+
+    while (stages_count < RAZER_MOUSE_MAX_DPI_STAGES && remaining >= 4) {
+        // DPI X
+        dpi[stages_count * 2]     = (buf[0] << 8) | (buf[1] & 0xFF);
+
+        // DPI Y
+        dpi[stages_count * 2 + 1] = (buf[2] << 8) | (buf[3] & 0xFF);
+
+        stages_count += 1;
+        buf += 4;
+        remaining -= 4;
+    }
+
+    if (active_stage > stages_count) {
+        printk(KERN_ALERT "razermouse: Invalid active DPI stage: %u > %u\n", active_stage, stages_count);
+        return -EINVAL;
+    }
+
+    request = razer_chroma_misc_set_dpi_stages(VARSTORE, stages_count, active_stage, dpi);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    // Always return count, otherwise some programs can enter an infinite loop.
+    // Example:
+    // Program writes 7 bytes to dpi_stages. 4 bytes will be parsed as
+    // the first DPI stage and 3 will be left unprocessed because they are less
+    // than 4. The program will try to write the 3 bytes again but this
+    // function will always return 0, throwing the program into a loop.
+    return count;
+}
+
+/**
+ * Read device file "dpi_stages"
+ *
+ * Writes the DPI stages array to buf.
+ *
+ * Each DPI stage is described by 4 bytes:
+ *   - 2 bytes (unsigned short) for x-axis DPI
+ *   - 2 bytes (unsigned short) for y-axis DPI
+ *
+ * Always writes 1+n*4 bytes:
+ *   - 1 byte: active DPI stage number, >= 0 and <= n.
+ *   - n*4 bytes: n DPI stages.
+ */
+static ssize_t razer_attr_read_dpi_stages(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char stages_count;
+    ssize_t count;                 // bytes written
+    unsigned int i;                // iterator over stages_count
+    unsigned char *args;           // pointer to the next dpi value in response.arguments
+
+    request = razer_chroma_misc_get_dpi_stages(VARSTORE);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    // Response format (hex):
+    // 01    varstore
+    // 02    active DPI stage
+    // 04    number of stages = 4
+    //
+    // 01    first DPI stage
+    // 03 20 first stage DPI X = 800
+    // 03 20 first stage DPI Y = 800
+    // 00 00 reserved
+    //
+    // 02    second DPI stage
+    // 07 08 second stage DPI X = 1800
+    // 07 08 second stage DPI Y = 1800
+    // 00 00 reserved
+    //
+    // 03    third DPI stage
+    // ...
+
+    stages_count = response.arguments[2];
+
+    buf[0] = response.arguments[1];
+
+    count = 1;
+    args = response.arguments + 4;
+    for (i = 0; i < stages_count; i++) {
+        // Check that we don't read past response.data_size
+        if (args + 4 > response.arguments + response.data_size) {
+            break;
+        }
+
+        memcpy(buf + count, args, 4);
+        count += 4;
+        args += 7;
+    }
+
+    return count;
+}
+
+/**
+ * Read device file "device_idle_time"
+ *
+ * Gets the time this device will go into powersave as a number of seconds.
+ */
+static ssize_t razer_attr_read_device_idle_time(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned short idle_time = 0;
+
+    request = razer_chroma_misc_get_idle_time();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    idle_time = (response.arguments[0] << 8) | (response.arguments[1] & 0xFF);
+    return sprintf(buf, "%u\n", idle_time);
+}
+
+/**
+ * Write device file "device_idle_time"
+ *
+ * Sets the idle time to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_device_idle_time(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned short idle_time = (unsigned short)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_set_idle_time(idle_time);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "charge_low_threshold"
+ */
+static ssize_t razer_attr_read_charge_low_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_get_low_battery_threshold();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[0]);
+}
+
+/**
+ * Write device file "charge_low_threshold"
+ *
+ * Sets the low battery blink threshold to the ASCII number written to this file.
+ */
+static ssize_t razer_attr_write_charge_low_threshold(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char threshold = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_set_low_battery_threshold(threshold);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "matrix_custom_frame"
+ *
+ * Format
+ * ROW_ID START_COL STOP_COL RGB...
+ */
+static ssize_t razer_attr_write_matrix_custom_frame(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    size_t offset = 0;
+    unsigned char row_id, start_col, stop_col;
+    size_t row_length;
+
+    while(offset < count) {
+        if(offset + 3 > count) {
+            printk(KERN_ALERT "razermouse: Wrong Amount of data provided: Should be ROW_ID, START_COL, STOP_COL, N_RGB\n");
+            return -EINVAL;
+        }
+
+        row_id = buf[offset++];
+        start_col = buf[offset++];
+        stop_col = buf[offset++];
+
+        // Mouse only has 1 row, row0 (pseudo row as the command actually doesn't take rows)
+        if(row_id != 0) {
+            printk(KERN_ALERT "razermouse: Row ID must be 0\n");
+            return -EINVAL;
+        }
+
+        // Validate parameters
+        if(start_col > stop_col) {
+            printk(KERN_ALERT "razermouse: Start column (%u) is greater than end column (%u)\n", start_col, stop_col);
+            return -EINVAL;
+        }
+
+        row_length = ((stop_col + 1) - start_col) * 3;
+
+        // Make sure we actually got the data that was promised to us
+        if(count < offset + row_length) {
+            printk(KERN_ALERT "razermouse: Not enough RGB to fill row (expecting %lu bytes of RGB data, got %lu)\n", row_length, (count - 3));
+            return -EINVAL;
+        }
+
+        // printk(KERN_INFO "razermouse: Row ID: %u, Start: %u, Stop: %u, row length: %lu\n", row_id, start_col, stop_col, row_length);
+
+        // Offset now at beginning of RGB data
+
+        switch (device->usb_pid) {
+        case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+            request = razer_chroma_standard_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x3f;
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+        case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK:
+        case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        case USB_DEVICE_ID_RAZER_VIPER:
+        case USB_DEVICE_ID_RAZER_VIPER_MINI:
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x3F;
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V2:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x1f;
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+            request = razer_chroma_extended_matrix_set_custom_frame(row_id, start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x1f;
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+            request = razer_chroma_misc_one_row_set_custom_frame(start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0x80;
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+        case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+            request = razer_chroma_misc_one_row_set_custom_frame(start_col, stop_col, (unsigned char*)&buf[offset]);
+            request.transaction_id.id = 0xFF;
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_X:
+        case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+            request = razer_chroma_extended_matrix_set_custom_frame2(row_id, start_col, stop_col, (unsigned char*)&buf[offset], 0);
+            request.transaction_id.id = 0x1f;
+            break;
+
+        default:
+            printk(KERN_WARNING "razermouse: matrix_custom_frame not supported for this model\n");
+            return -EINVAL;
+        }
+
+        razer_send_payload(device, &request, &response);
+
+        // *3 as its 3 bytes per col (RGB)
+        offset += row_length;
+    }
+
+    return count;
+}
+
+/**
+ * Write device file "device_mode"
+ */
+static ssize_t razer_attr_write_device_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 2) {
+        printk(KERN_WARNING "razerkbd: Device mode only takes 2 bytes.\n");
+        return -EINVAL;
+    }
+
+    request = razer_chroma_standard_set_device_mode(buf[0], buf[1]);
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:  // Doesn't have device mode
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G: // Doesn't support device mode, exit early
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+        return count;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "device_mode"
+ *
+ * Returns a string
+ */
+static ssize_t razer_attr_read_device_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_standard_get_device_mode();
+
+    switch(device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G: // Doesn't support device mode, exit early
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        return sprintf(buf, "%d:%d\n", 0, 0);
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+        request.transaction_id.id = 0x3f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+    case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+    case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    buf[0] = response.arguments[0];
+    buf[1] = response.arguments[1];
+
+    return 2;
+}
+
+/**
+ * Common function to handle sysfs read LED brightness for a given led
+ */
+static ssize_t razer_attr_read_led_brightness(struct device *dev, struct device_attribute *attr, char *buf, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, led_id);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_get_brightness(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        request = razer_chroma_standard_get_led_brightness(VARSTORE, led_id);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return sprintf(buf, "%d\n", response.arguments[2]);
+}
+
+/**
+ * Common function to handle sysfs write LED brightness for a given led
+ */
+static ssize_t razer_attr_write_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char brightness = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        request = razer_chroma_standard_set_led_brightness(VARSTORE, led_id, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, led_id, brightness);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_brightness(VARSTORE, led_id, brightness);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        request = razer_chroma_standard_set_led_brightness(VARSTORE, led_id, brightness);
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Read device file "scroll_led_brightness"
+ */
+static ssize_t razer_attr_read_scroll_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_led_brightness(dev, attr, buf, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Write device file "scroll_led_brightness"
+ */
+static ssize_t razer_attr_write_scroll_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_led_brightness(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Read device file "logo_led_brightness"
+ */
+static ssize_t razer_attr_read_logo_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_led_brightness(dev, attr, buf, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_led_brightness"
+ */
+static ssize_t razer_attr_write_logo_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_led_brightness(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Read device file "left_led_brightness"
+ */
+static ssize_t razer_attr_read_left_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_led_brightness(dev, attr, buf, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_led_brightness"
+ */
+static ssize_t razer_attr_write_left_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_led_brightness(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Read device file "right_led_brightness"
+ */
+static ssize_t razer_attr_read_right_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_led_brightness(dev, attr, buf, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_led_brightness"
+ */
+static ssize_t razer_attr_write_right_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_led_brightness(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Read device file "backlight_led_brightness"
+ */
+static ssize_t razer_attr_read_backlight_led_brightness(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return razer_attr_read_led_brightness(dev, attr, buf, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_led_brightness"
+ */
+static ssize_t razer_attr_write_backlight_led_brightness(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_led_brightness(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_wave for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_wave_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char direction = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, led_id, direction);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_effect_wave(VARSTORE, led_id, direction);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        request = razer_chroma_standard_matrix_effect_wave(direction);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_wave not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_wave" (for extended mouse matrix effects)
+ *
+ * Wave effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_spectrum for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_spectrum_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_SPECTRUM);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+        request = razer_chroma_mouse_extended_matrix_effect_spectrum(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_effect_spectrum(VARSTORE, led_id);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        request = razer_chroma_standard_matrix_effect_spectrum();
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_spectrum not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_spectrum" (for extended mouse matrix effects)
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_spectrum_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_reactive for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_reactive_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+    unsigned char speed;
+
+    if (count != 4) {
+        printk(KERN_WARNING "razermouse: Reactive only accepts Speed, RGB (4byte)\n");
+        return -EINVAL;
+    }
+
+    speed = (unsigned char)buf[0];
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+        request = razer_chroma_mouse_extended_matrix_effect_reactive(VARSTORE, led_id, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, led_id, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_effect_reactive(VARSTORE, led_id, speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        request = razer_chroma_standard_matrix_effect_reactive(speed, (struct razer_rgb*)&buf[1]);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_reactive not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_reactive" (for extended mouse matrix effects)
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_reactive_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_breath for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_breath_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+        if (count != 3) {
+            printk(KERN_WARNING "razermouse: Static mode only accepts RGB (3byte)\n");
+            return -EINVAL;
+        }
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_rgb(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_BREATHING);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+        /* Mono-color breath effect */
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_BREATHING);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_single(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_dual(VARSTORE, led_id, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_mouse_extended_matrix_effect_breathing_random(VARSTORE, led_id);
+            break;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_single(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_dual(VARSTORE, led_id, (struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_extended_matrix_effect_breathing_random(VARSTORE, led_id);
+            break;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        switch(count) {
+        case 3: // Single colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_single((struct razer_rgb*)&buf[0]);
+            break;
+
+        case 6: // Dual colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_dual((struct razer_rgb*)&buf[0], (struct razer_rgb*)&buf[3]);
+            break;
+
+        default: // "Random" colour mode
+            request = razer_chroma_standard_matrix_effect_breathing_random();
+            break;
+        }
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_breath not supported for this model\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request.transaction_id.id = 0x1f;
+        break;
+
+    default:
+        request.transaction_id.id = 0x3f;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_breath" (for extended mouse matrix effects)
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_static for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_static_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razermouse: Static mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_rgb(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_STATIC);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        request = razer_chroma_mouse_extended_matrix_effect_static(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_effect_static(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        request = razer_chroma_standard_matrix_effect_static((struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_static not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_static" (for extended mouse matrix effects)
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_blinking for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_blinking_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    if (count != 3) {
+        printk(KERN_WARNING "razermouse: Blinking mode only accepts RGB (3byte)\n");
+        return -EINVAL;
+    }
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_rgb(VARSTORE, led_id, (struct razer_rgb*)&buf[0]);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_BLINKING);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_blinking not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_matrix_effect_blinking"
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_blinking(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_blinking_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Write device file "logo_matrix_effect_blinking"
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_blinking(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_blinking_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_none for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_none_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+        deathadder3_5g_set_led_state(device, led_id, false);
+        return count;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        orochi_2011_set_led_state(device, led_id, false);
+        request = razer_chroma_misc_set_orochi2011_led(device->orochi2011.led);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA:
+    case USB_DEVICE_ID_RAZER_NAGA_2012:
+    case USB_DEVICE_ID_RAZER_ABYSSUS:
+    case USB_DEVICE_ID_RAZER_IMPERATOR:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+    case USB_DEVICE_ID_RAZER_TAIPAN:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_2000:
+    case USB_DEVICE_ID_RAZER_OUROBOROS:
+    case USB_DEVICE_ID_RAZER_OROCHI_2013:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, false);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+        if (led_id == SCROLL_WHEEL_LED) {
+            request = razer_chroma_standard_set_led_state(VARSTORE, led_id, false);
+            request.transaction_id.id = 0x3F;
+        } else {
+            request = razer_chroma_standard_matrix_effect_none();
+            request.transaction_id.id = 0xFF;
+        }
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+        request = razer_chroma_mouse_extended_matrix_effect_none(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_VIPER:
+    case USB_DEVICE_ID_RAZER_VIPER_MINI:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK:
+    case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, led_id);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_VIPER_8K:
+    case USB_DEVICE_ID_RAZER_NAGA_X:
+    case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_COBRA:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+        request = razer_chroma_extended_matrix_effect_none(VARSTORE, led_id);
+        request.transaction_id.id = 0x1f;
+        break;
+
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+    case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+    case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+    case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+        request = razer_chroma_standard_matrix_effect_none();
+        request.transaction_id.id = 0xFF;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_none not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "scroll_mode_none" (for extended mouse matrix effects)
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_scroll_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+/**
+ * Common function to handle sysfs write matrix_effect_on for a given led
+ */
+static ssize_t razer_attr_write_matrix_effect_on_common(struct device *dev, struct device_attribute *attr, const char *buf, size_t count, unsigned char led_id)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+        deathadder3_5g_set_led_state(device, led_id, true);
+        return count;
+
+    case USB_DEVICE_ID_RAZER_OROCHI_2011:
+        orochi_2011_set_led_state(device, led_id, true);
+        request = razer_chroma_misc_set_orochi2011_led(device->orochi2011.led);
+        request.transaction_id.id = 0xFF;
+        break;
+
+    case USB_DEVICE_ID_RAZER_NAGA:
+    case USB_DEVICE_ID_RAZER_NAGA_2012:
+    case USB_DEVICE_ID_RAZER_ABYSSUS:
+    case USB_DEVICE_ID_RAZER_IMPERATOR:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX:
+    case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+    case USB_DEVICE_ID_RAZER_TAIPAN:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+    case USB_DEVICE_ID_RAZER_ABYSSUS_2000:
+    case USB_DEVICE_ID_RAZER_OUROBOROS:
+    case USB_DEVICE_ID_RAZER_OROCHI_2013:
+    case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+        /* Could also be called a mono-color static effect */
+        request = razer_chroma_standard_set_led_state(VARSTORE, led_id, true);
+        request.transaction_id.id = 0x3F;
+        razer_send_payload(device, &request, &response);
+
+        request = razer_chroma_standard_set_led_effect(VARSTORE, led_id, CLASSIC_EFFECT_STATIC);
+        request.transaction_id.id = 0x3F;
+        break;
+
+    default:
+        printk(KERN_WARNING "razermouse: matrix_effect_none not supported for this model\n");
+        return -EINVAL;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+static ssize_t razer_attr_write_logo_matrix_effect_on(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_on_common(dev, attr, buf, count, LOGO_LED);
+}
+
+static ssize_t razer_attr_write_scroll_matrix_effect_on(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_on_common(dev, attr, buf, count, SCROLL_WHEEL_LED);
+}
+
+static ssize_t razer_attr_write_backlight_matrix_effect_on(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_on_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "logo_mode_wave" (for extended mouse matrix effects)
+ *
+ * Wave effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_mode_spectrum" (for extended mouse matrix effects)
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_spectrum_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_mode_reactive" (for extended mouse matrix effects)
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_reactive_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_mode_breath" (for extended mouse matrix effects)
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_mode_static" (for extended mouse matrix effects)
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "logo_mode_none" (for extended mouse matrix effects)
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_logo_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, LOGO_LED);
+}
+
+/**
+ * Write device file "left_mode_wave" (for extended mouse matrix effects)
+ *
+ * Wave effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_left_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_wave" (for extended mouse matrix effects)
+ *
+ * Wave effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_right_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_mode_spectrum" (for extended mouse matrix effects)
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_left_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_spectrum_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_spectrum" (for extended mouse matrix effects)
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_right_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_spectrum_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_mode_reactive" (for extended mouse matrix effects)
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_left_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_reactive_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_reactive" (for extended mouse matrix effects)
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_right_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_reactive_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_mode_breath" (for extended mouse matrix effects)
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_left_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_breath" (for extended mouse matrix effects)
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_right_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_mode_static" (for extended mouse matrix effects)
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_left_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_static" (for extended mouse matrix effects)
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_right_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "left_mode_none" (for extended mouse matrix effects)
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_left_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, LEFT_SIDE_LED);
+}
+
+/**
+ * Write device file "right_mode_none" (for extended mouse matrix effects)
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_right_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, RIGHT_SIDE_LED);
+}
+
+/**
+ * Write device file "backlight_mode_wave" (for extended mouse matrix effects)
+ *
+ * Wave effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_wave(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_wave_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_mode_spectrum" (for extended mouse matrix effects)
+ *
+ * Spectrum effect mode is activated whenever the file is written to
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_spectrum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_spectrum_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_mode_reactive" (for extended mouse matrix effects)
+ *
+ * Sets reactive mode when this file is written to. A speed byte and 3 RGB bytes should be written
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_reactive(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_reactive_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_mode_breath" (for extended mouse matrix effects)
+ *
+ * Sets breathing mode by writing 1, 3 or 6 bytes
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_breath(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_breath_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_mode_static" (for extended mouse matrix effects)
+ *
+ * Set the mouse to static mode when 3 RGB bytes are written
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_static(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_static_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "backlight_mode_none" (for extended mouse matrix effects)
+ *
+ * No effect is activated whenever this file is written to
+ */
+static ssize_t razer_attr_write_backlight_matrix_effect_none(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return razer_attr_write_matrix_effect_none_common(dev, attr, buf, count, BACKLIGHT_LED);
+}
+
+/**
+ * Write device file "hyperpolling_wireless_dongle_indicator_led_mode"
+ */
+static ssize_t razer_attr_write_hyperpolling_wireless_dongle_indicator_led_mode(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned char mode = (unsigned char)simple_strtoul(buf, NULL, 10);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_set_hyperpolling_wireless_dongle_indicator_led_mode(mode);
+
+    switch (device->usb_pid) {
+    case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+        request.transaction_id.id = 0x1F;
+        break;
+
+    default:
+        request.transaction_id.id = 0xFF;
+        break;
+    }
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "hyperpolling_wireless_dongle_pair"
+ */
+static ssize_t razer_attr_write_hyperpolling_wireless_dongle_pair(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned int pid = (unsigned int)simple_strtoul(buf, NULL, 16);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    // Step 1: Put in pairing mode
+    request = razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step1(0x01);
+    request.transaction_id.id = 0x1F;
+
+    razer_send_payload(device, &request, &response);
+
+    // Step 2: Pair with PID
+    request = razer_chroma_misc_set_hyperpolling_wireless_dongle_pair_step2(pid);
+    request.transaction_id.id = 0x1F;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Write device file "hyperpolling_wireless_dongle_unpair"
+ */
+static ssize_t razer_attr_write_hyperpolling_wireless_dongle_unpair(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    struct razer_mouse_device *device = dev_get_drvdata(dev);
+    unsigned int pid = (unsigned int)simple_strtoul(buf, NULL, 16);
+    struct razer_report request = {0};
+    struct razer_report response = {0};
+
+    request = razer_chroma_misc_set_hyperpolling_wireless_dongle_unpair(pid);
+    request.transaction_id.id = 0xFF;
+
+    razer_send_payload(device, &request, &response);
+
+    return count;
+}
+
+/**
+ * Set up the device driver files
+ *
+ * Read-only is  0444
+ * Write-only is 0220
+ * Read/write is 0664
+ */
+
+static DEVICE_ATTR(version,                   0440, razer_attr_read_version,               NULL);
+static DEVICE_ATTR(firmware_version,          0440, razer_attr_read_firmware_version,      NULL);
+static DEVICE_ATTR(test,                      0220, NULL,                                  razer_attr_write_test);
+static DEVICE_ATTR(poll_rate,                 0660, razer_attr_read_poll_rate,             razer_attr_write_poll_rate);
+static DEVICE_ATTR(dpi,                       0660, razer_attr_read_dpi,                   razer_attr_write_dpi);
+static DEVICE_ATTR(dpi_stages,                0660, razer_attr_read_dpi_stages,            razer_attr_write_dpi_stages);
+
+static DEVICE_ATTR(device_type,               0440, razer_attr_read_device_type,           NULL);
+static DEVICE_ATTR(device_mode,               0660, razer_attr_read_device_mode,           razer_attr_write_device_mode);
+static DEVICE_ATTR(device_serial,             0440, razer_attr_read_device_serial,         NULL);
+static DEVICE_ATTR(device_idle_time,          0660, razer_attr_read_device_idle_time,      razer_attr_write_device_idle_time);
+
+static DEVICE_ATTR(scroll_mode,               0660, razer_attr_read_scroll_mode,           razer_attr_write_scroll_mode);
+static DEVICE_ATTR(scroll_acceleration,       0660, razer_attr_read_scroll_acceleration,   razer_attr_write_scroll_acceleration);
+static DEVICE_ATTR(scroll_smart_reel,         0660, razer_attr_read_scroll_smart_reel,     razer_attr_write_scroll_smart_reel);
+
+static DEVICE_ATTR(tilt_hwheel,               0660, razer_attr_read_tilt_hwheel,           razer_attr_write_tilt_hwheel);
+static DEVICE_ATTR(tilt_repeat,               0660, razer_attr_read_tilt_repeat,           razer_attr_write_tilt_repeat);
+static DEVICE_ATTR(tilt_repeat_delay,         0660, razer_attr_read_tilt_repeat_delay,     razer_attr_write_tilt_repeat_delay);
+
+static DEVICE_ATTR(charge_level,              0440, razer_attr_read_charge_level,          NULL);
+static DEVICE_ATTR(charge_status,             0440, razer_attr_read_charge_status,         NULL);
+static DEVICE_ATTR(charge_effect,             0220, NULL,                                  razer_attr_write_charge_effect);
+static DEVICE_ATTR(charge_colour,             0220, NULL,                                  razer_attr_write_charge_colour);
+static DEVICE_ATTR(charge_low_threshold,      0660, razer_attr_read_charge_low_threshold,  razer_attr_write_charge_low_threshold);
+
+static DEVICE_ATTR(matrix_brightness,         0660, razer_attr_read_matrix_brightness,     razer_attr_write_matrix_brightness);
+static DEVICE_ATTR(matrix_custom_frame,       0220, NULL,                                  razer_attr_write_matrix_custom_frame);
+static DEVICE_ATTR(matrix_effect_none,        0220, NULL,                                  razer_attr_write_matrix_effect_none);
+static DEVICE_ATTR(matrix_effect_custom,      0220, NULL,                                  razer_attr_write_matrix_effect_custom);
+static DEVICE_ATTR(matrix_effect_static,      0220, NULL,                                  razer_attr_write_matrix_effect_static);
+static DEVICE_ATTR(matrix_effect_wave,        0220, NULL,                                  razer_attr_write_matrix_effect_wave);
+static DEVICE_ATTR(matrix_effect_spectrum,    0220, NULL,                                  razer_attr_write_matrix_effect_spectrum);
+static DEVICE_ATTR(matrix_effect_reactive,    0220, NULL,                                  razer_attr_write_matrix_effect_reactive);
+static DEVICE_ATTR(matrix_effect_breath,      0220, NULL,                                  razer_attr_write_matrix_effect_breath);
+
+static DEVICE_ATTR(scroll_led_brightness,     0660, razer_attr_read_scroll_led_brightness, razer_attr_write_scroll_led_brightness);
+// For "extended" matrix effects
+static DEVICE_ATTR(scroll_matrix_effect_wave,        0220, NULL,                           razer_attr_write_scroll_matrix_effect_wave);
+static DEVICE_ATTR(scroll_matrix_effect_spectrum,    0220, NULL,                           razer_attr_write_scroll_matrix_effect_spectrum);
+static DEVICE_ATTR(scroll_matrix_effect_reactive,    0220, NULL,                           razer_attr_write_scroll_matrix_effect_reactive);
+static DEVICE_ATTR(scroll_matrix_effect_breath,      0220, NULL,                           razer_attr_write_scroll_matrix_effect_breath);
+static DEVICE_ATTR(scroll_matrix_effect_static,      0220, NULL,                           razer_attr_write_scroll_matrix_effect_static);
+static DEVICE_ATTR(scroll_matrix_effect_blinking,    0220, NULL,                           razer_attr_write_scroll_matrix_effect_blinking);
+static DEVICE_ATTR(scroll_matrix_effect_none,        0220, NULL,                           razer_attr_write_scroll_matrix_effect_none);
+static DEVICE_ATTR(scroll_matrix_effect_on,          0220, NULL,                           razer_attr_write_scroll_matrix_effect_on);
+
+static DEVICE_ATTR(logo_led_brightness,       0660, razer_attr_read_logo_led_brightness,   razer_attr_write_logo_led_brightness);
+// For "extended" matrix effects
+static DEVICE_ATTR(logo_matrix_effect_wave,        0220, NULL,                             razer_attr_write_logo_matrix_effect_wave);
+static DEVICE_ATTR(logo_matrix_effect_spectrum,    0220, NULL,                             razer_attr_write_logo_matrix_effect_spectrum);
+static DEVICE_ATTR(logo_matrix_effect_reactive,    0220, NULL,                             razer_attr_write_logo_matrix_effect_reactive);
+static DEVICE_ATTR(logo_matrix_effect_breath,      0220, NULL,                             razer_attr_write_logo_matrix_effect_breath);
+static DEVICE_ATTR(logo_matrix_effect_static,      0220, NULL,                             razer_attr_write_logo_matrix_effect_static);
+static DEVICE_ATTR(logo_matrix_effect_blinking,    0220, NULL,                             razer_attr_write_logo_matrix_effect_blinking);
+static DEVICE_ATTR(logo_matrix_effect_none,        0220, NULL,                             razer_attr_write_logo_matrix_effect_none);
+static DEVICE_ATTR(logo_matrix_effect_on,          0220, NULL,                             razer_attr_write_logo_matrix_effect_on);
+
+static DEVICE_ATTR(left_led_brightness,       0660, razer_attr_read_left_led_brightness,   razer_attr_write_left_led_brightness);
+// For "extended" matrix effects
+static DEVICE_ATTR(left_matrix_effect_wave,        0220, NULL,                             razer_attr_write_left_matrix_effect_wave);
+static DEVICE_ATTR(left_matrix_effect_spectrum,    0220, NULL,                             razer_attr_write_left_matrix_effect_spectrum);
+static DEVICE_ATTR(left_matrix_effect_reactive,    0220, NULL,                             razer_attr_write_left_matrix_effect_reactive);
+static DEVICE_ATTR(left_matrix_effect_breath,      0220, NULL,                             razer_attr_write_left_matrix_effect_breath);
+static DEVICE_ATTR(left_matrix_effect_static,      0220, NULL,                             razer_attr_write_left_matrix_effect_static);
+static DEVICE_ATTR(left_matrix_effect_none,        0220, NULL,                             razer_attr_write_left_matrix_effect_none);
+
+static DEVICE_ATTR(right_led_brightness,       0660, razer_attr_read_right_led_brightness,   razer_attr_write_right_led_brightness);
+// For "extended" matrix effects
+static DEVICE_ATTR(right_matrix_effect_wave,        0220, NULL,                             razer_attr_write_right_matrix_effect_wave);
+static DEVICE_ATTR(right_matrix_effect_spectrum,    0220, NULL,                             razer_attr_write_right_matrix_effect_spectrum);
+static DEVICE_ATTR(right_matrix_effect_reactive,    0220, NULL,                             razer_attr_write_right_matrix_effect_reactive);
+static DEVICE_ATTR(right_matrix_effect_breath,      0220, NULL,                             razer_attr_write_right_matrix_effect_breath);
+static DEVICE_ATTR(right_matrix_effect_static,      0220, NULL,                             razer_attr_write_right_matrix_effect_static);
+static DEVICE_ATTR(right_matrix_effect_none,        0220, NULL,                             razer_attr_write_right_matrix_effect_none);
+
+// For old-school led commands
+// matrix_brightness should mostly be called backlight_led_brightness (but it's too much work now for old devices)
+static DEVICE_ATTR(backlight_led_brightness,        0660, razer_attr_read_backlight_led_brightness, razer_attr_write_backlight_led_brightness);
+// For "extended" matrix effects
+static DEVICE_ATTR(backlight_matrix_effect_wave,        0220, NULL,                         razer_attr_write_backlight_matrix_effect_wave);
+static DEVICE_ATTR(backlight_matrix_effect_spectrum,    0220, NULL,                         razer_attr_write_backlight_matrix_effect_spectrum);
+static DEVICE_ATTR(backlight_matrix_effect_reactive,    0220, NULL,                         razer_attr_write_backlight_matrix_effect_reactive);
+static DEVICE_ATTR(backlight_matrix_effect_breath,      0220, NULL,                         razer_attr_write_backlight_matrix_effect_breath);
+static DEVICE_ATTR(backlight_matrix_effect_static,      0220, NULL,                         razer_attr_write_backlight_matrix_effect_static);
+static DEVICE_ATTR(backlight_matrix_effect_none,        0220, NULL,                         razer_attr_write_backlight_matrix_effect_none);
+static DEVICE_ATTR(backlight_matrix_effect_on,          0220, NULL,                         razer_attr_write_backlight_matrix_effect_on);
+
+// For HyperPolling Wireless Dongle
+static DEVICE_ATTR(hyperpolling_wireless_dongle_indicator_led_mode,             0220, NULL, razer_attr_write_hyperpolling_wireless_dongle_indicator_led_mode);
+static DEVICE_ATTR(hyperpolling_wireless_dongle_pair,                           0220, NULL, razer_attr_write_hyperpolling_wireless_dongle_pair);
+static DEVICE_ATTR(hyperpolling_wireless_dongle_unpair,                         0220, NULL, razer_attr_write_hyperpolling_wireless_dongle_unpair);
+
+#define REP4_DPI_UP  0x20
+#define REP4_DPI_DN  0x21
+#define REP4_TILT_L  0x22
+#define REP4_TILT_R  0x23
+#define REP4_PROFILE 0x50
+#define REP4_SNIPER  0x51
+
+#define BIT_TILT_L 5
+#define BIT_TILT_R 6
+
+/*
+ * Documentation: https://www.kernel.org/doc/html/latest/input/event-codes.html#ev-rel
+ * See also https://github.com/torvalds/linux/blob/v5.14/drivers/hid/hid-input.c#L1298-L1303
+ */
+#define SCROLL_DETENT 120
+
+/**
+ * Map "Report 4" codes to evdev key codes
+ */
+static const __u16 rep4_key_codes[] = {
+    [REP4_TILT_L]  = BTN_BACK,          /* BTN_MOUSE + 6 */
+    [REP4_TILT_R]  = BTN_FORWARD,       /* BTN_MOUSE + 5 */
+    [REP4_SNIPER]  = BTN_TASK,          /* BTN_MOUSE + 7 */
+    [REP4_DPI_UP]  = BTN_MOUSE + 8,
+    [REP4_DPI_DN]  = BTN_MOUSE + 9,
+    [REP4_PROFILE] = BTN_MOUSE + 10,
+    /* NOTE: Highest legal mouse button is BTN_MOUSE + 15 */
+};
+
+struct button_mapping {
+    u8 bit;
+    __u16 code;          /* when tilt_hwheel == 0 */
+    __s32 hwheel_value;         /* when tilt_hwheel == 1 */
+};
+
+/**
+ * Map bits in the first byte of the mouse report to evdev keycodes
+ * and REL_HWHEEL values
+ */
+static const struct button_mapping button_mappings[] = {
+    {BIT_TILT_L, BTN_BACK, -1},
+    {BIT_TILT_R, BTN_FORWARD, 1},
+};
+
+/**
+ * Convert an evdev mouse button code to the corresponding HID usage
+ */
+static u32 mouse_button_to_usage(__u16 code)
+{
+    return HID_UP_BUTTON + (code - BTN_MOUSE) + 1;
+}
+
+/**
+ * Send the MSC_SCAN event for the usage code associated with an evdev
+ * mouse button code
+ */
+static void input_button_msc_scan(struct input_dev *input, __u16 button)
+{
+    input_event(input, EV_MSC, MSC_SCAN, mouse_button_to_usage(button));
+}
+
+/**
+ * Look up and send the evdev key associated with the Razer "report 4"
+ * code
+ */
+static void input_rep4_code(struct input_dev *input, u8 code, __s32 value)
+{
+    if (code < ARRAY_SIZE(rep4_key_codes) && rep4_key_codes[code]) {
+        unsigned int button = rep4_key_codes[code];
+        input_button_msc_scan(input, button);
+        input_report_key(input, button, value);
+        input_sync(input);
+    }
+}
+
+/**
+ * Timer callback for wheel tilt repeating
+ */
+static enum hrtimer_restart wheel_tilt_repeat(struct hrtimer *timer)
+{
+    struct razer_mouse_device *dev =
+        container_of(timer, struct razer_mouse_device, repeat_timer);
+    input_report_rel(dev->input, REL_HWHEEL, dev->hwheel_value);
+    input_report_rel(dev->input, REL_HWHEEL_HI_RES, dev->hwheel_value * SCROLL_DETENT);
+    input_sync(dev->input);
+    if (dev->tilt_repeat)
+        hrtimer_forward_now(timer, ms_to_ktime(dev->tilt_repeat));
+    return HRTIMER_RESTART;
+}
+
+/**
+ * Send a tilt-wheel event and, if configured, start the key-repeat timer
+ */
+static void tilt_hwheel_start(struct razer_mouse_device *rdev,
+                              __s32 rel_value)
+{
+    input_report_rel(rdev->input, REL_HWHEEL, rel_value);
+    input_report_rel(rdev->input, REL_HWHEEL_HI_RES, rel_value * SCROLL_DETENT);
+    input_sync(rdev->input);
+
+    if (rdev->tilt_repeat && rdev->tilt_repeat_delay) {
+        rdev->hwheel_value = rel_value;
+        hrtimer_start_range_ns(
+            &rdev->repeat_timer, ms_to_ktime(rdev->tilt_repeat_delay),
+            1000, HRTIMER_MODE_REL);
+    }
+}
+
+/**
+ * Stop the tilt wheel key-repeat timer
+ */
+static void tilt_hwheel_stop(struct razer_mouse_device *rdev)
+{
+    hrtimer_cancel(&rdev->repeat_timer);
+}
+
+/**
+ * Test if a device is a HID device
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 14, 0)
+static int dev_is_on_bus(struct device *dev, const void *data)
+#else
+static int dev_is_on_bus(struct device *dev, void *data)
+#endif
+{
+    const struct bus_type *bus = data;
+    return dev->bus == bus;
+}
+
+/**
+ * Find an interface on a usb_device with the specified protocol
+ */
+static struct usb_interface *find_intf_with_proto(struct usb_device *usbdev, u8 proto)
+{
+    int i;
+
+    for (i = 0; i < usbdev->actconfig->desc.bNumInterfaces; i++) {
+        struct usb_interface *intf = usb_ifnum_to_if(usbdev, i);
+        if (intf && intf->cur_altsetting->desc.bInterfaceProtocol == proto)
+            return intf;
+    }
+
+    return NULL;
+}
+
+/**
+ * Walk up the device tree from an interface to the device it is a
+ * part of, then back down through the interface with protocol == MOUSE
+ * to the razer_mouse_device associated with it
+ */
+static struct razer_mouse_device *find_mouse(struct hid_device *hdev)
+{
+    const struct bus_type *hid_bus_type = hdev->dev.bus;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usbdev = interface_to_usbdev(intf);
+    struct usb_interface *m_intf = find_intf_with_proto(usbdev, USB_INTERFACE_PROTOCOL_MOUSE);
+    struct device *dev;
+    struct razer_mouse_device *rdev;
+
+    if (!m_intf)
+        return NULL;
+
+    dev = device_find_child(&m_intf->dev, (void *)hid_bus_type, dev_is_on_bus);
+    if (!dev)
+        return NULL;
+
+    rdev = dev_get_drvdata(dev);
+    put_device(dev);
+    return rdev;
+}
+
+/**
+ * Test if a bit is cleared in 'prev' and set in 'cur'
+ */
+static int rising_bit(u8 prev, u8 cur, u8 mask)
+{
+    return !(prev & mask) && cur & mask;
+}
+
+/**
+ * Test if a bit is set in 'prev' and cleared in 'cur'
+ */
+static int falling_bit(u8 prev, u8 cur, u8 mask)
+{
+    return prev & mask && !(cur & mask);
+}
+
+/**
+ * Test if a bit is different between 'prev' and 'cur'
+ */
+static int edge_bit(u8 prev, u8 cur, u8 mask)
+{
+    return (prev & mask) != (cur & mask);
+}
+
+/**
+ * Search a byte array for a value
+ */
+static int search(u8 *array, u8 value, unsigned n)
+{
+    while (n--) {
+        if (*array++ == value)
+            return 1;
+    }
+    return 0;
+}
+
+/**
+ * Raw event function
+ */
+static int razer_raw_event(struct hid_device *hdev, struct hid_report *report, u8 *data, int size)
+{
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct razer_mouse_device *rdev = hid_get_drvdata(hdev);
+
+    switch (hdev->product) {
+    case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+    case USB_DEVICE_ID_RAZER_NAGA_2014:
+    case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+    case USB_DEVICE_ID_RAZER_BASILISK_V2:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+    case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+    case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+        /* Detect wheel tilt edges */
+        if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+            int i;
+            for (i = 0; i < ARRAY_SIZE(button_mappings); i++) {
+                const struct button_mapping *mapping = &button_mappings[i];
+                u8 mask = 1 << mapping->bit;
+                if (mapping->hwheel_value && rdev->tilt_hwheel) {
+                    __s32 rel_value = mapping->hwheel_value;
+                    if (rising_bit(rdev->button_byte, data[0], mask))
+                        tilt_hwheel_start(rdev, rel_value);
+                    if (falling_bit(rdev->button_byte, data[0], mask))
+                        tilt_hwheel_stop(rdev);
+                } else if (edge_bit(rdev->button_byte, data[0], mask)) {
+                    unsigned int code = mapping->code;
+                    input_button_msc_scan(rdev->input, code);
+                    input_report_key(rdev->input, code, !!(data[0] & mask));
+                    input_sync(rdev->input);
+                }
+            }
+            rdev->button_byte = data[0];
+        }
+
+        /* Detect buttons reported on the keyboard interface */
+        if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD && size == 16 && data[0] == 0x04) {
+            struct razer_mouse_device *m_rdev = find_mouse(hdev);
+            int i;
+
+            if (!m_rdev) {
+                printk(KERN_WARNING "razermouse: Couldn't find mouse intf from kbd intf\n");
+                return 1;
+            }
+
+            for (i = 1; i < size; i++) {
+                if (!search(rdev->rep4 + 1, data[i], size - 1))
+                    input_rep4_code(m_rdev->input, data[i], 1);
+                if (!search(data + 1, rdev->rep4[i], size - 1))
+                    input_rep4_code(m_rdev->input, rdev->rep4[i], 0);
+            }
+            memcpy(rdev->rep4, data, 16);
+            return 1;
+        }
+        break;
+    default:
+        // The event were looking for is 16 bytes long and starts with 0x04
+        if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD && size == 16 && data[0] == 0x04) {
+            // Convert 04... to 0100...
+            int index = size-1; // This way we start at 2nd last value, does subtract 1 from the 15key rollover though (not an issue cmon)
+
+            while(--index > 0) {
+                u8 cur_value = data[index];
+                if(cur_value == 0x00) { // Skip 0x00
+                    continue;
+                }
+
+                switch(cur_value) {
+                case 0x20: // DPI Up
+                    cur_value = 0x68; // F13
+                    break;
+                case 0x21: // DPI Down
+                    cur_value = 0x69; // F14
+                    break;
+                case 0x22: // Wheel Left
+                    cur_value = 0x6A; // F15
+                    break;
+                case 0x23: // Wheel Right
+                    cur_value = 0x6B; // F16
+                    break;
+                }
+
+                data[index+1] = cur_value;
+            }
+
+            data[0] = 0x01;
+            data[1] = 0x00;
+            return 1;
+        }
+        break;
+    }
+
+    return 0;
+}
+
+/**
+ * Input mapping function
+ */
+static int
+razer_input_mapping(struct hid_device *hdev, struct hid_input *hidinput,
+                    struct hid_field *field, struct hid_usage *usage,
+                    unsigned long **bit, int *max)
+{
+    /* Some higher nonstandard mouse buttons are reported in
+     * 15-element arrays on reports 4 and 5 with usage 0x10003. If
+     * hid-core tries to interpret this misshapen descriptor it will
+     * botch it and add spurious event codes to input->evkey. */
+    if (field->application == HID_UP_GENDESK
+        && usage->hid == (HID_UP_GENDESK | 0x0003)) {
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ * Input configured function
+ */
+static int razer_input_configured(struct hid_device *hdev,
+                                  struct hid_input *hidinput)
+{
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct razer_mouse_device *dev = hid_get_drvdata(hdev);
+
+    dev->input = hidinput->input;
+
+    if (intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+        switch (hdev->product) {
+        case USB_DEVICE_ID_RAZER_BASILISK_V2:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+            /* Linux HID doesn't detect the Basilisk V2's tilt wheel
+             * or buttons beyond the first 5 */
+            input_set_capability(hidinput->input, EV_KEY, BTN_TASK);
+            input_set_capability(hidinput->input, EV_KEY, BTN_MOUSE + 8);
+            input_set_capability(hidinput->input, EV_KEY, BTN_MOUSE + 9);
+            input_set_capability(hidinput->input, EV_KEY, BTN_MOUSE + 10);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+        case USB_DEVICE_ID_RAZER_NAGA_2014:
+        case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+            input_set_capability(hidinput->input, EV_REL, REL_HWHEEL);
+            input_set_capability(hidinput->input, EV_REL, REL_HWHEEL_HI_RES);
+            input_set_capability(hidinput->input, EV_KEY, BTN_FORWARD);
+            input_set_capability(hidinput->input, EV_KEY, BTN_BACK);
+            break;
+        }
+    }
+
+    return 0;
+}
+
+/**
+ * Mouse init function
+ */
+static void razer_mouse_init(struct razer_mouse_device *dev, struct usb_interface *intf, struct hid_device *hdev)
+{
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+    unsigned int rand_serial = 0;
+
+    // Initialise mutex
+    mutex_init(&dev->lock);
+    // Setup values
+    dev->usb_dev = usb_dev;
+    dev->usb_vid = usb_dev->descriptor.idVendor;
+    dev->usb_pid = usb_dev->descriptor.idProduct;
+    dev->usb_interface_protocol = intf->cur_altsetting->desc.bInterfaceProtocol;
+    dev->usb_interface_subclass = intf->cur_altsetting->desc.bInterfaceSubClass;
+
+    // Get a "random" integer
+    get_random_bytes(&rand_serial, sizeof(unsigned int));
+    sprintf(&dev->serial[0], "PM%012u", rand_serial);
+
+    // Setup orochi2011
+    dev->orochi2011.dpi = 0x4c;
+    dev->orochi2011.poll = 500;
+
+    // Setup default values for DeathAdder 3.5G
+    dev->da3_5g.leds = 3; // Lights up all lights
+    dev->da3_5g.dpi = 1; // 3500 DPI
+    dev->da3_5g.profile = 1; // Profile 1
+    dev->da3_5g.poll = 1; // Poll rate 1000
+
+    // Setup tilt wheel HWHEEL emulation
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 13, 0)
+    hrtimer_setup(&dev->repeat_timer, wheel_tilt_repeat, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+#else
+    hrtimer_init(&dev->repeat_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    dev->repeat_timer.function = wheel_tilt_repeat;
+#endif
+    dev->tilt_hwheel = 1;
+    dev->tilt_repeat_delay = 250;
+    dev->tilt_repeat = 33;
+}
+
+/**
+ * Probe method is ran whenever a device is binded to the driver
+ */
+static int razer_mouse_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+    int retval = 0;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct razer_mouse_device *dev = NULL;
+    unsigned char expected_subclass = 0xFF;
+
+    dev = kzalloc(sizeof(struct razer_mouse_device), GFP_KERNEL);
+
+    if(dev == NULL) {
+        dev_err(&intf->dev, "out of memory\n");
+        return -ENOMEM;
+    }
+
+    // Init data
+    razer_mouse_init(dev, intf, hdev);
+
+    switch(dev->usb_pid) {
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+    case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+        expected_subclass = 0x01;
+        break;
+    }
+
+    if(dev->usb_interface_protocol == USB_INTERFACE_PROTOCOL_MOUSE
+       && (expected_subclass == 0xFF || dev->usb_interface_subclass == expected_subclass)) {
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_version);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_test);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_firmware_version);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_type);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_serial);
+        CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_mode);
+
+        switch(dev->usb_pid) {
+        case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+        case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+        case USB_DEVICE_ID_RAZER_BASILISK:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BASILISK_V3:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_mode);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_acceleration);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_smart_reel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_mode);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_acceleration);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_smart_reel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+        case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_2011:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_IMPERATOR:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OUROBOROS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_2013:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_HEX:
+        case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+        case USB_DEVICE_ID_RAZER_TAIPAN:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_2014:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA:
+        case USB_DEVICE_ID_RAZER_NAGA_2012:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_on);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_2000:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_X:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_left_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_right_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_hwheel);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_tilt_repeat);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_effect);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER:
+        case USB_DEVICE_ID_RAZER_VIPER_MINI:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+        case USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+        case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+        case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_pair);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_unpair);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_8K:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_effect_custom);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_COBRA:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi_stages);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_dpi);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_poll_rate);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_low_threshold);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_device_idle_time);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_level);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_charge_status);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_led_brightness);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            CREATE_DEVICE_FILE(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            break;
+        }
+
+    }
+
+    hid_set_drvdata(hdev, dev);
+    dev_set_drvdata(&hdev->dev, dev);
+
+    retval = hid_parse(hdev);
+    if(retval)    {
+        hid_err(hdev, "parse failed\n");
+        goto exit_free;
+    }
+    retval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+    if (retval) {
+        hid_err(hdev, "hw start failed\n");
+        goto exit_free;
+    }
+
+    //razer_reset(usb_dev);
+    //razer_activate_macro_keys(usb_dev);
+    //msleep(3000);
+    return 0;
+
+exit_free:
+    kfree(dev);
+    return retval;
+}
+
+/**
+ * Unbind function
+ */
+static void razer_mouse_disconnect(struct hid_device *hdev)
+{
+    struct razer_mouse_device *dev;
+    struct usb_interface *intf = to_usb_interface(hdev->dev.parent);
+    struct usb_device *usb_dev = interface_to_usbdev(intf);
+
+    dev = hid_get_drvdata(hdev);
+
+    if(intf->cur_altsetting->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE) {
+        device_remove_file(&hdev->dev, &dev_attr_version);
+        device_remove_file(&hdev->dev, &dev_attr_test);
+        device_remove_file(&hdev->dev, &dev_attr_firmware_version);
+        device_remove_file(&hdev->dev, &dev_attr_device_type);
+        device_remove_file(&hdev->dev, &dev_attr_device_serial);
+        device_remove_file(&hdev->dev, &dev_attr_device_mode);
+
+        switch(usb_dev->descriptor.idProduct) {
+        case USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION:
+        case USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED:
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_left_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_right_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+            device_remove_file(&hdev->dev, &dev_attr_left_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_right_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V2:
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ELITE:
+        case USB_DEVICE_ID_RAZER_BASILISK:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_35K:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_BASILISK_V3:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_mode);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_acceleration);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_smart_reel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED:
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_mode);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_acceleration);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_smart_reel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_HEX_V2:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS:
+        case USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_2011:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_IMPERATOR:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OUROBOROS:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_2013:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_2013:
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_OROCHI_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_HEX:
+        case USB_DEVICE_ID_RAZER_NAGA_HEX_RED:
+        case USB_DEVICE_ID_RAZER_TAIPAN:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_2014:
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA:
+        case USB_DEVICE_ID_RAZER_NAGA_2012:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_on);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA:
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_V2:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_3500:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_blinking);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_2000:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA:
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_backlight_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_1800:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_1800:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_ABYSSUS_2000:
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_on);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_X:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_left_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_right_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_ELITE:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_left_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_left_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_right_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_right_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+
+            device_remove_file(&hdev->dev, &dev_attr_tilt_hwheel);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat_delay);
+            device_remove_file(&hdev->dev, &dev_attr_tilt_repeat);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_TRINITY:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_static);
+            break;
+
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_charge_effect);
+            device_remove_file(&hdev->dev, &dev_attr_charge_colour);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER:
+        case USB_DEVICE_ID_RAZER_VIPER_MINI:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER:
+        case USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER:
+        case USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED:
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS:
+        case USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER:
+        case USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED:
+        case USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS:
+            device_remove_file(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            fallthrough;
+        case USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_indicator_led_mode);
+            device_remove_file(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_pair);
+            device_remove_file(&hdev->dev, &dev_attr_hyperpolling_wireless_dongle_unpair);
+            break;
+
+        case USB_DEVICE_ID_RAZER_VIPER_8K:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_effect_custom);
+            device_remove_file(&hdev->dev, &dev_attr_matrix_custom_frame);
+            break;
+
+        case USB_DEVICE_ID_RAZER_COBRA:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+
+            device_remove_file(&hdev->dev, &dev_attr_logo_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_logo_matrix_effect_breath);
+            break;
+
+        case USB_DEVICE_ID_RAZER_DEATHADDER_V3:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED:
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_dpi_stages);
+
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_wave);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_reactive);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_breath);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            break;
+
+        case USB_DEVICE_ID_RAZER_NAGA_EPIC:
+            device_remove_file(&hdev->dev, &dev_attr_dpi);
+            device_remove_file(&hdev->dev, &dev_attr_poll_rate);
+            device_remove_file(&hdev->dev, &dev_attr_charge_low_threshold);
+            device_remove_file(&hdev->dev, &dev_attr_device_idle_time);
+            device_remove_file(&hdev->dev, &dev_attr_charge_level);
+            device_remove_file(&hdev->dev, &dev_attr_charge_status);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_led_brightness);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_none);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_static);
+            device_remove_file(&hdev->dev, &dev_attr_scroll_matrix_effect_spectrum);
+            break;
+        }
+
+    }
+
+    hid_hw_stop(hdev);
+    hrtimer_cancel(&dev->repeat_timer);
+
+    kfree(dev);
+    dev_info(&intf->dev, "Razer Device disconnected\n");
+}
+
+/**
+ * Device ID mapping table
+ */
+static const struct hid_device_id razer_devices[] = {
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OROCHI_2011) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS_1800) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS_2000) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_3_5G) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_HEX_RED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_2012) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_2014) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_HEX) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_TAIPAN) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_IMPERATOR) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OUROBOROS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_2013) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OROCHI_2013) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OROCHI_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_HEX_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_ELITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_3500) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_TRINITY) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_ELITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_1800) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_MINI) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_2000) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_X) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_8K) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_35K) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_COBRA) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS) },
+    { HID_USB_DEVICE(USB_VENDOR_ID_RAZER,USB_DEVICE_ID_RAZER_NAGA_EPIC) },
+    { 0 }
+};
+
+MODULE_DEVICE_TABLE(hid, razer_devices);
+
+/**
+ * Describes the contents of the driver
+ */
+static struct hid_driver razer_mouse_driver = {
+    .name      = "razermouse",
+    .id_table  = razer_devices,
+    .probe     = razer_mouse_probe,
+    .remove    = razer_mouse_disconnect,
+
+    .raw_event = razer_raw_event,
+    .input_mapping = razer_input_mapping,
+    .input_configured = razer_input_configured,
+};
+
+module_hid_driver(razer_mouse_driver);
diff --git a/drivers/custom/razer/driver/razermouse_driver.h b/drivers/custom/razer/driver/razermouse_driver.h
new file mode 100644
index 000000000000..60807fca9a1b
--- /dev/null
+++ b/drivers/custom/razer/driver/razermouse_driver.h
@@ -0,0 +1,181 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2015 Terri Cain <terri@dolphincorp.co.uk>
+ */
+
+#ifndef __HID_RAZER_MOUSE_H
+#define __HID_RAZER_MOUSE_H
+
+#define USB_DEVICE_ID_RAZER_OROCHI_2011 0x0013
+#define USB_DEVICE_ID_RAZER_NAGA 0x0015
+#define USB_DEVICE_ID_RAZER_DEATHADDER_3_5G 0x0016
+#define USB_DEVICE_ID_RAZER_NAGA_EPIC 0x001F
+#define USB_DEVICE_ID_RAZER_ABYSSUS_1800 0x0020
+#define USB_DEVICE_ID_RAZER_MAMBA_2012_WIRED 0x0024
+#define USB_DEVICE_ID_RAZER_MAMBA_2012_WIRELESS 0x0025
+#define USB_DEVICE_ID_RAZER_DEATHADDER_3_5G_BLACK 0x0029
+#define USB_DEVICE_ID_RAZER_NAGA_2012 0x002E
+#define USB_DEVICE_ID_RAZER_IMPERATOR 0x002F
+#define USB_DEVICE_ID_RAZER_OUROBOROS 0x0032
+#define USB_DEVICE_ID_RAZER_TAIPAN 0x0034
+#define USB_DEVICE_ID_RAZER_NAGA_HEX_RED 0x0036
+#define USB_DEVICE_ID_RAZER_DEATHADDER_2013 0x0037
+#define USB_DEVICE_ID_RAZER_DEATHADDER_1800 0x0038
+#define USB_DEVICE_ID_RAZER_OROCHI_2013 0x0039
+#define USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA 0x003E
+#define USB_DEVICE_ID_RAZER_NAGA_EPIC_CHROMA_DOCK 0x003F
+#define USB_DEVICE_ID_RAZER_NAGA_2014 0x0040
+#define USB_DEVICE_ID_RAZER_NAGA_HEX 0x0041
+#define USB_DEVICE_ID_RAZER_ABYSSUS 0x0042
+#define USB_DEVICE_ID_RAZER_DEATHADDER_CHROMA 0x0043
+#define USB_DEVICE_ID_RAZER_MAMBA_WIRED 0x0044
+#define USB_DEVICE_ID_RAZER_MAMBA_WIRELESS 0x0045
+#define USB_DEVICE_ID_RAZER_MAMBA_TE_WIRED 0x0046
+#define USB_DEVICE_ID_RAZER_OROCHI_CHROMA 0x0048
+#define USB_DEVICE_ID_RAZER_DIAMONDBACK_CHROMA 0x004C
+#define USB_DEVICE_ID_RAZER_DEATHADDER_2000 0x004F
+#define USB_DEVICE_ID_RAZER_NAGA_HEX_V2 0x0050
+#define USB_DEVICE_ID_RAZER_NAGA_CHROMA 0x0053
+#define USB_DEVICE_ID_RAZER_DEATHADDER_3500 0x0054
+#define USB_DEVICE_ID_RAZER_LANCEHEAD_WIRED 0x0059
+#define USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS 0x005A
+#define USB_DEVICE_ID_RAZER_ABYSSUS_V2 0x005B
+#define USB_DEVICE_ID_RAZER_DEATHADDER_ELITE 0x005C
+#define USB_DEVICE_ID_RAZER_ABYSSUS_2000 0x005E
+#define USB_DEVICE_ID_RAZER_LANCEHEAD_TE_WIRED 0x0060
+#define USB_DEVICE_ID_RAZER_ATHERIS_RECEIVER 0x0062
+#define USB_DEVICE_ID_RAZER_BASILISK 0x0064
+#define USB_DEVICE_ID_RAZER_BASILISK_ESSENTIAL 0x0065
+#define USB_DEVICE_ID_RAZER_NAGA_TRINITY 0x0067
+#define USB_DEVICE_ID_RAZER_ABYSSUS_ELITE_DVA_EDITION 0x006A
+#define USB_DEVICE_ID_RAZER_ABYSSUS_ESSENTIAL 0x006B
+#define USB_DEVICE_ID_RAZER_MAMBA_ELITE 0x006C
+#define USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL 0x006E
+#define USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_RECEIVER 0x006F
+#define USB_DEVICE_ID_RAZER_LANCEHEAD_WIRELESS_WIRED 0x0070
+#define USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_WHITE_EDITION 0x0071
+#define USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_RECEIVER 0x0072
+#define USB_DEVICE_ID_RAZER_MAMBA_WIRELESS_WIRED 0x0073
+#define USB_DEVICE_ID_RAZER_PRO_CLICK_RECEIVER 0x0077
+#define USB_DEVICE_ID_RAZER_VIPER 0x0078
+#define USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRED 0x007A
+#define USB_DEVICE_ID_RAZER_VIPER_ULTIMATE_WIRELESS 0x007B
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRED 0x007C
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2_PRO_WIRELESS 0x007D
+#define USB_DEVICE_ID_RAZER_PRO_CLICK_WIRED 0x0080
+#define USB_DEVICE_ID_RAZER_BASILISK_X_HYPERSPEED 0x0083
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2 0x0084
+#define USB_DEVICE_ID_RAZER_BASILISK_V2 0x0085
+#define USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_WIRED 0x0086
+#define USB_DEVICE_ID_RAZER_BASILISK_ULTIMATE_RECEIVER 0x0088
+#define USB_DEVICE_ID_RAZER_VIPER_MINI 0x008A
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2_MINI 0x008C
+#define USB_DEVICE_ID_RAZER_NAGA_LEFT_HANDED_2020 0x008D
+#define USB_DEVICE_ID_RAZER_NAGA_PRO_WIRED 0x008F
+#define USB_DEVICE_ID_RAZER_NAGA_PRO_WIRELESS 0x0090
+#define USB_DEVICE_ID_RAZER_VIPER_8K 0x0091
+#define USB_DEVICE_ID_RAZER_OROCHI_V2_RECEIVER 0x0094
+#define USB_DEVICE_ID_RAZER_OROCHI_V2_BLUETOOTH 0x0095
+#define USB_DEVICE_ID_RAZER_NAGA_X 0x0096
+#define USB_DEVICE_ID_RAZER_DEATHADDER_ESSENTIAL_2021 0x0098
+#define USB_DEVICE_ID_RAZER_BASILISK_V3 0x0099
+#define USB_DEVICE_ID_RAZER_PRO_CLICK_MINI_RECEIVER 0x009A
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2_X_HYPERSPEED 0x009C
+#define USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRED 0x009E
+#define USB_DEVICE_ID_RAZER_VIPER_MINI_SE_WIRELESS 0x009F
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V2_LITE 0x00A1
+#define USB_DEVICE_ID_RAZER_COBRA 0x00A3
+#define USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRED 0x00A5
+#define USB_DEVICE_ID_RAZER_VIPER_V2_PRO_WIRELESS 0x00A6
+#define USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRED 0x00A7
+#define USB_DEVICE_ID_RAZER_NAGA_V2_PRO_WIRELESS 0x00A8
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRED 0x00AA
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_WIRELESS 0x00AB
+#define USB_DEVICE_ID_RAZER_COBRA_PRO_WIRED 0x00AF
+#define USB_DEVICE_ID_RAZER_COBRA_PRO_WIRELESS 0x00B0
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3 0x00B2
+#define USB_DEVICE_ID_RAZER_HYPERPOLLING_WIRELESS_DONGLE 0x00B3
+#define USB_DEVICE_ID_RAZER_NAGA_V2_HYPERSPEED_RECEIVER 0x00B4
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED 0x00B6
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS 0x00B7
+#define USB_DEVICE_ID_RAZER_VIPER_V3_HYPERSPEED 0x00B8
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_X_HYPERSPEED 0x00B9
+#define USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRED 0x00C0
+#define USB_DEVICE_ID_RAZER_VIPER_V3_PRO_WIRELESS 0x00C1
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRED_ALT 0x00C2
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_PRO_WIRELESS_ALT 0x00C3
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRED 0x00C4
+#define USB_DEVICE_ID_RAZER_DEATHADDER_V3_HYPERSPEED_WIRELESS 0x00C5
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_35K 0x00CB
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRED 0x00CC
+#define USB_DEVICE_ID_RAZER_BASILISK_V3_PRO_35K_WIRELESS 0x00CD
+
+/* Each keyboard report has 90 bytes*/
+#define RAZER_REPORT_LEN 0x5A
+
+#define RAZER_MAMBA_ROW_LEN 15          // 0 => 14
+#define RAZER_MAMBA_TE_ROW_LEN 16       // 0 => 15
+#define RAZER_DIAMONDBACK_ROW_LEN 21    // 0 => 20
+
+#define RAZER_MOUSE_WAIT_MIN_US 600
+#define RAZER_MOUSE_WAIT_MAX_US 800
+
+#define RAZER_NEW_MOUSE_RECEIVER_WAIT_MIN_US 31000
+#define RAZER_NEW_MOUSE_RECEIVER_WAIT_MAX_US 31100
+
+#define RAZER_ATHERIS_RECEIVER_WAIT_MIN_US 400000
+#define RAZER_ATHERIS_RECEIVER_WAIT_MAX_US 400100
+
+#define RAZER_VIPER_MOUSE_RECEIVER_WAIT_MIN_US 59900
+#define RAZER_VIPER_MOUSE_RECEIVER_WAIT_MAX_US 60000
+
+#define RAZER_MOUSE_MAX_DPI_STAGES 5
+
+struct razer_mouse_device {
+    struct usb_device *usb_dev;
+    struct mutex lock;
+
+    struct input_dev *input;
+    struct hrtimer repeat_timer;
+    unsigned int tilt_hwheel;
+    unsigned int tilt_repeat_delay;
+    unsigned int tilt_repeat;
+    __s32 hwheel_value;
+    u8 button_byte; // Previous value of mouse button byte in HID record
+    u8 rep4[16]; // Previous value of report 4 on the keyboard intf
+
+    unsigned char usb_interface_protocol;
+    unsigned char usb_interface_subclass;
+
+    unsigned short usb_vid;
+    unsigned short usb_pid;
+
+    char serial[23]; // Now storing a random serial to be used with old devices that don't support it
+
+    struct {
+        unsigned char led;
+        unsigned char dpi;
+        unsigned short poll;
+    } orochi2011;
+
+    // The DeathAdder 3.5G, uses OR logic so need to remember last values. Part of a 4byte payload
+    struct {
+        unsigned char poll;
+        unsigned char dpi;
+        unsigned char profile;
+        unsigned char leds;
+    } da3_5g;
+};
+
+// Mamba Key Location
+// 0 => 6  --->  top left  => bottom left
+// 7 => 13 --->  top right => bottom right
+// 14      --->  Scroll LED
+
+// Mamba TE Key Location
+// 0 => 6  --->  top left  => bottom left
+// 7 => 13 --->  top right => bottom right
+// 14      --->  Logo LED
+// 15      --->  Scroll LED
+
+#endif
diff --git a/drivers/custom/razer/driver/usb_hid_keys.h b/drivers/custom/razer/driver/usb_hid_keys.h
new file mode 100644
index 000000000000..a5fbb68e0a64
--- /dev/null
+++ b/drivers/custom/razer/driver/usb_hid_keys.h
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * USB HID keycodes
+ * http://www.freebsddiary.org/APC/usb_hid_usages.php
+ */
+
+#ifndef __USB_HID_KEYS_H
+#define __USB_HID_KEYS_H
+
+#define USB_HID_KEY_F13 0x68
+#define USB_HID_KEY_F14 0x69
+#define USB_HID_KEY_F15 0x6A
+#define USB_HID_KEY_F16 0x6B
+#define USB_HID_KEY_F17 0x6C
+#define USB_HID_KEY_F18 0x6D
+#define USB_HID_KEY_F19 0x6E
+#define USB_HID_KEY_F20 0x6F
+#define USB_HID_KEY_F21 0x70
+#define USB_HID_KEY_F22 0x71
+#define USB_HID_KEY_F23 0x72
+#define USB_HID_KEY_F24 0x73
+
+#define USB_HID_KEY_MEDIA_PLAYPAUSE 0xE8
+#define USB_HID_KEY_MEDIA_PREVIOUSSONG  0xEA
+#define USB_HID_KEY_MEDIA_NEXTSONG  0xEB
+#define USB_HID_KEY_MEDIA_VOLUMEUP 0xED
+#define USB_HID_KEY_MEDIA_VOLUMEDOWN 0xEE
+#define USB_HID_KEY_MEDIA_MUTE 0xEF
+#define USB_HID_KEY_MEDIA_SLEEP 0xF8
+
+// https://usb.org/sites/default/files/hut1_22.pdf
+#define USB_HID_USAGE_MEDIA_PLAYPAUSE 0xCD
+#define USB_HID_USAGE_MEDIA_PREVIOUSSONG 0xB6
+#define USB_HID_USAGE_MEDIA_NEXTSONG 0xB5
+#define USB_HID_USAGE_MEDIA_VOLUMEUP 0xE9
+#define USB_HID_USAGE_MEDIA_VOLUMEDOWN 0xEA
+#define USB_HID_USAGE_MEDIA_MUTE 0xE2
+
+#endif // __USB_HID_KEYS_H
diff --git a/drivers/custom/razer/install_files/udev/99-razer.rules b/drivers/custom/razer/install_files/udev/99-razer.rules
new file mode 100644
index 000000000000..b25569c524f2
--- /dev/null
+++ b/drivers/custom/razer/install_files/udev/99-razer.rules
@@ -0,0 +1,39 @@
+ACTION!="add", GOTO="razer_end"
+SUBSYSTEMS=="usb|input|hid", ATTRS{idVendor}=="1532", GOTO="razer_vendor"
+GOTO="razer_end"
+
+LABEL="razer_vendor"
+
+# Mice
+ATTRS{idProduct}=="0013|0015|0016|001f|0020|0024|0025|0029|002e|002f|0032|0034|0036|0037|0038|0039|003e|003f|0040|0041|0042|0043|0044|0045|0046|0048|004c|004f|0050|0053|0054|0059|005a|005b|005c|005e|0060|0062|0064|0065|0067|006a|006b|006c|006e|006f|0070|0071|0072|0073|0077|0078|007a|007b|007c|007d|0080|0083|0084|0085|0086|0088|008a|008c|008d|008f|0090|0091|0094|0095|0096|0098|0099|009a|009c|009e|009f|00a1|00a3|00a5|00a6|00a7|00a8|00aa|00ab|00af|00b0|00b2|00b3|00b4|00b6|00b7|00b8|00b9|00c0|00c1|00c2|00c3|00c4|00c5|00cb|00cc|00cd", \
+    ATTRS{idVendor}=="1532", \
+    ENV{ID_RAZER_CHROMA}="1", ENV{RAZER_DRIVER}="razermouse"
+
+# Keyboards
+ATTRS{idProduct}=="010d|010e|010f|0111|0113|0118|011a|011b|011c|0201|0202|0203|0204|0205|0207|0208|0209|020f|0210|0211|0214|0216|0217|021a|021e|021f|0220|0221|0224|0225|0226|0227|0228|022a|022b|022c|022d|022f|0232|0233|0234|0235|0237|0239|023a|023b|023f|0240|0241|0243|0245|0246|024a|024b|024c|024d|024e|0252|0253|0255|0256|0257|0258|0259|025a|025c|025d|025e|0266|0268|0269|026a|026b|026c|026d|026e|026f|0270|0271|0276|0279|027a|0282|0287|028a|028b|028c|028d|028f|0290|0292|0293|0294|0295|0296|0298|029d|029e|029f|02a0|02a1|02a2|02a3|02a5|02a6|02b6|02b8|0a24", \
+    ATTRS{idVendor}=="1532", \
+    ENV{ID_RAZER_CHROMA}="1", ENV{RAZER_DRIVER}="razerkbd"
+
+# Kraken
+ATTRS{idProduct}=="0501|0504|0506|0510|0527|0560", \
+    ATTRS{idVendor}=="1532", \
+    ENV{ID_RAZER_CHROMA}="1", ENV{RAZER_DRIVER}="razerkraken"
+
+# Accessories (Speakers, Mousemats, Razer Core, etc)
+ATTRS{idProduct}=="0068|007e|0215|0517|0518|0c00|0c01|0c02|0c04|0c06|0f07|0f08|0f09|0f0d|0f12|0f19|0f1a|0f1d|0f1f|0f20|0f21|0f26|0f2b", \
+    ATTRS{idVendor}=="1532", \
+    ENV{ID_RAZER_CHROMA}="1", ENV{RAZER_DRIVER}="razeraccessory"
+
+# Get out if no match
+ENV{ID_RAZER_CHROMA}!="1", GOTO="razer_end"
+
+# Set permissions if this is an input node
+SUBSYSTEM=="usb|input|hid", GROUP:="plugdev"
+
+# We're done unless it's the hid node
+SUBSYSTEM!="hid|usb", GOTO="razer_end"
+
+# Rebind if needed
+SUBSYSTEM=="hid|usb", RUN+="razer_mount $env{RAZER_DRIVER} $kernel"
+
+LABEL="razer_end"
diff --git a/drivers/custom/razer/install_files/udev/razer_mount b/drivers/custom/razer/install_files/udev/razer_mount
new file mode 100755
index 000000000000..3fc0fef19aac
--- /dev/null
+++ b/drivers/custom/razer/install_files/udev/razer_mount
@@ -0,0 +1,62 @@
+#!/bin/sh
+
+# Exit on error
+set -e
+
+PATH='/sbin:/bin:/usr/sbin:/usr/bin'
+
+if [ -x /usr/bin/logger ]; then
+    LOGGER=/usr/bin/logger
+elif [ -x /bin/logger ]; then
+    LOGGER=/bin/logger
+else
+    unset LOGGER
+fi
+
+# for diagnostics
+if [ -t 1 -a -z "$LOGGER" ] || [ ! -e '/dev/log' ]; then
+    mesg() {
+        echo "$@" >&2
+    }
+elif [ -t 1 ]; then
+    mesg() {
+        echo "$@"
+        $LOGGER -t "${0##*/}[$$]" "$@"
+    }
+else
+    mesg() {
+        $LOGGER -t "${0##*/}[$$]" "$@"
+    }
+fi
+
+DRIVER=$1
+DEVICE_ID=$2
+
+mesg "Driver $DRIVER"
+mesg "Device_ID $DEVICE_ID"
+
+if [ ! -d /sys/bus/hid/drivers/"$DRIVER" ] ; then
+	mesg "Modprobing $DRIVER"
+	modprobe "$DRIVER"
+	sleep 0.05
+	mesg "Modprobed $DRIVER"
+fi
+
+for GENERIC_DRIVER in "razer" "hid-generic"; do
+	if [ -d /sys/bus/hid/drivers/"$GENERIC_DRIVER"/"$DEVICE_ID" ] ; then
+		# Unbind from hid
+		mesg "Unbinding $DEVICE_ID from $GENERIC_DRIVER"
+		printf '%s' "$DEVICE_ID" > /sys/bus/hid/drivers/"$GENERIC_DRIVER"/unbind
+		mesg "Binding $DEVICE_ID to $DRIVER"
+		printf '%s' "$DEVICE_ID" > /sys/bus/hid/drivers/"$DRIVER"/bind
+		sleep 0.1
+		mesg "Finished binding $DEVICE_ID"
+	fi
+done
+
+if [ -d /sys/bus/hid/drivers/"$DRIVER"/"$DEVICE_ID" ] ; then
+	mesg "Changing group /sys/bus/hid/drivers/$DRIVER/$DEVICE_ID/"
+	chgrp -R plugdev /sys/bus/hid/drivers/"$DRIVER"/"$DEVICE_ID"/
+	mesg "Changed group /sys/bus/hid/drivers/$DRIVER/$DEVICE_ID/"
+fi
+
# ----------------------------------------
# Module: v4l2loopback
# Version: 5eaa59e7c41d
# ----------------------------------------
diff --git a/drivers/custom/v4l2loopback/Kbuild b/drivers/custom/v4l2loopback/Kbuild
new file mode 100644
index 000000000000..9aad4eb75294
--- /dev/null
+++ b/drivers/custom/v4l2loopback/Kbuild
@@ -0,0 +1 @@
+obj-m		:= v4l2loopback.o
diff --git a/drivers/custom/v4l2loopback/Makefile b/drivers/custom/v4l2loopback/Makefile
new file mode 100644
index 000000000000..6d86646d5d04
--- /dev/null
+++ b/drivers/custom/v4l2loopback/Makefile
@@ -0,0 +1,139 @@
+ifneq ($(wildcard .gitversion),)
+# building a snapshot version
+V4L2LOOPBACK_SNAPSHOT_VERSION=$(patsubst v%,%,$(shell git describe --always --dirty 2>/dev/null || shell git describe --always 2>/dev/null || echo snapshot))
+override KCPPFLAGS += -DSNAPSHOT_VERSION='"$(V4L2LOOPBACK_SNAPSHOT_VERSION)"'
+endif
+
+include Kbuild
+ifeq ($(KBUILD_MODULES),)
+
+KERNELRELEASE	?= `uname -r`
+KERNEL_DIR	?= /lib/modules/$(KERNELRELEASE)/build
+PWD		:= $(shell pwd)
+
+PREFIX ?= /usr/local
+BINDIR  = $(PREFIX)/bin
+INCLUDEDIR = $(PREFIX)/include
+MANDIR  = $(PREFIX)/share/man
+MAN1DIR = $(MANDIR)/man1
+INSTALL = install
+INSTALL_PROGRAM = $(INSTALL) -p -m 755
+INSTALL_DIR     = $(INSTALL) -p -m 755 -d
+INSTALL_DATA    = $(INSTALL) -m 644
+
+MODULE_OPTIONS = devices=2
+
+##########################################
+# note on build targets
+#
+# module-assistant makes some assumptions about targets, namely
+#  <modulename>: must be present and build the module <modulename>
+#                <modulename>.ko is not enough
+# install: must be present (and should only install the module)
+#
+# we therefore make <modulename> a .PHONY alias to <modulename>.ko
+# and remove utils-installation from 'install'
+# call 'make install-all' if you want to install everything
+##########################################
+
+
+.PHONY: all install clean distclean
+.PHONY: install-all install-extra install-utils install-man install-headers
+.PHONY: modprobe v4l2loopback
+
+# we don't control the .ko file dependencies, as it is done by kernel
+# makefiles. therefore v4l2loopback.ko is a phony target actually
+.PHONY: v4l2loopback.ko utils
+
+all: v4l2loopback.ko utils
+
+v4l2loopback: v4l2loopback.ko
+v4l2loopback.ko:
+	@echo "Building v4l2-loopback driver..."
+	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) KCPPFLAGS="$(KCPPFLAGS)" modules
+
+install-all: install install-extra
+install:
+	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules_install
+	@echo ""
+	@echo "SUCCESS (if you got 'SSL errors' above, you can safely ignore them)"
+	@echo ""
+
+install-extra: install-utils install-man install-headers
+install-utils: utils/v4l2loopback-ctl
+	$(INSTALL_DIR) "$(DESTDIR)$(BINDIR)"
+	$(INSTALL_PROGRAM) $< "$(DESTDIR)$(BINDIR)"
+
+install-man: man/v4l2loopback-ctl.1
+	$(INSTALL_DIR) "$(DESTDIR)$(MAN1DIR)"
+	$(INSTALL_DATA) $< "$(DESTDIR)$(MAN1DIR)"
+
+install-headers: v4l2loopback.h
+	$(INSTALL_DIR) "$(DESTDIR)$(INCLUDEDIR)/linux"
+	$(INSTALL_DATA) $< "$(DESTDIR)$(INCLUDEDIR)/linux"
+
+clean:
+	rm -f *~
+	rm -f Module.symvers Module.markers modules.order
+	$(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean
+	-$(MAKE) -C utils clean
+
+distclean: clean
+	rm -f man/v4l2loopback-ctl.1
+
+modprobe: v4l2loopback.ko
+	-sudo chmod a+r $<
+	-sudo modprobe videodev
+	-sudo rmmod $<
+	sudo insmod ./$< $(MODULE_OPTIONS)
+
+man/v4l2loopback-ctl.1: utils/v4l2loopback-ctl
+	help2man -N --name "control v4l2 loopback devices" \
+		--no-discard-stderr --help-option=-h --version-option=-v \
+		$^ > $@
+
+utils: utils/v4l2loopback-ctl
+utils/v4l2loopback-ctl: utils/v4l2loopback-ctl.c v4l2loopback.h
+	$(MAKE) -C utils V4L2LOOPBACK_SNAPSHOT_VERSION=$(V4L2LOOPBACK_SNAPSHOT_VERSION)
+
+.clang-format:
+	curl "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/.clang-format" > $@
+
+.PHONY: clang-format
+clang-format: .clang-format
+	clang-format -i *.c *.h utils/*.c
+
+.PHONY: sign
+# try to read the default certificate/key from the dkms config
+dkms_framework=/etc/dkms/framework.conf /etc/dkms/framework.conf.d/*.conf
+KBUILD_SIGN_KEY=$(patsubst mok_signing_key=%,%,$(lastword $(shell grep -h -E "^[[:space:]]*mok_signing_key=" $(dkms_framework))))
+KBUILD_SIGN_CERT=$(patsubst mok_certificate=%,%,$(lastword $(shell grep -h -E "^[[:space:]]*mok_certificate=" $(dkms_framework))))
+
+ifeq ($(KBUILD_SIGN_PIN),)
+define usage_kbuildsignpin
+$(info )
+$(info ++++++ If your certificate requires a password, pass it via the KBUILD_SIGN_PIN env-var!)
+$(info ++++++ E.g. using 'export KBUILD_SIGN_PIN; read -s -p "Passphrase for signing key $(KBUILD_SIGN_KEY): " KBUILD_SIGN_PIN; sudo --preserve-env=KBUILD_SIGN_PIN make sign')
+$(info )
+endef
+endif
+
+define usage_kbuildsign
+sign: v4l2loopback.ko
+	$(info )
+	$(info ++++++ To sign the $< module, you must set KBUILD_SIGN_KEY/KBUILD_SIGN_CERT to point to the signing key/certificate!)
+	$(info ++++++ For your convenience, we try to read these variables as 'mok_signing_key' resp. 'mok_certificate' from $(dkms_framework))
+	$(call usage_kbuildsignpin)
+endef
+
+ifeq ($(wildcard $(KBUILD_SIGN_KEY)),)
+$(call usage_kbuildsign)
+else ifeq ($(wildcard $(KBUILD_SIGN_CERT)),)
+$(call usage_kbuildsign)
+else
+sign: v4l2loopback.ko
+	$(call usage_kbuildsignpin)
+	"$(KERNEL_DIR)"/scripts/sign-file sha256 $(KBUILD_SIGN_KEY) $(KBUILD_SIGN_CERT) $<
+endif
+
+endif # !kbuild
diff --git a/drivers/custom/v4l2loopback/doc/missingformats.h b/drivers/custom/v4l2loopback/doc/missingformats.h
new file mode 100644
index 000000000000..89de33cbe2b8
--- /dev/null
+++ b/drivers/custom/v4l2loopback/doc/missingformats.h
@@ -0,0 +1,291 @@
+#ifdef V4L2_PIX_FMT_Y10BPACK
+	}, {
+		.name     = "10 bpp Greyscale bit-packed",
+		.fourcc   = V4L2_PIX_FMT_Y10BPACK,
+		.depth    = 10,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_Y10BPACK */
+#ifdef V4L2_PIX_FMT_PAL8
+	}, {
+		.name     = "8 bpp 8-bit palette",
+		.fourcc   = V4L2_PIX_FMT_PAL8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_PAL8 */
+#ifdef V4L2_PIX_FMT_UV8
+	}, {
+		.name     = "8 bpp UV 4:4",
+		.fourcc   = V4L2_PIX_FMT_UV8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_UV8 */
+
+#ifdef V4L2_PIX_FMT_HI240
+	}, {
+		.name     = "8 bpp 8-bit color  ",
+		.fourcc   = V4L2_PIX_FMT_HI240,
+		.depth    = 8,
+		.flags    = FORMAT_FLAGS_PLANAR,
+#endif /* V4L2_PIX_FMT_HI240 */
+#ifdef V4L2_PIX_FMT_HM12
+	}, {
+		.name     = "8 bpp YUV 4:2:0 16x16 macroblocks",
+		.fourcc   = V4L2_PIX_FMT_HM12,
+		.depth    = 8,
+		.flags    = FORMAT_FLAGS_PLANAR,
+#endif /* V4L2_PIX_FMT_HM12 */
+#ifdef V4L2_PIX_FMT_M420
+	}, {
+		.name     = "12 bpp YUV 4:2:0 2 lines y, 1 line uv interleaved",
+		.fourcc   = V4L2_PIX_FMT_M420,
+		.depth    = 12,
+		.flags    = FORMAT_FLAGS_PLANAR,
+#endif /* V4L2_PIX_FMT_M420 */
+
+
+
+#ifdef V4L2_PIX_FMT_NV12
+	}, {
+		.name     = "12 bpp Y/CbCr 4:2:0 ",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV12 */
+#ifdef V4L2_PIX_FMT_NV21
+	}, {
+		.name     = "12 bpp Y/CrCb 4:2:0 ",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV21 */
+#ifdef V4L2_PIX_FMT_NV16
+	}, {
+		.name     = "16 bpp Y/CbCr 4:2:2 ",
+		.fourcc   = V4L2_PIX_FMT_NV16,
+		.depth    = 16,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV16 */
+#ifdef V4L2_PIX_FMT_NV61
+	}, {
+		.name     = "16 bpp Y/CrCb 4:2:2 ",
+		.fourcc   = V4L2_PIX_FMT_NV61,
+		.depth    = 16,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV61 */
+#ifdef V4L2_PIX_FMT_NV24
+	}, {
+		.name     = "24 bpp Y/CbCr 4:4:4 ",
+		.fourcc   = V4L2_PIX_FMT_NV24,
+		.depth    = 24,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV24 */
+#ifdef V4L2_PIX_FMT_NV42
+	}, {
+		.name     = "24 bpp Y/CrCb 4:4:4 ",
+		.fourcc   = V4L2_PIX_FMT_NV42,
+		.depth    = 24,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV42 */
+#ifdef V4L2_PIX_FMT_NV12M
+	}, {
+		.name     = "12 bpp Y/CbCr 4:2:0 ",
+		.fourcc   = V4L2_PIX_FMT_NV12M,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV12M */
+#ifdef V4L2_PIX_FMT_NV21M
+	}, {
+		.name     = "21 bpp Y/CrCb 4:2:0 ",
+		.fourcc   = V4L2_PIX_FMT_NV21M,
+		.depth    = 21,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV21M */
+#ifdef V4L2_PIX_FMT_NV16M
+	}, {
+		.name     = "16 bpp Y/CbCr 4:2:2 ",
+		.fourcc   = V4L2_PIX_FMT_NV16M,
+		.depth    = 16,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV16M */
+#ifdef V4L2_PIX_FMT_NV61M
+	}, {
+		.name     = "16 bpp Y/CrCb 4:2:2 ",
+		.fourcc   = V4L2_PIX_FMT_NV61M,
+		.depth    = 16,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV61M */
+#ifdef V4L2_PIX_FMT_NV12MT
+	}, {
+		.name     = "12 bpp Y/CbCr 4:2:0 64x32 macroblocks",
+		.fourcc   = V4L2_PIX_FMT_NV12MT,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV12MT */
+#ifdef V4L2_PIX_FMT_NV12MT_16X16
+	}, {
+		.name     = "12 bpp Y/CbCr 4:2:0 16x16 macroblocks",
+		.fourcc   = V4L2_PIX_FMT_NV12MT_16X16,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_NV12MT_16X16 */
+#ifdef V4L2_PIX_FMT_YUV420M
+	}, {
+		.name     = "12 bpp YUV420 planar",
+		.fourcc   = V4L2_PIX_FMT_YUV420M,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_YUV420M */
+#ifdef V4L2_PIX_FMT_YVU420M
+	}, {
+		.name     = "12 bpp YVU420 planar",
+		.fourcc   = V4L2_PIX_FMT_YVU420M,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_YVU420M */
+#ifdef V4L2_PIX_FMT_SBGGR8
+	}, {
+		.name     = "8 bpp BGBG.. GRGR..",
+		.fourcc   = V4L2_PIX_FMT_SBGGR8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR8 */
+#ifdef V4L2_PIX_FMT_SGBRG8
+	}, {
+		.name     = "8 bpp GBGB.. RGRG..",
+		.fourcc   = V4L2_PIX_FMT_SGBRG8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGBRG8 */
+#ifdef V4L2_PIX_FMT_SGRBG8
+	}, {
+		.name     = "8 bpp GRGR.. BGBG..",
+		.fourcc   = V4L2_PIX_FMT_SGRBG8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGRBG8 */
+#ifdef V4L2_PIX_FMT_SRGGB8
+	}, {
+		.name     = "8 bpp RGRG.. GBGB..",
+		.fourcc   = V4L2_PIX_FMT_SRGGB8,
+		.depth    = 8,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SRGGB8 */
+#ifdef V4L2_PIX_FMT_SBGGR10
+	}, {
+		.name     = "10 bpp BGBG.. GRGR..",
+		.fourcc   = V4L2_PIX_FMT_SBGGR10,
+		.depth    = 10,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR10 */
+#ifdef V4L2_PIX_FMT_SGBRG10
+	}, {
+		.name     = "10 bpp GBGB.. RGRG..",
+		.fourcc   = V4L2_PIX_FMT_SGBRG10,
+		.depth    = 10,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGBRG10 */
+#ifdef V4L2_PIX_FMT_SGRBG10
+	}, {
+		.name     = "10 bpp GRGR.. BGBG..",
+		.fourcc   = V4L2_PIX_FMT_SGRBG10,
+		.depth    = 10,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGRBG10 */
+#ifdef V4L2_PIX_FMT_SRGGB10
+	}, {
+		.name     = "10 bpp RGRG.. GBGB..",
+		.fourcc   = V4L2_PIX_FMT_SRGGB10,
+		.depth    = 10,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SRGGB10 */
+#ifdef V4L2_PIX_FMT_SBGGR12
+	}, {
+		.name     = "12 bpp BGBG.. GRGR..",
+		.fourcc   = V4L2_PIX_FMT_SBGGR12,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR12 */
+#ifdef V4L2_PIX_FMT_SGBRG12
+	}, {
+		.name     = "12 bpp GBGB.. RGRG..",
+		.fourcc   = V4L2_PIX_FMT_SGBRG12,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGBRG12 */
+#ifdef V4L2_PIX_FMT_SGRBG12
+	}, {
+		.name     = "12 bpp GRGR.. BGBG..",
+		.fourcc   = V4L2_PIX_FMT_SGRBG12,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGRBG12 */
+#ifdef V4L2_PIX_FMT_SRGGB12
+	}, {
+		.name     = "12 bpp RGRG.. GBGB..",
+		.fourcc   = V4L2_PIX_FMT_SRGGB12,
+		.depth    = 12,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SRGGB12 */
+#ifdef V4L2_PIX_FMT_SBGGR10ALAW8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SBGGR10ALAW8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR10ALAW8 */
+#ifdef V4L2_PIX_FMT_SGBRG10ALAW8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SGBRG10ALAW8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGBRG10ALAW8 */
+#ifdef V4L2_PIX_FMT_SGRBG10ALAW8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SGRBG10ALAW8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGRBG10ALAW8 */
+#ifdef V4L2_PIX_FMT_SRGGB10ALAW8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SRGGB10ALAW8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SRGGB10ALAW8 */
+#ifdef V4L2_PIX_FMT_SBGGR10DPCM8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SBGGR10DPCM8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR10DPCM8 */
+#ifdef V4L2_PIX_FMT_SGBRG10DPCM8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SGBRG10DPCM8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGBRG10DPCM8 */
+#ifdef V4L2_PIX_FMT_SGRBG10DPCM8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SGRBG10DPCM8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SGRBG10DPCM8 */
+#ifdef V4L2_PIX_FMT_SRGGB10DPCM8
+	}, {
+		.name     = "",
+		.fourcc   = V4L2_PIX_FMT_SRGGB10DPCM8,
+		.depth    = 0,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SRGGB10DPCM8 */
+#ifdef V4L2_PIX_FMT_SBGGR16
+	}, {
+		.name     = "16 bpp BGBG.. GRGR..",
+		.fourcc   = V4L2_PIX_FMT_SBGGR16,
+		.depth    = 16,
+		.flags    = 0,
+#endif /* V4L2_PIX_FMT_SBGGR16 */
diff --git a/drivers/custom/v4l2loopback/examples/ondemandcam.c b/drivers/custom/v4l2loopback/examples/ondemandcam.c
new file mode 100644
index 000000000000..eae56bb7658f
--- /dev/null
+++ b/drivers/custom/v4l2loopback/examples/ondemandcam.c
@@ -0,0 +1,130 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>                /* low-level i/o */
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include <malloc.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
+#include <pthread.h>
+#include <semaphore.h>
+
+static char *v4l2dev = "/dev/video1";
+static int v4l2sink = -1;
+static int width = 80;                //640;    // Default for Flash
+static int height = 60;        //480;    // Default for Flash
+static char *vidsendbuf = NULL;
+static int vidsendsiz = 0;
+
+static void init_device() {
+
+}
+
+static void grab_frame() {
+
+    struct timespec ts;
+    clock_gettime(CLOCK_REALTIME, &ts);
+    memset( vidsendbuf, 0, 3);
+    switch( ts.tv_sec & 3 ) {
+    case 0:
+        vidsendbuf[0] = 255;
+        break;
+    case 1:
+        vidsendbuf[0] = 255;
+        vidsendbuf[1] = 255;
+        break;
+    case 2:
+        vidsendbuf[1] = 255;
+        break;
+    case 3:
+        vidsendbuf[2] = 255;
+        break;
+    }
+    memcpy( vidsendbuf+3, vidsendbuf, vidsendsiz-3 );
+}
+
+static void stop_device() {
+
+}
+
+static void open_vpipe()
+{
+    v4l2sink = open(v4l2dev, O_WRONLY);
+    if (v4l2sink < 0) {
+        fprintf(stderr, "Failed to open v4l2sink device. (%s)\n", strerror(errno));
+        exit(-2);
+    }
+    // setup video for proper format
+    struct v4l2_format v;
+    int t;
+    v.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    t = ioctl(v4l2sink, VIDIOC_G_FMT, &v);
+    if( t < 0 )
+        exit(t);
+    v.fmt.pix.width = width;
+    v.fmt.pix.height = height;
+    v.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB24;
+    vidsendsiz = width * height * 3;
+    v.fmt.pix.sizeimage = vidsendsiz;
+    t = ioctl(v4l2sink, VIDIOC_S_FMT, &v);
+    if( t < 0 )
+        exit(t);
+    vidsendbuf = malloc( vidsendsiz );
+}
+
+static pthread_t sender;
+static sem_t lock1,lock2;
+static void *sendvid(void *v)
+{
+    for (;;) {
+        sem_wait(&lock1);
+        if (vidsendsiz != write(v4l2sink, vidsendbuf, vidsendsiz))
+            exit(-1);
+        sem_post(&lock2);
+    }
+}
+
+int main(int argc, char **argv)
+{
+    struct timespec ts;
+
+    if( argc == 2 )
+        v4l2dev = argv[1];
+
+    open_vpipe();
+
+    // open and lock response
+    if (sem_init(&lock2, 0, 1) == -1)
+        exit(-1);
+    sem_wait(&lock2);
+
+    if (sem_init(&lock1, 0, 1) == -1)
+        exit(-1);
+    pthread_create(&sender, NULL, sendvid, NULL);
+
+    for (;;) {
+        // wait until a frame can be written
+        fprintf( stderr, "Waiting for sink\n" );
+        sem_wait(&lock2);
+        // setup source
+        init_device(); // open and setup SPI
+        for (;;) {
+            grab_frame();
+            // push it out
+            sem_post(&lock1);
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_sec += 2;
+            // wait for it to get written (or is blocking)
+            if (sem_timedwait(&lock2, &ts))
+                break;
+        }
+        stop_device(); // close SPI
+    }
+    close(v4l2sink);
+    return 0;
+}
diff --git a/drivers/custom/v4l2loopback/examples/test.c b/drivers/custom/v4l2loopback/examples/test.c
new file mode 100644
index 000000000000..ca0b4f549305
--- /dev/null
+++ b/drivers/custom/v4l2loopback/examples/test.c
@@ -0,0 +1,188 @@
+/*
+ * How to test v4l2loopback:
+ * 1. launch this test program (even in background), it will initialize the
+ *    loopback device and keep it open so it won't loose the settings.
+ * 2. Feed the video device with data according to the settings specified
+ *    below: size, pixelformat, etc.
+ *    For instance, you can try the default settings with this command:
+ *    mencoder video.avi -ovc raw -nosound -vf scale=640:480,format=yuy2 -o /dev/video1
+ *    TODO: a command that limits the fps would be better :)
+ *
+ * Test the video in your favourite viewer, for instance:
+ *   luvcview -d /dev/video1 -f yuyv
+ */
+
+#include <linux/videodev2.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <assert.h>
+
+#define ROUND_UP_2(num)  (((num)+1)&~1)
+#define ROUND_UP_4(num)  (((num)+3)&~3)
+#define ROUND_UP_8(num)  (((num)+7)&~7)
+#define ROUND_UP_16(num) (((num)+15)&~15)
+#define ROUND_UP_32(num) (((num)+31)&~31)
+#define ROUND_UP_64(num) (((num)+63)&~63)
+
+
+
+
+#if 0
+# define CHECK_REREAD
+#endif
+
+#define VIDEO_DEVICE "/dev/video0"
+#if 1
+# define FRAME_WIDTH  640
+# define FRAME_HEIGHT 480
+#else
+# define FRAME_WIDTH  512
+# define FRAME_HEIGHT 512
+#endif
+
+#if 0
+# define FRAME_FORMAT V4L2_PIX_FMT_YUYV
+#else
+# define FRAME_FORMAT V4L2_PIX_FMT_YVU420
+#endif
+
+static int debug = 0;
+
+
+int format_properties(const unsigned int format,
+		const unsigned int width,
+		const unsigned int height,
+		size_t*linewidth,
+		size_t*framewidth) {
+size_t lw, fw;
+	switch(format) {
+	case V4L2_PIX_FMT_YUV420: case V4L2_PIX_FMT_YVU420:
+		lw = width; /* ??? */
+		fw = ROUND_UP_4 (width) * ROUND_UP_2 (height);
+		fw += 2 * ((ROUND_UP_8 (width) / 2) * (ROUND_UP_2 (height) / 2));
+	break;
+	case V4L2_PIX_FMT_UYVY: case V4L2_PIX_FMT_Y41P: case V4L2_PIX_FMT_YUYV: case V4L2_PIX_FMT_YVYU:
+		lw = (ROUND_UP_2 (width) * 2);
+		fw = lw * height;
+	break;
+	default:
+		return 0;
+	}
+
+	if(linewidth)*linewidth=lw;
+	if(framewidth)*framewidth=fw;
+
+	return 1;
+}
+
+
+void print_format(struct v4l2_format*vid_format) {
+  printf("	vid_format->type                =%d\n",	vid_format->type );
+  printf("	vid_format->fmt.pix.width       =%d\n",	vid_format->fmt.pix.width );
+  printf("	vid_format->fmt.pix.height      =%d\n",	vid_format->fmt.pix.height );
+  printf("	vid_format->fmt.pix.pixelformat =%d\n",	vid_format->fmt.pix.pixelformat);
+  printf("	vid_format->fmt.pix.sizeimage   =%d\n",	vid_format->fmt.pix.sizeimage );
+  printf("	vid_format->fmt.pix.field       =%d\n",	vid_format->fmt.pix.field );
+  printf("	vid_format->fmt.pix.bytesperline=%d\n",	vid_format->fmt.pix.bytesperline );
+  printf("	vid_format->fmt.pix.colorspace  =%d\n",	vid_format->fmt.pix.colorspace );
+}
+
+int main(int argc, char**argv)
+{
+	struct v4l2_capability vid_caps;
+	struct v4l2_format vid_format;
+
+	size_t framesize = 0;
+	size_t linewidth = 0;
+
+	__u8*buffer;
+	__u8*check_buffer;
+
+  const char*video_device=VIDEO_DEVICE;
+	int fdwr = 0;
+	int ret_code = 0;
+
+	int i;
+
+	if(argc>1) {
+		video_device=argv[1];
+		printf("using output device: %s\n", video_device);
+	}
+
+	fdwr = open(video_device, O_RDWR);
+	assert(fdwr >= 0);
+
+	ret_code = ioctl(fdwr, VIDIOC_QUERYCAP, &vid_caps);
+	assert(ret_code != -1);
+
+	memset(&vid_format, 0, sizeof(vid_format));
+
+	ret_code = ioctl(fdwr, VIDIOC_G_FMT, &vid_format);
+  if(debug)print_format(&vid_format);
+
+	vid_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	vid_format.fmt.pix.width = FRAME_WIDTH;
+	vid_format.fmt.pix.height = FRAME_HEIGHT;
+	vid_format.fmt.pix.pixelformat = FRAME_FORMAT;
+	vid_format.fmt.pix.sizeimage = framesize;
+	vid_format.fmt.pix.field = V4L2_FIELD_NONE;
+	vid_format.fmt.pix.bytesperline = linewidth;
+	vid_format.fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+
+  if(debug)print_format(&vid_format);
+	ret_code = ioctl(fdwr, VIDIOC_S_FMT, &vid_format);
+
+	assert(ret_code != -1);
+
+	if(debug)printf("frame: format=%d\tsize=%lu\n", FRAME_FORMAT, framesize);
+  print_format(&vid_format);
+
+	if(!format_properties(vid_format.fmt.pix.pixelformat,
+                        vid_format.fmt.pix.width, vid_format.fmt.pix.height,
+                        &linewidth,
+                        &framesize)) {
+		printf("unable to guess correct settings for format '%d'\n", FRAME_FORMAT);
+	}
+	buffer=(__u8*)malloc(sizeof(__u8)*framesize);
+	check_buffer=(__u8*)malloc(sizeof(__u8)*framesize);
+
+	memset(buffer, 0, framesize);
+	memset(check_buffer, 0, framesize);
+	for (i = 0; i < framesize; ++i) {
+		//buffer[i] = i % 2;
+		check_buffer[i] = 0;
+	}
+
+
+
+
+
+	write(fdwr, buffer, framesize);
+
+#ifdef CHECK_REREAD
+	do {
+	/* check if we get the same data on output */
+	int fdr = open(video_device, O_RDONLY);
+	read(fdr, check_buffer, framesize);
+	for (i = 0; i < framesize; ++i) {
+		if (buffer[i] != check_buffer[i])
+			assert(0);
+	}
+	close(fdr);
+	} while(0);
+#endif
+
+	pause();
+
+	close(fdwr);
+
+	free(buffer);
+	free(check_buffer);
+
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/examples/yuv420_infiniteloop.c b/drivers/custom/v4l2loopback/examples/yuv420_infiniteloop.c
new file mode 100644
index 000000000000..78a30c0be7e8
--- /dev/null
+++ b/drivers/custom/v4l2loopback/examples/yuv420_infiniteloop.c
@@ -0,0 +1,121 @@
+/* Read a yuv file directly and play with infinite loop
+ *
+ * Example:
+ * $ ./yuv420_infiniteloop /dev/video1 akiyo_qcif.yuv 176 144 30
+
+ * This will loop a yuv file named akiyo_qcif.yuv over video 1
+ *
+ * Modified by T. Xu <x.tongda@nyu.edu> from yuv4mpeg_to_v4l2 example,
+ * original Copyright (C) 2011  Eric C. Cooper <ecc@cmu.edu>
+ * Released under the GNU General Public License
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
+
+char *prog;
+
+struct yuv_setup {
+	char *device;
+	char *file_name;
+	int frame_width;
+	int frame_height;
+	int frame_bytes;
+	float fps;
+};
+
+void
+fail(char *msg)
+{
+	fprintf(stderr, "%s: %s\n", prog, msg);
+	exit(1);
+}
+
+struct yuv_setup
+process_args(int argc, char **argv)
+{
+	prog = argv[0];
+	struct yuv_setup setup;
+	if (argc != 6) {
+		fail("invalid argument");
+	} else {
+		setup.device = argv[1];
+		setup.file_name = argv[2];
+		setup.frame_width = atoi(argv[3]);
+		setup.frame_height = atoi(argv[4]);
+		setup.frame_bytes = 3 * setup.frame_height * setup.frame_width / 2;
+		setup.fps = atof(argv[5]);
+	}
+	return setup;
+}
+
+void
+copy_frames(struct yuv_setup setup, int dev_fd)
+{
+
+	FILE * yuv_file = fopen (setup.file_name,"rb");
+	if (yuv_file == NULL) {
+		fail("can not open yuv file");
+	}
+
+	char *frame = malloc(setup.frame_bytes);
+
+	if (frame == NULL) {
+		fail("cannot malloc frame");
+	}
+
+	while (1) {
+		int read_size = fread(frame, 1, setup.frame_bytes, yuv_file);
+		usleep(1.0f/setup.fps * 1000000.0f);
+		if (read_size == setup.frame_bytes) {
+			write(dev_fd, frame, setup.frame_bytes);
+		} else if (read_size == 0) {
+			fclose(yuv_file);
+			yuv_file = fopen (setup.file_name,"rb");
+		} else {
+			free(frame);
+			fail("invalid frame size or file ending");
+		}
+	}
+
+  free(frame);
+}
+
+int
+open_video(struct yuv_setup setup)
+{
+	struct v4l2_format v;
+
+	int dev_fd = open(setup.device, O_RDWR);
+	if (dev_fd == -1) {
+		fail("cannot open video device");
+	}
+	v.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (ioctl(dev_fd, VIDIOC_G_FMT, &v) == -1) {
+		fail("cannot setup video device");
+	}
+	v.fmt.pix.width = setup.frame_width;
+	v.fmt.pix.height = setup.frame_height;
+	v.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+	v.fmt.pix.sizeimage = setup.frame_bytes;
+	v.fmt.pix.field = V4L2_FIELD_NONE;
+	if (ioctl(dev_fd, VIDIOC_S_FMT, &v) == -1) {
+		fail("cannot setup video device");
+	}
+
+	return dev_fd;
+}
+
+int
+main(int argc, char **argv)
+{
+	struct yuv_setup loc_setup = process_args(argc, argv);
+	int loc_dev = open_video(loc_setup);
+	copy_frames(loc_setup, loc_dev);
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/examples/yuv4mpeg_to_v4l2.c b/drivers/custom/v4l2loopback/examples/yuv4mpeg_to_v4l2.c
new file mode 100644
index 000000000000..d1d9bdfc0430
--- /dev/null
+++ b/drivers/custom/v4l2loopback/examples/yuv4mpeg_to_v4l2.c
@@ -0,0 +1,184 @@
+/*
+ * Copy a YUV4MPEG stream to a v4l2 output device.
+ * The stream is read from standard input.
+ * The device can be specified as argument; it defaults to /dev/video0.
+ *
+ * Example using mplayer as a producer for the v4l2loopback driver:
+ *
+ * $ mkfifo /tmp/pipe
+ * $ ./yuv4mpeg_to_v4l2 < /tmp/pipe &
+ * $ mplayer movie.mp4 -vo yuv4mpeg:file=/tmp/pipe
+ *
+ * Copyright (C) 2011  Eric C. Cooper <ecc@cmu.edu>
+ * Released under the GNU General Public License
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
+
+char *prog;
+
+char *device;
+int dev_fd;
+
+int frame_width;
+int frame_height;
+int frame_bytes;
+
+void
+usage(void)
+{
+	fprintf(stderr, "Usage: %s [/dev/videoN]\n", prog);
+	exit(1);
+}
+
+void
+process_args(int argc, char **argv)
+{
+	prog = argv[0];
+	switch (argc) {
+	case 1:
+		device = "/dev/video0";
+		break;
+	case 2:
+		device = argv[1];
+		break;
+	default:
+		usage();
+		break;
+	}
+}
+
+void
+sysfail(char *msg)
+{
+	perror(msg);
+	exit(1);
+}
+
+void
+fail(char *msg)
+{
+	fprintf(stderr, "%s: %s\n", prog, msg);
+	exit(1);
+}
+
+void
+bad_header(char *kind)
+{
+	char msg[64];
+
+	sprintf(msg, "malformed %s header", kind);
+	fail(msg);
+}
+
+void
+do_tag(char tag, char *value)
+{
+	switch (tag) {
+	case 'W':
+		frame_width = strtoul(value, NULL, 10);
+		break;
+	case 'H':
+		frame_height = strtoul(value, NULL, 10);
+		break;
+	}
+}
+
+int
+read_header(char *magic)
+{
+	char *p, *q, *p0;
+	size_t n;
+	int first, done;
+
+	p0 = NULL;
+	if (getline(&p0, &n, stdin) == -1) {
+    free(p0);
+    return 0;
+  }
+
+	q = p = p0;
+	first = 1;
+	done = 0;
+	while (!done) {
+		while (*q != ' ' && *q != '\n')
+			if (*q++ == '\0') bad_header(magic);
+		done = (*q == '\n');
+		*q = '\0';
+		if (first)
+			if (strcmp(p, magic) == 0) first = 0;
+			else bad_header(magic);
+		else
+			do_tag(*p, p + 1);
+		p = ++q;
+	}
+
+  free(p0);
+	return 1;
+}
+
+void
+process_header(void)
+{
+	if (!read_header("YUV4MPEG2")) fail("missing YUV4MPEG2 header");
+	frame_bytes = 3 * frame_width * frame_height / 2;
+	if (frame_bytes == 0) fail("frame width or height is missing");
+}
+
+void
+copy_frames(void)
+{
+	char *frame;
+
+	frame = malloc(frame_bytes);
+	if (frame == NULL) fail("cannot malloc frame");
+	while (read_header("FRAME")) {
+		if (fread(frame, 1, frame_bytes, stdin) != frame_bytes) {
+      free(frame);
+			fail("malformed frame");
+    }
+		else if (write(dev_fd, frame, frame_bytes) != frame_bytes) {
+      free(frame);
+			sysfail("write");
+    }
+	}
+
+  free(frame);
+}
+
+#define vidioc(op, arg) \
+	if (ioctl(dev_fd, VIDIOC_##op, arg) == -1) \
+		sysfail(#op); \
+	else
+
+void
+open_video(void)
+{
+	struct v4l2_format v;
+
+	dev_fd = open(device, O_RDWR);
+	if (dev_fd == -1) sysfail(device);
+	v.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	vidioc(G_FMT, &v);
+	v.fmt.pix.width = frame_width;
+	v.fmt.pix.height = frame_height;
+	v.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+	v.fmt.pix.sizeimage = frame_bytes;
+	vidioc(S_FMT, &v);
+}
+
+int
+main(int argc, char **argv)
+{
+	process_args(argc, argv);
+	process_header();
+	open_video();
+	copy_frames();
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/tests/common.h b/drivers/custom/v4l2loopback/tests/common.h
new file mode 100644
index 000000000000..3878deabe30b
--- /dev/null
+++ b/drivers/custom/v4l2loopback/tests/common.h
@@ -0,0 +1,154 @@
+/* -*- c-file-style: "linux" -*- */
+/*
+ * common.h  --  some commong functions
+ *
+ * Copyright (C) 2023 IOhannes m zmoelnig (zmoelnig@iem.at)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <stdio.h>
+#include <linux/videodev2.h>
+
+static char *fourcc2str(unsigned int fourcc, char buf[4])
+{
+	buf[0] = (fourcc >> 0) & 0xFF;
+	buf[1] = (fourcc >> 8) & 0xFF;
+	buf[2] = (fourcc >> 16) & 0xFF;
+	buf[3] = (fourcc >> 24) & 0xFF;
+
+	return buf;
+}
+static const char *field2str(unsigned int field)
+{
+	switch (field) {
+	case V4L2_FIELD_ANY:
+		return "any";
+	case V4L2_FIELD_NONE:
+		return "none";
+	case V4L2_FIELD_TOP:
+		return "top";
+	case V4L2_FIELD_BOTTOM:
+		return "bottom";
+	case V4L2_FIELD_INTERLACED:
+		return "interlaced";
+	case V4L2_FIELD_SEQ_TB:
+		return "seq/topbottom";
+	case V4L2_FIELD_SEQ_BT:
+		return "seq/bottomtop";
+	case V4L2_FIELD_ALTERNATE:
+		return "alternate";
+	case V4L2_FIELD_INTERLACED_TB:
+		return "interlaced/topbottom";
+	case V4L2_FIELD_INTERLACED_BT:
+		return "interlaced/bottomtop";
+
+	default:
+		break;
+	}
+	return "unknown";
+}
+
+static const char *buftype2str(unsigned int type)
+{
+	switch (type) {
+	default:
+		break;
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		return "CAPTURE";
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		return "CAPTURE(planar)";
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		return "OUTPUT";
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+		return "OUTPUT(planar)";
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
+		return "OUTPUT(overlay)";
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		return "OVERLAY";
+	case V4L2_BUF_TYPE_VBI_CAPTURE:
+		return "VBI(capture)";
+	case V4L2_BUF_TYPE_VBI_OUTPUT:
+		return "VBI(output)";
+	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
+		return "SlicedVBI(capture)";
+	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
+		return "SlicedVBI(output)";
+	case V4L2_BUF_TYPE_SDR_CAPTURE:
+		return "SDR(capture)";
+	case V4L2_BUF_TYPE_SDR_OUTPUT:
+		return "SDR(output)";
+	case V4L2_BUF_TYPE_META_CAPTURE:
+		return "META(capture)";
+	case V4L2_BUF_TYPE_META_OUTPUT:
+		return "META(output)";
+	case V4L2_BUF_TYPE_PRIVATE:
+		return "private";
+	}
+	return "unknown";
+}
+
+static const char *bufmemory2str(unsigned int mem)
+{
+	switch (mem) {
+	case V4L2_MEMORY_MMAP:
+		return "MMAP";
+	case V4L2_MEMORY_USERPTR:
+		return "USERPTR";
+	case V4L2_MEMORY_OVERLAY:
+		return "OVERLAY";
+	case V4L2_MEMORY_DMABUF:
+		return "DMABUF";
+	default:
+		break;
+	}
+	return "unknown";
+}
+
+static const char *snprintf_format(char *buf, size_t size,
+				   struct v4l2_format *fmt)
+{
+	char fourcc[5];
+	fourcc[4] = 0;
+	switch (fmt->type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		snprintf(buf, size,
+			 "%s:%dx%d:%s bytes/line=%u sizeimage=%u field=%s",
+			 buftype2str(fmt->type), fmt->fmt.pix.width,
+			 fmt->fmt.pix.height,
+			 fourcc2str(fmt->fmt.pix.pixelformat, fourcc),
+			 fmt->fmt.pix.bytesperline, fmt->fmt.pix.sizeimage,
+			 field2str(fmt->fmt.pix.field));
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		snprintf(buf, size, "%s:%dx%d:%s (%d planes) field=%s",
+			 buftype2str(fmt->type), fmt->fmt.pix_mp.width,
+			 fmt->fmt.pix_mp.height,
+			 fourcc2str(fmt->fmt.pix_mp.pixelformat, fourcc),
+			 fmt->fmt.pix_mp.num_planes,
+			 field2str(fmt->fmt.pix_mp.field));
+	default:
+		snprintf(buf, size, "TODO: %s(type=%d)", __FUNCTION__,
+			 (fmt->type));
+	}
+	return buf;
+}
+
+static const char *snprintf_buffer(char *strbuf, size_t size,
+				   struct v4l2_buffer *buf)
+{
+	snprintf(
+		strbuf, size,
+		"buffer#%d @ %p %s bytesused=%d, length=%d flags=0x%08X field=%s timestamp=%ld.%06ld memory=%s (offset=%d)",
+		buf->index, buf, buftype2str(buf->type), buf->bytesused,
+		buf->length, buf->flags, field2str(buf->field),
+		buf->timestamp.tv_sec, buf->timestamp.tv_usec,
+		bufmemory2str(buf->memory), buf->m.offset);
+	return strbuf;
+}
diff --git a/drivers/custom/v4l2loopback/tests/consumer.c b/drivers/custom/v4l2loopback/tests/consumer.c
new file mode 100644
index 000000000000..434b1d27b8af
--- /dev/null
+++ b/drivers/custom/v4l2loopback/tests/consumer.c
@@ -0,0 +1,632 @@
+/*
+ *  V4L2 video capture example
+ *
+ *  This program can be used and distributed without restrictions.
+ *
+ *      This program is provided with the V4L2 API
+ * see http://linuxtv.org/docs.php for more information
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include <getopt.h> /* getopt_long() */
+
+#include <fcntl.h> /* low-level i/o */
+#include <unistd.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <linux/videodev2.h>
+
+#include "common.h"
+
+#define CLEAR(x) memset(&(x), 0, sizeof(x))
+
+enum io_method {
+	IO_METHOD_READ,
+	IO_METHOD_MMAP,
+	IO_METHOD_USERPTR,
+};
+
+struct buffer {
+	void *start;
+	size_t length;
+};
+
+static char *dev_name;
+static enum io_method io = IO_METHOD_MMAP;
+static int fd = -1;
+struct buffer *buffers;
+static unsigned int n_buffers;
+static int frame_count = 70;
+
+static void errno_exit(const char *s)
+{
+	fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno));
+	exit(EXIT_FAILURE);
+}
+
+static int xioctl(int fh, unsigned long int request, void *arg)
+{
+	int r;
+
+	do {
+		r = ioctl(fh, request, arg);
+	} while (-1 == r && EINTR == errno);
+
+	return r;
+}
+
+static int read_frame(void)
+{
+	char strbuf[1024];
+	struct v4l2_buffer buf;
+	unsigned int i;
+
+	switch (io) {
+	case IO_METHOD_READ:
+		if (-1 == read(fd, buffers[0].start, buffers[0].length)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("read");
+			}
+		}
+		printf("READ\t%lu@%p\n", buffers[0].length, buffers[0].start);
+		break;
+
+	case IO_METHOD_MMAP:
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		buf.memory = V4L2_MEMORY_MMAP;
+
+		if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("VIDIOC_DQBUF");
+			}
+		}
+
+		printf("MMAP\t%s\n",
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+		assert(buf.index < n_buffers);
+
+		if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+			errno_exit("VIDIOC_QBUF");
+		break;
+
+	case IO_METHOD_USERPTR:
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		buf.memory = V4L2_MEMORY_USERPTR;
+
+		if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("VIDIOC_DQBUF");
+			}
+		}
+
+		for (i = 0; i < n_buffers; ++i)
+			if (buf.m.userptr == (unsigned long)buffers[i].start &&
+			    buf.length == buffers[i].length)
+				break;
+
+		printf("USERPTR\t%s\n",
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+		assert(i < n_buffers);
+
+		if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+			errno_exit("VIDIOC_QBUF");
+		break;
+	}
+
+	return 1;
+}
+
+static void mainloop(void)
+{
+	unsigned int count;
+	int keep_running = 1;
+
+	count = frame_count;
+
+	while (1) {
+		if (count < 1)
+			break;
+		if (frame_count >= 0) {
+			count--;
+		}
+
+		for (;;) {
+			fd_set fds;
+			struct timeval tv;
+			int r;
+
+			FD_ZERO(&fds);
+			FD_SET(fd, &fds);
+
+			/* Timeout. */
+			tv.tv_sec = 2;
+			tv.tv_usec = 0;
+
+			r = select(fd + 1, &fds, NULL, NULL, &tv);
+
+			if (-1 == r) {
+				if (EINTR == errno)
+					continue;
+				errno_exit("select");
+			}
+
+			if (0 == r) {
+				fprintf(stderr, "select timeout\n");
+				exit(EXIT_FAILURE);
+			}
+
+			if (read_frame())
+				break;
+			/* EAGAIN - continue select loop. */
+		}
+	}
+}
+
+static void stop_capturing(void)
+{
+	enum v4l2_buf_type type;
+
+	switch (io) {
+	case IO_METHOD_READ:
+		/* Nothing to do. */
+		break;
+
+	case IO_METHOD_MMAP:
+	case IO_METHOD_USERPTR:
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &type))
+			errno_exit("VIDIOC_STREAMOFF");
+		break;
+	}
+}
+
+static void start_capturing(void)
+{
+	unsigned int i;
+	enum v4l2_buf_type type;
+
+	switch (io) {
+	case IO_METHOD_READ:
+		/* Nothing to do. */
+		break;
+
+	case IO_METHOD_MMAP:
+		for (i = 0; i < n_buffers; ++i) {
+			struct v4l2_buffer buf;
+
+			CLEAR(buf);
+			buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			buf.memory = V4L2_MEMORY_MMAP;
+			buf.index = i;
+
+			if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+				errno_exit("VIDIOC_QBUF");
+		}
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))
+			errno_exit("VIDIOC_STREAMON");
+		break;
+
+	case IO_METHOD_USERPTR:
+		for (i = 0; i < n_buffers; ++i) {
+			struct v4l2_buffer buf;
+
+			CLEAR(buf);
+			buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			buf.memory = V4L2_MEMORY_USERPTR;
+			buf.index = i;
+			buf.m.userptr = (unsigned long)buffers[i].start;
+			buf.length = buffers[i].length;
+
+			if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+				errno_exit("VIDIOC_QBUF");
+		}
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))
+			errno_exit("VIDIOC_STREAMON");
+		break;
+	}
+}
+
+static void uninit_device(void)
+{
+	unsigned int i;
+
+	switch (io) {
+	case IO_METHOD_READ:
+		free(buffers[0].start);
+		break;
+
+	case IO_METHOD_MMAP:
+		for (i = 0; i < n_buffers; ++i)
+			if (-1 == munmap(buffers[i].start, buffers[i].length))
+				errno_exit("munmap");
+		break;
+
+	case IO_METHOD_USERPTR:
+		for (i = 0; i < n_buffers; ++i)
+			free(buffers[i].start);
+		break;
+	}
+
+	free(buffers);
+}
+
+static void init_read(unsigned int buffer_size)
+{
+	buffers = calloc(1, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	buffers[0].length = buffer_size;
+	buffers[0].start = malloc(buffer_size);
+
+	if (!buffers[0].start) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void init_mmap(void)
+{
+	char strbuf[1024];
+	const int count = 4;
+	struct v4l2_requestbuffers req;
+
+	CLEAR(req);
+
+	req.count = count;
+	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory = V4L2_MEMORY_MMAP;
+
+	if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+		if (EINVAL == errno) {
+			fprintf(stderr,
+				"%s does not support "
+				"memory mapping\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_REQBUFS");
+		}
+	}
+	printf("requested %d buffers, got %d\n", count, req.count);
+
+	if (req.count < 2) {
+		fprintf(stderr, "Insufficient buffer memory on %s\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	buffers = calloc(req.count, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
+		struct v4l2_buffer buf;
+
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		buf.memory = V4L2_MEMORY_MMAP;
+		buf.index = n_buffers;
+
+		if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf))
+			errno_exit("VIDIOC_QUERYBUF");
+		printf("requested buffer %d/%d: %s\n", n_buffers, count,
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+
+		buffers[n_buffers].length = buf.length;
+		buffers[n_buffers].start =
+			mmap(NULL /* start anywhere */, buf.length,
+			     PROT_READ | PROT_WRITE /* required */,
+			     MAP_SHARED /* recommended */, fd, buf.m.offset);
+
+		if (MAP_FAILED == buffers[n_buffers].start)
+			errno_exit("mmap");
+	}
+}
+
+static void init_userp(unsigned int buffer_size)
+{
+	struct v4l2_requestbuffers req;
+
+	CLEAR(req);
+
+	req.count = 4;
+	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	req.memory = V4L2_MEMORY_USERPTR;
+
+	if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+		if (EINVAL == errno) {
+			fprintf(stderr,
+				"%s does not support "
+				"user pointer i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_REQBUFS");
+		}
+	}
+
+	buffers = calloc(4, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	for (n_buffers = 0; n_buffers < 4; ++n_buffers) {
+		buffers[n_buffers].length = buffer_size;
+		buffers[n_buffers].start = malloc(buffer_size);
+
+		if (!buffers[n_buffers].start) {
+			fprintf(stderr, "Out of memory\n");
+			exit(EXIT_FAILURE);
+		}
+	}
+}
+
+static void init_device(void)
+{
+	char strbuf[1024];
+	struct v4l2_capability cap;
+	struct v4l2_cropcap cropcap;
+	struct v4l2_crop crop;
+	struct v4l2_format fmt;
+
+	if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {
+		if (EINVAL == errno) {
+			fprintf(stderr, "%s is no V4L2 device\n", dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_QUERYCAP");
+		}
+	}
+
+	if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
+		fprintf(stderr, "%s is no video capture device\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	switch (io) {
+	case IO_METHOD_READ:
+		if (!(cap.capabilities & V4L2_CAP_READWRITE)) {
+			fprintf(stderr, "%s does not support read i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		}
+		break;
+
+	case IO_METHOD_MMAP:
+	case IO_METHOD_USERPTR:
+		if (!(cap.capabilities & V4L2_CAP_STREAMING)) {
+			fprintf(stderr, "%s does not support streaming i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		}
+		break;
+	}
+
+	/* Select video input, video standard and tune here. */
+
+	CLEAR(cropcap);
+
+	cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	if (0 == xioctl(fd, VIDIOC_CROPCAP, &cropcap)) {
+		crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		crop.c = cropcap.defrect; /* reset to default */
+
+		if (-1 == xioctl(fd, VIDIOC_S_CROP, &crop)) {
+			switch (errno) {
+			case EINVAL:
+				/* Cropping not supported. */
+				break;
+			default:
+				/* Errors ignored. */
+				break;
+			}
+		}
+	} else {
+		/* Errors ignored. */
+	}
+
+	CLEAR(fmt);
+
+	/* get the current format */
+	fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (-1 == xioctl(fd, VIDIOC_G_FMT, &fmt))
+		errno_exit("VIDIOC_G_FMT");
+	printf("got format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	/* try to set the current format (no-change should always succeed) */
+	if (xioctl(fd, VIDIOC_S_FMT, &fmt) < 0) {
+		const char *s = "VIDIOC_S_FMT";
+		fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno));
+		//errno_exit("VIDIOC_S_FMT");
+	}
+	printf("set format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	switch (io) {
+	case IO_METHOD_READ:
+		init_read(fmt.fmt.pix.sizeimage);
+		break;
+
+	case IO_METHOD_MMAP:
+		init_mmap();
+		break;
+
+	case IO_METHOD_USERPTR:
+		init_userp(fmt.fmt.pix.sizeimage);
+		break;
+	}
+}
+
+static void close_device(void)
+{
+	if (-1 == close(fd))
+		errno_exit("close");
+
+	fd = -1;
+}
+
+static void open_device(void)
+{
+	struct stat st;
+
+	if (-1 == stat(dev_name, &st)) {
+		fprintf(stderr, "Cannot identify '%s': %d, %s\n", dev_name,
+			errno, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	if (!S_ISCHR(st.st_mode)) {
+		fprintf(stderr, "%s is no device\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);
+
+	if (-1 == fd) {
+		fprintf(stderr, "Cannot open '%s': %d, %s\n", dev_name, errno,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void usage(FILE *fp, int argc, char **argv)
+{
+	fprintf(fp,
+		"Usage: %s [options]\n\n"
+		"Version 1.3\n"
+		"Options:\n"
+		"-d | --device name   Video device name [%s]\n"
+		"-h | --help          Print this message\n"
+		"-m | --mmap          Use memory mapped buffers [default]\n"
+		"-r | --read          Use read() calls\n"
+		"-u | --userp         Use application allocated buffers\n"
+		"-c | --count         Number of frames to grab [%i] (negative numbers: no limit)\n"
+		"",
+		argv[0], dev_name, frame_count);
+}
+
+static const char short_options[] = "d:hmruofc:";
+
+static const struct option long_options[] = {
+	{ "device", required_argument, NULL, 'd' },
+	{ "help", no_argument, NULL, 'h' },
+	{ "mmap", no_argument, NULL, 'm' },
+	{ "read", no_argument, NULL, 'r' },
+	{ "userp", no_argument, NULL, 'u' },
+	{ "count", required_argument, NULL, 'c' },
+	{ 0, 0, 0, 0 }
+};
+
+int main(int argc, char **argv)
+{
+	dev_name = "/dev/video0";
+
+	for (;;) {
+		int idx;
+		int c;
+
+		c = getopt_long(argc, argv, short_options, long_options, &idx);
+
+		if (-1 == c)
+			break;
+
+		switch (c) {
+		case 0: /* getopt_long() flag */
+			break;
+
+		case 'd':
+			dev_name = optarg;
+			break;
+
+		case 'h':
+			usage(stdout, argc, argv);
+			exit(EXIT_SUCCESS);
+
+		case 'm':
+			io = IO_METHOD_MMAP;
+			break;
+
+		case 'r':
+			io = IO_METHOD_READ;
+			break;
+
+		case 'u':
+			io = IO_METHOD_USERPTR;
+			break;
+
+		case 'c':
+			errno = 0;
+			frame_count = strtol(optarg, NULL, 0);
+			if (errno)
+				errno_exit(optarg);
+			break;
+
+		default:
+			usage(stderr, argc, argv);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	open_device();
+	init_device();
+	start_capturing();
+	mainloop();
+	stop_capturing();
+	uninit_device();
+	close_device();
+	fprintf(stderr, "\n");
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/tests/producer.c b/drivers/custom/v4l2loopback/tests/producer.c
new file mode 100644
index 000000000000..03c73e4acc37
--- /dev/null
+++ b/drivers/custom/v4l2loopback/tests/producer.c
@@ -0,0 +1,720 @@
+/*
+ *  V4L2 video output example
+ *
+ *  This program can be used and distributed without restrictions.
+ *
+ *      This program is provided with the V4L2 API
+ * see http://linuxtv.org/docs.php for more information
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include <time.h> /* clock_gettime() */
+#include <getopt.h> /* getopt_long() */
+
+#include <fcntl.h> /* low-level i/o */
+#include <unistd.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+
+#include <linux/videodev2.h>
+
+#include "common.h"
+
+#define CLEAR(x) memset(&(x), 0, sizeof(x))
+
+#define SET_QUEUED(buffer) ((buffer).flags |= V4L2_BUF_FLAG_QUEUED)
+
+#define IS_QUEUED(buffer) \
+	((buffer).flags & (V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE))
+
+enum io_method {
+	IO_METHOD_WRITE,
+	IO_METHOD_MMAP,
+	IO_METHOD_USERPTR,
+};
+
+struct buffer {
+	void *start;
+	size_t length;
+	size_t bytesused;
+};
+
+static char *dev_name;
+static enum io_method io = IO_METHOD_MMAP;
+static int fd = -1;
+struct buffer *buffers;
+static unsigned int n_buffers;
+static int frame_count = 70;
+static unsigned int width = 640;
+static unsigned int height = 480;
+static unsigned int pixelformat = V4L2_PIX_FMT_YUYV;
+static int set_timestamp = 0;
+static char strbuf[1024];
+
+static void errno_exit(const char *s)
+{
+	fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno));
+	exit(EXIT_FAILURE);
+}
+static unsigned int str2fourcc(char buf[4])
+{
+	return (buf[0]) + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
+}
+
+static int xioctl(int fh, unsigned long int request, void *arg)
+{
+	int r;
+
+	do {
+		r = ioctl(fh, request, arg);
+	} while (-1 == r && EINTR == errno);
+
+	return r;
+}
+
+static unsigned int random_nextseed = 148985372;
+static unsigned char randombyte(void)
+{
+	random_nextseed = (random_nextseed * 472940017) + 832416023;
+	return ((random_nextseed >> 16) & 0xFF);
+}
+static void process_image(unsigned char *data, size_t length)
+{
+	size_t i;
+	for (i = 0; i < length; i++) {
+		data[i] = randombyte();
+	}
+}
+
+static int framenum = 0;
+static int write_frame(void)
+{
+	struct v4l2_buffer buf;
+	unsigned int i;
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		process_image(buffers[0].start, buffers[0].bytesused);
+		if (-1 == write(fd, buffers[0].start, buffers[0].length)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("write");
+			}
+		}
+		printf("WRITE %p: %lu/%lu\n", buffers[0].start,
+		       buffers[0].bytesused, buffers[0].length);
+		break;
+
+	case IO_METHOD_MMAP:
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		buf.memory = V4L2_MEMORY_MMAP;
+
+		if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("VIDIOC_DQBUF");
+			}
+		}
+		if (set_timestamp) {
+			struct timespec curTime;
+			clock_gettime(CLOCK_MONOTONIC, &curTime);
+			buf.timestamp.tv_sec = curTime.tv_sec;
+			buf.timestamp.tv_usec = curTime.tv_nsec / 1000ULL;
+		} else {
+			buf.timestamp.tv_sec = 0;
+			buf.timestamp.tv_usec = 0;
+		}
+		printf("MMAP\t%s\n",
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+		fflush(stdout);
+		assert(buf.index < n_buffers);
+		process_image(buffers[buf.index].start, buf.bytesused);
+
+		if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+			errno_exit("VIDIOC_QBUF");
+		if (!IS_QUEUED(buf)) {
+			printf("driver pretends buffer is not queued even if queue succeeded\n");
+			SET_QUEUED(buf);
+		}
+		break;
+
+	case IO_METHOD_USERPTR:
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		buf.memory = V4L2_MEMORY_USERPTR;
+
+		if (-1 == xioctl(fd, VIDIOC_DQBUF, &buf)) {
+			switch (errno) {
+			case EAGAIN:
+				return 0;
+
+			case EIO:
+				/* Could ignore EIO, see spec. */
+
+				/* fall through */
+
+			default:
+				errno_exit("VIDIOC_DQBUF");
+			}
+		}
+
+		for (i = 0; i < n_buffers; ++i)
+			if (buf.m.userptr == (unsigned long)buffers[i].start &&
+			    buf.bytesused == buffers[i].bytesused)
+				break;
+
+		assert(i < n_buffers);
+		printf("USERPTR\t%s\n",
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+		process_image(buffers[buf.index].start, buf.bytesused);
+
+		if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+			errno_exit("VIDIOC_QBUF");
+		break;
+	}
+
+	return 1;
+}
+
+static void mainloop(void)
+{
+	unsigned int count;
+	int keep_running = 1;
+
+	count = frame_count;
+
+	while (1) {
+		if (count < 1)
+			break;
+		if (frame_count >= 0) {
+			count--;
+		}
+
+		for (;;) {
+			if (write_frame())
+				break;
+			/* EAGAIN - continue select loop. */
+		}
+		usleep(33000);
+	}
+}
+
+static void stop_capturing(void)
+{
+	enum v4l2_buf_type type;
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		/* Nothing to do. */
+		break;
+
+	case IO_METHOD_MMAP:
+	case IO_METHOD_USERPTR:
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		if (-1 == xioctl(fd, VIDIOC_STREAMOFF, &type))
+			errno_exit("VIDIOC_STREAMOFF");
+		break;
+	}
+}
+
+static void start_capturing(void)
+{
+	unsigned int i;
+	enum v4l2_buf_type type;
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		/* Nothing to do. */
+		break;
+
+	case IO_METHOD_MMAP:
+		for (i = 0; i < n_buffers; ++i) {
+			struct v4l2_buffer buf;
+
+			CLEAR(buf);
+			buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			buf.memory = V4L2_MEMORY_MMAP;
+			buf.index = i;
+			buf.length = buffers[i].length;
+			buf.bytesused = buffers[i].bytesused;
+
+			printf("MMAP init qbuf %d/%d (length=%d): %s\n", i,
+			       n_buffers, buffers[i].length,
+			       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+			if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+				errno_exit("VIDIOC_QBUF");
+		}
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))
+			errno_exit("VIDIOC_STREAMON");
+		break;
+
+	case IO_METHOD_USERPTR:
+		for (i = 0; i < n_buffers; ++i) {
+			struct v4l2_buffer buf;
+
+			CLEAR(buf);
+			buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			buf.memory = V4L2_MEMORY_USERPTR;
+			buf.index = i;
+			buf.m.userptr = (unsigned long)buffers[i].start;
+			buf.bytesused = buffers[i].bytesused;
+			buf.length = buffers[i].length;
+
+			printf("USERPTR init qbuf %d/%d: %s\n", i, n_buffers,
+			       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+			if (-1 == xioctl(fd, VIDIOC_QBUF, &buf))
+				errno_exit("VIDIOC_QBUF");
+		}
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		if (-1 == xioctl(fd, VIDIOC_STREAMON, &type))
+			errno_exit("VIDIOC_STREAMON");
+		break;
+	}
+}
+
+static void uninit_device(void)
+{
+	unsigned int i;
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		free(buffers[0].start);
+		break;
+
+	case IO_METHOD_MMAP:
+		for (i = 0; i < n_buffers; ++i)
+			if (-1 == munmap(buffers[i].start, buffers[i].length))
+				errno_exit("munmap");
+		break;
+
+	case IO_METHOD_USERPTR:
+		for (i = 0; i < n_buffers; ++i)
+			free(buffers[i].start);
+		break;
+	}
+
+	free(buffers);
+}
+
+static void init_write(unsigned int buffer_size)
+{
+	buffers = calloc(1, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	buffers[0].length = buffer_size;
+	buffers[0].bytesused = buffer_size;
+	buffers[0].start = malloc(buffer_size);
+
+	if (!buffers[0].start) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void init_mmap(void)
+{
+	const int count = 4;
+	struct v4l2_requestbuffers req;
+
+	CLEAR(req);
+
+	req.count = count;
+	req.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	req.memory = V4L2_MEMORY_MMAP;
+
+	if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+		if (EINVAL == errno) {
+			fprintf(stderr,
+				"%s does not support "
+				"memory mapping\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_REQBUFS");
+		}
+	}
+	printf("requested %d buffers, got %d\n", count, req.count);
+
+	if (req.count < 2) {
+		fprintf(stderr, "Insufficient buffer memory on %s\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	buffers = calloc(req.count, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	for (n_buffers = 0; n_buffers < req.count; ++n_buffers) {
+		struct v4l2_buffer buf;
+
+		CLEAR(buf);
+
+		buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		buf.memory = V4L2_MEMORY_MMAP;
+		buf.index = n_buffers;
+
+		if (-1 == xioctl(fd, VIDIOC_QUERYBUF, &buf))
+			errno_exit("VIDIOC_QUERYBUF");
+		printf("requested buffer %d/%d: %s\n", n_buffers, count,
+		       snprintf_buffer(strbuf, sizeof(strbuf), &buf));
+
+		buffers[n_buffers].length = buf.length;
+		buffers[n_buffers].bytesused = buf.bytesused;
+		buffers[n_buffers].start =
+			mmap(NULL /* start anywhere */, buf.length,
+			     PROT_READ | PROT_WRITE /* required */,
+			     MAP_SHARED /* recommended */, fd, buf.m.offset);
+
+		if (MAP_FAILED == buffers[n_buffers].start)
+			errno_exit("mmap");
+		printf("buffer#%d @%p of %d bytes\n", n_buffers,
+		       buffers[n_buffers].start, buffers[n_buffers].length);
+	}
+}
+
+static void init_userp(unsigned int buffer_size)
+{
+	struct v4l2_requestbuffers req;
+
+	CLEAR(req);
+
+	req.count = 4;
+	req.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	req.memory = V4L2_MEMORY_USERPTR;
+
+	if (-1 == xioctl(fd, VIDIOC_REQBUFS, &req)) {
+		if (EINVAL == errno) {
+			fprintf(stderr,
+				"%s does not support "
+				"user pointer i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_REQBUFS");
+		}
+	}
+
+	buffers = calloc(4, sizeof(*buffers));
+
+	if (!buffers) {
+		fprintf(stderr, "Out of memory\n");
+		exit(EXIT_FAILURE);
+	}
+
+	for (n_buffers = 0; n_buffers < 4; ++n_buffers) {
+		buffers[n_buffers].length = buffer_size;
+		buffers[n_buffers].start = malloc(buffer_size);
+		buffers[n_buffers].bytesused = buffer_size;
+
+		if (!buffers[n_buffers].start) {
+			fprintf(stderr, "Out of memory\n");
+			exit(EXIT_FAILURE);
+		}
+	}
+}
+
+static void init_device(void)
+{
+	struct v4l2_capability cap;
+	struct v4l2_cropcap cropcap;
+	struct v4l2_crop crop;
+	struct v4l2_format fmt;
+
+	if (-1 == xioctl(fd, VIDIOC_QUERYCAP, &cap)) {
+		if (EINVAL == errno) {
+			fprintf(stderr, "%s is no V4L2 device\n", dev_name);
+			exit(EXIT_FAILURE);
+		} else {
+			errno_exit("VIDIOC_QUERYCAP");
+		}
+	}
+
+	if (!(cap.capabilities & V4L2_CAP_VIDEO_OUTPUT)) {
+		fprintf(stderr, "%s is no video output device\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		if (!(cap.capabilities & V4L2_CAP_READWRITE)) {
+			fprintf(stderr, "%s does not support write i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		}
+		break;
+
+	case IO_METHOD_MMAP:
+	case IO_METHOD_USERPTR:
+		if (!(cap.capabilities & V4L2_CAP_STREAMING)) {
+			fprintf(stderr, "%s does not support streaming i/o\n",
+				dev_name);
+			exit(EXIT_FAILURE);
+		}
+		break;
+	}
+
+	/* Select video input, video standard and tune here. */
+
+	CLEAR(cropcap);
+
+	cropcap.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+
+	if (0 == xioctl(fd, VIDIOC_CROPCAP, &cropcap)) {
+		crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		crop.c = cropcap.defrect; /* reset to default */
+
+		if (-1 == xioctl(fd, VIDIOC_S_CROP, &crop)) {
+			switch (errno) {
+			case EINVAL:
+				/* Cropping not supported. */
+				break;
+			default:
+				/* Errors ignored. */
+				break;
+			}
+		}
+	} else {
+		/* Errors ignored. */
+	}
+
+	CLEAR(fmt);
+
+	/* get the current format */
+	fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (-1 == xioctl(fd, VIDIOC_G_FMT, &fmt))
+		errno_exit("VIDIOC_G_FMT");
+	printf("get format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	/* try to set the current format (no-change should always succeed) */
+	if (xioctl(fd, VIDIOC_TRY_FMT, &fmt) < 0)
+		errno_exit("VIDIOC_TRY_FMT");
+	printf("tried format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+	/* and get the format again */
+	if (-1 == xioctl(fd, VIDIOC_G_FMT, &fmt))
+		errno_exit("VIDIOC_G_FMT");
+	printf("got format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	/* try to set the current format (no-change should always succeed) */
+	if (xioctl(fd, VIDIOC_S_FMT, &fmt) < 0)
+		errno_exit("VIDIOC_S_FMT");
+	printf("set format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	switch (fmt.type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		fmt.fmt.pix.width = width;
+		fmt.fmt.pix.height = height;
+		fmt.fmt.pix.pixelformat = pixelformat;
+		break;
+	default:
+		printf("unable to set format for anything but output/single-plane\n");
+		break;
+	}
+	printf("finalizing format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+	if (xioctl(fd, VIDIOC_S_FMT, &fmt) < 0) {
+		fprintf(stderr, "VIDIOC_S_FMT error %d, %s\n", errno,
+			strerror(errno));
+	}
+	printf("final format: %s\n",
+	       snprintf_format(strbuf, sizeof(strbuf), &fmt));
+
+	switch (io) {
+	case IO_METHOD_WRITE:
+		init_write(fmt.fmt.pix.sizeimage);
+		break;
+
+	case IO_METHOD_MMAP:
+		init_mmap();
+		break;
+
+	case IO_METHOD_USERPTR:
+		init_userp(fmt.fmt.pix.sizeimage);
+		break;
+	}
+}
+
+static void close_device(void)
+{
+	if (-1 == close(fd))
+		errno_exit("close");
+
+	fd = -1;
+}
+
+static void open_device(void)
+{
+	struct stat st;
+
+	if (-1 == stat(dev_name, &st)) {
+		fprintf(stderr, "Cannot identify '%s': %d, %s\n", dev_name,
+			errno, strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	if (!S_ISCHR(st.st_mode)) {
+		fprintf(stderr, "%s is no device\n", dev_name);
+		exit(EXIT_FAILURE);
+	}
+
+	fd = open(dev_name, O_RDWR /* required */ | O_NONBLOCK, 0);
+
+	if (-1 == fd) {
+		fprintf(stderr, "Cannot open '%s': %d, %s\n", dev_name, errno,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+}
+
+static void usage(FILE *fp, int argc, char **argv)
+{
+	char fourccstr[5];
+	fourccstr[4] = 0;
+	fprintf(fp,
+		"Usage: %s [options]\n\n"
+		"Version 1.3\n"
+		"Options:\n"
+		"-d | --device name   Video device name [%s]\n"
+		"-h | --help          Print this message\n"
+		"-m | --mmap          Use memory mapped buffers [default]\n"
+		"-w | --write         Use write() calls\n"
+		"-u | --userp         Use application allocated buffers\n"
+		"-c | --count         Number of frames to create [%i] (negative numbers: no limit)\n"
+		"-f | --format        Use format [%dx%d@%s]\n"
+		"-t | --timestamp     Set timestamp\n"
+		"",
+		argv[0], dev_name, frame_count, width, height,
+		fourcc2str(pixelformat, fourccstr));
+}
+
+static const char short_options[] = "d:hmwuc:f:t";
+
+static const struct option long_options[] = {
+	{ "device", required_argument, NULL, 'd' },
+	{ "help", no_argument, NULL, 'h' },
+	{ "mmap", no_argument, NULL, 'm' },
+	{ "write", no_argument, NULL, 'w' },
+	{ "userp", no_argument, NULL, 'u' },
+	{ "count", required_argument, NULL, 'c' },
+	{ "format", required_argument, NULL, 'f' },
+	{ "timestamp", no_argument, NULL, 't' },
+	{ 0, 0, 0, 0 }
+};
+
+int main(int argc, char **argv)
+{
+	dev_name = "/dev/video0";
+
+	for (;;) {
+		int idx;
+		int c;
+
+		c = getopt_long(argc, argv, short_options, long_options, &idx);
+
+		if (-1 == c)
+			break;
+
+		switch (c) {
+		case 0: /* getopt_long() flag */
+			break;
+
+		case 'd':
+			dev_name = optarg;
+			break;
+
+		case 'h':
+			usage(stdout, argc, argv);
+			exit(EXIT_SUCCESS);
+
+		case 'm':
+			io = IO_METHOD_MMAP;
+			break;
+
+		case 'w':
+			io = IO_METHOD_WRITE;
+			break;
+
+		case 'u':
+			io = IO_METHOD_USERPTR;
+			break;
+
+		case 'c':
+			errno = 0;
+			frame_count = strtol(optarg, NULL, 0);
+			if (errno)
+				errno_exit(optarg);
+			break;
+
+		case 'f': {
+			int n;
+			int w = 0, h = 0;
+			char col[5];
+			n = sscanf(optarg, "%dx%d@%4c", &w, &h, col);
+			if (n == 3) {
+				width = (w > 0) ? w : 0;
+				height = (h > 0) ? h : 0;
+				pixelformat = str2fourcc(col);
+				col[4] = 0;
+			} else {
+				errno_exit(optarg);
+			}
+			break;
+		case 't':
+			set_timestamp = 1;
+			break;
+		}
+
+		default:
+			usage(stderr, argc, argv);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	open_device();
+	init_device();
+	start_capturing();
+	mainloop();
+	stop_capturing();
+	uninit_device();
+	close_device();
+	fprintf(stderr, "\n");
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/tests/test_dqbuf.c b/drivers/custom/v4l2loopback/tests/test_dqbuf.c
new file mode 100644
index 000000000000..b67cf0438a9e
--- /dev/null
+++ b/drivers/custom/v4l2loopback/tests/test_dqbuf.c
@@ -0,0 +1,134 @@
+/*
+ * v4l2loopback.c  --  video4linux2 loopback driver
+ *
+ * Copyright (C) 2014 Nicolas Dufresne
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/videodev2.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <stdlib.h>
+
+#define COUNT 4
+#define sysfail(msg)                                               \
+	{                                                          \
+		printf("%s failed: %s\n", (msg), strerror(errno)); \
+		return -1;                                         \
+	}
+
+void usage(const char *progname)
+{
+	printf("usage: %s <videodevice>\n", progname);
+	exit(1);
+}
+
+int main(int argc, char **argv)
+{
+	struct v4l2_format fmt = { 0 };
+	struct v4l2_requestbuffers breq = { 0 };
+	struct v4l2_buffer bufs[COUNT];
+	void *data[COUNT] = { 0 };
+	int fd;
+	int i;
+
+	if (argc < 2)
+		usage(argv[0]);
+
+	fd = open(argv[1], O_RDWR);
+	if (fd < 0)
+		sysfail("open");
+
+	fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	fmt.fmt.pix.width = 320;
+	fmt.fmt.pix.height = 240;
+	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB32;
+
+	if (ioctl(fd, VIDIOC_S_FMT, &fmt) < 0)
+		sysfail("S_FMT");
+
+	breq.count = COUNT;
+	breq.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	breq.memory = V4L2_MEMORY_MMAP;
+
+	if (ioctl(fd, VIDIOC_REQBUFS, &breq) < 0)
+		sysfail("REQBUFS");
+
+	assert(breq.count == COUNT);
+
+	memset(bufs, 0, sizeof(bufs));
+
+	for (i = 0; i < COUNT; i++) {
+		int p;
+
+		bufs[i].index = i;
+		bufs[i].type = breq.type;
+		bufs[i].memory = breq.memory;
+
+		if (ioctl(fd, VIDIOC_QUERYBUF, &bufs[i]) < 0)
+			sysfail("QUERYBUF");
+
+		data[i] = mmap(NULL, bufs[i].length, PROT_WRITE, MAP_SHARED, fd,
+			       bufs[i].m.offset);
+		if (data[i] == MAP_FAILED)
+			sysfail("mmap");
+
+		for (p = 0; p < (bufs[i].bytesused >> 2); p++)
+			((unsigned int *)data[i])[p] = 0xFF00FF00;
+	}
+
+	if (ioctl(fd, VIDIOC_QBUF, &bufs[0]) < 0)
+		sysfail("QBUF");
+
+	if ((bufs[0].flags & V4L2_BUF_FLAG_QUEUED) == 0) {
+		printf("BUG #1: Driver should set the QUEUED flag before returning from QBUF\n");
+		bufs[0].flags |= V4L2_BUF_FLAG_QUEUED;
+	}
+
+	if (ioctl(fd, VIDIOC_STREAMON, &fmt.type) < 0)
+		sysfail("STREAMON");
+
+	i = 1;
+	while (1) {
+		struct v4l2_buffer buf = { 0 };
+
+		if (ioctl(fd, VIDIOC_QBUF, &bufs[i]) < 0)
+			sysfail("QBUF");
+
+		printf("\tQUEUED=%d\tDONE=%d\n",
+		       bufs[i].flags & V4L2_BUF_FLAG_QUEUED,
+		       bufs[i].flags & V4L2_BUF_FLAG_DONE);
+
+		if ((bufs[i].flags & V4L2_BUF_FLAG_QUEUED) == 0) {
+			printf("BUG #1: Driver should set the QUEUED flag before returning from QBUF\n");
+			bufs[i].flags |= V4L2_BUF_FLAG_QUEUED;
+		}
+
+		buf.type = breq.type;
+		buf.memory = breq.memory;
+
+		if (ioctl(fd, VIDIOC_DQBUF, &buf) < 0)
+			sysfail("DBBUF");
+
+		i = buf.index;
+
+		if ((bufs[i].flags & V4L2_BUF_FLAG_QUEUED) == 0) {
+			printf("BUG #2: Driver should not dequeue a buffer that was not initially queued\n");
+		}
+
+#if 0
+    assert (bufs[i].flags & V4L2_BUF_FLAG_QUEUED);
+    assert (!(buf.flags & (V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE)));
+#endif
+		bufs[i] = buf;
+	}
+
+	return 0;
+}
diff --git a/drivers/custom/v4l2loopback/utils/Makefile b/drivers/custom/v4l2loopback/utils/Makefile
new file mode 100644
index 000000000000..99c68620b16f
--- /dev/null
+++ b/drivers/custom/v4l2loopback/utils/Makefile
@@ -0,0 +1,28 @@
+CPPFLAGS += -I..
+ifneq ($(V4L2LOOPBACK_SNAPSHOT_VERSION),)
+CPPFLAGS += -DSNAPSHOT_VERSION='"$(V4L2LOOPBACK_SNAPSHOT_VERSION)"'
+endif
+
+prefix?=/usr
+exec_prefix = ${prefix}
+bindir = ${exec_prefix}/bin
+INSTALL = /usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL}
+MKDIR_P = /usr/bin/mkdir -p
+
+.PHONY: default clean
+
+programs = v4l2loopback-ctl
+
+default: $(programs)
+
+clean:
+	-rm $(programs)
+	-rm $(programs:%=%.o)
+
+install:
+	$(MKDIR_P) $(DESTDIR)$(bindir)
+	$(INSTALL_PROGRAM) $(programs) $(DESTDIR)$(bindir)
+
+v4l2loopback-ctl.o: v4l2loopback-ctl.c ../v4l2loopback.h
+v4l2loopback-ctl: v4l2loopback-ctl.o
diff --git a/drivers/custom/v4l2loopback/utils/v4l2loopback-ctl.c b/drivers/custom/v4l2loopback/utils/v4l2loopback-ctl.c
new file mode 100644
index 000000000000..ba996021baab
--- /dev/null
+++ b/drivers/custom/v4l2loopback/utils/v4l2loopback-ctl.c
@@ -0,0 +1,1579 @@
+/* -*- c-file-style: "linux" -*- */
+/*
+ * v4l2loopback-ctl  --  An application to control v4l2loopback devices driver
+ *
+ * Copyright (C) 2020-2023 IOhannes m zmoelnig (zmoelnig@iem.at)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <glob.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/ioctl.h>
+#include <linux/videodev2.h>
+
+#include <errno.h>
+
+#include "v4l2loopback.h"
+
+#ifndef GLOB_ONLYDIR
+/* Fix for musl libc and other libcs missing GLOB_ONLYDIR at glob.h */
+/* (GLOB_ONLYDIR is not required by POSIX) */
+#define GLOB_ONLYDIR 0
+#endif
+
+#define CONTROLDEVICE "/dev/v4l2loopback"
+
+#if 0
+#define MARK() dprintf(2, "%s:%d @ %s\n", __FILE__, __LINE__, __func__)
+#else
+#define MARK()
+#endif
+
+struct v4l2l_format {
+	char *name;
+	int fourcc; /* video4linux 2 */
+	int depth; /* bit/pixel */
+	int flags;
+};
+#define FORMAT_FLAGS_PLANAR 0x01
+#define FORMAT_FLAGS_COMPRESSED 0x02
+#include "../v4l2loopback_formats.h"
+
+/********************/
+/* helper functions */
+
+/* running externals programs */
+static char *which(char *outbuf, size_t bufsize, const char *filename)
+{
+	struct stat statbuf;
+	char *paths, *saveptr = NULL;
+	if (filename && '/' == *filename) {
+		/* an absolute filename */
+		int err = stat(filename, &statbuf);
+		if (!err) {
+			snprintf(outbuf, bufsize, "%s", filename);
+			return outbuf;
+		}
+		return NULL;
+	}
+	for (paths = getenv("PATH");; paths = NULL) {
+		char *path = strtok_r(paths, ":", &saveptr);
+		int err;
+		if (path == NULL)
+			return NULL;
+		snprintf(outbuf, bufsize, "%s/%s", path, filename);
+		err = stat(outbuf, &statbuf);
+		if (!err)
+			return outbuf;
+	}
+	return NULL;
+}
+
+static pid_t pid;
+void exec_cleanup(int signal)
+{
+	if (pid) {
+		switch (signal) {
+		default:
+			break;
+		case SIGINT:
+			kill(pid, SIGTERM);
+			break;
+		}
+	}
+
+	while (waitpid((pid_t)(-1), 0, WNOHANG) > 0) {
+	}
+}
+static int my_execv(char *const *cmdline)
+{
+	char exe[1024];
+	int res = 0;
+	if (!which(exe, 1024, cmdline[0])) {
+		dprintf(2, "cannot find %s - is it installed???\n", cmdline[0]);
+		return 1;
+	}
+#if 0
+	do {
+		char *const *argp = cmdline;
+		dprintf(2, "%s:", exe);
+		while (*argp) {
+			dprintf(2, " %s", *argp++);
+		};
+		dprintf(2, "\n");
+	} while(0);
+#endif
+
+	pid = fork();
+	if (pid == 0) { /* this is the child-process */
+		res = execv(exe, cmdline);
+		if (res < 0) {
+			dprintf(2, "ERROR running helper program (%d, %d)", res,
+				errno);
+			dprintf(2, "failed program was:\n\t");
+			while (*cmdline)
+				dprintf(2, " %s", *cmdline++);
+			dprintf(2, "\n");
+			exit(0);
+		}
+		exit(0);
+	} else if (pid > 0) { /* we are parent: wait for child */
+		int status = 0;
+		int waitoptions = 0;
+		signal(SIGCHLD, exec_cleanup);
+		signal(SIGINT, exec_cleanup);
+		waitpid(pid, &status, waitoptions);
+		pid = 0;
+		if (WIFEXITED(status))
+			return WEXITSTATUS(status);
+		return 0;
+	} else { /* pid < 0, error */
+		dprintf(2, "ERROR: child fork failed\n");
+		exit(1);
+	}
+	return 0;
+}
+
+/* misc */
+static int my_atoi(const char *name, const char *s)
+{
+	char *endptr = 0;
+	int n = strtol(s, &endptr, 10);
+	if (*endptr) {
+		dprintf(2, "%s must be a number (got: '%s')\n", name, s);
+		exit(1);
+	}
+	return n;
+}
+
+static void printf_raw(const char *str, int escape_level)
+{
+	const char *backslash = (escape_level > 1) ? "\\\\" : "\\";
+	if (escape_level > 0)
+		while (*str) {
+			char c = *str++;
+			switch (c) {
+			case '\"':
+				printf("%s\"", backslash);
+				break;
+			case '\'':
+				printf("%s\'", backslash);
+				break;
+			case '\\':
+				printf("%s\\", backslash);
+				break;
+			case '\a':
+				printf("%sa", backslash);
+				break;
+			case '\b':
+				printf("%sb", backslash);
+				break;
+			case '\n':
+				printf("%sn", backslash);
+				break;
+			case '\t':
+				printf("%st", backslash);
+				break;
+				// and so on
+			default:
+				if (iscntrl(c))
+					printf("%s%03o", backslash, c);
+				else
+					printf("%c", c);
+			}
+		}
+	else
+		printf("%s", str);
+}
+
+static char *fourcc2str(unsigned int fourcc, char buf[4])
+{
+	buf[0] = (fourcc >> 0) & 0xFF;
+	buf[1] = (fourcc >> 8) & 0xFF;
+	buf[2] = (fourcc >> 16) & 0xFF;
+	buf[3] = (fourcc >> 24) & 0xFF;
+
+	return buf;
+}
+unsigned int str2fourcc(char buf[4])
+{
+	return (buf[0]) + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
+}
+
+/* helper functions */
+/********************/
+
+static unsigned int _get_control_id(int fd, const char *control)
+{
+	const size_t length = strnlen(control, 1024);
+	const unsigned next = V4L2_CTRL_FLAG_NEXT_CTRL;
+	struct v4l2_queryctrl qctrl;
+	int id;
+
+	memset(&qctrl, 0, sizeof(qctrl));
+	while (ioctl(fd, VIDIOC_QUERYCTRL, &qctrl) == 0) {
+		if (!strncmp(qctrl.name, control, length))
+			return qctrl.id;
+		qctrl.id |= next;
+	}
+	for (id = V4L2_CID_USER_BASE; id < V4L2_CID_LASTP1; id++) {
+		qctrl.id = id;
+		if (ioctl(fd, VIDIOC_QUERYCTRL, &qctrl) == 0) {
+			if (!strncmp(qctrl.name, control, length))
+				return qctrl.id;
+		}
+	}
+	for (qctrl.id = V4L2_CID_PRIVATE_BASE;
+	     ioctl(fd, VIDIOC_QUERYCTRL, &qctrl) == 0; qctrl.id++) {
+		if (!strncmp(qctrl.name, control, length)) {
+			unsigned int id = qctrl.id;
+			return id;
+		}
+	}
+	return 0;
+}
+
+static int set_control_i(int fd, const char *control, int value)
+{
+	struct v4l2_control ctrl;
+	memset(&ctrl, 0, sizeof(ctrl));
+	ctrl.id = _get_control_id(fd, control);
+	ctrl.value = value;
+	if (ctrl.id && ioctl(fd, VIDIOC_S_CTRL, &ctrl) == 0) {
+		int value = ctrl.value;
+		return value;
+	}
+	return 0;
+}
+static int get_control_i(int fd, const char *control)
+{
+	struct v4l2_control ctrl;
+	memset(&ctrl, 0, sizeof(ctrl));
+	ctrl.id = _get_control_id(fd, control);
+
+	if (ctrl.id && ioctl(fd, VIDIOC_G_CTRL, &ctrl) == 0) {
+		int value = ctrl.value;
+		return value;
+	}
+	return 0;
+}
+
+/********************/
+/* main logic       */
+typedef enum {
+	VERSION,
+	HELP,
+	ADD,
+	DELETE,
+	LIST,
+	QUERY,
+	SET_FPS,
+	GET_FPS,
+	SET_CAPS,
+	GET_CAPS,
+	SET_TIMEOUTIMAGE,
+	MOO,
+	_UNKNOWN
+} t_command;
+
+static void _help(int detail, const char *section, const char *program,
+		  const char *verb, const char *argstring,
+		  const char *description, const char *options)
+{
+	(void)section;
+	if (!detail) {
+		dprintf(2, "%s%s%s %s\n", program ? program : "",
+			program ? " " : "", verb, argstring);
+		return;
+	}
+
+	dprintf(2, "\n%s%s%s %s:\n", program ? program : "", program ? " " : "",
+		verb, argstring);
+
+	dprintf(2, " %s\n ", description);
+
+	if (options) {
+		dprintf(2, "%s\n", options);
+		//dprintf(2, "\n\n'%s' OPTIONS:%s\n", verb, options);
+	}
+}
+
+static void help_list(const char *program, int detail)
+{
+	_help(detail, "Listing Devices", program, "list", "[OPTIONS]",
+	      "list all available loopback-devices",
+	      "\n\t-e, --escape             escape control-characters in (device) names"
+	      "\n\t-h, --help               print this help and exit"
+	      "");
+}
+static void help_add(const char *program, int detail)
+{
+	_help(detail, "Adding Devices", program, "add",
+	      "[OPTIONS] [<outputdevice> [<capturedevice>]]",
+	      "create/add a new loopback-device",
+	      "\n\t-b <num>, --buffers <num>     buffers to queue"
+	      "\n\t-h <h>, --max-height <h>      maximum allowed frame height"
+	      "\n\t-n <name>, --name <name>      pretty name for the device"
+	      "\n\t-o <num>, --max-openers <num> maximum allowed concurrent openers"
+	      "\n\t-v, --verbose                 verbose mode (print properties of device after successfully creating it)"
+	      "\n\t-w <w>, --max-width <w>       maximum allowed frame width"
+	      "\n\t-x <x>, --exclusive-caps <x>  whether to announce OUTPUT/CAPTURE capabilities exclusively"
+	      "\n\t--min-width <w>               minimum allowed frame width"
+	      "\n\t--min-height <w>              minimum allowed frame height"
+	      "\n\t-?, --help                    print this help and exit"
+	      "\n"
+	      "\n  <outputdevice>\tif given, create a specific device (otherwise just create a free one)."
+	      "\n          \teither specify a device name (e.g. '/dev/video1') or a device number ('1')."
+	      "\n  <capturedevice>\tif given, use separate output & capture devices (otherwise they are the same).");
+}
+static void help_delete(const char *program, int detail)
+{
+	_help(detail, "Deleting Devices", program, "delete", "<device>",
+	      "delete/remove an unused loopback device",
+	      "\n  <device>\tcan be given one more more times (to delete multiple devices at once)."
+	      "\n          \teither specify a device name (e.g. '/dev/video1') or a device number ('1').");
+}
+static void help_query(const char *program, int detail)
+{
+	_help(detail, "Querying Devices", program, "query",
+	      "[OPTIONS] <device>", "query information about a loopback device",
+	      "\n\t-e, --escape             escape control-characters in (device) names"
+	      "\n\t-h, --help               print this help and exit"
+	      "\n"
+	      "\n  <device>\tcan be given one more more times (to query multiple devices at once)."
+	      "\n         \teither specify a device name (e.g. '/dev/video1') or a device number ('1').");
+}
+static void help_setfps(const char *program, int detail)
+{
+	_help(detail, "Setting Framerate", program, "set-fps", "<device> <fps>",
+	      "set the default framerate for a loopback device",
+	      "\n  <device>\teither specify a device name (e.g. '/dev/video1') or a device number ('1')."
+	      "\n     <fps>\tframes per second, either as integer ('30') or fraction ('50/2').");
+}
+static void help_getfps(const char *program, int detail)
+{
+	_help(detail, "Getting Framerate", program, "get-fps", "<device>",
+	      "query the framerate of a loopback device", 0);
+}
+static void help_setcaps(const char *program, int detail)
+{
+	_help(detail, "Setting Capabilities", program, "set-caps",
+	      "<device> <caps>",
+	      "set format/dimension/framerate of a loopback device",
+	      "\n  <device>\teither specify a device name (e.g. '/dev/video1') or a device number ('1')."
+	      "\n    <caps>\tformat specification as '<fourcc>:<width>x<height>@<fps>' (e.g. 'UYVY:1024x768@60/1')"
+	      "\n          \tunset the current caps with the special value 'any'");
+	if (detail > 1) {
+		dprintf(2, "\nknown fourcc-codes"
+			   "\n=================="
+			   "\nFOURCC\thex       \tdec         \tdescription"
+			   "\n------\t----------\t------------\t-----------"
+			   "");
+		char fourcc[5];
+		const size_t num_formats = sizeof(formats) / sizeof(*formats);
+		size_t i = 0;
+		for (i = 0; i < num_formats; i++) {
+			const struct v4l2l_format *fmt = formats + i;
+			memset(fourcc, 0, 5);
+			dprintf(2, "'%4s'\t0x%08X\t%12d\t%s\n",
+				fourcc2str(fmt->fourcc, fourcc), fmt->fourcc,
+				fmt->fourcc, fmt->name);
+		}
+	}
+}
+static void help_getcaps(const char *program, int detail)
+{
+	_help(detail, "Getting Capabilities", program, "get-caps", "<device>",
+	      "get current format/dimension/framerate of a loopback device", 0);
+}
+static void help_settimeoutimage(const char *program, int detail)
+{
+	_help(detail, "Setting Timeout Image", program, "set-timeout-image",
+	      "[OPTIONS] <device> <image>",
+	      "set a fallback image to be used if a video producer does not send new frames in time.",
+	      "\n   <flags>\tany of the following flags may be present"
+	      "\n\t-h, --help                         print this help and exit"
+	      "\n\t-t <timeout>, --timeout <timeout>  timeout (in ms)"
+	      "\n\t-v, --verbose                      raise verbosity (print what is being done)"
+	      "\n"
+	      "\n  <device>\teither specify a device name (e.g. '/dev/video1') or a device number ('1')."
+	      "\n   <image>\timage file");
+}
+static void help_none(const char *program, int detail)
+{
+}
+typedef void (*t_help)(const char *, int);
+static t_help get_help(t_command cmd)
+{
+	switch (cmd) {
+	default:
+		break;
+	case ADD:
+		return help_add;
+	case DELETE:
+		return help_delete;
+	case LIST:
+		return help_list;
+	case QUERY:
+		return help_query;
+	case SET_FPS:
+		return help_setfps;
+	case GET_FPS:
+		return help_getfps;
+	case SET_CAPS:
+		return help_setcaps;
+	case GET_CAPS:
+		return help_getcaps;
+	case SET_TIMEOUTIMAGE:
+		return help_settimeoutimage;
+	}
+	return help_none;
+}
+
+static void help(const char *name, int status)
+{
+	t_command cmd;
+	dprintf(2, "Usage: %s [OPTIONS]\n", name);
+	for (cmd = ADD; cmd < _UNKNOWN; cmd++) {
+		t_help hlp = get_help(cmd);
+		if (help_none == hlp)
+			continue;
+		dprintf(2, "  or:  %s ", name);
+		hlp(0, 0);
+	}
+
+	dprintf(2, "\nManage v4l2 loopback devices.");
+	dprintf(2,
+		"\n"
+		"\nThe general invocation uses a verb (like 'add' or 'delete') that defines"
+		"\nan action to be executed. Each verb has their own options and arguments."
+		"\n"
+		"\nOptions:"
+		"\n\t-h, -?, --help: print this help and exit"
+		"\n\t-v, --version: print version and exit"
+		"\n\n");
+
+	/* long helps */
+	dprintf(2, "*Verbs and their arguments*\n");
+	for (cmd = ADD; cmd < _UNKNOWN; cmd++) {
+		t_help hlp = get_help(cmd);
+		if (help_none == hlp)
+			continue;
+		hlp("v4l2loopback-ctl", 1);
+		dprintf(2, "\n\n");
+	}
+
+	dprintf(2,
+		"*Reporting Bugs*\n"
+		"\nIssue tracker: https://github.com/umlaeute/v4l2loopback/issues"
+		"\nSecurity Issue tracker: https://git.iem.at/zmoelnig/v4l2loopback/-/issues"
+		"\n\n");
+	exit(status);
+}
+static void usage(const char *name)
+{
+	help(name, 1);
+}
+static void usage_topic(const char *name, t_command cmd, int argc, char **argv)
+{
+	t_help hlp = get_help(cmd);
+	if (help_none == hlp)
+		usage(name);
+	else
+		hlp(name, 2);
+	dprintf(2, "\n");
+	exit(1);
+}
+
+static const char *my_realpath(const char *path, char *resolved_path)
+{
+	char *str = realpath(path, resolved_path);
+	return str ? str : path;
+}
+static int parse_device(const char *devicename_)
+{
+	char devicenamebuf[4096];
+	const char *devicename = my_realpath(devicename_, devicenamebuf);
+	int ret = strncmp(devicename, "/dev/video", 10);
+	const char *device = (ret) ? devicename : (devicename + 10);
+	char *endptr = 0;
+	int dev = strtol(device, &endptr, 10);
+	if (!*endptr)
+		return dev;
+
+	return -1;
+}
+
+static void print_conf(struct v4l2_loopback_config *cfg, int escape_level)
+{
+	int output_nr, capture_nr;
+	MARK();
+	if (!cfg) {
+		printf("configuration: %p\n", cfg);
+		return;
+	}
+	output_nr = capture_nr = cfg->output_nr;
+#ifdef SPLIT_DEVICES
+	capture_nr = cfg->capture_nr;
+#endif
+	MARK();
+	printf("\tcapture_device#  : %d"
+	       "\n\toutput_device#   : %d"
+	       "\n\tcard_label       : ",
+	       capture_nr, output_nr);
+	printf_raw(cfg->card_label, escape_level);
+	printf("\n\tmin_width        : %d"
+	       "\n\tmax_width        : %d"
+	       "\n\tmin_height       : %d"
+	       "\n\tmax_height       : %d"
+	       "\n\tannounce_all_caps: %d"
+	       "\n\tmax_buffers      : %d"
+	       "\n\tmax_openers      : %d"
+	       "\n\tdebug            : %d"
+	       "\n",
+	       cfg->min_width, cfg->max_width, cfg->min_height, cfg->max_height,
+	       cfg->announce_all_caps, cfg->max_buffers, cfg->max_openers,
+	       cfg->debug);
+	MARK();
+}
+
+static struct v4l2_loopback_config *
+make_conf(struct v4l2_loopback_config *cfg, const char *label, int min_width,
+	  int max_width, int min_height, int max_height, int exclusive_caps,
+	  int buffers, int openers, int capture_device, int output_device)
+{
+	if (!cfg)
+		return 0;
+	/* check if at least one of the args are non-default */
+	if (!label && min_width <= 0 && max_width <= 0 && min_height <= 0 &&
+	    max_height <= 0 && exclusive_caps < 0 && buffers <= 0 &&
+	    openers <= 0 && capture_device < 0 && output_device < 0)
+		return 0;
+#ifdef SPLIT_DEVICES
+	cfg->capture_nr = capture_device;
+#endif
+	cfg->output_nr = output_device;
+	cfg->card_label[0] = 0;
+	if (label)
+		snprintf(cfg->card_label, 32, "%s", label);
+	cfg->min_width = (min_width < 0) ? 0 : min_width;
+	cfg->max_width = (max_width < 0) ? 0 : max_width;
+	cfg->min_height = (min_height < 0) ? 0 : min_height;
+	cfg->max_height = (max_height < 0) ? 0 : max_height;
+	cfg->announce_all_caps = (exclusive_caps < 0) ? -1 : !exclusive_caps;
+	cfg->max_buffers = buffers;
+	cfg->max_openers = openers;
+	cfg->debug = 0;
+	return cfg;
+}
+
+static int add_device(int fd, struct v4l2_loopback_config *cfg, int verbose)
+{
+	int err = 0;
+	MARK();
+	int ret = ioctl(fd, V4L2LOOPBACK_CTL_ADD, cfg);
+	MARK();
+	if (ret < 0) {
+		err = errno;
+		perror("failed to create device");
+		return err;
+	}
+	MARK();
+
+	printf("/dev/video%d\n", ret);
+
+	if (verbose > 0) {
+		MARK();
+		struct v4l2_loopback_config config;
+		memset(&config, 0, sizeof(config));
+		config.output_nr = ret;
+#ifdef SPLIT_DEVICES
+		config.capture_nr = ret;
+#endif
+		ret = ioctl(fd, V4L2LOOPBACK_CTL_QUERY, &config);
+		if (ret < 0) {
+			err = errno;
+			perror("failed querying newly added device");
+		}
+		MARK();
+		print_conf(&config, 0);
+		MARK();
+	}
+	return err;
+}
+
+static int delete_device(int fd, const char *devicename)
+{
+	int err = 0;
+	int dev = parse_device(devicename);
+	if (dev < 0) {
+		dprintf(2, "ignoring illegal devicename '%s'\n", devicename);
+		return 1;
+	}
+	if (ioctl(fd, V4L2LOOPBACK_CTL_REMOVE, dev) < 0) {
+		err = errno;
+		perror(devicename);
+	}
+
+	return err;
+}
+
+static int query_device(int fd, const char *devicename, int escape)
+{
+	int err;
+	struct v4l2_loopback_config config;
+	int dev = parse_device(devicename);
+	if (dev < 0) {
+		dprintf(2, "ignoring illegal devicename '%s'\n", devicename);
+		return 1;
+	}
+
+	memset(&config, 0, sizeof(config));
+	config.output_nr = dev;
+#ifdef SPLIT_DEVICES
+	config.capture_nr = dev;
+#endif
+	err = ioctl(fd, V4L2LOOPBACK_CTL_QUERY, &config);
+	if (err)
+		perror("query failed");
+	else {
+		printf("%s\n", devicename);
+		print_conf(&config, escape);
+		return 0;
+	}
+	return err;
+}
+static int list_devices(int fd, int escape)
+{
+	struct devnode_ {
+		int output, capture;
+		char name[32];
+	} *devices = 0;
+	size_t numdevices = 0, i;
+	glob_t globbuf = { 0 };
+	int output_nr, capture_nr;
+	glob("/sys/devices/virtual/video4linux/video*", GLOB_ONLYDIR, 0,
+	     &globbuf);
+	if (globbuf.gl_pathc) {
+		devices = malloc(globbuf.gl_pathc * sizeof(*devices));
+	}
+	for (i = 0; i < globbuf.gl_pathc; i++) {
+		size_t j;
+		struct v4l2_loopback_config config = { 0 };
+		int dev = -1;
+		char *endptr;
+		struct stat sb;
+		const char *path = globbuf.gl_pathv[i];
+		if (lstat(path, &sb)) {
+			//perror("stat");
+			continue;
+		}
+		if (!S_ISDIR(sb.st_mode)) {
+			//dprintf(2, "not a directory\n");
+			continue;
+		}
+		dev = strtol(path + 38, &endptr, 10);
+		if (*endptr) {
+			//dprintf(2, "unable to parse device-name\n");
+			continue;
+		}
+		/* check if this is a loopback device */
+		config.output_nr = dev;
+#ifdef SPLIT_DEVICES
+		config.capture_nr = -1;
+		if (ioctl(fd, V4L2LOOPBACK_CTL_QUERY, &config)) {
+			memset(&config, 0, sizeof(config));
+			config.output_nr = -1;
+			config.capture_nr = dev;
+			if (ioctl(fd, V4L2LOOPBACK_CTL_QUERY, &config)) {
+				//dprintf(2, "not a loopback device\n");
+				continue;
+			}
+		}
+		capture_nr = config.capture_nr;
+#else
+		if (ioctl(fd, V4L2LOOPBACK_CTL_QUERY, &config)) {
+			//dprintf(2, "not a loopback device\n");
+			continue;
+		}
+		capture_nr = config.output_nr;
+#endif
+		output_nr = config.output_nr;
+		/* check if we already have this device */
+		for (j = 0; j < numdevices; j++) {
+			if ((devices[j].output == output_nr) &&
+			    (devices[j].capture == capture_nr)) {
+				//dprintf(2, "duplicate device\n");
+				output_nr = capture_nr = -1;
+				break;
+			}
+		}
+		if ((output_nr < 0) || (capture_nr < 0))
+			continue;
+
+		devices[numdevices].output = output_nr;
+		devices[numdevices].capture = capture_nr;
+		snprintf(devices[numdevices].name,
+			 sizeof(devices[numdevices].name), "%s",
+			 config.card_label);
+		numdevices++;
+	}
+	if (numdevices) {
+		dprintf(2, "OUTPUT       \tCAPTURE      \tNAME\n");
+	} else {
+		dprintf(2, "no loopback devices found\n");
+	}
+	for (i = 0; i < numdevices; i++) {
+		const char *str = devices[i].name;
+		printf("/dev/video%-3d\t/dev/video%-3d\t", devices[i].output,
+		       devices[i].capture);
+		printf_raw(str, escape);
+		printf("\n");
+	}
+	globfree(&globbuf);
+	free(devices);
+	return 0;
+}
+static int open_videodevice(const char *devicename, int mode)
+{
+	int fd = open(devicename, mode);
+	if (fd < 0) {
+		int devnr = parse_device(devicename);
+		if (devnr >= 0) {
+			char devname[100];
+			snprintf(devname, 99, "/dev/video%d", devnr);
+			devname[99] = 0;
+			fd = open(devname, mode);
+		}
+	}
+	return fd;
+}
+static int open_controldevice()
+{
+	int fd = open(CONTROLDEVICE, 0);
+	if (fd < 0) {
+		perror("unable to open control device '" CONTROLDEVICE "'");
+		exit(1);
+	}
+	return fd;
+}
+
+static int open_sysfs_file(const char *devicename, const char *filename,
+			   int flags)
+{
+	int fd = -1;
+	char sysdev[100];
+	int dev = parse_device(devicename);
+	if (dev < 0) {
+		dprintf(2, "ignoring illegal devicename '%s'\n", devicename);
+		return -1;
+	}
+	snprintf(sysdev, sizeof(sysdev) - 1,
+		 "/sys/devices/virtual/video4linux/video%d/%s", dev, filename);
+	sysdev[sizeof(sysdev) - 1] = 0;
+	fd = open(sysdev, flags);
+	if (fd < 0) {
+		perror(sysdev);
+		return -1;
+	}
+	//dprintf(2, "%s\n", sysdev);
+	return fd;
+}
+
+static int parse_fps(const char *fps, int *numerator, int *denominator)
+{
+	int num = 0;
+	int denom = 1;
+	if (sscanf(fps, "%d/%d", &num, &denom) <= 0) {
+		return 1;
+	}
+	if (numerator)
+		*numerator = num;
+	if (denominator)
+		*denominator = denom;
+	return 0;
+}
+static int is_fps(const char *fps)
+{
+	return parse_fps(fps, 0, 0);
+}
+
+static int set_fps(const char *devicename, const char *fps)
+{
+	int result = 1;
+	char _fps[100];
+	int fd = open_sysfs_file(devicename, "format", O_WRONLY);
+	if (fd < 0)
+		return 1;
+	snprintf(_fps, sizeof(_fps) - 1, "@%s", fps);
+	_fps[sizeof(_fps) - 1] = 0;
+
+	if (write(fd, _fps, strnlen(_fps, sizeof(_fps))) < 0) {
+		perror("failed to set fps");
+		goto done;
+	}
+
+	result = 0;
+done:
+	close(fd);
+	return result;
+}
+
+typedef struct _caps {
+	unsigned int fourcc;
+	int width, height;
+	int fps_num, fps_denom;
+} t_caps;
+
+static void print_caps(t_caps *caps)
+{
+	char fourcc[4];
+	if (!caps) {
+		dprintf(2, "no caps\n");
+		return;
+	}
+	dprintf(2, "FOURCC : %.4s\n", fourcc2str(caps->fourcc, fourcc));
+	dprintf(2, "dimen  : %dx%d\n", caps->width, caps->height);
+	dprintf(2, "fps    : %d/%d\n", caps->fps_num, caps->fps_denom);
+}
+static int parse_caps(const char *buffer, t_caps *caps)
+{
+	char fourcc[5];
+	memset(caps, 0, sizeof(*caps));
+	memset(fourcc, 0, sizeof(*fourcc));
+	caps->fps_denom = 1;
+
+	if (!(buffer && *buffer))
+		return 1;
+
+	if (sscanf(buffer, "%4c:%dx%d@%d/%d", fourcc, &caps->width,
+		   &caps->height, &caps->fps_num, &caps->fps_denom) <= 0) {
+	}
+	caps->fourcc = str2fourcc(fourcc);
+	return (0 == caps->fourcc);
+}
+static int read_caps(const char *devicename, t_caps *caps)
+{
+	int result = 1;
+	char _caps[100];
+	int len;
+	int fd = open_sysfs_file(devicename, "format", O_RDONLY);
+	if (fd < 0)
+		return 1;
+
+	len = read(fd, _caps, 100);
+	if (len <= 0) {
+		if (len)
+			perror("failed to read fps");
+		goto done;
+	}
+	_caps[100 - 1] = 0;
+	if (caps) {
+		if (parse_caps(_caps, caps)) {
+			dprintf(2, "unable to parse format '%s'\n", _caps);
+			goto done;
+		}
+	}
+	result = 0;
+done:
+	close(fd);
+	return result;
+}
+
+static int get_fps(const char *devicename)
+{
+	t_caps caps;
+	struct v4l2_streamparm param;
+	int fd = -1;
+	int num = -1, denom = -1;
+	int ret = 0;
+
+	if (!read_caps(devicename, &caps)) {
+		num = caps.fps_num;
+		denom = caps.fps_denom;
+		goto done;
+	}
+
+	/* get the framerate via ctls */
+	fd = open_videodevice(devicename, O_RDWR);
+	if (fd < 0) {
+		ret = 1;
+		goto done;
+	}
+
+	memset(&param, 0, sizeof(param));
+	param.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (ioctl(fd, VIDIOC_G_PARM, &param) == 0) {
+		const struct v4l2_fract *tf = &param.parm.output.timeperframe;
+		num = tf->numerator;
+		denom = tf->denominator;
+		goto done;
+	}
+
+	memset(&param, 0, sizeof(param));
+	param.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	if (ioctl(fd, VIDIOC_G_PARM, &param) == 0) {
+		const struct v4l2_fract *tf = &param.parm.output.timeperframe;
+		num = tf->numerator;
+		denom = tf->denominator;
+		goto done;
+	}
+
+	ret = 1;
+done:
+	if (fd >= 0)
+		close(fd);
+	printf("%d/%d\n", num, denom);
+	return ret;
+}
+static int set_caps(const char *devicename, const char *capsstring)
+{
+	int result = 1;
+	int fd = open_videodevice(devicename, O_RDWR);
+	struct v4l2_format vid_format;
+	struct v4l2_capability vid_caps;
+	t_caps caps;
+
+	/* now open up the device */
+	if (fd < 0)
+		goto done;
+
+	if (!strncmp("any", capsstring, 4)) {
+		/* skip caps-parsing */
+	} else if (!strncmp("video/", capsstring, 6)) {
+		dprintf(2,
+			"ERROR: GStreamer-style caps are no longer supported!\n");
+		dprintf(2,
+			"ERROR: use '<FOURCC>:<width>x<height>[@<fps>] instead\n");
+		dprintf(2,
+			"       e.g. 'UYVY:640x480@30/1' or 'RGBA:1024x768'\n");
+		goto done;
+	} else if (parse_caps(capsstring, &caps)) {
+		dprintf(2, "unable to parse format '%s'\n", capsstring);
+		goto done;
+	}
+	//print_caps(&caps);
+
+	/* check whether this is actually a video-device */
+	if (ioctl(fd, VIDIOC_QUERYCAP, &vid_caps) == -1) {
+		perror("VIDIOC_QUERYCAP");
+		goto done;
+	}
+
+	if (!strncmp("any", capsstring, 4)) {
+		set_control_i(fd, "keep_format", 0);
+		//set_control_i(fd, "sustain_framerate", 0);
+		result = 0;
+		goto done;
+	}
+
+	/* try to get the default values for the format first */
+	memset(&vid_format, 0, sizeof(vid_format));
+
+	vid_format.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	if (ioctl(fd, VIDIOC_G_FMT, &vid_format) == -1) {
+		perror("VIDIOC_G_FMT");
+	}
+
+	/* and set those caps that we have */
+	if (caps.width)
+		vid_format.fmt.pix.width = caps.width;
+	if (caps.height)
+		vid_format.fmt.pix.height = caps.height;
+	if (caps.fourcc)
+		vid_format.fmt.pix.pixelformat = caps.fourcc;
+
+	if (ioctl(fd, VIDIOC_S_FMT, &vid_format) == -1) {
+		perror("unable to set requested format");
+		goto done;
+	}
+
+	set_control_i(fd, "keep_format", 1);
+
+	/* finally, try setting the fps */
+	if (caps.fps_num && caps.fps_denom) {
+		char fps[100];
+		int didit;
+		snprintf(fps, 100, "%d/%d", caps.fps_num, caps.fps_denom);
+		didit = set_fps(devicename, fps);
+		if (!didit) {
+			set_control_i(fd, "sustain_framerate", 1);
+		}
+		close(fd);
+		fd = -1;
+		return didit;
+	}
+
+	result = 0;
+done:
+	if (fd >= 0)
+		close(fd);
+	return result;
+}
+static int get_caps(const char *devicename)
+{
+	int format = 0;
+	t_caps caps;
+	char fourcc[4];
+	if (read_caps(devicename, &caps))
+		return 1;
+	switch (format) {
+	default:
+		printf("%.4s:%dx%d@%d/%d\n", fourcc2str(caps.fourcc, fourcc),
+		       caps.width, caps.height, caps.fps_num, caps.fps_denom);
+		break;
+	case 1: /* GStreamer-1.0 */
+
+		/* FOURCC is different everywhere... */
+		switch (caps.fourcc) {
+		default:
+			break;
+		case 0x56595559: /* YUYV */
+			caps.fourcc = str2fourcc("YUY2");
+			break;
+		}
+
+		printf("video/x-raw,format=%.4s,width=%d,height=%d,framerate=%d/%d\n",
+		       fourcc2str(caps.fourcc, fourcc), caps.width, caps.height,
+		       caps.fps_num, caps.fps_denom);
+		break;
+	}
+	return 0;
+}
+static int set_timeoutimage(const char *devicename, const char *imagefile,
+			    int timeout, int verbose)
+{
+	int err = 0;
+	int fd = -1;
+	char imagearg[4096], imagefile2[4096], devicearg[4096];
+	char *args[] = { "gst-launch-1.0",
+			 "uridecodebin",
+			 0,
+			 "!",
+			 "videoconvert",
+			 "!",
+			 "videoscale",
+			 "!",
+			 "imagefreeze",
+			 "!",
+			 "identity",
+			 "eos-after=2",
+			 "drop-allocation=1",
+			 "!",
+			 "v4l2sink",
+			 "show-preroll-frame=false",
+			 0,
+			 0 };
+	if (verbose)
+		printf("set-timeout-image '%s' for '%s' with %dms timeout\n",
+		       imagefile, devicename, timeout);
+
+	snprintf(imagearg, 4096, "uri=file://%s",
+		 realpath(imagefile, imagefile2));
+	snprintf(devicearg, 4096, "device=%s", devicename);
+	imagearg[4095] = devicearg[4095] = 0;
+	args[2] = imagearg;
+	args[16] = devicearg;
+
+	fd = open_videodevice(devicename, O_RDWR);
+	if (fd >= 0) {
+		dprintf(2, "v4l2-ctl -d %s -c timeout_image_io=1\n",
+			devicename);
+		set_control_i(fd, "timeout_image_io", 1);
+		close(fd);
+	} else {
+		err = errno;
+	}
+
+	if (verbose > 1) {
+		char **ap = args;
+		while (*ap) {
+			dprintf(2, "%s", *ap);
+			if (*ap++)
+				dprintf(2, " ");
+			else
+				dprintf(2, "\n");
+		}
+	}
+
+	dprintf(2,
+		"v======================================================================v\n");
+	if (my_execv(args)) {
+		dprintf(2, "ERROR: setting time-out image failed\n");
+		err = 1;
+	}
+	dprintf(2,
+		"^======================================================================^\n");
+
+	fd = open_videodevice(devicename, O_RDWR);
+	if (fd >= 0) {
+		/* finally check the timeout */
+		if (timeout < 0) {
+			timeout = get_control_i(fd, "timeout");
+		} else {
+			dprintf(2, "v4l2-ctl -d %s -c timeout=%d\n", devicename,
+				timeout);
+			timeout = set_control_i(fd, "timeout", timeout);
+		}
+		if (timeout <= 0) {
+			dprintf(2,
+				"Timeout is currently disabled; you can set it to some positive value, e.g.:\n");
+			dprintf(2, "    $  v4l2-ctl -d %s -c timeout=3000\n",
+				devicename);
+		}
+
+		close(fd);
+	} else {
+		err = errno;
+	}
+	return err;
+}
+
+static t_command get_command(const char *command)
+{
+	if (!strncmp(command, "-h", 3))
+		return HELP;
+	if (!strncmp(command, "-?", 3))
+		return HELP;
+	if (!strncmp(command, "--help", 7))
+		return HELP;
+	if (!strncmp(command, "-v", 3))
+		return VERSION;
+	if (!strncmp(command, "--version", 10))
+		return VERSION;
+	if (!strncmp(command, "list", 5))
+		return LIST;
+	if (!strncmp(command, "add", 4))
+		return ADD;
+	if (!strncmp(command, "del", 3)) /* also allow delete */
+		return DELETE;
+	if (!strncmp(command, "query", 6))
+		return QUERY;
+	if (!strncmp(command, "set-fps", 8))
+		return SET_FPS;
+	if (!strncmp(command, "get-fps", 8))
+		return GET_FPS;
+	if (!strncmp(command, "set-caps", 9))
+		return SET_CAPS;
+	if (!strncmp(command, "get-caps", 9))
+		return GET_CAPS;
+	if (!strncmp(command, "set-timeout-image", 18))
+		return SET_TIMEOUTIMAGE;
+	if (!strncmp(command, "moo", 10))
+		return MOO;
+	return _UNKNOWN;
+}
+
+typedef int (*t_argcheck)(const char *);
+static int called_deprecated(const char *device, const char *argument,
+			     const char *programname, const char *cmdname,
+			     const char *argname, t_argcheck argcheck)
+{
+	/* check if <device> does not look like a device, but <argument> does
+	 * if so, assume that the user swapped the two */
+	/* if the <device> looks about right, optionally do some extra
+	 * <argument>-check, to see if it can be used
+	 */
+
+	int deviceswapped = 0;
+	int argswapped = 0;
+
+	if (argcheck)
+		argswapped =
+			((argcheck(argument) != 0) && (argcheck(device) == 0));
+
+	if (!argswapped)
+		deviceswapped = (parse_device(device) < 0 &&
+				 parse_device(argument) >= 0);
+
+	if (argswapped || deviceswapped) {
+		dprintf(2, "WARNING: '%s %s <%s> <image>' is deprecated!\n",
+			programname, cmdname, argname);
+		dprintf(2, "WARNING: use '%s %s <device> <%s>' instead.\n",
+			programname, cmdname, argname);
+		return 1;
+	}
+	return 0;
+}
+
+static int do_defaultargs(const char *progname, t_command cmd, int argc,
+			  char **argv)
+{
+	static const char options_short[] = "?h";
+	static const struct option options_long[] = {
+		{ "help", no_argument, NULL, 'h' }, { 0, 0, 0, 0 }
+	};
+	for (;;) {
+		int c;
+		int idx;
+		c = getopt_long(argc - 1, argv + 1, options_short, options_long,
+				&idx);
+		if (-1 == c)
+			break;
+		switch (c) {
+		case 'h':
+			usage_topic(argv[0], cmd, argc - 1, argv + 1);
+			exit(0);
+		default:
+			usage_topic(argv[0], cmd, argc - 1, argv + 1);
+			exit(1);
+		}
+	}
+	return optind;
+}
+
+int main(int argc, char **argv)
+{
+	const char *progname = argv[0];
+	int i;
+	int fd = -1;
+	int verbose = 0;
+	t_command cmd;
+
+	char *label = 0;
+	int min_width = -1;
+	int max_width = -1;
+	int min_height = -1;
+	int max_height = -1;
+	int exclusive_caps = -1;
+	int buffers = -1;
+	int openers = -1;
+	int escape_strings = 0;
+
+	int ret = 0;
+
+	static const char add_options_short[] = "?vn:w:h:x:b:o:";
+	static const struct option add_options_long[] = {
+		{ "help", no_argument, NULL, '?' },
+		{ "verbose", no_argument, NULL, 'v' },
+		{ "name", required_argument, NULL, 'n' },
+		{ "min-width", required_argument, NULL, 'w' + 0xFFFF },
+		{ "max-width", required_argument, NULL, 'w' },
+		{ "min-height", required_argument, NULL, 'h' + 0xFFFF },
+		{ "max-height", required_argument, NULL, 'h' },
+		{ "exclusive-caps", required_argument, NULL, 'x' },
+		{ "buffers", required_argument, NULL, 'b' },
+		{ "max-openers", required_argument, NULL, 'o' },
+		{ 0, 0, 0, 0 }
+	};
+	static const char list_options_short[] = "?he";
+	static const struct option list_options_long[] = {
+		{ "help", no_argument, NULL, 'h' },
+		{ "escape", no_argument, NULL, 'e' },
+		{ 0, 0, 0, 0 }
+	};
+	static const char timeoutimg_options_short[] = "?ht:v";
+	static const struct option timeoutimg_options_long[] = {
+		{ "help", no_argument, NULL, 'h' },
+		{ "timeout", required_argument, NULL, 't' },
+		{ "verbose", no_argument, NULL, 'v' },
+		{ 0, 0, 0, 0 }
+	};
+
+	if (argc < 2)
+		usage(progname);
+	cmd = get_command(argv[1]);
+	if (_UNKNOWN == cmd) {
+		dprintf(2, "unknown command '%s'\n\n", argv[1]);
+		usage(progname);
+		return 1;
+	}
+	argc--;
+	argv++;
+	switch (cmd) {
+	case HELP:
+		help(progname, 0);
+		break;
+	case LIST:
+		for (;;) {
+			int c;
+			int idx;
+			c = getopt_long(argc, argv, list_options_short,
+					list_options_long, &idx);
+			if (-1 == c)
+				break;
+			switch (c) {
+			case 'e':
+				escape_strings++;
+				break;
+			default:
+				usage_topic(progname, cmd, argc - 1, argv + 1);
+				return 1;
+			}
+		}
+		argc -= optind;
+		argv += optind;
+
+		if (argc) {
+			dprintf(2, "'list' does not take any arguments\n");
+			return 1;
+		}
+		fd = open_controldevice();
+		if (fd >= 0)
+			list_devices(fd, escape_strings);
+		else
+			return 1;
+		break;
+	case ADD:
+		for (;;) {
+			int c;
+			int idx;
+			c = getopt_long(argc, argv, add_options_short,
+					add_options_long, &idx);
+			if (-1 == c)
+				break;
+			switch (c) {
+			case 'v':
+				verbose++;
+				break;
+			case 'n':
+				label = optarg;
+				break;
+			case 'w' + 0xFFFF:
+				min_width = my_atoi("min_width", optarg);
+				break;
+			case 'h' + 0xFFFF:
+				min_height = my_atoi("min_height", optarg);
+				break;
+			case 'w':
+				max_width = my_atoi("max_width", optarg);
+				break;
+			case 'h':
+				max_height = my_atoi("max_height", optarg);
+				break;
+			case 'x':
+				exclusive_caps =
+					my_atoi("exclusive_caps", optarg);
+				break;
+			case 'b':
+				buffers = my_atoi("buffers", optarg);
+				break;
+			case 'o':
+				openers = my_atoi("openers", optarg);
+				break;
+			default:
+				usage_topic(progname, cmd, argc - 1, argv + 1);
+				return 1;
+			}
+		}
+		argc -= optind;
+		argv += optind;
+		fd = open_controldevice();
+		if (min_width > max_width && max_width > 0) {
+			dprintf(2,
+				"min_width (%d) must not be greater than max_width (%d)\n",
+				min_width, max_width);
+			return 1;
+		}
+		if (min_height > max_height && max_height > 0) {
+			dprintf(2,
+				"min_height (%d) must not be greater than max_height (%d)\n",
+				min_height, max_height);
+			return 1;
+		}
+		do {
+			struct v4l2_loopback_config cfg;
+			int capture_nr = -1, output_nr = -1;
+			switch (argc) {
+			case 0:
+				/* no device given: pick some */
+				break;
+			case 2:
+				/* two devices given: capture_device and output_device */
+				output_nr = parse_device(argv[0]);
+				capture_nr = parse_device(argv[1]);
+#ifndef SPLIT_DEVICES
+				if (capture_nr != output_nr)
+					dprintf(2,
+						"split output/capture devices currently not supported...ignoring capture device\n");
+				capture_nr = output_nr;
+#endif
+				break;
+			case 1:
+				/* single device given: use it for both input and output */
+				capture_nr = output_nr = parse_device(argv[0]);
+				break;
+			default:
+				usage_topic(progname, cmd, argc, argv);
+				return 1;
+			}
+			ret = add_device(fd,
+					 make_conf(&cfg, label, min_width,
+						   max_width, min_height,
+						   max_height, exclusive_caps,
+						   buffers, openers, capture_nr,
+						   output_nr),
+					 verbose);
+		} while (0);
+		break;
+	case DELETE:
+		optind = do_defaultargs(progname, cmd, argc, argv);
+		argc -= optind;
+		argv += optind;
+
+		if (!argc)
+			usage_topic(progname, cmd, argc, argv);
+		fd = open_controldevice();
+		for (i = 0; i < argc; i++) {
+			int err = delete_device(fd, argv[i]);
+			if (err)
+				ret = err;
+		}
+		break;
+	case QUERY:
+		for (;;) {
+			int c;
+			int idx;
+			c = getopt_long(argc, argv, list_options_short,
+					list_options_long, &idx);
+			if (-1 == c)
+				break;
+			switch (c) {
+			case 'e':
+				escape_strings++;
+				break;
+			default:
+				usage_topic(progname, cmd, argc - 1, argv + 1);
+				return 1;
+			}
+		}
+		argc -= optind;
+		argv += optind;
+
+		if (!argc)
+			usage_topic(progname, cmd, argc, argv);
+		fd = open_controldevice();
+		for (i = 0; i < argc; i++) {
+			ret += query_device(fd, argv[i], escape_strings);
+		}
+		ret = (ret > 0);
+		break;
+	case SET_FPS:
+		optind = do_defaultargs(progname, cmd, argc, argv);
+		argc -= optind;
+		argv += optind;
+		if (argc != 2)
+			usage_topic(progname, cmd, argc, argv);
+		if (called_deprecated(argv[0], argv[1], progname, "set-fps",
+				      "fps", is_fps)) {
+			ret = set_fps(argv[1], argv[0]);
+		} else
+			ret = set_fps(argv[0], argv[1]);
+		break;
+	case GET_FPS:
+		optind = do_defaultargs(progname, cmd, argc, argv);
+		argc -= optind;
+		argv += optind;
+		if (argc != 1)
+			usage_topic(progname, cmd, argc, argv);
+		ret = get_fps(argv[0]);
+		break;
+	case SET_CAPS:
+		optind = do_defaultargs(progname, cmd, argc, argv);
+		argc -= optind;
+		argv += optind;
+		if (argc != 2)
+			usage_topic(progname, cmd, argc, argv);
+		if (called_deprecated(argv[0], argv[1], progname, "set-caps",
+				      "caps", 0)) {
+			ret = set_caps(argv[1], argv[0]);
+		} else {
+			ret = set_caps(argv[0], argv[1]);
+		}
+		break;
+	case GET_CAPS:
+		optind = do_defaultargs(progname, cmd, argc, argv);
+		argc -= optind;
+		argv += optind;
+		if (argc != 1)
+			usage_topic(progname, cmd, argc, argv);
+		ret = get_caps(argv[0]);
+		break;
+	case SET_TIMEOUTIMAGE:
+		if ((3 == argc) && (strncmp("-t", argv[1], 3)) &&
+		    (strncmp("--timeout", argv[1], 10)) &&
+		    (called_deprecated(argv[1], argv[2], progname,
+				       "set-timeout-image", "image", 0))) {
+			ret = set_timeoutimage(argv[2], argv[1], -1, verbose);
+		} else {
+			int timeout = -1;
+			for (;;) {
+				int c, idx;
+				c = getopt_long(argc, argv,
+						timeoutimg_options_short,
+						timeoutimg_options_long, &idx);
+				if (-1 == c)
+					break;
+				switch (c) {
+				case 't':
+					timeout = my_atoi("timeout", optarg);
+					break;
+				case 'v':
+					verbose++;
+					break;
+				default:
+					usage_topic(progname, cmd, argc, argv);
+				}
+			}
+			argc -= optind;
+			argv += optind;
+			if (argc != 2)
+				usage_topic(progname, cmd, argc, argv);
+			ret = set_timeoutimage(argv[0], argv[1], timeout,
+					       verbose);
+		}
+		break;
+	case VERSION:
+#ifdef SNAPSHOT_VERSION
+		printf("%s v%s\n", progname, SNAPSHOT_VERSION);
+#else
+		printf("%s v%d.%d.%d\n", progname, V4L2LOOPBACK_VERSION_MAJOR,
+		       V4L2LOOPBACK_VERSION_MINOR, V4L2LOOPBACK_VERSION_BUGFIX);
+#endif
+		fd = open("/sys/module/v4l2loopback/version", O_RDONLY);
+		if (fd >= 0) {
+			char buf[1024];
+			int len = read(fd, buf, sizeof(buf));
+			if (len > 0) {
+				if (len < sizeof(buf))
+					buf[len] = 0;
+				printf("v4l2loopback sysfs v%s", buf);
+			}
+			close(fd);
+		}
+		fd = open_controldevice();
+		if (fd >= 0) {
+			__u32 version = 0;
+			if (ioctl(fd, V4L2LOOPBACK_CTL_VERSION, &version) ==
+			    0) {
+				printf("v4l2loopback module v%d.%d.%d\n",
+				       (version >> 16) & 0xff,
+				       (version >> 8) & 0xff,
+				       (version >> 0) & 0xff);
+			}
+		}
+		break;
+	default:
+		dprintf(2, "not implemented: '%s'\n", argv[0]);
+		break;
+	}
+
+	if (fd >= 0)
+		close(fd);
+
+	return ret;
+}
diff --git a/drivers/custom/v4l2loopback/v4l2loopback.c b/drivers/custom/v4l2loopback/v4l2loopback.c
new file mode 100644
index 000000000000..3be7c4abc1e7
--- /dev/null
+++ b/drivers/custom/v4l2loopback/v4l2loopback.c
@@ -0,0 +1,3316 @@
+/* -*- c-file-style: "linux" -*- */
+/*
+ * v4l2loopback.c  --  video4linux2 loopback driver
+ *
+ * Copyright (C) 2005-2009 Vasily Levin (vasaka@gmail.com)
+ * Copyright (C) 2010-2023 IOhannes m zmoelnig (zmoelnig@iem.at)
+ * Copyright (C) 2011 Stefan Diewald (stefan.diewald@mytum.de)
+ * Copyright (C) 2012 Anton Novikov (random.plant@gmail.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/time.h>
+#include <linux/module.h>
+#include <linux/videodev2.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/timer.h>
+#include <linux/eventpoll.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+
+#include <linux/miscdevice.h>
+#include "v4l2loopback.h"
+
+#define V4L2LOOPBACK_CTL_ADD_legacy 0x4C80
+#define V4L2LOOPBACK_CTL_REMOVE_legacy 0x4C81
+#define V4L2LOOPBACK_CTL_QUERY_legacy 0x4C82
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
+#error This module is not supported on kernels before 4.0.0.
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
+#define strscpy strlcpy
+#endif
+
+#if defined(timer_setup)
+#define HAVE_TIMER_SETUP
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0)
+#define VFL_TYPE_VIDEO VFL_TYPE_GRABBER
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+#define timer_delete_sync del_timer_sync
+#endif
+
+#define V4L2LOOPBACK_VERSION_CODE                                              \
+	KERNEL_VERSION(V4L2LOOPBACK_VERSION_MAJOR, V4L2LOOPBACK_VERSION_MINOR, \
+		       V4L2LOOPBACK_VERSION_BUGFIX)
+
+MODULE_DESCRIPTION("V4L2 loopback video device");
+MODULE_AUTHOR("Vasily Levin, "
+	      "IOhannes m zmoelnig <zmoelnig@iem.at>,"
+	      "Stefan Diewald,"
+	      "Anton Novikov"
+	      "et al.");
+#ifdef SNAPSHOT_VERSION
+MODULE_VERSION(__stringify(SNAPSHOT_VERSION));
+#else
+MODULE_VERSION("" __stringify(V4L2LOOPBACK_VERSION_MAJOR) "." __stringify(
+	V4L2LOOPBACK_VERSION_MINOR) "." __stringify(V4L2LOOPBACK_VERSION_BUGFIX));
+#endif
+MODULE_LICENSE("GPL");
+
+/*
+ * helpers
+ */
+#define dprintk(fmt, args...)                                          \
+	do {                                                           \
+		if (debug > 0) {                                       \
+			printk(KERN_INFO "v4l2-loopback[" __stringify( \
+				       __LINE__) "], pid(%d):  " fmt,  \
+			       task_pid_nr(current), ##args);          \
+		}                                                      \
+	} while (0)
+
+#define MARK()                                                             \
+	do {                                                               \
+		if (debug > 1) {                                           \
+			printk(KERN_INFO "%s:%d[%s], pid(%d)\n", __FILE__, \
+			       __LINE__, __func__, task_pid_nr(current));  \
+		}                                                          \
+	} while (0)
+
+#define dprintkrw(fmt, args...)                                        \
+	do {                                                           \
+		if (debug > 2) {                                       \
+			printk(KERN_INFO "v4l2-loopback[" __stringify( \
+				       __LINE__) "], pid(%d): " fmt,   \
+			       task_pid_nr(current), ##args);          \
+		}                                                      \
+	} while (0)
+
+static inline void v4l2l_get_timestamp(struct v4l2_buffer *b)
+{
+	struct timespec64 ts;
+	ktime_get_ts64(&ts);
+
+	b->timestamp.tv_sec = ts.tv_sec;
+	b->timestamp.tv_usec = (ts.tv_nsec / NSEC_PER_USEC);
+	b->flags |= V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	b->flags &= ~V4L2_BUF_FLAG_TIMESTAMP_COPY;
+}
+
+#if BITS_PER_LONG == 32
+#include <asm/div64.h> /* do_div() for 64bit division */
+static inline int v4l2l_mod64(const s64 A, const u32 B)
+{
+	u64 a = (u64)A;
+	u32 b = B;
+
+	if (A > 0)
+		return do_div(a, b);
+	a = -A;
+	return -do_div(a, b);
+}
+#else
+static inline int v4l2l_mod64(const s64 A, const u32 B)
+{
+	return A % B;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0)
+typedef unsigned __poll_t;
+#endif
+
+/* module constants
+ *  can be overridden during he build process using something like
+ *	make KCPPFLAGS="-DMAX_DEVICES=100"
+ */
+
+/* maximum number of v4l2loopback devices that can be created */
+#ifndef MAX_DEVICES
+#define MAX_DEVICES 8
+#endif
+
+/* whether the default is to announce capabilities exclusively or not */
+#ifndef V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS
+#define V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS 0
+#endif
+
+/* when a producer is considered to have gone stale */
+#ifndef MAX_TIMEOUT
+#define MAX_TIMEOUT (100 * 1000) /* in msecs */
+#endif
+
+/* max buffers that can be mapped, actually they
+ * are all mapped to max_buffers buffers */
+#ifndef MAX_BUFFERS
+#define MAX_BUFFERS 32
+#endif
+
+/* module parameters */
+static int debug = 0;
+module_param(debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "debugging level (higher values == more verbose)");
+
+#define V4L2LOOPBACK_DEFAULT_MAX_BUFFERS 2
+static int max_buffers = V4L2LOOPBACK_DEFAULT_MAX_BUFFERS;
+module_param(max_buffers, int, S_IRUGO);
+MODULE_PARM_DESC(max_buffers,
+		 "how many buffers should be allocated [DEFAULT: " __stringify(
+			 V4L2LOOPBACK_DEFAULT_MAX_BUFFERS) "]");
+
+/* how many times a device can be opened
+ * the per-module default value can be overridden on a per-device basis using
+ * the /sys/devices interface
+ *
+ * note that max_openers should be at least 2 in order to get a working system:
+ *   one opener for the producer and one opener for the consumer
+ *   however, we leave that to the user
+ */
+#define V4L2LOOPBACK_DEFAULT_MAX_OPENERS 10
+static int max_openers = V4L2LOOPBACK_DEFAULT_MAX_OPENERS;
+module_param(max_openers, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(
+	max_openers,
+	"how many users can open the loopback device [DEFAULT: " __stringify(
+		V4L2LOOPBACK_DEFAULT_MAX_OPENERS) "]");
+
+static int devices = -1;
+module_param(devices, int, 0);
+MODULE_PARM_DESC(devices, "how many devices should be created");
+
+static int video_nr[MAX_DEVICES] = { [0 ...(MAX_DEVICES - 1)] = -1 };
+module_param_array(video_nr, int, NULL, 0444);
+MODULE_PARM_DESC(video_nr,
+		 "video device numbers (-1=auto, 0=/dev/video0, etc.)");
+
+static char *card_label[MAX_DEVICES];
+module_param_array(card_label, charp, NULL, 0000);
+MODULE_PARM_DESC(card_label, "card labels for each device");
+
+static bool exclusive_caps[MAX_DEVICES] = {
+	[0 ...(MAX_DEVICES - 1)] = V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS
+};
+module_param_array(exclusive_caps, bool, NULL, 0444);
+/* FIXXME: wording */
+MODULE_PARM_DESC(
+	exclusive_caps,
+	"whether to announce OUTPUT/CAPTURE capabilities exclusively or not  [DEFAULT: " __stringify(
+		V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS) "]");
+
+/* format specifications */
+#define V4L2LOOPBACK_SIZE_MIN_WIDTH 2
+#define V4L2LOOPBACK_SIZE_MIN_HEIGHT 1
+#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH 8192
+#define V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT 8192
+
+#define V4L2LOOPBACK_SIZE_DEFAULT_WIDTH 640
+#define V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT 480
+
+static int max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;
+module_param(max_width, int, S_IRUGO);
+MODULE_PARM_DESC(max_width,
+		 "maximum allowed frame width [DEFAULT: " __stringify(
+			 V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH) "]");
+static int max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;
+module_param(max_height, int, S_IRUGO);
+MODULE_PARM_DESC(max_height,
+		 "maximum allowed frame height [DEFAULT: " __stringify(
+			 V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT) "]");
+
+static DEFINE_IDR(v4l2loopback_index_idr);
+static DEFINE_MUTEX(v4l2loopback_ctl_mutex);
+
+/* frame intervals */
+#define V4L2LOOPBACK_FRAME_INTERVAL_MAX __UINT32_MAX__
+#define V4L2LOOPBACK_FPS_DEFAULT 30
+#define V4L2LOOPBACK_FPS_MAX 1000
+
+/* control IDs */
+#define V4L2LOOPBACK_CID_BASE (V4L2_CID_USER_BASE | 0xf000)
+#define CID_KEEP_FORMAT (V4L2LOOPBACK_CID_BASE + 0)
+#define CID_SUSTAIN_FRAMERATE (V4L2LOOPBACK_CID_BASE + 1)
+#define CID_TIMEOUT (V4L2LOOPBACK_CID_BASE + 2)
+#define CID_TIMEOUT_IMAGE_IO (V4L2LOOPBACK_CID_BASE + 3)
+
+static int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl);
+static const struct v4l2_ctrl_ops v4l2loopback_ctrl_ops = {
+	.s_ctrl = v4l2loopback_s_ctrl,
+};
+static const struct v4l2_ctrl_config v4l2loopback_ctrl_keepformat = {
+	// clang-format off
+	.ops	= &v4l2loopback_ctrl_ops,
+	.id	= CID_KEEP_FORMAT,
+	.name	= "keep_format",
+	.type	= V4L2_CTRL_TYPE_BOOLEAN,
+	.min	= 0,
+	.max	= 1,
+	.step	= 1,
+	.def	= 0,
+	// clang-format on
+};
+static const struct v4l2_ctrl_config v4l2loopback_ctrl_sustainframerate = {
+	// clang-format off
+	.ops	= &v4l2loopback_ctrl_ops,
+	.id	= CID_SUSTAIN_FRAMERATE,
+	.name	= "sustain_framerate",
+	.type	= V4L2_CTRL_TYPE_BOOLEAN,
+	.min	= 0,
+	.max	= 1,
+	.step	= 1,
+	.def	= 0,
+	// clang-format on
+};
+static const struct v4l2_ctrl_config v4l2loopback_ctrl_timeout = {
+	// clang-format off
+	.ops	= &v4l2loopback_ctrl_ops,
+	.id	= CID_TIMEOUT,
+	.name	= "timeout",
+	.type	= V4L2_CTRL_TYPE_INTEGER,
+	.min	= 0,
+	.max	= MAX_TIMEOUT,
+	.step	= 1,
+	.def	= 0,
+	// clang-format on
+};
+static const struct v4l2_ctrl_config v4l2loopback_ctrl_timeoutimageio = {
+	// clang-format off
+	.ops	= &v4l2loopback_ctrl_ops,
+	.id	= CID_TIMEOUT_IMAGE_IO,
+	.name	= "timeout_image_io",
+	.type	= V4L2_CTRL_TYPE_BUTTON,
+	.min	= 0,
+	.max	= 0,
+	.step	= 0,
+	.def	= 0,
+	// clang-format on
+};
+
+/* module structures */
+struct v4l2loopback_private {
+	int device_nr;
+};
+
+/* TODO(vasaka) use typenames which are common to kernel, but first find out if
+ * it is needed */
+/* struct keeping state and settings of loopback device */
+
+struct v4l2l_buffer {
+	struct v4l2_buffer buffer;
+	struct list_head list_head;
+	atomic_t use_count;
+};
+
+struct v4l2_loopback_device {
+	struct v4l2_device v4l2_dev;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct video_device *vdev;
+
+	/* loopback device-specific parameters */
+	char card_label[32];
+	bool announce_all_caps; /* announce both OUTPUT and CAPTURE capabilities
+				 * when true; else announce OUTPUT when no
+				 * writer is streaming, otherwise CAPTURE. */
+	int max_openers; /* how many times can this device be opened */
+	int min_width, max_width;
+	int min_height, max_height;
+
+	/* pixel and stream format */
+	struct v4l2_pix_format pix_format;
+	bool pix_format_has_valid_sizeimage;
+	struct v4l2_captureparm capture_param;
+	unsigned long frame_jiffies;
+
+	/* ctrls */
+	int keep_format; /* CID_KEEP_FORMAT; lock the format, do not free
+			  * on close(), and when `!announce_all_caps` do NOT
+			  * fall back to OUTPUT when no writers attached (clear
+			  * `keep_format` to attach a new writer) */
+	int sustain_framerate; /* CID_SUSTAIN_FRAMERATE; duplicate frames to maintain
+				  (close to) nominal framerate */
+	unsigned long timeout_jiffies; /* CID_TIMEOUT; 0 means disabled */
+	int timeout_image_io; /* CID_TIMEOUT_IMAGE_IO; next opener will
+			       * queue/dequeue the timeout image buffer */
+
+	/* buffers for OUTPUT and CAPTURE */
+	u8 *image; /* pointer to actual buffers data */
+	unsigned long image_size; /* number of bytes alloc'd for all buffers */
+	struct v4l2l_buffer buffers[MAX_BUFFERS]; /* inner driver buffers */
+	u32 buffer_count; /* should not be big, 4 is a good choice */
+	u32 buffer_size; /* number of bytes alloc'd per buffer */
+	u32 used_buffer_count; /* number of buffers allocated to openers */
+	struct list_head outbufs_list; /* FIFO queue for OUTPUT buffers */
+	u32 bufpos2index[MAX_BUFFERS]; /* mapping of `(position % used_buffers)`
+					* to `buffers[index]` */
+	s64 write_position; /* sequence number of last 'displayed' buffer plus
+			     * one */
+
+	/* synchronization between openers */
+	atomic_t open_count;
+	struct mutex image_mutex; /* mutex for allocating image(s) and
+				   * exchanging format tokens */
+	spinlock_t lock; /* lock for the timeout and framerate timers */
+	spinlock_t list_lock; /* lock for the OUTPUT buffer queue */
+	wait_queue_head_t read_event;
+	u32 format_tokens; /* tokens to 'set format' for OUTPUT, CAPTURE, or
+			    * timeout buffers */
+	u32 stream_tokens; /* tokens to 'start' OUTPUT, CAPTURE, or timeout
+			    * stream */
+
+	/* sustain framerate */
+	struct timer_list sustain_timer;
+	unsigned int reread_count;
+
+	/* timeout */
+	u8 *timeout_image; /* copied to outgoing buffers when timeout passes */
+	struct v4l2l_buffer timeout_buffer;
+	u32 timeout_buffer_size; /* number bytes alloc'd for timeout buffer */
+	struct timer_list timeout_timer;
+	int timeout_happened;
+};
+
+enum v4l2l_io_method {
+	V4L2L_IO_NONE = 0,
+	V4L2L_IO_MMAP = 1,
+	V4L2L_IO_FILE = 2,
+	V4L2L_IO_TIMEOUT = 3,
+};
+
+/* struct keeping state and type of opener */
+struct v4l2_loopback_opener {
+	u32 format_token; /* token (if any) for type used in call to S_FMT or
+			   * REQBUFS */
+	u32 stream_token; /* token (if any) for type used in call to STREAMON */
+	u32 buffer_count; /* number of buffers (if any) that opener acquired via
+			   * REQBUFS */
+	s64 read_position; /* sequence number of the next 'captured' frame */
+	unsigned int reread_count;
+	enum v4l2l_io_method io_method;
+
+	struct v4l2_fh fh;
+};
+
+#define fh_to_opener(ptr) container_of((ptr), struct v4l2_loopback_opener, fh)
+
+/* this is heavily inspired by the bttv driver found in the linux kernel */
+struct v4l2l_format {
+	char *name;
+	int fourcc; /* video4linux 2 */
+	int depth; /* bit/pixel */
+	int flags;
+};
+/* set the v4l2l_format.flags to PLANAR for non-packed formats */
+#define FORMAT_FLAGS_PLANAR 0x01
+#define FORMAT_FLAGS_COMPRESSED 0x02
+
+#include "v4l2loopback_formats.h"
+
+#ifndef V4L2_TYPE_IS_CAPTURE
+#define V4L2_TYPE_IS_CAPTURE(type)                \
+	((type) == V4L2_BUF_TYPE_VIDEO_CAPTURE || \
+	 (type) == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+#endif /* V4L2_TYPE_IS_CAPTURE */
+#ifndef V4L2_TYPE_IS_OUTPUT
+#define V4L2_TYPE_IS_OUTPUT(type)                \
+	((type) == V4L2_BUF_TYPE_VIDEO_OUTPUT || \
+	 (type) == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+#endif /* V4L2_TYPE_IS_OUTPUT */
+
+/* token values for privilege to set format or start/stop stream */
+#define V4L2L_TOKEN_CAPTURE 0x01
+#define V4L2L_TOKEN_OUTPUT 0x02
+#define V4L2L_TOKEN_TIMEOUT 0x04
+#define V4L2L_TOKEN_MASK \
+	(V4L2L_TOKEN_CAPTURE | V4L2L_TOKEN_OUTPUT | V4L2L_TOKEN_TIMEOUT)
+
+/* helpers for token exchange and token status */
+#define token_from_type(type) \
+	(V4L2_TYPE_IS_CAPTURE(type) ? V4L2L_TOKEN_CAPTURE : V4L2L_TOKEN_OUTPUT)
+#define acquire_token(dev, opener, label, token) \
+	do {                                     \
+		(opener)->label##_token = token; \
+		(dev)->label##_tokens &= ~token; \
+	} while (0)
+#define release_token(dev, opener, label)                         \
+	do {                                                      \
+		(dev)->label##_tokens |= (opener)->label##_token; \
+		(opener)->label##_token = 0;                      \
+	} while (0)
+#define has_output_token(token) (token & V4L2L_TOKEN_OUTPUT)
+#define has_capture_token(token) (token & V4L2L_TOKEN_CAPTURE)
+#define has_no_owners(dev) ((~((dev)->format_tokens) & V4L2L_TOKEN_MASK) == 0)
+#define has_other_owners(opener, dev) \
+	(~((dev)->format_tokens ^ (opener)->format_token) & V4L2L_TOKEN_MASK)
+#define need_timeout_buffer(dev, token) \
+	((dev)->timeout_jiffies > 0 || (token) & V4L2L_TOKEN_TIMEOUT)
+
+static const unsigned int FORMATS = ARRAY_SIZE(formats);
+
+static char *fourcc2str(unsigned int fourcc, char buf[5])
+{
+	buf[0] = (fourcc >> 0) & 0xFF;
+	buf[1] = (fourcc >> 8) & 0xFF;
+	buf[2] = (fourcc >> 16) & 0xFF;
+	buf[3] = (fourcc >> 24) & 0xFF;
+	buf[4] = 0;
+
+	return buf;
+}
+
+static const struct v4l2l_format *format_by_fourcc(int fourcc)
+{
+	unsigned int i;
+	char buf[5];
+
+	for (i = 0; i < FORMATS; i++) {
+		if (formats[i].fourcc == fourcc)
+			return formats + i;
+	}
+
+	dprintk("unsupported format '%4s'\n", fourcc2str(fourcc, buf));
+	return NULL;
+}
+
+static void pix_format_set_size(struct v4l2_pix_format *f,
+				const struct v4l2l_format *fmt,
+				unsigned int width, unsigned int height)
+{
+	f->width = width;
+	f->height = height;
+
+	if (fmt->flags & FORMAT_FLAGS_PLANAR) {
+		f->bytesperline = width; /* Y plane */
+		f->sizeimage = (width * height * fmt->depth) >> 3;
+	} else if (fmt->flags & FORMAT_FLAGS_COMPRESSED) {
+		/* doesn't make sense for compressed formats */
+		f->bytesperline = 0;
+		f->sizeimage = (width * height * fmt->depth) >> 3;
+	} else {
+		f->bytesperline = (width * fmt->depth) >> 3;
+		f->sizeimage = height * f->bytesperline;
+	}
+}
+
+static int v4l2l_fill_format(struct v4l2_format *fmt, const u32 minwidth,
+			     const u32 maxwidth, const u32 minheight,
+			     const u32 maxheight)
+{
+	u32 width = fmt->fmt.pix.width, height = fmt->fmt.pix.height;
+	u32 pixelformat = fmt->fmt.pix.pixelformat;
+	struct v4l2_format fmt0 = *fmt;
+	u32 bytesperline = 0, sizeimage = 0;
+
+	if (!width)
+		width = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;
+	if (!height)
+		height = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;
+	width = clamp_val(width, minwidth, maxwidth);
+	height = clamp_val(height, minheight, maxheight);
+
+	/* sets: width,height,pixelformat,bytesperline,sizeimage */
+	if (!(V4L2_TYPE_IS_MULTIPLANAR(fmt0.type))) {
+		fmt0.fmt.pix.bytesperline = 0;
+		fmt0.fmt.pix.sizeimage = 0;
+	}
+
+	if (0) {
+		;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
+	} else if (!v4l2_fill_pixfmt(&fmt0.fmt.pix, pixelformat, width,
+				     height)) {
+		;
+	} else if (!v4l2_fill_pixfmt_mp(&fmt0.fmt.pix_mp, pixelformat, width,
+					height)) {
+		;
+#endif
+	} else {
+		const struct v4l2l_format *format =
+			format_by_fourcc(pixelformat);
+		if (!format)
+			return -EINVAL;
+		pix_format_set_size(&fmt0.fmt.pix, format, width, height);
+		fmt0.fmt.pix.pixelformat = format->fourcc;
+	}
+
+	if (V4L2_TYPE_IS_MULTIPLANAR(fmt0.type)) {
+		*fmt = fmt0;
+
+		if ((fmt->fmt.pix_mp.colorspace == V4L2_COLORSPACE_DEFAULT) ||
+		    (fmt->fmt.pix_mp.colorspace > V4L2_COLORSPACE_DCI_P3))
+			fmt->fmt.pix_mp.colorspace = V4L2_COLORSPACE_SRGB;
+		if (V4L2_FIELD_ANY == fmt->fmt.pix_mp.field)
+			fmt->fmt.pix_mp.field = V4L2_FIELD_NONE;
+	} else {
+		bytesperline = fmt->fmt.pix.bytesperline;
+		sizeimage = fmt->fmt.pix.sizeimage;
+
+		*fmt = fmt0;
+
+		if (!fmt->fmt.pix.bytesperline)
+			fmt->fmt.pix.bytesperline = bytesperline;
+		if (!fmt->fmt.pix.sizeimage)
+			fmt->fmt.pix.sizeimage = sizeimage;
+
+		if ((fmt->fmt.pix.colorspace == V4L2_COLORSPACE_DEFAULT) ||
+		    (fmt->fmt.pix.colorspace > V4L2_COLORSPACE_DCI_P3))
+			fmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+		if (V4L2_FIELD_ANY == fmt->fmt.pix.field)
+			fmt->fmt.pix.field = V4L2_FIELD_NONE;
+	}
+
+	return 0;
+}
+
+/* Checks if v4l2l_fill_format() has set a valid, fixed sizeimage val. */
+static bool v4l2l_pix_format_has_valid_sizeimage(struct v4l2_format *fmt)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
+	const struct v4l2_format_info *info;
+
+	info = v4l2_format_info(fmt->fmt.pix.pixelformat);
+	if (info && info->mem_planes == 1)
+		return true;
+#endif
+
+	return false;
+}
+
+static int pix_format_eq(const struct v4l2_pix_format *ref,
+			 const struct v4l2_pix_format *tgt, int strict)
+{
+	/* check if the two formats are equivalent.
+	 * ANY fields are handled gracefully
+	 */
+#define _pix_format_eq0(x)    \
+	if (ref->x != tgt->x) \
+	result = 0
+#define _pix_format_eq1(x, def)                              \
+	do {                                                 \
+		if ((def != tgt->x) && (ref->x != tgt->x)) { \
+			printk(KERN_INFO #x " failed");      \
+			result = 0;                          \
+		}                                            \
+	} while (0)
+	int result = 1;
+	_pix_format_eq0(width);
+	_pix_format_eq0(height);
+	_pix_format_eq0(pixelformat);
+	if (!strict)
+		return result;
+	_pix_format_eq1(field, V4L2_FIELD_ANY);
+	_pix_format_eq0(bytesperline);
+	_pix_format_eq0(sizeimage);
+	_pix_format_eq1(colorspace, V4L2_COLORSPACE_DEFAULT);
+	return result;
+}
+
+static void set_timeperframe(struct v4l2_loopback_device *dev,
+			     struct v4l2_fract *tpf)
+{
+	if (!tpf->denominator && !tpf->numerator) {
+		tpf->numerator = 1;
+		tpf->denominator = V4L2LOOPBACK_FPS_DEFAULT;
+	} else if (tpf->numerator >
+		   V4L2LOOPBACK_FRAME_INTERVAL_MAX * tpf->denominator) {
+		/* divide-by-zero or greater than maximum interval => min FPS */
+		tpf->numerator = V4L2LOOPBACK_FRAME_INTERVAL_MAX;
+		tpf->denominator = 1;
+	} else if (tpf->numerator * V4L2LOOPBACK_FPS_MAX < tpf->denominator) {
+		/* zero or lower than minimum interval => max FPS */
+		tpf->numerator = 1;
+		tpf->denominator = V4L2LOOPBACK_FPS_MAX;
+	}
+
+	dev->capture_param.timeperframe = *tpf;
+	dev->frame_jiffies =
+		max(1UL, (msecs_to_jiffies(1000) * tpf->numerator) /
+				 tpf->denominator);
+}
+
+static struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd);
+
+/* device attributes */
+/* available via sysfs: /sys/devices/virtual/video4linux/video* */
+
+static ssize_t attr_show_format(struct device *cd,
+				struct device_attribute *attr, char *buf)
+{
+	/* gets the current format as "FOURCC:WxH@f/s", e.g. "YUYV:320x240@1000/30" */
+	struct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);
+	const struct v4l2_fract *tpf;
+	char buf4cc[5], buf_fps[32];
+
+	if (!dev || (has_no_owners(dev) && !dev->keep_format))
+		return 0;
+	tpf = &dev->capture_param.timeperframe;
+
+	fourcc2str(dev->pix_format.pixelformat, buf4cc);
+	if (tpf->numerator == 1)
+		snprintf(buf_fps, sizeof(buf_fps), "%u", tpf->denominator);
+	else
+		snprintf(buf_fps, sizeof(buf_fps), "%u/%u", tpf->denominator,
+			 tpf->numerator);
+	return sprintf(buf, "%4s:%ux%u@%s\n", buf4cc, dev->pix_format.width,
+		       dev->pix_format.height, buf_fps);
+}
+
+static ssize_t attr_store_format(struct device *cd,
+				 struct device_attribute *attr, const char *buf,
+				 size_t len)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);
+	int fps_num = 0, fps_den = 1;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* only fps changing is supported */
+	if (sscanf(buf, "@%u/%u", &fps_num, &fps_den) > 0) {
+		struct v4l2_fract f = { .numerator = fps_den,
+					.denominator = fps_num };
+		set_timeperframe(dev, &f);
+		return len;
+	}
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(format, S_IRUGO | S_IWUSR, attr_show_format,
+		   attr_store_format);
+
+static ssize_t attr_show_buffers(struct device *cd,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);
+
+	if (!dev)
+		return -ENODEV;
+
+	return sprintf(buf, "%u\n", dev->used_buffer_count);
+}
+
+static DEVICE_ATTR(buffers, S_IRUGO, attr_show_buffers, NULL);
+
+static ssize_t attr_show_maxopeners(struct device *cd,
+				    struct device_attribute *attr, char *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);
+
+	if (!dev)
+		return -ENODEV;
+
+	return sprintf(buf, "%d\n", dev->max_openers);
+}
+
+static ssize_t attr_store_maxopeners(struct device *cd,
+				     struct device_attribute *attr,
+				     const char *buf, size_t len)
+{
+	struct v4l2_loopback_device *dev = NULL;
+	unsigned long curr = 0;
+
+	if (kstrtoul(buf, 0, &curr))
+		return -EINVAL;
+
+	dev = v4l2loopback_cd2dev(cd);
+	if (!dev)
+		return -ENODEV;
+
+	if (dev->max_openers == curr)
+		return len;
+
+	if (curr > __INT_MAX__ || dev->open_count.counter > curr) {
+		/* request to limit to less openers as are currently attached to us */
+		return -EINVAL;
+	}
+
+	dev->max_openers = (int)curr;
+
+	return len;
+}
+
+static DEVICE_ATTR(max_openers, S_IRUGO | S_IWUSR, attr_show_maxopeners,
+		   attr_store_maxopeners);
+
+static ssize_t attr_show_state(struct device *cd, struct device_attribute *attr,
+			       char *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);
+
+	if (!dev)
+		return -ENODEV;
+
+	if (!has_output_token(dev->stream_tokens) || dev->keep_format) {
+		return sprintf(buf, "capture\n");
+	} else
+		return sprintf(buf, "output\n");
+
+	return -EAGAIN;
+}
+
+static DEVICE_ATTR(state, S_IRUGO, attr_show_state, NULL);
+
+static void v4l2loopback_remove_sysfs(struct video_device *vdev)
+{
+#define V4L2_SYSFS_DESTROY(x) device_remove_file(&vdev->dev, &dev_attr_##x)
+
+	if (vdev) {
+		V4L2_SYSFS_DESTROY(format);
+		V4L2_SYSFS_DESTROY(buffers);
+		V4L2_SYSFS_DESTROY(max_openers);
+		V4L2_SYSFS_DESTROY(state);
+		/* ... */
+	}
+}
+
+static void v4l2loopback_create_sysfs(struct video_device *vdev)
+{
+	int res = 0;
+
+#define V4L2_SYSFS_CREATE(x)                                 \
+	res = device_create_file(&vdev->dev, &dev_attr_##x); \
+	if (res < 0)                                         \
+	break
+	if (!vdev)
+		return;
+	do {
+		V4L2_SYSFS_CREATE(format);
+		V4L2_SYSFS_CREATE(buffers);
+		V4L2_SYSFS_CREATE(max_openers);
+		V4L2_SYSFS_CREATE(state);
+		/* ... */
+	} while (0);
+
+	if (res >= 0)
+		return;
+	dev_err(&vdev->dev, "%s error: %d\n", __func__, res);
+}
+
+/* Event APIs */
+
+#define V4L2LOOPBACK_EVENT_BASE (V4L2_EVENT_PRIVATE_START)
+#define V4L2LOOPBACK_EVENT_OFFSET 0x08E00000
+#define V4L2_EVENT_PRI_CLIENT_USAGE \
+	(V4L2LOOPBACK_EVENT_BASE + V4L2LOOPBACK_EVENT_OFFSET + 1)
+
+struct v4l2_event_client_usage {
+	__u32 count;
+};
+
+/* global module data */
+/* find a device based on it's device-number (e.g. '3' for /dev/video3) */
+struct v4l2loopback_lookup_cb_data {
+	int device_nr;
+	struct v4l2_loopback_device *device;
+};
+static int v4l2loopback_lookup_cb(int id, void *ptr, void *data)
+{
+	struct v4l2_loopback_device *device = ptr;
+	struct v4l2loopback_lookup_cb_data *cbdata = data;
+	if (cbdata && device && device->vdev) {
+		if (device->vdev->num == cbdata->device_nr) {
+			cbdata->device = device;
+			cbdata->device_nr = id;
+			return 1;
+		}
+	}
+	return 0;
+}
+static int v4l2loopback_lookup(int device_nr,
+			       struct v4l2_loopback_device **device)
+{
+	struct v4l2loopback_lookup_cb_data data = {
+		.device_nr = device_nr,
+		.device = NULL,
+	};
+	int err = idr_for_each(&v4l2loopback_index_idr, &v4l2loopback_lookup_cb,
+			       &data);
+	if (1 == err) {
+		if (device)
+			*device = data.device;
+		return data.device_nr;
+	}
+	return -ENODEV;
+}
+#define v4l2loopback_get_vdev_nr(vdev) \
+	((struct v4l2loopback_private *)video_get_drvdata(vdev))->device_nr
+static struct v4l2_loopback_device *v4l2loopback_cd2dev(struct device *cd)
+{
+	struct video_device *loopdev = to_video_device(cd);
+	int device_nr = v4l2loopback_get_vdev_nr(loopdev);
+
+	return idr_find(&v4l2loopback_index_idr, device_nr);
+}
+
+static struct v4l2_loopback_device *v4l2loopback_getdevice(struct file *f)
+{
+	struct v4l2loopback_private *ptr = video_drvdata(f);
+	int nr = ptr->device_nr;
+
+	return idr_find(&v4l2loopback_index_idr, nr);
+}
+
+/* forward declarations */
+static void client_usage_queue_event(struct video_device *vdev);
+static bool any_buffers_mapped(struct v4l2_loopback_device *dev);
+static int allocate_buffers(struct v4l2_loopback_device *dev,
+			    struct v4l2_pix_format *pix_format);
+static void init_buffers(struct v4l2_loopback_device *dev, u32 bytes_used,
+			 u32 buffer_size);
+static void free_buffers(struct v4l2_loopback_device *dev);
+static int allocate_timeout_buffer(struct v4l2_loopback_device *dev);
+static void free_timeout_buffer(struct v4l2_loopback_device *dev);
+static void check_timers(struct v4l2_loopback_device *dev);
+static const struct v4l2_file_operations v4l2_loopback_fops;
+static const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops;
+
+/* V4L2 ioctl caps and params calls */
+/* returns device capabilities
+ * called on VIDIOC_QUERYCAP
+ */
+static int vidioc_querycap(struct file *file, void *fh,
+			   struct v4l2_capability *cap)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	int device_nr = v4l2loopback_get_vdev_nr(dev->vdev);
+	__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+
+	strscpy(cap->driver, "v4l2 loopback", sizeof(cap->driver));
+	snprintf(cap->card, sizeof(cap->card), "%s", dev->card_label);
+	snprintf(cap->bus_info, sizeof(cap->bus_info),
+		 "platform:v4l2loopback-%03d", device_nr);
+
+	if (dev->announce_all_caps) {
+		capabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;
+	} else {
+		if (opener->io_method == V4L2L_IO_TIMEOUT ||
+		    (has_output_token(dev->stream_tokens) &&
+		     !dev->keep_format)) {
+			capabilities |= V4L2_CAP_VIDEO_OUTPUT;
+		} else
+			capabilities |= V4L2_CAP_VIDEO_CAPTURE;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	dev->vdev->device_caps =
+#endif /* >=linux-4.7.0 */
+		cap->device_caps = cap->capabilities = capabilities;
+
+	cap->capabilities |= V4L2_CAP_DEVICE_CAPS;
+
+	memset(cap->reserved, 0, sizeof(cap->reserved));
+	return 0;
+}
+
+static int vidioc_enum_framesizes(struct file *file, void *fh,
+				  struct v4l2_frmsizeenum *argp)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+
+	/* there can be only one... */
+	if (argp->index)
+		return -EINVAL;
+
+	if (dev->keep_format || has_other_owners(opener, dev)) {
+		/* only current frame size supported */
+		if (argp->pixel_format != dev->pix_format.pixelformat)
+			return -EINVAL;
+
+		argp->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+
+		argp->discrete.width = dev->pix_format.width;
+		argp->discrete.height = dev->pix_format.height;
+	} else {
+		/* return continuous sizes if pixel format is supported */
+		if (NULL == format_by_fourcc(argp->pixel_format))
+			return -EINVAL;
+
+		if (dev->min_width == dev->max_width &&
+		    dev->min_height == dev->max_height) {
+			argp->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+
+			argp->discrete.width = dev->min_width;
+			argp->discrete.height = dev->min_height;
+		} else {
+			argp->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+
+			argp->stepwise.min_width = dev->min_width;
+			argp->stepwise.min_height = dev->min_height;
+
+			argp->stepwise.max_width = dev->max_width;
+			argp->stepwise.max_height = dev->max_height;
+
+			argp->stepwise.step_width = 1;
+			argp->stepwise.step_height = 1;
+		}
+	}
+	return 0;
+}
+
+/* Test if the device is currently 'capable' of the buffer (stream) type when
+ * the `exclusive_caps` parameter is set. `keep_format` should lock the format
+ * and prevent free of buffers */
+static int check_buffer_capability(struct v4l2_loopback_device *dev,
+				   struct v4l2_loopback_opener *opener,
+				   enum v4l2_buf_type type)
+{
+	/* short-circuit for (non-compliant) timeout image mode */
+	if (opener->io_method == V4L2L_IO_TIMEOUT)
+		return 0;
+	if (dev->announce_all_caps)
+		return (type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||
+			type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+			       0 :
+			       -EINVAL;
+	/* CAPTURE if opener has a capture format or a writer is streaming;
+	 * else OUTPUT. */
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (!(has_capture_token(opener->format_token) ||
+		      !has_output_token(dev->stream_tokens)))
+			return -EINVAL;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (!(has_output_token(opener->format_token) ||
+		      has_output_token(dev->stream_tokens)))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+/* returns frameinterval (fps) for the set resolution
+ * called on VIDIOC_ENUM_FRAMEINTERVALS
+ */
+static int vidioc_enum_frameintervals(struct file *file, void *fh,
+				      struct v4l2_frmivalenum *argp)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+
+	/* there can be only one... */
+	if (argp->index)
+		return -EINVAL;
+
+	if (dev->keep_format || has_other_owners(opener, dev)) {
+		/* keep_format also locks the frame rate */
+		if (argp->width != dev->pix_format.width ||
+		    argp->height != dev->pix_format.height ||
+		    argp->pixel_format != dev->pix_format.pixelformat)
+			return -EINVAL;
+
+		argp->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+		argp->discrete = dev->capture_param.timeperframe;
+	} else {
+		if (argp->width < dev->min_width ||
+		    argp->width > dev->max_width ||
+		    argp->height < dev->min_height ||
+		    argp->height > dev->max_height ||
+		    !format_by_fourcc(argp->pixel_format))
+			return -EINVAL;
+
+		argp->type = V4L2_FRMIVAL_TYPE_CONTINUOUS;
+		argp->stepwise.min.numerator = 1;
+		argp->stepwise.min.denominator = V4L2LOOPBACK_FPS_MAX;
+		argp->stepwise.max.numerator = V4L2LOOPBACK_FRAME_INTERVAL_MAX;
+		argp->stepwise.max.denominator = 1;
+		argp->stepwise.step.numerator = 1;
+		argp->stepwise.step.denominator = 1;
+	}
+
+	return 0;
+}
+
+/* Enumerate device formats
+ * Returns:
+ * -   EINVAL the index is out of bounds; or if non-zero when format is fixed
+ * -   EFAULT unexpected null pointer */
+static int vidioc_enum_fmt_vid(struct file *file, void *fh,
+			       struct v4l2_fmtdesc *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	int fixed = dev->keep_format || has_other_owners(opener, dev);
+	const struct v4l2l_format *fmt;
+
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+
+	if (!(f->index < FORMATS))
+		return -EINVAL;
+	/* TODO: Support 6.14 V4L2_FMTDESC_FLAG_ENUM_ALL */
+	if (fixed && f->index)
+		return -EINVAL;
+
+	fmt = fixed ? format_by_fourcc(dev->pix_format.pixelformat) :
+		      &formats[f->index];
+	if (!fmt)
+		return -EFAULT;
+
+	f->flags = 0;
+	if (fmt->flags & FORMAT_FLAGS_COMPRESSED)
+		f->flags |= V4L2_FMT_FLAG_COMPRESSED;
+	snprintf(f->description, sizeof(f->description), fmt->name);
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+/* Tests (or tries) the format.
+ * Returns:
+ * -   EINVAL if the buffer type or format is not supported
+ */
+static int vidioc_try_fmt_vid(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+	if (v4l2l_fill_format(f, dev->min_width, dev->max_width,
+			      dev->min_height, dev->max_height) != 0)
+		return -EINVAL;
+	if (dev->keep_format || has_other_owners(opener, dev))
+		/* use existing format - including colorspace info */
+		f->fmt.pix = dev->pix_format;
+
+	return 0;
+}
+
+/* Sets new format. Fills 'f' argument with the requested or existing format.
+ * Side-effect: buffers are allocated for the (returned) format.
+ * Returns:
+ * -   EINVAL if the type is not supported
+ * -   EBUSY if buffers are already allocated
+ * TODO: (vasaka) set subregions of input
+ */
+static int vidioc_s_fmt_vid(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = opener->io_method == V4L2L_IO_TIMEOUT ?
+			    V4L2L_TOKEN_TIMEOUT :
+			    token_from_type(f->type);
+	int changed, result;
+	char buf[5];
+
+	result = vidioc_try_fmt_vid(file, fh, f);
+	if (result < 0)
+		return result;
+
+	if (opener->buffer_count > 0)
+		/* must free buffers before format can be set */
+		return -EBUSY;
+
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result;
+
+	if (opener->format_token)
+		release_token(dev, opener, format);
+	if (!(dev->format_tokens & token)) {
+		result = -EBUSY;
+		goto exit_s_fmt_unlock;
+	}
+
+	dprintk("S_FMT[%s] %4s:%ux%u size=%u\n",
+		V4L2_TYPE_IS_CAPTURE(f->type) ? "CAPTURE" : "OUTPUT",
+		fourcc2str(f->fmt.pix.pixelformat, buf), f->fmt.pix.width,
+		f->fmt.pix.height, f->fmt.pix.sizeimage);
+	changed = !pix_format_eq(&dev->pix_format, &f->fmt.pix, 0);
+	if (changed || has_no_owners(dev)) {
+		result = allocate_buffers(dev, &f->fmt.pix);
+		if (result < 0)
+			goto exit_s_fmt_unlock;
+	}
+	if ((dev->timeout_image && changed) ||
+	    (!dev->timeout_image && need_timeout_buffer(dev, token))) {
+		result = allocate_timeout_buffer(dev);
+		if (result < 0)
+			goto exit_s_fmt_free;
+	}
+	if (changed) {
+		dev->pix_format = f->fmt.pix;
+		dev->pix_format_has_valid_sizeimage =
+			v4l2l_pix_format_has_valid_sizeimage(f);
+	}
+	acquire_token(dev, opener, format, token);
+	if (opener->io_method == V4L2L_IO_TIMEOUT)
+		dev->timeout_image_io = 0;
+	goto exit_s_fmt_unlock;
+exit_s_fmt_free:
+	free_buffers(dev);
+exit_s_fmt_unlock:
+	mutex_unlock(&dev->image_mutex);
+	return result;
+}
+
+/* ------------------ CAPTURE ----------------------- */
+/* ioctl for VIDIOC_ENUM_FMT, _G_FMT, _S_FMT, and _TRY_FMT when buffer type
+ * is V4L2_BUF_TYPE_VIDEO_CAPTURE */
+
+static int vidioc_enum_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_fmtdesc *f)
+{
+	return vidioc_enum_fmt_vid(file, fh, f);
+}
+
+static int vidioc_g_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+	f->fmt.pix = dev->pix_format;
+	return 0;
+}
+
+static int vidioc_try_fmt_cap(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	return vidioc_try_fmt_vid(file, fh, f);
+}
+
+static int vidioc_s_fmt_cap(struct file *file, void *fh, struct v4l2_format *f)
+{
+	return vidioc_s_fmt_vid(file, fh, f);
+}
+
+/* ------------------ OUTPUT ----------------------- */
+/* ioctl for VIDIOC_ENUM_FMT, _G_FMT, _S_FMT, and _TRY_FMT when buffer type
+ * is V4L2_BUF_TYPE_VIDEO_OUTPUT */
+
+static int vidioc_enum_fmt_out(struct file *file, void *fh,
+			       struct v4l2_fmtdesc *f)
+{
+	return vidioc_enum_fmt_vid(file, fh, f);
+}
+
+static int vidioc_g_fmt_out(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, f->type) < 0)
+		return -EINVAL;
+	/*
+	 * LATER: this should return the currently valid format
+	 * gstreamer doesn't like it, if this returns -EINVAL, as it
+	 * then concludes that there is _no_ valid format
+	 * CHECK whether this assumption is wrong,
+	 * or whether we have to always provide a valid format
+	 */
+	f->fmt.pix = dev->pix_format;
+	return 0;
+}
+
+static int vidioc_try_fmt_out(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	return vidioc_try_fmt_vid(file, fh, f);
+}
+
+static int vidioc_s_fmt_out(struct file *file, void *fh, struct v4l2_format *f)
+{
+	return vidioc_s_fmt_vid(file, fh, f);
+}
+
+// #define V4L2L_OVERLAY
+#ifdef V4L2L_OVERLAY
+/* ------------------ OVERLAY ----------------------- */
+/* currently unsupported */
+/* GSTreamer's v4l2sink is buggy, as it requires the overlay to work
+ * while it should only require it, if overlay is requested
+ * once the gstreamer element is fixed, remove the overlay dummies
+ */
+#warning OVERLAY dummies
+static int vidioc_g_fmt_overlay(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	return 0;
+}
+
+static int vidioc_s_fmt_overlay(struct file *file, void *priv,
+				struct v4l2_format *fmt)
+{
+	return 0;
+}
+#endif /* V4L2L_OVERLAY */
+
+/* ------------------ PARAMs ----------------------- */
+
+/* get some data flow parameters, only capability, fps and readbuffers has
+ * effect on this driver
+ * called on VIDIOC_G_PARM
+ */
+static int vidioc_g_parm(struct file *file, void *fh,
+			 struct v4l2_streamparm *parm)
+{
+	/* do not care about type of opener, hope these enums would always be
+	 * compatible */
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, parm->type) < 0)
+		return -EINVAL;
+	parm->parm.capture = dev->capture_param;
+	return 0;
+}
+
+/* get some data flow parameters, only capability, fps and readbuffers has
+ * effect on this driver
+ * called on VIDIOC_S_PARM
+ */
+static int vidioc_s_parm(struct file *file, void *fh,
+			 struct v4l2_streamparm *parm)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+
+	dprintk("S_PARM(frame-time=%u/%u)\n",
+		parm->parm.capture.timeperframe.numerator,
+		parm->parm.capture.timeperframe.denominator);
+	if (check_buffer_capability(dev, opener, parm->type) < 0)
+		return -EINVAL;
+
+	switch (parm->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		set_timeperframe(dev, &parm->parm.capture.timeperframe);
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		set_timeperframe(dev, &parm->parm.output.timeperframe);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	parm->parm.capture = dev->capture_param;
+	return 0;
+}
+
+#ifdef V4L2LOOPBACK_WITH_STD
+/* sets a tv standard, actually we do not need to handle this any special way
+ * added to support effecttv
+ * called on VIDIOC_S_STD
+ */
+static int vidioc_s_std(struct file *file, void *fh, v4l2_std_id *_std)
+{
+	v4l2_std_id req_std = 0, supported_std = 0;
+	const v4l2_std_id all_std = V4L2_STD_ALL, no_std = 0;
+
+	if (_std) {
+		req_std = *_std;
+		*_std = all_std;
+	}
+
+	/* we support everything in V4L2_STD_ALL, but not more... */
+	supported_std = (all_std & req_std);
+	if (no_std == supported_std)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* gets a fake video standard
+ * called on VIDIOC_G_STD
+ */
+static int vidioc_g_std(struct file *file, void *fh, v4l2_std_id *norm)
+{
+	if (norm)
+		*norm = V4L2_STD_ALL;
+	return 0;
+}
+/* gets a fake video standard
+ * called on VIDIOC_QUERYSTD
+ */
+static int vidioc_querystd(struct file *file, void *fh, v4l2_std_id *norm)
+{
+	if (norm)
+		*norm = V4L2_STD_ALL;
+	return 0;
+}
+#endif /* V4L2LOOPBACK_WITH_STD */
+
+static int v4l2loopback_set_ctrl(struct v4l2_loopback_device *dev, u32 id,
+				 s64 val)
+{
+	int result = 0;
+	switch (id) {
+	case CID_KEEP_FORMAT:
+		if (val < 0 || val > 1)
+			return -EINVAL;
+		dev->keep_format = val;
+		result = mutex_lock_killable(&dev->image_mutex);
+		if (result < 0)
+			return result;
+		if (!dev->keep_format) {
+			if (has_no_owners(dev) && !any_buffers_mapped(dev))
+				free_buffers(dev);
+		}
+		mutex_unlock(&dev->image_mutex);
+		break;
+	case CID_SUSTAIN_FRAMERATE:
+		if (val < 0 || val > 1)
+			return -EINVAL;
+		spin_lock_bh(&dev->lock);
+		dev->sustain_framerate = val;
+		check_timers(dev);
+		spin_unlock_bh(&dev->lock);
+		break;
+	case CID_TIMEOUT:
+		if (val < 0 || val > MAX_TIMEOUT)
+			return -EINVAL;
+		if (val > 0) {
+			result = mutex_lock_killable(&dev->image_mutex);
+			if (result < 0)
+				return result;
+			/* on-the-fly allocate if device is owned; else
+			 * allocate occurs on next S_FMT or REQBUFS */
+			if (!has_no_owners(dev))
+				result = allocate_timeout_buffer(dev);
+			mutex_unlock(&dev->image_mutex);
+			if (result < 0) {
+				/* disable timeout as buffer not alloc'd */
+				spin_lock_bh(&dev->lock);
+				dev->timeout_jiffies = 0;
+				spin_unlock_bh(&dev->lock);
+				return result;
+			}
+		}
+		spin_lock_bh(&dev->lock);
+		dev->timeout_jiffies = msecs_to_jiffies(val);
+		check_timers(dev);
+		spin_unlock_bh(&dev->lock);
+		break;
+	case CID_TIMEOUT_IMAGE_IO:
+		dev->timeout_image_io = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int v4l2loopback_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_loopback_device *dev = container_of(
+		ctrl->handler, struct v4l2_loopback_device, ctrl_handler);
+	return v4l2loopback_set_ctrl(dev, ctrl->id, ctrl->val);
+}
+
+/* returns set of device outputs, in our case there is only one
+ * called on VIDIOC_ENUMOUTPUT
+ */
+static int vidioc_enum_output(struct file *file, void *fh,
+			      struct v4l2_output *outp)
+{
+	__u32 index = outp->index;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
+		return -ENOTTY;
+	if (index)
+		return -EINVAL;
+
+	/* clear all data (including the reserved fields) */
+	memset(outp, 0, sizeof(*outp));
+
+	outp->index = index;
+	strscpy(outp->name, "loopback in", sizeof(outp->name));
+	outp->type = V4L2_OUTPUT_TYPE_ANALOG;
+	outp->audioset = 0;
+	outp->modulator = 0;
+#ifdef V4L2LOOPBACK_WITH_STD
+	outp->std = V4L2_STD_ALL;
+#ifdef V4L2_OUT_CAP_STD
+	outp->capabilities |= V4L2_OUT_CAP_STD;
+#endif /*  V4L2_OUT_CAP_STD */
+#endif /* V4L2LOOPBACK_WITH_STD */
+
+	return 0;
+}
+
+/* which output is currently active,
+ * called on VIDIOC_G_OUTPUT
+ */
+static int vidioc_g_output(struct file *file, void *fh, unsigned int *index)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
+		return -ENOTTY;
+	if (index)
+		*index = 0;
+	return 0;
+}
+
+/* set output, can make sense if we have more than one video src,
+ * called on VIDIOC_S_OUTPUT
+ */
+static int vidioc_s_output(struct file *file, void *fh, unsigned int index)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_OUTPUT))
+		return -ENOTTY;
+	return index == 0 ? index : -EINVAL;
+}
+
+/* returns set of device inputs, in our case there is only one,
+ * but later I may add more
+ * called on VIDIOC_ENUMINPUT
+ */
+static int vidioc_enum_input(struct file *file, void *fh,
+			     struct v4l2_input *inp)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	__u32 index = inp->index;
+
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY;
+	if (index)
+		return -EINVAL;
+
+	/* clear all data (including the reserved fields) */
+	memset(inp, 0, sizeof(*inp));
+
+	inp->index = index;
+	strscpy(inp->name, "loopback", sizeof(inp->name));
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->audioset = 0;
+	inp->tuner = 0;
+	inp->status = 0;
+
+#ifdef V4L2LOOPBACK_WITH_STD
+	inp->std = V4L2_STD_ALL;
+#ifdef V4L2_IN_CAP_STD
+	inp->capabilities |= V4L2_IN_CAP_STD;
+#endif
+#endif /* V4L2LOOPBACK_WITH_STD */
+
+	if (has_output_token(dev->stream_tokens) && !dev->keep_format)
+		/* if no outputs attached; pretend device is powered off */
+		inp->status |= V4L2_IN_ST_NO_SIGNAL;
+
+	return 0;
+}
+
+/* which input is currently active,
+ * called on VIDIOC_G_INPUT
+ */
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *index)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY; /* NOTE: -EAGAIN might be more informative */
+	if (index)
+		*index = 0;
+	return 0;
+}
+
+/* set input, can make sense if we have more than one video src,
+ * called on VIDIOC_S_INPUT
+ */
+static int vidioc_s_input(struct file *file, void *fh, unsigned int index)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	if (index != 0)
+		return -EINVAL;
+	if (check_buffer_capability(dev, opener, V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -ENOTTY; /* NOTE: -EAGAIN might be more informative */
+	return 0;
+}
+
+/* --------------- V4L2 ioctl buffer related calls ----------------- */
+
+#define is_allocated(opener, type, index)                                \
+	(opener->format_token & (opener->io_method == V4L2L_IO_TIMEOUT ? \
+					 V4L2L_TOKEN_TIMEOUT :           \
+					 token_from_type(type)) &&       \
+	 (index) < (opener)->buffer_count)
+#define BUFFER_DEBUG_FMT_STR                                      \
+	"buffer#%u @ %p type=%u bytesused=%u length=%u flags=%x " \
+	"field=%u timestamp= %lld.%06lldsequence=%u\n"
+#define BUFFER_DEBUG_FMT_ARGS(buf)                                         \
+	(buf)->index, (buf), (buf)->type, (buf)->bytesused, (buf)->length, \
+		(buf)->flags, (buf)->field,                                \
+		(long long)(buf)->timestamp.tv_sec,                        \
+		(long long)(buf)->timestamp.tv_usec, (buf)->sequence
+/* Buffer flag helpers */
+#define unset_flags(flags)                      \
+	do {                                    \
+		flags &= ~V4L2_BUF_FLAG_QUEUED; \
+		flags &= ~V4L2_BUF_FLAG_DONE;   \
+	} while (0)
+#define set_queued(flags)                      \
+	do {                                   \
+		flags |= V4L2_BUF_FLAG_QUEUED; \
+		flags &= ~V4L2_BUF_FLAG_DONE;  \
+	} while (0)
+#define set_done(flags)                         \
+	do {                                    \
+		flags &= ~V4L2_BUF_FLAG_QUEUED; \
+		flags |= V4L2_BUF_FLAG_DONE;    \
+	} while (0)
+
+static bool any_buffers_mapped(struct v4l2_loopback_device *dev)
+{
+	u32 index;
+	for (index = 0; index < dev->buffer_count; ++index)
+		if (dev->buffers[index].buffer.flags & V4L2_BUF_FLAG_MAPPED)
+			return true;
+	return false;
+}
+
+static void prepare_buffer_queue(struct v4l2_loopback_device *dev, int count)
+{
+	struct v4l2l_buffer *bufd, *n;
+	u32 pos;
+
+	spin_lock_bh(&dev->list_lock);
+
+	/* ensure sufficient number of buffers in queue */
+	for (pos = 0; pos < count; ++pos) {
+		bufd = &dev->buffers[pos];
+		if (list_empty(&bufd->list_head))
+			list_add_tail(&bufd->list_head, &dev->outbufs_list);
+	}
+	if (list_empty(&dev->outbufs_list))
+		goto exit_prepare_queue_unlock;
+
+	/* remove any excess buffers */
+	list_for_each_entry_safe(bufd, n, &dev->outbufs_list, list_head) {
+		if (bufd->buffer.index >= count)
+			list_del_init(&bufd->list_head);
+	}
+
+	/* buffers are no longer queued; and `write_position` will correspond
+	 * to the first item of `outbufs_list`. */
+	pos = v4l2l_mod64(dev->write_position, count);
+	list_for_each_entry(bufd, &dev->outbufs_list, list_head) {
+		unset_flags(bufd->buffer.flags);
+		dev->bufpos2index[pos % count] = bufd->buffer.index;
+		++pos;
+	}
+exit_prepare_queue_unlock:
+	spin_unlock_bh(&dev->list_lock);
+}
+
+/* forward declaration */
+static int vidioc_streamoff(struct file *file, void *fh,
+			    enum v4l2_buf_type type);
+/* negotiate buffer type
+ * only mmap streaming supported
+ * called on VIDIOC_REQBUFS
+ */
+static int vidioc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *reqbuf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = opener->io_method == V4L2L_IO_TIMEOUT ?
+			    V4L2L_TOKEN_TIMEOUT :
+			    token_from_type(reqbuf->type);
+	u32 req_count = reqbuf->count;
+	int result = 0;
+
+	dprintk("REQBUFS(memory=%u, req_count=%u) and device-bufs=%u/%u "
+		"[used/max]\n",
+		reqbuf->memory, req_count, dev->used_buffer_count,
+		dev->buffer_count);
+
+	switch (reqbuf->memory) {
+	case V4L2_MEMORY_MMAP:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+		reqbuf->capabilities = 0; /* only guarantee MMAP support */
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+		reqbuf->flags = 0; /* no memory consistency support */
+#endif
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (opener->format_token & ~token)
+		/* different (buffer) type already assigned to descriptor by
+		 * S_FMT or REQBUFS */
+		return -EINVAL;
+
+	MARK();
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result; /* -EINTR */
+
+	/* CASE queue/dequeue timeout-buffer only: */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		opener->buffer_count = req_count;
+		if (req_count == 0)
+			release_token(dev, opener, format);
+		goto exit_reqbufs_unlock;
+	}
+
+	MARK();
+	/* CASE count is zero: streamoff, free buffers, release their token */
+	if (req_count == 0) {
+		if (dev->format_tokens & token) {
+			acquire_token(dev, opener, format, token);
+			opener->io_method = V4L2L_IO_MMAP;
+		}
+		result = vidioc_streamoff(file, fh, reqbuf->type);
+		opener->buffer_count = 0;
+		/* undocumented requirement - REQBUFS with count zero should
+		 * ALSO release lock on logical stream */
+		if (opener->format_token)
+			release_token(dev, opener, format);
+		if (has_no_owners(dev))
+			dev->used_buffer_count = 0;
+		goto exit_reqbufs_unlock;
+	}
+
+	/* CASE count non-zero: allocate buffers and acquire token for them */
+	MARK();
+	switch (reqbuf->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (!(dev->format_tokens & token ||
+		      opener->format_token & token))
+			/* only exclusive ownership for each stream */
+			result = -EBUSY;
+		break;
+	default:
+		result = -EINVAL;
+	}
+	if (result < 0)
+		goto exit_reqbufs_unlock;
+
+	if (has_other_owners(opener, dev) && dev->used_buffer_count > 0) {
+		/* allow 'allocation' of existing number of buffers */
+		req_count = dev->used_buffer_count;
+	} else if (any_buffers_mapped(dev)) {
+		/* do not allow re-allocation if buffers are mapped */
+		result = -EBUSY;
+		goto exit_reqbufs_unlock;
+	}
+
+	MARK();
+	opener->buffer_count = 0;
+
+	if (req_count > dev->buffer_count)
+		req_count = dev->buffer_count;
+
+	if (has_no_owners(dev)) {
+		result = allocate_buffers(dev, &dev->pix_format);
+		if (result < 0)
+			goto exit_reqbufs_unlock;
+	}
+	if (!dev->timeout_image && need_timeout_buffer(dev, token)) {
+		result = allocate_timeout_buffer(dev);
+		if (result < 0)
+			goto exit_reqbufs_unlock;
+	}
+	acquire_token(dev, opener, format, token);
+
+	MARK();
+	switch (opener->io_method) {
+	case V4L2L_IO_TIMEOUT:
+		dev->timeout_image_io = 0;
+		opener->buffer_count = req_count;
+		break;
+	default:
+		opener->io_method = V4L2L_IO_MMAP;
+		prepare_buffer_queue(dev, req_count);
+		dev->used_buffer_count = opener->buffer_count = req_count;
+	}
+exit_reqbufs_unlock:
+	mutex_unlock(&dev->image_mutex);
+	reqbuf->count = opener->buffer_count;
+	return result;
+}
+
+/* returns buffer asked for;
+ * give app as many buffers as it wants, if it less than MAX,
+ * but map them in our inner buffers
+ * called on VIDIOC_QUERYBUF
+ */
+static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 type = buf->type;
+	u32 index = buf->index;
+
+	if ((type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
+	    (type != V4L2_BUF_TYPE_VIDEO_OUTPUT))
+		return -EINVAL;
+	if (!is_allocated(opener, type, index))
+		return -EINVAL;
+
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		*buf = dev->timeout_buffer.buffer;
+		buf->index = index;
+	} else
+		*buf = dev->buffers[index].buffer;
+
+	buf->type = type;
+
+	if (!(buf->flags & (V4L2_BUF_FLAG_DONE | V4L2_BUF_FLAG_QUEUED))) {
+		/* v4l2-compliance requires these to be zero */
+		buf->sequence = 0;
+		buf->timestamp.tv_sec = buf->timestamp.tv_usec = 0;
+	} else if (V4L2_TYPE_IS_CAPTURE(type)) {
+		/* guess flags based on sequence values */
+		if (buf->sequence >= opener->read_position) {
+			set_done(buf->flags);
+		} else if (buf->flags & V4L2_BUF_FLAG_DONE) {
+			set_queued(buf->flags);
+		}
+	}
+	dprintkrw("QUERYBUF(%s, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+		  V4L2_TYPE_IS_CAPTURE(type) ? "CAPTURE" : "OUTPUT", index,
+		  BUFFER_DEBUG_FMT_ARGS(buf));
+	return 0;
+}
+
+static void buffer_written(struct v4l2_loopback_device *dev,
+			   struct v4l2l_buffer *buf)
+{
+	timer_delete_sync(&dev->sustain_timer);
+	timer_delete_sync(&dev->timeout_timer);
+
+	spin_lock_bh(&dev->list_lock);
+	list_move_tail(&buf->list_head, &dev->outbufs_list);
+	spin_unlock_bh(&dev->list_lock);
+
+	spin_lock_bh(&dev->lock);
+	dev->bufpos2index[v4l2l_mod64(dev->write_position,
+				      dev->used_buffer_count)] =
+		buf->buffer.index;
+	++dev->write_position;
+	dev->reread_count = 0;
+
+	check_timers(dev);
+	spin_unlock_bh(&dev->lock);
+}
+
+/* put buffer to queue
+ * called on VIDIOC_QBUF
+ */
+static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	struct v4l2l_buffer *bufd;
+	u32 index = buf->index;
+	u32 type = buf->type;
+
+	if (!is_allocated(opener, type, index))
+		return -EINVAL;
+	bufd = &dev->buffers[index];
+
+	switch (buf->memory) {
+	case V4L2_MEMORY_MMAP:
+		if (!(bufd->buffer.flags & V4L2_BUF_FLAG_MAPPED))
+			dprintkrw("QBUF() unmapped buffer [index=%u]\n", index);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		set_queued(buf->flags);
+		return 0;
+	}
+
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		dprintkrw("QBUF(CAPTURE, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+			  index, BUFFER_DEBUG_FMT_ARGS(buf));
+		set_queued(buf->flags);
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		dprintkrw("QBUF(OUTPUT, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+			  index, BUFFER_DEBUG_FMT_ARGS(buf));
+		if (!(bufd->buffer.flags & V4L2_BUF_FLAG_TIMESTAMP_COPY) &&
+		    (buf->timestamp.tv_sec == 0 &&
+		     buf->timestamp.tv_usec == 0)) {
+			v4l2l_get_timestamp(&bufd->buffer);
+		} else {
+			bufd->buffer.timestamp = buf->timestamp;
+			bufd->buffer.flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+			bufd->buffer.flags &=
+				~V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+		}
+		if (dev->pix_format_has_valid_sizeimage) {
+			if (buf->bytesused >= dev->pix_format.sizeimage) {
+				bufd->buffer.bytesused =
+					dev->pix_format.sizeimage;
+			} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+				dev_warn_ratelimited(
+					&dev->vdev->dev,
+#else
+				dprintkrw(
+#endif
+					"warning queued output buffer bytesused too small %u < %u\n",
+					buf->bytesused,
+					dev->pix_format.sizeimage);
+				bufd->buffer.bytesused = buf->bytesused;
+			}
+		} else {
+			bufd->buffer.bytesused = buf->bytesused;
+		}
+		bufd->buffer.sequence = dev->write_position;
+		set_queued(bufd->buffer.flags);
+		*buf = bufd->buffer;
+		buffer_written(dev, bufd);
+		set_done(bufd->buffer.flags);
+		wake_up_all(&dev->read_event);
+		break;
+	default:
+		return -EINVAL;
+	}
+	buf->type = type;
+	return 0;
+}
+
+static int can_read(struct v4l2_loopback_device *dev,
+		    struct v4l2_loopback_opener *opener)
+{
+	int ret;
+
+	spin_lock_bh(&dev->lock);
+	check_timers(dev);
+	ret = dev->write_position > opener->read_position ||
+	      dev->reread_count > opener->reread_count || dev->timeout_happened;
+	spin_unlock_bh(&dev->lock);
+	return ret;
+}
+
+static int get_capture_buffer(struct file *file)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
+	int pos, timeout_happened;
+	u32 index;
+
+	if ((file->f_flags & O_NONBLOCK) &&
+	    (dev->write_position <= opener->read_position &&
+	     dev->reread_count <= opener->reread_count &&
+	     !dev->timeout_happened))
+		return -EAGAIN;
+	wait_event_interruptible(dev->read_event, can_read(dev, opener));
+
+	spin_lock_bh(&dev->lock);
+	if (dev->write_position == opener->read_position) {
+		if (dev->reread_count > opener->reread_count + 2)
+			opener->reread_count = dev->reread_count - 1;
+		++opener->reread_count;
+		pos = v4l2l_mod64(opener->read_position +
+					  dev->used_buffer_count - 1,
+				  dev->used_buffer_count);
+	} else {
+		opener->reread_count = 0;
+		if (dev->write_position >
+		    opener->read_position + dev->used_buffer_count)
+			opener->read_position = dev->write_position - 1;
+		pos = v4l2l_mod64(opener->read_position,
+				  dev->used_buffer_count);
+		++opener->read_position;
+	}
+	timeout_happened = dev->timeout_happened && (dev->timeout_jiffies > 0);
+	dev->timeout_happened = 0;
+	spin_unlock_bh(&dev->lock);
+
+	index = dev->bufpos2index[pos];
+	if (timeout_happened) {
+		if (index >= dev->used_buffer_count) {
+			dprintkrw("get_capture_buffer() read position is at "
+				  "an unallocated buffer [index=%u]\n",
+				  index);
+			return -EFAULT;
+		}
+		/* although allocated on-demand, timeout_image is freed only
+		 * in free_buffers(), so we don't need to worry about it being
+		 * deallocated suddenly */
+		memcpy(dev->image + dev->buffers[index].buffer.m.offset,
+		       dev->timeout_image, dev->buffer_size);
+	}
+	return (int)index;
+}
+
+/* put buffer to dequeue
+ * called on VIDIOC_DQBUF
+ */
+static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 type = buf->type;
+	int index;
+	struct v4l2l_buffer *bufd;
+
+	if (buf->memory != V4L2_MEMORY_MMAP)
+		return -EINVAL;
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT) {
+		*buf = dev->timeout_buffer.buffer;
+		buf->type = type;
+		unset_flags(buf->flags);
+		return 0;
+	}
+	if ((opener->buffer_count == 0) ||
+	    !(opener->format_token & token_from_type(type)))
+		return -EINVAL;
+
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		index = get_capture_buffer(file);
+		if (index < 0)
+			return index;
+		*buf = dev->buffers[index].buffer;
+		unset_flags(buf->flags);
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		spin_lock_bh(&dev->list_lock);
+
+		bufd = list_first_entry_or_null(&dev->outbufs_list,
+						struct v4l2l_buffer, list_head);
+		if (bufd)
+			list_move_tail(&bufd->list_head, &dev->outbufs_list);
+
+		spin_unlock_bh(&dev->list_lock);
+		if (!bufd)
+			return -EFAULT;
+		unset_flags(bufd->buffer.flags);
+		*buf = bufd->buffer;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	buf->type = type;
+	dprintkrw("DQBUF(%s, index=%u) -> " BUFFER_DEBUG_FMT_STR,
+		  V4L2_TYPE_IS_CAPTURE(type) ? "CAPTURE" : "OUTPUT", index,
+		  BUFFER_DEBUG_FMT_ARGS(buf));
+	return 0;
+}
+
+/* ------------- STREAMING ------------------- */
+
+/* start streaming
+ * called on VIDIOC_STREAMON
+ */
+static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = token_from_type(type);
+
+	/* short-circuit when using timeout buffer set */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT)
+		return 0;
+	/* opener must have claimed (same) buffer set via REQBUFS */
+	if (!opener->buffer_count || !(opener->format_token & token))
+		return -EINVAL;
+
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (has_output_token(dev->stream_tokens) && !dev->keep_format)
+			return -EIO;
+		if (dev->stream_tokens & token) {
+			acquire_token(dev, opener, stream, token);
+			client_usage_queue_event(dev->vdev);
+		}
+		return 0;
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (dev->stream_tokens & token)
+			acquire_token(dev, opener, stream, token);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/* stop streaming
+ * called on VIDIOC_STREAMOFF
+ */
+static int vidioc_streamoff(struct file *file, void *fh,
+			    enum v4l2_buf_type type)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	u32 token = token_from_type(type);
+
+	/* short-circuit when using timeout buffer set */
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT)
+		return 0;
+	/* short-circuit when buffer set has no owner */
+	if (dev->format_tokens & token)
+		return 0;
+	/* opener needs a claim to buffer set */
+	if (!opener->format_token)
+		return -EBUSY;
+	if (opener->format_token & ~token)
+		return -EINVAL;
+
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+		if (opener->stream_token & token)
+			release_token(dev, opener, stream);
+		/* reset output queue */
+		if (dev->used_buffer_count > 0)
+			prepare_buffer_queue(dev, dev->used_buffer_count);
+		return 0;
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (opener->stream_token & token) {
+			release_token(dev, opener, stream);
+			client_usage_queue_event(dev->vdev);
+		}
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf(struct file *file, void *fh, struct video_mbuf *p)
+{
+	struct v4l2_loopback_device *dev;
+	MARK();
+
+	dev = v4l2loopback_getdevice(file);
+	p->frames = dev->buffer_count;
+	p->offsets[0] = 0;
+	p->offsets[1] = 0;
+	p->size = dev->buffer_size;
+	return 0;
+}
+#endif
+
+static void client_usage_queue_event(struct video_device *vdev)
+{
+	struct v4l2_event ev;
+	struct v4l2_loopback_device *dev;
+
+	dev = container_of(vdev->v4l2_dev, struct v4l2_loopback_device,
+			   v4l2_dev);
+
+	memset(&ev, 0, sizeof(ev));
+	ev.type = V4L2_EVENT_PRI_CLIENT_USAGE;
+	((struct v4l2_event_client_usage *)&ev.u)->count =
+		!has_capture_token(dev->stream_tokens);
+
+	v4l2_event_queue(vdev, &ev);
+}
+
+static int client_usage_ops_add(struct v4l2_subscribed_event *sev,
+				unsigned elems)
+{
+	if (!(sev->flags & V4L2_EVENT_SUB_FL_SEND_INITIAL))
+		return 0;
+
+	client_usage_queue_event(sev->fh->vdev);
+	return 0;
+}
+
+static void client_usage_ops_replace(struct v4l2_event *old,
+				     const struct v4l2_event *new)
+{
+	*((struct v4l2_event_client_usage *)&old->u) =
+		*((struct v4l2_event_client_usage *)&new->u);
+}
+
+static void client_usage_ops_merge(const struct v4l2_event *old,
+				   struct v4l2_event *new)
+{
+	*((struct v4l2_event_client_usage *)&new->u) =
+		*((struct v4l2_event_client_usage *)&old->u);
+}
+
+const struct v4l2_subscribed_event_ops client_usage_ops = {
+	.add = client_usage_ops_add,
+	.replace = client_usage_ops_replace,
+	.merge = client_usage_ops_merge,
+};
+
+static int vidioc_subscribe_event(struct v4l2_fh *fh,
+				  const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	case V4L2_EVENT_PRI_CLIENT_USAGE:
+		return v4l2_event_subscribe(fh, sub, 0, &client_usage_ops);
+	}
+
+	return -EINVAL;
+}
+
+/* file operations */
+static void vm_open(struct vm_area_struct *vma)
+{
+	struct v4l2l_buffer *buf;
+	MARK();
+
+	buf = vma->vm_private_data;
+	atomic_inc(&buf->use_count);
+	buf->buffer.flags |= V4L2_BUF_FLAG_MAPPED;
+}
+
+static void vm_close(struct vm_area_struct *vma)
+{
+	struct v4l2l_buffer *buf;
+	MARK();
+
+	buf = vma->vm_private_data;
+	if (atomic_dec_and_test(&buf->use_count))
+		buf->buffer.flags &= ~V4L2_BUF_FLAG_MAPPED;
+}
+
+static struct vm_operations_struct vm_ops = {
+	.open = vm_open,
+	.close = vm_close,
+};
+
+static int v4l2_loopback_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	u8 *addr;
+	unsigned long start, size, offset;
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
+	struct v4l2l_buffer *buffer = NULL;
+	int result = 0;
+	MARK();
+
+	offset = (unsigned long)vma->vm_pgoff << PAGE_SHIFT;
+	start = (unsigned long)vma->vm_start;
+	size = (unsigned long)(vma->vm_end - vma->vm_start); /* always != 0 */
+
+	/* ensure buffer size, count, and allocated image(s) are not altered by
+	 * other file descriptors */
+	result = mutex_lock_killable(&dev->image_mutex);
+	if (result < 0)
+		return result;
+
+	if (size > dev->buffer_size) {
+		dprintk("mmap() attempt to map %lubytes when %ubytes are "
+			"allocated to buffers\n",
+			size, dev->buffer_size);
+		result = -EINVAL;
+		goto exit_mmap_unlock;
+	}
+	if (offset % dev->buffer_size != 0) {
+		dprintk("mmap() offset does not match start of any buffer\n");
+		result = -EINVAL;
+		goto exit_mmap_unlock;
+	}
+	switch (opener->format_token) {
+	case V4L2L_TOKEN_TIMEOUT:
+		if (offset != (unsigned long)dev->buffer_size * MAX_BUFFERS) {
+			dprintk("mmap() incorrect offset for timeout image\n");
+			result = -EINVAL;
+			goto exit_mmap_unlock;
+		}
+		buffer = &dev->timeout_buffer;
+		addr = dev->timeout_image;
+		break;
+	default:
+		if (offset >= dev->image_size) {
+			dprintk("mmap() attempt to map beyond all buffers\n");
+			result = -EINVAL;
+			goto exit_mmap_unlock;
+		}
+		u32 index = offset / dev->buffer_size;
+		buffer = &dev->buffers[index];
+		addr = dev->image + offset;
+		break;
+	}
+
+	while (size > 0) {
+		struct page *page = vmalloc_to_page(addr);
+
+		result = vm_insert_page(vma, start, page);
+		if (result < 0)
+			goto exit_mmap_unlock;
+
+		start += PAGE_SIZE;
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	vma->vm_ops = &vm_ops;
+	vma->vm_private_data = buffer;
+
+	vm_open(vma);
+exit_mmap_unlock:
+	mutex_unlock(&dev->image_mutex);
+	return result;
+}
+
+static unsigned int v4l2_loopback_poll(struct file *file,
+				       struct poll_table_struct *pts)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
+	__poll_t req_events = poll_requested_events(pts);
+	int ret_mask = 0;
+
+	/* call poll_wait in first call, regardless, to ensure that the
+	 * wait-queue is not null */
+	poll_wait(file, &dev->read_event, pts);
+	poll_wait(file, &opener->fh.wait, pts);
+
+	if (req_events & POLLPRI) {
+		if (v4l2_event_pending(&opener->fh)) {
+			ret_mask |= POLLPRI;
+			if (!(req_events & DEFAULT_POLLMASK))
+				return ret_mask;
+		}
+	}
+
+	switch (opener->format_token) {
+	case V4L2L_TOKEN_OUTPUT:
+		if (opener->stream_token != 0 ||
+		    opener->io_method == V4L2L_IO_NONE)
+			ret_mask |= POLLOUT | POLLWRNORM;
+		break;
+	case V4L2L_TOKEN_CAPTURE:
+		if ((opener->io_method == V4L2L_IO_NONE ||
+		     opener->stream_token != 0) &&
+		    can_read(dev, opener))
+			ret_mask |= POLLIN | POLLWRNORM;
+		break;
+	case V4L2L_TOKEN_TIMEOUT:
+		ret_mask |= POLLOUT | POLLWRNORM;
+		break;
+	default:
+		break;
+	}
+
+	return ret_mask;
+}
+
+/* do not want to limit device opens, it can be as many readers as user want,
+ * writers are limited by means of setting writer field */
+static int v4l2_loopback_open(struct file *file)
+{
+	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_opener *opener;
+
+	dev = v4l2loopback_getdevice(file);
+	if (dev->open_count.counter >= dev->max_openers)
+		return -EBUSY;
+	/* kfree on close */
+	opener = kzalloc(sizeof(*opener), GFP_KERNEL);
+	if (opener == NULL)
+		return -ENOMEM;
+
+	atomic_inc(&dev->open_count);
+	if (dev->timeout_image_io && dev->format_tokens & V4L2L_TOKEN_TIMEOUT)
+		/* will clear timeout_image_io once buffer set acquired */
+		opener->io_method = V4L2L_IO_TIMEOUT;
+
+	v4l2_fh_init(&opener->fh, video_devdata(file));
+	file->private_data = &opener->fh;
+
+	v4l2_fh_add(&opener->fh);
+	dprintk("open() -> dev@%p with image@%p\n", dev,
+		dev ? dev->image : NULL);
+	return 0;
+}
+
+static int v4l2_loopback_close(struct file *file)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(file->private_data);
+	int result = 0;
+	dprintk("close() -> dev@%p with image@%p\n", dev,
+		dev ? dev->image : NULL);
+
+	if (opener->format_token) {
+		struct v4l2_requestbuffers reqbuf = {
+			.count = 0, .memory = V4L2_MEMORY_MMAP, .type = 0
+		};
+		switch (opener->format_token) {
+		case V4L2L_TOKEN_CAPTURE:
+			reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			break;
+		case V4L2L_TOKEN_OUTPUT:
+		case V4L2L_TOKEN_TIMEOUT:
+			reqbuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			break;
+		}
+		if (reqbuf.type)
+			result = vidioc_reqbufs(file, file->private_data,
+						&reqbuf);
+		if (result < 0)
+			dprintk("failed to free buffers REQBUFS(count=0) "
+				" returned %d\n",
+				result);
+		mutex_lock(&dev->image_mutex);
+		release_token(dev, opener, format);
+		mutex_unlock(&dev->image_mutex);
+	}
+
+	if (atomic_dec_and_test(&dev->open_count)) {
+		timer_delete_sync(&dev->sustain_timer);
+		timer_delete_sync(&dev->timeout_timer);
+		if (!dev->keep_format) {
+			mutex_lock(&dev->image_mutex);
+			free_buffers(dev);
+			mutex_unlock(&dev->image_mutex);
+		}
+	}
+
+	v4l2_fh_del(&opener->fh);
+	v4l2_fh_exit(&opener->fh);
+
+	kfree(opener);
+	return 0;
+}
+
+static int start_fileio(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_loopback_opener *opener = fh_to_opener(fh);
+	struct v4l2_requestbuffers reqbuf = { .count = dev->buffer_count,
+					      .memory = V4L2_MEMORY_MMAP,
+					      .type = type };
+	int token = token_from_type(type);
+	int result;
+
+	if (opener->format_token & V4L2L_TOKEN_TIMEOUT ||
+	    opener->format_token & ~token)
+		return -EBUSY; /* NOTE: -EBADF might be more informative */
+
+	/* short-circuit if already have stream token */
+	if (opener->stream_token && opener->io_method == V4L2L_IO_FILE)
+		return 0;
+
+	/* otherwise attempt to acquire stream token and assign IO method */
+	if (!(dev->stream_tokens & token) || opener->io_method != V4L2L_IO_NONE)
+		return -EBUSY;
+
+	result = vidioc_reqbufs(file, fh, &reqbuf);
+	if (result < 0)
+		return result;
+	result = vidioc_streamon(file, fh, type);
+	if (result < 0)
+		return result;
+
+	opener->io_method = V4L2L_IO_FILE;
+	return 0;
+}
+
+static ssize_t v4l2_loopback_read(struct file *file, char __user *buf,
+				  size_t count, loff_t *ppos)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_buffer *b;
+	int index, result;
+
+	dprintkrw("read() %zu bytes\n", count);
+	result = start_fileio(file, file->private_data,
+			      V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	if (result < 0)
+		return result;
+
+	index = get_capture_buffer(file);
+	if (index < 0)
+		return index;
+	b = &dev->buffers[index].buffer;
+	if (count > b->bytesused)
+		count = b->bytesused;
+	if (copy_to_user((void *)buf, (void *)(dev->image + b->m.offset),
+			 count)) {
+		printk(KERN_ERR "v4l2-loopback read() failed copy_to_user()\n");
+		return -EFAULT;
+	}
+	return count;
+}
+
+static ssize_t v4l2_loopback_write(struct file *file, const char __user *buf,
+				   size_t count, loff_t *ppos)
+{
+	struct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);
+	struct v4l2_buffer *b;
+	int index, result;
+
+	dprintkrw("write() %zu bytes\n", count);
+	result = start_fileio(file, file->private_data,
+			      V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	if (result < 0)
+		return result;
+
+	if (count > dev->buffer_size)
+		count = dev->buffer_size;
+	index = v4l2l_mod64(dev->write_position, dev->used_buffer_count);
+	b = &dev->buffers[index].buffer;
+
+	if (copy_from_user((void *)(dev->image + b->m.offset), (void *)buf,
+			   count)) {
+		printk(KERN_ERR
+		       "v4l2-loopback write() failed copy_from_user()\n");
+		return -EFAULT;
+	}
+	b->bytesused = count;
+
+	v4l2l_get_timestamp(b);
+	b->sequence = dev->write_position;
+	set_queued(b->flags);
+	buffer_written(dev, &dev->buffers[index]);
+	set_done(b->flags);
+	wake_up_all(&dev->read_event);
+
+	return count;
+}
+
+/* init functions */
+/* frees buffers, if allocated */
+static void free_buffers(struct v4l2_loopback_device *dev)
+{
+	dprintk("free_buffers() with image@%p\n", dev->image);
+	if (!dev->image)
+		return;
+	if (!has_no_owners(dev) || any_buffers_mapped(dev))
+		/* maybe an opener snuck in before image_mutex was acquired */
+		printk(KERN_WARNING
+		       "v4l2-loopback free_buffers() buffers of video device "
+		       "#%u freed while still mapped to userspace\n",
+		       dev->vdev->num);
+	vfree(dev->image);
+	dev->image = NULL;
+	dev->image_size = 0;
+	dev->buffer_size = 0;
+}
+
+static void free_timeout_buffer(struct v4l2_loopback_device *dev)
+{
+	dprintk("free_timeout_buffer() with timeout_image@%p\n",
+		dev->timeout_image);
+	if (!dev->timeout_image)
+		return;
+
+	if ((dev->timeout_jiffies > 0 && !has_no_owners(dev)) ||
+	    dev->timeout_buffer.buffer.flags & V4L2_BUF_FLAG_MAPPED)
+		printk(KERN_WARNING
+		       "v4l2-loopback free_timeout_buffer() timeout image "
+		       "of device #%u freed while still mapped to userspace\n",
+		       dev->vdev->num);
+
+	vfree(dev->timeout_image);
+	dev->timeout_image = NULL;
+	dev->timeout_buffer_size = 0;
+}
+/* allocates buffers if no (other) openers are already using them */
+static int allocate_buffers(struct v4l2_loopback_device *dev,
+			    struct v4l2_pix_format *pix_format)
+{
+	u32 buffer_size = PAGE_ALIGN(pix_format->sizeimage);
+	unsigned long image_size =
+		(unsigned long)buffer_size * (unsigned long)dev->buffer_count;
+	/* vfree on close file operation in case no open handles left */
+
+	if (buffer_size == 0 || dev->buffer_count == 0 ||
+	    buffer_size < pix_format->sizeimage)
+		return -EINVAL;
+
+	if ((__LONG_MAX__ / buffer_size) < dev->buffer_count)
+		return -ENOSPC;
+
+	dprintk("allocate_buffers() size %lubytes = %ubytes x %ubuffers\n",
+		image_size, buffer_size, dev->buffer_count);
+	if (dev->image) {
+		/* check that no buffers are expected in user-space */
+		if (!has_no_owners(dev) || any_buffers_mapped(dev))
+			return -EBUSY;
+		dprintk("allocate_buffers() existing size=%lubytes\n",
+			dev->image_size);
+		/* FIXME: prevent double allocation more intelligently! */
+		if (image_size == dev->image_size) {
+			dprintk("allocate_buffers() keep existing\n");
+			return 0;
+		}
+		free_buffers(dev);
+	}
+
+	/* FIXME: set buffers to 0 */
+	dev->image = vmalloc(image_size);
+	if (dev->image == NULL) {
+		dev->buffer_size = dev->image_size = 0;
+		return -ENOMEM;
+	}
+	init_buffers(dev, pix_format->sizeimage, buffer_size);
+	dev->buffer_size = buffer_size;
+	dev->image_size = image_size;
+	dprintk("allocate_buffers() -> vmalloc'd %lubytes\n", dev->image_size);
+	return 0;
+}
+static int allocate_timeout_buffer(struct v4l2_loopback_device *dev)
+{
+	/* device's `buffer_size` and `buffers` must be initialised in
+	 * allocate_buffers() */
+
+	dprintk("allocate_timeout_buffer() size %ubytes\n", dev->buffer_size);
+	if (dev->buffer_size == 0)
+		return -EINVAL;
+
+	if (dev->timeout_image) {
+		if (dev->timeout_buffer.buffer.flags & V4L2_BUF_FLAG_MAPPED)
+			return -EBUSY;
+		if (dev->buffer_size == dev->timeout_buffer_size)
+			return 0;
+		free_timeout_buffer(dev);
+	}
+
+	dev->timeout_image = vzalloc(dev->buffer_size);
+	if (!dev->timeout_image) {
+		dev->timeout_buffer_size = 0;
+		return -ENOMEM;
+	}
+	dev->timeout_buffer_size = dev->buffer_size;
+	return 0;
+}
+/* init inner buffers, they are capture mode and flags are set as for capture
+ * mode buffers */
+static void init_buffers(struct v4l2_loopback_device *dev, u32 bytes_used,
+			 u32 buffer_size)
+{
+	u32 i;
+
+	for (i = 0; i < dev->buffer_count; ++i) {
+		struct v4l2_buffer *b = &dev->buffers[i].buffer;
+		b->index = i;
+		b->bytesused = bytes_used;
+		b->length = buffer_size;
+		b->field = V4L2_FIELD_NONE;
+		b->flags = 0;
+		b->m.offset = i * buffer_size;
+		b->memory = V4L2_MEMORY_MMAP;
+		b->sequence = 0;
+		b->timestamp.tv_sec = 0;
+		b->timestamp.tv_usec = 0;
+		b->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+		v4l2l_get_timestamp(b);
+	}
+	dev->timeout_buffer = dev->buffers[0];
+	dev->timeout_buffer.buffer.m.offset = MAX_BUFFERS * buffer_size;
+}
+
+/* fills and register video device */
+static void init_vdev(struct video_device *vdev, int nr)
+{
+#ifdef V4L2LOOPBACK_WITH_STD
+	vdev->tvnorms = V4L2_STD_ALL;
+#endif /* V4L2LOOPBACK_WITH_STD */
+
+	vdev->vfl_type = VFL_TYPE_VIDEO;
+	vdev->fops = &v4l2_loopback_fops;
+	vdev->ioctl_ops = &v4l2_loopback_ioctl_ops;
+	vdev->release = &video_device_release;
+	vdev->minor = -1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	vdev->device_caps = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_VIDEO_CAPTURE |
+			    V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_READWRITE |
+			    V4L2_CAP_STREAMING;
+#endif
+
+	if (debug > 1)
+		vdev->dev_debug = V4L2_DEV_DEBUG_IOCTL |
+				  V4L2_DEV_DEBUG_IOCTL_ARG;
+
+	vdev->vfl_dir = VFL_DIR_M2M;
+}
+
+/* init default capture parameters, only fps may be changed in future */
+static void init_capture_param(struct v4l2_captureparm *capture_param)
+{
+	capture_param->capability = V4L2_CAP_TIMEPERFRAME; /* since 2.16 */
+	capture_param->capturemode = 0;
+	capture_param->extendedmode = 0;
+	capture_param->readbuffers = max_buffers;
+	capture_param->timeperframe.numerator = 1;
+	capture_param->timeperframe.denominator = V4L2LOOPBACK_FPS_DEFAULT;
+}
+
+static void check_timers(struct v4l2_loopback_device *dev)
+{
+	if (has_output_token(dev->stream_tokens))
+		return;
+
+	if (dev->timeout_jiffies > 0 && !timer_pending(&dev->timeout_timer))
+		mod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);
+	if (dev->sustain_framerate && !timer_pending(&dev->sustain_timer))
+		mod_timer(&dev->sustain_timer,
+			  jiffies + dev->frame_jiffies * 3 / 2);
+}
+#ifdef HAVE_TIMER_SETUP
+static void sustain_timer_clb(struct timer_list *t)
+{
+	struct v4l2_loopback_device *dev =
+		container_of(t, struct v4l2_loopback_device, sustain_timer);
+#else
+static void sustain_timer_clb(unsigned long nr)
+{
+	struct v4l2_loopback_device *dev =
+		idr_find(&v4l2loopback_index_idr, nr);
+#endif
+	spin_lock(&dev->lock);
+	if (dev->sustain_framerate) {
+		dev->reread_count++;
+		dprintkrw("sustain_timer_clb() write_pos=%lld reread=%u\n",
+			  (long long)dev->write_position, dev->reread_count);
+		if (dev->reread_count == 1)
+			mod_timer(&dev->sustain_timer,
+				  jiffies + max(1UL, dev->frame_jiffies / 2));
+		else
+			mod_timer(&dev->sustain_timer,
+				  jiffies + dev->frame_jiffies);
+		wake_up_all(&dev->read_event);
+	}
+	spin_unlock(&dev->lock);
+}
+#ifdef HAVE_TIMER_SETUP
+static void timeout_timer_clb(struct timer_list *t)
+{
+	struct v4l2_loopback_device *dev =
+		container_of(t, struct v4l2_loopback_device, timeout_timer);
+#else
+static void timeout_timer_clb(unsigned long nr)
+{
+	struct v4l2_loopback_device *dev =
+		idr_find(&v4l2loopback_index_idr, nr);
+#endif
+	spin_lock(&dev->lock);
+	if (dev->timeout_jiffies > 0) {
+		dev->timeout_happened = 1;
+		mod_timer(&dev->timeout_timer, jiffies + dev->timeout_jiffies);
+		wake_up_all(&dev->read_event);
+	}
+	spin_unlock(&dev->lock);
+}
+
+/* init loopback main structure */
+#define DEFAULT_FROM_CONF(confmember, default_condition, default_value)        \
+	((conf) ?                                                              \
+		 ((conf->confmember default_condition) ? (default_value) :     \
+							 (conf->confmember)) : \
+		 default_value)
+
+static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)
+{
+	struct v4l2_loopback_device *dev;
+	struct v4l2_ctrl_handler *hdl;
+	struct v4l2loopback_private *vdev_priv = NULL;
+	int err;
+
+	u32 _width = V4L2LOOPBACK_SIZE_DEFAULT_WIDTH;
+	u32 _height = V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT;
+
+	u32 _min_width = DEFAULT_FROM_CONF(min_width,
+					   < V4L2LOOPBACK_SIZE_MIN_WIDTH,
+					   V4L2LOOPBACK_SIZE_MIN_WIDTH);
+	u32 _min_height = DEFAULT_FROM_CONF(min_height,
+					    < V4L2LOOPBACK_SIZE_MIN_HEIGHT,
+					    V4L2LOOPBACK_SIZE_MIN_HEIGHT);
+	u32 _max_width = DEFAULT_FROM_CONF(max_width, < _min_width, max_width);
+	u32 _max_height =
+		DEFAULT_FROM_CONF(max_height, < _min_height, max_height);
+	bool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?
+					  (bool)(conf->announce_all_caps) :
+					  !(V4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS);
+	int _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);
+	int _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);
+	struct v4l2_format _fmt;
+
+	int nr = -1;
+
+	if (conf) {
+		const int output_nr = conf->output_nr;
+#ifdef SPLIT_DEVICES
+		const int capture_nr = conf->capture_nr;
+#else
+		const int capture_nr = output_nr;
+#endif
+		if (capture_nr >= 0 && output_nr == capture_nr) {
+			nr = output_nr;
+		} else if (capture_nr < 0 && output_nr < 0) {
+			nr = -1;
+		} else if (capture_nr < 0) {
+			nr = output_nr;
+		} else if (output_nr < 0) {
+			nr = capture_nr;
+		} else {
+			printk(KERN_ERR
+			       "v4l2-loopback add() split OUTPUT and CAPTURE "
+			       "devices not yet supported.\n");
+			printk(KERN_INFO
+			       "v4l2-loopback add() both devices must have the "
+			       "same number (%d != %d).\n",
+			       output_nr, capture_nr);
+			return -EINVAL;
+		}
+	}
+
+	if (idr_find(&v4l2loopback_index_idr, nr))
+		return -EEXIST;
+
+	/* initialisation of a new device */
+	dprintk("add() creating device #%d\n", nr);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	/* allocate id, if @id >= 0, we're requesting that specific id */
+	if (nr >= 0) {
+		err = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,
+				GFP_KERNEL);
+		if (err == -ENOSPC)
+			err = -EEXIST;
+	} else {
+		err = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);
+	}
+	if (err < 0)
+		goto out_free_dev;
+
+	/* register new device */
+	MARK();
+	nr = err;
+
+	if (conf && conf->card_label[0]) {
+		snprintf(dev->card_label, sizeof(dev->card_label), "%s",
+			 conf->card_label);
+	} else {
+		snprintf(dev->card_label, sizeof(dev->card_label),
+			 "Dummy video device (0x%04X)", nr);
+	}
+	snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
+		 "v4l2loopback-%03d", nr);
+
+	err = v4l2_device_register(NULL, &dev->v4l2_dev);
+	if (err)
+		goto out_free_idr;
+
+	/* initialise the _video_ device */
+	MARK();
+	err = -ENOMEM;
+	dev->vdev = video_device_alloc();
+	if (dev->vdev == NULL)
+		goto out_unregister;
+
+	vdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);
+	if (vdev_priv == NULL)
+		goto out_unregister;
+
+	video_set_drvdata(dev->vdev, vdev_priv);
+	if (video_get_drvdata(dev->vdev) == NULL)
+		goto out_unregister;
+
+	snprintf(dev->vdev->name, sizeof(dev->vdev->name), "%s",
+		 dev->card_label);
+	vdev_priv->device_nr = nr;
+	init_vdev(dev->vdev, nr);
+	dev->vdev->v4l2_dev = &dev->v4l2_dev;
+
+	/* initialise v4l2-loopback specific parameters */
+	MARK();
+	dev->announce_all_caps = _announce_all_caps;
+	dev->min_width = _min_width;
+	dev->min_height = _min_height;
+	dev->max_width = _max_width;
+	dev->max_height = _max_height;
+	dev->max_openers = _max_openers;
+
+	/* set (initial) pixel and stream format */
+	_width = clamp_val(_width, _min_width, _max_width);
+	_height = clamp_val(_height, _min_height, _max_height);
+	_fmt = (struct v4l2_format){
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.fmt.pix = { .width = _width,
+			     .height = _height,
+			     .pixelformat = formats[0].fourcc,
+			     .colorspace = V4L2_COLORSPACE_DEFAULT,
+			     .field = V4L2_FIELD_NONE }
+	};
+
+	err = v4l2l_fill_format(&_fmt, _min_width, _max_width, _min_height,
+				_max_height);
+	if (err)
+		/* highly unexpected failure to assign default format */
+		goto out_unregister;
+	dev->pix_format = _fmt.fmt.pix;
+	init_capture_param(&dev->capture_param);
+	set_timeperframe(dev, &dev->capture_param.timeperframe);
+
+	/* ctrls parameters */
+	dev->keep_format = 0;
+	dev->sustain_framerate = 0;
+	dev->timeout_jiffies = 0;
+	dev->timeout_image_io = 0;
+
+	/* initialise OUTPUT and CAPTURE buffer values */
+	dev->image = NULL;
+	dev->image_size = 0;
+	dev->buffer_count = _max_buffers;
+	dev->buffer_size = 0;
+	dev->used_buffer_count = 0;
+	INIT_LIST_HEAD(&dev->outbufs_list);
+	do {
+		u32 index;
+		for (index = 0; index < dev->buffer_count; ++index)
+			INIT_LIST_HEAD(&dev->buffers[index].list_head);
+
+	} while (0);
+	memset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));
+	dev->write_position = 0;
+
+	/* initialise synchronisation data */
+	atomic_set(&dev->open_count, 0);
+	mutex_init(&dev->image_mutex);
+	spin_lock_init(&dev->lock);
+	spin_lock_init(&dev->list_lock);
+	init_waitqueue_head(&dev->read_event);
+	dev->format_tokens = V4L2L_TOKEN_MASK;
+	dev->stream_tokens = V4L2L_TOKEN_MASK;
+
+	/* initialise sustain frame rate and timeout parameters, and timers */
+	dev->reread_count = 0;
+	dev->timeout_image = NULL;
+	dev->timeout_happened = 0;
+#ifdef HAVE_TIMER_SETUP
+	timer_setup(&dev->sustain_timer, sustain_timer_clb, 0);
+	timer_setup(&dev->timeout_timer, timeout_timer_clb, 0);
+#else
+	setup_timer(&dev->sustain_timer, sustain_timer_clb, nr);
+	setup_timer(&dev->timeout_timer, timeout_timer_clb, nr);
+#endif
+
+	/* initialise the control handler and add controls */
+	MARK();
+	hdl = &dev->ctrl_handler;
+	err = v4l2_ctrl_handler_init(hdl, 4);
+	if (err)
+		goto out_unregister;
+	v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);
+	v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);
+	v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);
+	v4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);
+	if (hdl->error) {
+		err = hdl->error;
+		goto out_free_handler;
+	}
+	dev->v4l2_dev.ctrl_handler = hdl;
+
+	err = v4l2_ctrl_handler_setup(hdl);
+	if (err)
+		goto out_free_handler;
+
+	/* register the device (creates /dev/video*) */
+	MARK();
+	if (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {
+		printk(KERN_ERR
+		       "v4l2-loopback add() failed video_register_device()\n");
+		err = -EFAULT;
+		goto out_free_device;
+	}
+	v4l2loopback_create_sysfs(dev->vdev);
+	/* NOTE: ambivalent if sysfs entries fail */
+
+	if (ret_nr)
+		*ret_nr = dev->vdev->num;
+	return 0;
+
+out_free_device:
+	video_device_release(dev->vdev);
+out_free_handler:
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+out_unregister:
+	video_set_drvdata(dev->vdev, NULL);
+	if (vdev_priv != NULL)
+		kfree(vdev_priv);
+	v4l2_device_unregister(&dev->v4l2_dev);
+out_free_idr:
+	idr_remove(&v4l2loopback_index_idr, nr);
+out_free_dev:
+	kfree(dev);
+	return err;
+}
+
+static void v4l2_loopback_remove(struct v4l2_loopback_device *dev)
+{
+	int device_nr = v4l2loopback_get_vdev_nr(dev->vdev);
+	mutex_lock(&dev->image_mutex);
+	free_buffers(dev);
+	free_timeout_buffer(dev);
+	mutex_unlock(&dev->image_mutex);
+	v4l2loopback_remove_sysfs(dev->vdev);
+	v4l2_ctrl_handler_free(&dev->ctrl_handler);
+	kfree(video_get_drvdata(dev->vdev));
+	video_unregister_device(dev->vdev);
+	v4l2_device_unregister(&dev->v4l2_dev);
+	idr_remove(&v4l2loopback_index_idr, device_nr);
+	kfree(dev);
+}
+
+static long v4l2loopback_control_ioctl(struct file *file, unsigned int cmd,
+				       unsigned long parm)
+{
+	struct v4l2_loopback_device *dev;
+	struct v4l2_loopback_config conf;
+	struct v4l2_loopback_config *confptr = &conf;
+	int device_nr, capture_nr, output_nr;
+	int ret;
+	const __u32 version = V4L2LOOPBACK_VERSION_CODE;
+
+	ret = mutex_lock_killable(&v4l2loopback_ctl_mutex);
+	if (ret)
+		return ret;
+
+	ret = -EINVAL;
+	switch (cmd) {
+	default:
+		ret = -ENOSYS;
+		break;
+		/* add a v4l2loopback device (pair), based on the user-provided specs */
+	case V4L2LOOPBACK_CTL_ADD:
+	case V4L2LOOPBACK_CTL_ADD_legacy:
+		if (parm) {
+			if ((ret = copy_from_user(&conf, (void *)parm,
+						  sizeof(conf))) < 0)
+				break;
+		} else
+			confptr = NULL;
+		ret = v4l2_loopback_add(confptr, &device_nr);
+		if (ret >= 0)
+			ret = device_nr;
+		break;
+		/* remove a v4l2loopback device (both capture and output) */
+	case V4L2LOOPBACK_CTL_REMOVE:
+	case V4L2LOOPBACK_CTL_REMOVE_legacy:
+		ret = v4l2loopback_lookup((__u32)parm, &dev);
+		if (ret >= 0 && dev) {
+			ret = -EBUSY;
+			if (dev->open_count.counter > 0)
+				break;
+			v4l2_loopback_remove(dev);
+			ret = 0;
+		};
+		break;
+		/* get information for a loopback device.
+		 * this is mostly about limits (which cannot be queried directly with  VIDIOC_G_FMT and friends
+		 */
+	case V4L2LOOPBACK_CTL_QUERY:
+	case V4L2LOOPBACK_CTL_QUERY_legacy:
+		if (!parm)
+			break;
+		if ((ret = copy_from_user(&conf, (void *)parm, sizeof(conf))) <
+		    0)
+			break;
+		capture_nr = output_nr = conf.output_nr;
+#ifdef SPLIT_DEVICES
+		capture_nr = conf.capture_nr;
+#endif
+		device_nr = (output_nr < 0) ? capture_nr : output_nr;
+		MARK();
+		/* get the device from either capture_nr or output_nr (whatever is valid) */
+		if ((ret = v4l2loopback_lookup(device_nr, &dev)) < 0)
+			break;
+		MARK();
+		/* if we got the device from output_nr and there is a valid capture_nr,
+		 * make sure that both refer to the same device (or bail out)
+		 */
+		if ((device_nr != capture_nr) && (capture_nr >= 0) &&
+		    ((ret = v4l2loopback_lookup(capture_nr, 0)) < 0))
+			break;
+		MARK();
+		/* if otoh, we got the device from capture_nr and there is a valid output_nr,
+		 * make sure that both refer to the same device (or bail out)
+		 */
+		if ((device_nr != output_nr) && (output_nr >= 0) &&
+		    ((ret = v4l2loopback_lookup(output_nr, 0)) < 0))
+			break;
+
+		/* v4l2_loopback_config identified a single device, so fetch the data */
+		snprintf(conf.card_label, sizeof(conf.card_label), "%s",
+			 dev->card_label);
+
+		conf.output_nr = dev->vdev->num;
+#ifdef SPLIT_DEVICES
+		conf.capture_nr = dev->vdev->num;
+#endif
+		conf.min_width = dev->min_width;
+		conf.min_height = dev->min_height;
+		conf.max_width = dev->max_width;
+		conf.max_height = dev->max_height;
+		conf.announce_all_caps = dev->announce_all_caps;
+		conf.max_buffers = dev->buffer_count;
+		conf.max_openers = dev->max_openers;
+		conf.debug = debug;
+		MARK();
+		if (copy_to_user((void *)parm, &conf, sizeof(conf))) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = 0;
+		break;
+	case V4L2LOOPBACK_CTL_VERSION:
+		if (!parm)
+			break;
+		if (copy_to_user((void *)parm, &version, sizeof(version))) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = 0;
+		break;
+	}
+
+	mutex_unlock(&v4l2loopback_ctl_mutex);
+	MARK();
+	return ret;
+}
+
+/* LINUX KERNEL */
+
+static const struct file_operations v4l2loopback_ctl_fops = {
+	// clang-format off
+	.owner		= THIS_MODULE,
+	.open		= nonseekable_open,
+	.unlocked_ioctl	= v4l2loopback_control_ioctl,
+	.compat_ioctl	= v4l2loopback_control_ioctl,
+	.llseek		= noop_llseek,
+	// clang-format on
+};
+
+static struct miscdevice v4l2loopback_misc = {
+	// clang-format off
+	.minor		= MISC_DYNAMIC_MINOR,
+	.name		= "v4l2loopback",
+	.fops		= &v4l2loopback_ctl_fops,
+	// clang-format on
+};
+
+static const struct v4l2_file_operations v4l2_loopback_fops = {
+	// clang-format off
+	.owner		= THIS_MODULE,
+	.open		= v4l2_loopback_open,
+	.release	= v4l2_loopback_close,
+	.read		= v4l2_loopback_read,
+	.write		= v4l2_loopback_write,
+	.poll		= v4l2_loopback_poll,
+	.mmap		= v4l2_loopback_mmap,
+	.unlocked_ioctl	= video_ioctl2,
+	// clang-format on
+};
+
+static const struct v4l2_ioctl_ops v4l2_loopback_ioctl_ops = {
+	// clang-format off
+	.vidioc_querycap		= &vidioc_querycap,
+	.vidioc_enum_framesizes		= &vidioc_enum_framesizes,
+	.vidioc_enum_frameintervals	= &vidioc_enum_frameintervals,
+
+	.vidioc_enum_output		= &vidioc_enum_output,
+	.vidioc_g_output		= &vidioc_g_output,
+	.vidioc_s_output		= &vidioc_s_output,
+
+	.vidioc_enum_input		= &vidioc_enum_input,
+	.vidioc_g_input			= &vidioc_g_input,
+	.vidioc_s_input			= &vidioc_s_input,
+
+	.vidioc_enum_fmt_vid_cap	= &vidioc_enum_fmt_cap,
+	.vidioc_g_fmt_vid_cap		= &vidioc_g_fmt_cap,
+	.vidioc_s_fmt_vid_cap		= &vidioc_s_fmt_cap,
+	.vidioc_try_fmt_vid_cap		= &vidioc_try_fmt_cap,
+
+	.vidioc_enum_fmt_vid_out	= &vidioc_enum_fmt_out,
+	.vidioc_s_fmt_vid_out		= &vidioc_s_fmt_out,
+	.vidioc_g_fmt_vid_out		= &vidioc_g_fmt_out,
+	.vidioc_try_fmt_vid_out		= &vidioc_try_fmt_out,
+
+#ifdef V4L2L_OVERLAY
+	.vidioc_s_fmt_vid_overlay	= &vidioc_s_fmt_overlay,
+	.vidioc_g_fmt_vid_overlay	= &vidioc_g_fmt_overlay,
+#endif
+
+#ifdef V4L2LOOPBACK_WITH_STD
+	.vidioc_s_std			= &vidioc_s_std,
+	.vidioc_g_std			= &vidioc_g_std,
+	.vidioc_querystd		= &vidioc_querystd,
+#endif /* V4L2LOOPBACK_WITH_STD */
+
+	.vidioc_g_parm			= &vidioc_g_parm,
+	.vidioc_s_parm			= &vidioc_s_parm,
+
+	.vidioc_reqbufs			= &vidioc_reqbufs,
+	.vidioc_querybuf		= &vidioc_querybuf,
+	.vidioc_qbuf			= &vidioc_qbuf,
+	.vidioc_dqbuf			= &vidioc_dqbuf,
+
+	.vidioc_streamon		= &vidioc_streamon,
+	.vidioc_streamoff		= &vidioc_streamoff,
+
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf			= &vidiocgmbuf,
+#endif
+
+	.vidioc_subscribe_event		= &vidioc_subscribe_event,
+	.vidioc_unsubscribe_event	= &v4l2_event_unsubscribe,
+	// clang-format on
+};
+
+static int free_device_cb(int id, void *ptr, void *data)
+{
+	struct v4l2_loopback_device *dev = ptr;
+	v4l2_loopback_remove(dev);
+	return 0;
+}
+static void free_devices(void)
+{
+	idr_for_each(&v4l2loopback_index_idr, &free_device_cb, NULL);
+	idr_destroy(&v4l2loopback_index_idr);
+}
+
+static int __init v4l2loopback_init_module(void)
+{
+	const u32 min_width = V4L2LOOPBACK_SIZE_MIN_WIDTH;
+	const u32 min_height = V4L2LOOPBACK_SIZE_MIN_HEIGHT;
+	int err;
+	int i;
+	MARK();
+
+	err = misc_register(&v4l2loopback_misc);
+	if (err < 0)
+		return err;
+
+	if (devices < 0) {
+		devices = 1;
+
+		/* try guessing the devices from the "video_nr" parameter */
+		for (i = MAX_DEVICES - 1; i >= 0; i--) {
+			if (video_nr[i] >= 0) {
+				devices = i + 1;
+				break;
+			}
+		}
+	}
+
+	if (devices > MAX_DEVICES) {
+		devices = MAX_DEVICES;
+		printk(KERN_INFO
+		       "v4l2-loopback init() number of initial devices is "
+		       "limited to: %d\n",
+		       MAX_DEVICES);
+	}
+
+	if (max_buffers > MAX_BUFFERS) {
+		max_buffers = MAX_BUFFERS;
+		printk(KERN_INFO
+		       "v4l2-loopback init() number of buffers is limited "
+		       "to: %d\n",
+		       MAX_BUFFERS);
+	}
+
+	if (max_openers < 0) {
+		printk(KERN_INFO
+		       "v4l2-loopback init() allowing %d openers rather "
+		       "than %d\n",
+		       2, max_openers);
+		max_openers = 2;
+	}
+
+	if (max_width < min_width) {
+		max_width = V4L2LOOPBACK_SIZE_DEFAULT_MAX_WIDTH;
+		printk(KERN_INFO "v4l2-loopback init() using max_width %d\n",
+		       max_width);
+	}
+	if (max_height < min_height) {
+		max_height = V4L2LOOPBACK_SIZE_DEFAULT_MAX_HEIGHT;
+		printk(KERN_INFO "v4l2-loopback init() using max_height %d\n",
+		       max_height);
+	}
+
+	for (i = 0; i < devices; i++) {
+		struct v4l2_loopback_config cfg = {
+			// clang-format off
+			.output_nr		= video_nr[i],
+#ifdef SPLIT_DEVICES
+			.capture_nr		= video_nr[i],
+#endif
+			.min_width		= min_width,
+			.min_height		= min_height,
+			.max_width		= max_width,
+			.max_height		= max_height,
+			.announce_all_caps	= (!exclusive_caps[i]),
+			.max_buffers		= max_buffers,
+			.max_openers		= max_openers,
+			.debug			= debug,
+			// clang-format on
+		};
+		cfg.card_label[0] = 0;
+		if (card_label[i])
+			snprintf(cfg.card_label, sizeof(cfg.card_label), "%s",
+				 card_label[i]);
+		err = v4l2_loopback_add(&cfg, 0);
+		if (err) {
+			free_devices();
+			goto error;
+		}
+	}
+
+	dprintk("module installed\n");
+
+	printk(KERN_INFO "v4l2-loopback driver version %d.%d.%d%s loaded\n",
+	       // clang-format off
+	       (V4L2LOOPBACK_VERSION_CODE >> 16) & 0xff,
+	       (V4L2LOOPBACK_VERSION_CODE >>  8) & 0xff,
+	       (V4L2LOOPBACK_VERSION_CODE      ) & 0xff,
+#ifdef SNAPSHOT_VERSION
+	       " (" __stringify(SNAPSHOT_VERSION) ")"
+#else
+	       ""
+#endif
+	       );
+	// clang-format on
+
+	return 0;
+error:
+	misc_deregister(&v4l2loopback_misc);
+	return err;
+}
+
+static void v4l2loopback_cleanup_module(void)
+{
+	MARK();
+	/* unregister the device -> it deletes /dev/video* */
+	free_devices();
+	/* and get rid of /dev/v4l2loopback */
+	misc_deregister(&v4l2loopback_misc);
+	dprintk("module removed\n");
+}
+
+MODULE_ALIAS_MISCDEV(MISC_DYNAMIC_MINOR);
+
+module_init(v4l2loopback_init_module);
+module_exit(v4l2loopback_cleanup_module);
diff --git a/drivers/custom/v4l2loopback/v4l2loopback.h b/drivers/custom/v4l2loopback/v4l2loopback.h
new file mode 100644
index 000000000000..8beca10d7bbd
--- /dev/null
+++ b/drivers/custom/v4l2loopback/v4l2loopback.h
@@ -0,0 +1,108 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
+/*
+ * v4l2loopback.h
+ *
+ * Written by IOhannes m zmlnig, 7/1/20.
+ *
+ * Copyright 2020 by IOhannes m zmlnig.  Redistribution of this file is
+ * permitted under the GNU General Public License.
+ */
+#ifndef _V4L2LOOPBACK_H
+#define _V4L2LOOPBACK_H
+
+#define V4L2LOOPBACK_VERSION_MAJOR 0
+#define V4L2LOOPBACK_VERSION_MINOR 15
+#define V4L2LOOPBACK_VERSION_BUGFIX 1
+
+/* /dev/v4l2loopback interface */
+
+struct v4l2_loopback_config {
+	/**
+         * the device-number (/dev/video<nr>)
+         * V4L2LOOPBACK_CTL_ADD:
+         * setting this to a value<0, will allocate an available one
+         * if nr>=0 and the device already exists, the ioctl will EEXIST
+         * if output_nr and capture_nr are the same, only a single device will be created
+	 * NOTE: currently split-devices (where output_nr and capture_nr differ)
+	 *   are not implemented yet.
+	 *   until then, requesting different device-IDs will result in EINVAL.
+         *
+         * V4L2LOOPBACK_CTL_QUERY:
+         * either both output_nr and capture_nr must refer to the same loopback,
+         * or one (and only one) of them must be -1
+         *
+         */
+	__s32 output_nr;
+	__s32 unused; /*capture_nr;*/
+
+	/**
+         * a nice name for your device
+         * if (*card_label)==0, an automatic name is assigned
+         */
+	char card_label[32];
+
+	/**
+         * allowed frame size
+         * if too low, default values are used
+         */
+	__u32 min_width;
+	__u32 max_width;
+	__u32 min_height;
+	__u32 max_height;
+
+	/**
+         * number of buffers to allocate for the queue
+         * if set to <=0, default values are used
+         */
+	__s32 max_buffers;
+
+	/**
+         * how many consumers are allowed to open this device concurrently
+         * if set to <=0, default values are used
+         */
+	__s32 max_openers;
+
+	/**
+         * set the debugging level for this device
+         */
+	__s32 debug;
+
+	/**
+         * whether to announce OUTPUT/CAPTURE capabilities exclusively
+         * for this device or not
+         * (!exclusive_caps)
+	 * NOTE: this is going to be removed once separate output/capture
+	 *       devices are implemented
+         */
+	__s32 announce_all_caps;
+};
+
+#define V4L2LOOPBACK_CTL_IOCTLMAGIC '~'
+
+/* a pointer to an (unsigned int) that - on success - will hold
+ * the version code of the v4l2loopback module
+ * as returned by KERNEL_VERSION(MAJOR, MINOR, BUGFIX)
+ */
+#define V4L2LOOPBACK_CTL_VERSION _IOR(V4L2LOOPBACK_CTL_IOCTLMAGIC, 0, __u32)
+
+/* a pointer to a (struct v4l2_loopback_config) that has all values you wish to impose on the
+ * to-be-created device set.
+ * if the ptr is NULL, a new device is created with default values at the driver's discretion.
+ *
+ * returns the device_nr of the OUTPUT device (which can be used with V4L2LOOPBACK_CTL_QUERY,
+ * to get more information on the device)
+ */
+#define V4L2LOOPBACK_CTL_ADD \
+	_IOW(V4L2LOOPBACK_CTL_IOCTLMAGIC, 1, struct v4l2_loopback_config)
+
+/* the device-number (either CAPTURE or OUTPUT) associated with the loopback-device */
+#define V4L2LOOPBACK_CTL_REMOVE _IOW(V4L2LOOPBACK_CTL_IOCTLMAGIC, 2, __u32)
+
+/* a pointer to a (struct v4l2_loopback_config) that has output_nr and/or capture_nr set
+ * (the two values must either refer to video-devices associated with the same loopback device
+ *  or exactly one of them must be <0
+ */
+#define V4L2LOOPBACK_CTL_QUERY \
+	_IOWR(V4L2LOOPBACK_CTL_IOCTLMAGIC, 3, struct v4l2_loopback_config)
+
+#endif /* _V4L2LOOPBACK_H */
diff --git a/drivers/custom/v4l2loopback/v4l2loopback_formats.h b/drivers/custom/v4l2loopback/v4l2loopback_formats.h
new file mode 100644
index 000000000000..ac2f1cbc062c
--- /dev/null
+++ b/drivers/custom/v4l2loopback/v4l2loopback_formats.h
@@ -0,0 +1,453 @@
+static const struct v4l2l_format formats[] = {
+#ifndef V4L2_PIX_FMT_VP9
+#define V4L2_PIX_FMT_VP9 v4l2_fourcc('V', 'P', '9', '0')
+#endif
+#ifndef V4L2_PIX_FMT_HEVC
+#define V4L2_PIX_FMT_HEVC v4l2_fourcc('H', 'E', 'V', 'C')
+#endif
+
+	/* here come the packed formats */
+	{
+		.name = "32 bpp RGB, le",
+		.fourcc = V4L2_PIX_FMT_BGR32,
+		.depth = 32,
+		.flags = 0,
+	},
+	{
+		.name = "32 bpp RGB, be",
+		.fourcc = V4L2_PIX_FMT_RGB32,
+		.depth = 32,
+		.flags = 0,
+	},
+	{
+		.name = "24 bpp RGB, le",
+		.fourcc = V4L2_PIX_FMT_BGR24,
+		.depth = 24,
+		.flags = 0,
+	},
+	{
+		.name = "24 bpp RGB, be",
+		.fourcc = V4L2_PIX_FMT_RGB24,
+		.depth = 24,
+		.flags = 0,
+	},
+#ifdef V4L2_PIX_FMT_ABGR32
+	{
+		.name = "32 bpp RGBA, le",
+		.fourcc = V4L2_PIX_FMT_ABGR32,
+		.depth = 32,
+		.flags = 0,
+	},
+#endif
+#ifdef V4L2_PIX_FMT_XBGR32
+	{
+		.name = "32 bpp BGRX-8-8-8-8",
+		.fourcc = V4L2_PIX_FMT_XBGR32,
+		.depth = 32,
+		.flags = 0,
+	},
+#endif
+#ifdef V4L2_PIX_FMT_RGBA32
+	{
+		.name = "32 bpp RGBA",
+		.fourcc = V4L2_PIX_FMT_RGBA32,
+		.depth = 32,
+		.flags = 0,
+	},
+#endif
+#ifdef V4L2_PIX_FMT_RGB332
+	{
+		.name = "8 bpp RGB-3-3-2",
+		.fourcc = V4L2_PIX_FMT_RGB332,
+		.depth = 8,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB332 */
+#ifdef V4L2_PIX_FMT_RGB444
+	{
+		.name = "16 bpp RGB (xxxxrrrr ggggbbbb)",
+		.fourcc = V4L2_PIX_FMT_RGB444,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB444 */
+#ifdef V4L2_PIX_FMT_RGB555
+	{
+		.name = "16 bpp RGB-5-5-5",
+		.fourcc = V4L2_PIX_FMT_RGB555,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB555 */
+#ifdef V4L2_PIX_FMT_RGB565
+	{
+		.name = "16 bpp RGB-5-6-5",
+		.fourcc = V4L2_PIX_FMT_RGB565,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB565 */
+#ifdef V4L2_PIX_FMT_RGB555X
+	{
+		.name = "16 bpp RGB-5-5-5 BE",
+		.fourcc = V4L2_PIX_FMT_RGB555X,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB555X */
+#ifdef V4L2_PIX_FMT_RGB565X
+	{
+		.name = "16 bpp RGB-5-6-5 BE",
+		.fourcc = V4L2_PIX_FMT_RGB565X,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_RGB565X */
+#ifdef V4L2_PIX_FMT_BGR666
+	{
+		.name = "18 bpp BGR-6-6-6",
+		.fourcc = V4L2_PIX_FMT_BGR666,
+		.depth = 18,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_BGR666 */
+	{
+		.name = "4:2:2, packed, YUYV",
+		.fourcc = V4L2_PIX_FMT_YUYV,
+		.depth = 16,
+		.flags = 0,
+	},
+	{
+		.name = "4:2:2, packed, UYVY",
+		.fourcc = V4L2_PIX_FMT_UYVY,
+		.depth = 16,
+		.flags = 0,
+	},
+#ifdef V4L2_PIX_FMT_YVYU
+	{
+		.name = "4:2:2, packed YVYU",
+		.fourcc = V4L2_PIX_FMT_YVYU,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif
+#ifdef V4L2_PIX_FMT_VYUY
+	{
+		.name = "4:2:2, packed VYUY",
+		.fourcc = V4L2_PIX_FMT_VYUY,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif
+	{
+		.name = "4:2:2, packed YYUV",
+		.fourcc = V4L2_PIX_FMT_YYUV,
+		.depth = 16,
+		.flags = 0,
+	},
+	{
+		.name = "YUV-8-8-8-8",
+		.fourcc = V4L2_PIX_FMT_YUV32,
+		.depth = 32,
+		.flags = 0,
+	},
+	{
+		.name = "8 bpp, Greyscale",
+		.fourcc = V4L2_PIX_FMT_GREY,
+		.depth = 8,
+		.flags = 0,
+	},
+#ifdef V4L2_PIX_FMT_Y4
+	{
+		.name = "4 bpp Greyscale",
+		.fourcc = V4L2_PIX_FMT_Y4,
+		.depth = 4,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_Y4 */
+#ifdef V4L2_PIX_FMT_Y6
+	{
+		.name = "6 bpp Greyscale",
+		.fourcc = V4L2_PIX_FMT_Y6,
+		.depth = 6,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_Y6 */
+#ifdef V4L2_PIX_FMT_Y10
+	{
+		.name = "10 bpp Greyscale",
+		.fourcc = V4L2_PIX_FMT_Y10,
+		.depth = 10,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_Y10 */
+#ifdef V4L2_PIX_FMT_Y12
+	{
+		.name = "12 bpp Greyscale",
+		.fourcc = V4L2_PIX_FMT_Y12,
+		.depth = 12,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_Y12 */
+	{
+		.name = "16 bpp, Greyscale",
+		.fourcc = V4L2_PIX_FMT_Y16,
+		.depth = 16,
+		.flags = 0,
+	},
+#ifdef V4L2_PIX_FMT_YUV444
+	{
+		.name = "16 bpp xxxxyyyy uuuuvvvv",
+		.fourcc = V4L2_PIX_FMT_YUV444,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_YUV444 */
+#ifdef V4L2_PIX_FMT_YUV555
+	{
+		.name = "16 bpp YUV-5-5-5",
+		.fourcc = V4L2_PIX_FMT_YUV555,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_YUV555 */
+#ifdef V4L2_PIX_FMT_YUV565
+	{
+		.name = "16 bpp YUV-5-6-5",
+		.fourcc = V4L2_PIX_FMT_YUV565,
+		.depth = 16,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_YUV565 */
+
+/* bayer formats */
+#ifdef V4L2_PIX_FMT_SRGGB8
+	{
+		.name = "Bayer RGGB 8bit",
+		.fourcc = V4L2_PIX_FMT_SRGGB8,
+		.depth = 8,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_SRGGB8 */
+#ifdef V4L2_PIX_FMT_SGRBG8
+	{
+		.name = "Bayer GRBG 8bit",
+		.fourcc = V4L2_PIX_FMT_SGRBG8,
+		.depth = 8,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_SGRBG8 */
+#ifdef V4L2_PIX_FMT_SGBRG8
+	{
+		.name = "Bayer GBRG 8bit",
+		.fourcc = V4L2_PIX_FMT_SGBRG8,
+		.depth = 8,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_SGBRG8 */
+#ifdef V4L2_PIX_FMT_SBGGR8
+	{
+		.name = "Bayer BA81 8bit",
+		.fourcc = V4L2_PIX_FMT_SBGGR8,
+		.depth = 8,
+		.flags = 0,
+	},
+#endif /* V4L2_PIX_FMT_SBGGR8 */
+
+	/* here come the planar formats */
+	{
+		.name = "4:1:0, planar, Y-Cr-Cb",
+		.fourcc = V4L2_PIX_FMT_YVU410,
+		.depth = 9,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+	{
+		.name = "4:2:0, planar, Y-Cr-Cb",
+		.fourcc = V4L2_PIX_FMT_YVU420,
+		.depth = 12,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+	{
+		.name = "4:1:0, planar, Y-Cb-Cr",
+		.fourcc = V4L2_PIX_FMT_YUV410,
+		.depth = 9,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+	{
+		.name = "4:2:0, planar, Y-Cb-Cr",
+		.fourcc = V4L2_PIX_FMT_YUV420,
+		.depth = 12,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+#ifdef V4L2_PIX_FMT_YUV422P
+	{
+		.name = "16 bpp YVU422 planar",
+		.fourcc = V4L2_PIX_FMT_YUV422P,
+		.depth = 16,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+#endif /* V4L2_PIX_FMT_YUV422P */
+#ifdef V4L2_PIX_FMT_YUV411P
+	{
+		.name = "16 bpp YVU411 planar",
+		.fourcc = V4L2_PIX_FMT_YUV411P,
+		.depth = 16,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+#endif /* V4L2_PIX_FMT_YUV411P */
+#ifdef V4L2_PIX_FMT_Y41P
+	{
+		.name = "12 bpp YUV 4:1:1",
+		.fourcc = V4L2_PIX_FMT_Y41P,
+		.depth = 12,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+#endif /* V4L2_PIX_FMT_Y41P */
+#ifdef V4L2_PIX_FMT_NV12
+	{
+		.name = "12 bpp Y/CbCr 4:2:0 ",
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.depth = 12,
+		.flags = FORMAT_FLAGS_PLANAR,
+	},
+#endif /* V4L2_PIX_FMT_NV12 */
+
+/* here come the compressed formats */
+
+#ifdef V4L2_PIX_FMT_MJPEG
+	{
+		.name = "Motion-JPEG",
+		.fourcc = V4L2_PIX_FMT_MJPEG,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_MJPEG */
+#ifdef V4L2_PIX_FMT_JPEG
+	{
+		.name = "JFIF JPEG",
+		.fourcc = V4L2_PIX_FMT_JPEG,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_JPEG */
+#ifdef V4L2_PIX_FMT_DV
+	{
+		.name = "DV1394",
+		.fourcc = V4L2_PIX_FMT_DV,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_DV */
+#ifdef V4L2_PIX_FMT_MPEG
+	{
+		.name = "MPEG-1/2/4 Multiplexed",
+		.fourcc = V4L2_PIX_FMT_MPEG,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_MPEG */
+#ifdef V4L2_PIX_FMT_H264
+	{
+		.name = "H264 with start codes",
+		.fourcc = V4L2_PIX_FMT_H264,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_H264 */
+#ifdef V4L2_PIX_FMT_H264_NO_SC
+	{
+		.name = "H264 without start codes",
+		.fourcc = V4L2_PIX_FMT_H264_NO_SC,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_H264_NO_SC */
+#ifdef V4L2_PIX_FMT_H264_MVC
+	{
+		.name = "H264 MVC",
+		.fourcc = V4L2_PIX_FMT_H264_MVC,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_H264_MVC */
+#ifdef V4L2_PIX_FMT_H263
+	{
+		.name = "H263",
+		.fourcc = V4L2_PIX_FMT_H263,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_H263 */
+#ifdef V4L2_PIX_FMT_MPEG1
+	{
+		.name = "MPEG-1 ES",
+		.fourcc = V4L2_PIX_FMT_MPEG1,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_MPEG1 */
+#ifdef V4L2_PIX_FMT_MPEG2
+	{
+		.name = "MPEG-2 ES",
+		.fourcc = V4L2_PIX_FMT_MPEG2,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_MPEG2 */
+#ifdef V4L2_PIX_FMT_MPEG4
+	{
+		.name = "MPEG-4 part 2 ES",
+		.fourcc = V4L2_PIX_FMT_MPEG4,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_MPEG4 */
+#ifdef V4L2_PIX_FMT_XVID
+	{
+		.name = "Xvid",
+		.fourcc = V4L2_PIX_FMT_XVID,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_XVID */
+#ifdef V4L2_PIX_FMT_VC1_ANNEX_G
+	{
+		.name = "SMPTE 421M Annex G compliant stream",
+		.fourcc = V4L2_PIX_FMT_VC1_ANNEX_G,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_VC1_ANNEX_G */
+#ifdef V4L2_PIX_FMT_VC1_ANNEX_L
+	{
+		.name = "SMPTE 421M Annex L compliant stream",
+		.fourcc = V4L2_PIX_FMT_VC1_ANNEX_L,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_VC1_ANNEX_L */
+#ifdef V4L2_PIX_FMT_VP8
+	{
+		.name = "VP8",
+		.fourcc = V4L2_PIX_FMT_VP8,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_VP8 */
+#ifdef V4L2_PIX_FMT_VP9
+	{
+		.name = "VP9",
+		.fourcc = V4L2_PIX_FMT_VP9,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_VP9 */
+#ifdef V4L2_PIX_FMT_HEVC
+	{
+		.name = "HEVC",
+		.fourcc = V4L2_PIX_FMT_HEVC,
+		.depth = 32,
+		.flags = FORMAT_FLAGS_COMPRESSED,
+	},
+#endif /* V4L2_PIX_FMT_HEVC */
+};
# ----------------------------------------
# Module: evdi
# Version: v1.14.11
# ----------------------------------------
diff --git a/drivers/custom/evdi/module/Kconfig b/drivers/custom/evdi/module/Kconfig
new file mode 100644
index 000000000000..80d876599640
--- /dev/null
+++ b/drivers/custom/evdi/module/Kconfig
@@ -0,0 +1,33 @@
+#
+# Copyright (c) 2015 - 2019 DisplayLink (UK) Ltd.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License v2. See the file COPYING in the main directory of this archive for
+# more details.
+#
+
+config DRM_EVDI
+	tristate "Extensible Virtual Display Interface"
+	depends on DRM
+	depends on USB_SUPPORT
+	depends on USB_ARCH_HAS_HCD
+	depends on MODULES
+	select USB
+	select DRM_KMS_HELPER
+	help
+		This is a KMS interface driver allowing user-space programs to
+		register a virtual display (that imitates physical monitor) and
+		retrieve contents (as a frame buffer) that system renders on it.
+		Say M/Y to add support for these devices via DRM/KMS interfaces.
+
+config DRM_EVDI_KUNIT_TEST
+	tristate "KUnit tests for evdi" if !KUNIT_ALL_TESTS
+		depends on DRM_EVDI && KUNIT
+		default KUNIT_ALL_TESTS
+	help
+		KUnit tests for evdi DRM module.
+		This option is useful for kernel developers.
+		Please remember to provide tests for code you add.
+
+		If in doubt, say "N".
+
diff --git a/drivers/custom/evdi/module/Makefile b/drivers/custom/evdi/module/Makefile
new file mode 100644
index 000000000000..5bb0134b67a5
--- /dev/null
+++ b/drivers/custom/evdi/module/Makefile
@@ -0,0 +1,105 @@
+#
+# Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License v2. See the file COPYING in the main directory of this archive for
+# more details.
+#
+
+include /etc/os-release
+
+ifneq (,$(findstring rhel,$(ID_LIKE)))
+ELFLAG := -DEL$(VERSION_ID)
+endif
+
+Raspbian := $(shell grep -Eic 'raspb(erry|ian)' /proc/cpuinfo /etc/os-release 2>/dev/null )
+ifeq (,$(findstring 0, $(Raspbian)))
+RPIFLAG := -DRPI
+endif
+
+ifneq ($(DKMS_BUILD),)
+
+# DKMS
+
+KERN_DIR := /lib/modules/$(KERNELRELEASE)/build
+
+ccflags-y := -Iinclude/uapi/drm -Iinclude/drm $(ELFLAG) $(RPIFLAG)
+evdi-y := evdi_platform_drv.o evdi_platform_dev.o evdi_sysfs.o evdi_modeset.o evdi_connector.o evdi_encoder.o evdi_drm_drv.o evdi_fb.o evdi_gem.o evdi_painter.o evdi_params.o evdi_cursor.o evdi_debug.o evdi_i2c.o
+evdi-$(CONFIG_COMPAT) += evdi_ioc32.o
+obj-m := evdi.o
+
+KBUILD_VERBOSE ?= 1
+
+all:
+	$(MAKE) KBUILD_VERBOSE=$(KBUILD_VERBOSE) M=$(CURDIR) SUBDIRS=$(CURDIR) SRCROOT=$(CURDIR) CONFIG_MODULE_SIG= -C $(KERN_DIR) modules
+
+clean:
+	@echo $(KERN_DIR)
+	$(MAKE) KBUILD_VERBOSE=$(KBUILD_VERBOSE) M=$(CURDIR) SUBDIRS=$(CURDIR) SRCROOT=$(CURDIR) -C $(KERN_DIR) clean
+
+else
+
+# Not DKMS
+
+ifneq ($(KERNELRELEASE),)
+
+# inside kbuild
+# Note: this can be removed once it is in kernel tree and Kconfig is properly used
+ccflags-y := -isystem include/uapi/drm $(CFLAGS) $(ELFLAG) $(RPIFLAG)
+evdi-y := evdi_platform_drv.o evdi_platform_dev.o evdi_sysfs.o evdi_modeset.o evdi_connector.o evdi_encoder.o evdi_drm_drv.o evdi_fb.o evdi_gem.o evdi_painter.o evdi_params.o evdi_cursor.o evdi_debug.o evdi_i2c.o
+evdi-$(CONFIG_COMPAT) += evdi_ioc32.o
+CONFIG_DRM_EVDI ?= m
+obj-$(CONFIG_DRM_EVDI) := evdi.o
+obj-y += tests/
+
+else
+
+# kbuild against specified or current kernel
+CP ?= cp
+DKMS ?= dkms
+RM ?= rm
+
+MODVER=1.14.11
+
+ifeq ($(KVER),)
+	KVER := $(shell uname -r)
+endif
+
+ifneq ($(RUN_DEPMOD),)
+	DEPMOD := /sbin/depmod -a
+else
+	DEPMOD := true
+endif
+
+ifeq ($(KDIR),)
+	KDIR := /lib/modules/$(KVER)/build
+endif
+
+MOD_KERNEL_PATH := /kernel/drivers/gpu/drm/evdi
+
+default: module
+
+module:
+	$(MAKE) -C $(KDIR) M=$$PWD
+
+clean:
+	$(RM) -rf *.o *.a *.ko .tmp* .*.*.cmd Module.symvers evdi.mod.c modules.order
+
+install:
+	$(MAKE) -C $(KDIR) M=$$PWD INSTALL_MOD_PATH=$(DESTDIR) INSTALL_MOD_DIR=$(MOD_KERNEL_PATH) modules_install
+	$(DEPMOD)
+
+uninstall:
+	$(RM) -rf $(DESTDIR)/lib/modules/$(KVER)/$(MOD_KERNEL_PATH)
+	$(DEPMOD)
+
+install_dkms:
+	$(DKMS) install .
+
+uninstall_dkms:
+	$(DKMS) remove evdi/$(MODVER) --all
+	$(RM) -rf /usr/src/evdi-$(MODVER)
+
+endif # ifneq ($(KERNELRELEASE),)
+
+endif # ifneq ($(DKMS_BUILD),)
diff --git a/drivers/custom/evdi/module/evdi_connector.c b/drivers/custom/evdi/module/evdi_connector.c
new file mode 100644
index 000000000000..21555074cc0e
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_connector.c
@@ -0,0 +1,207 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/version.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include "evdi_drm_drv.h"
+
+#if KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_probe_helper.h>
+#endif
+
+/*
+ * dummy connector to just get EDID,
+ * all EVDI appear to have a DVI-D
+ */
+
+static int evdi_get_modes(struct drm_connector *connector)
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+	struct edid *edid = NULL;
+	int ret = 0;
+
+	edid = (struct edid *)evdi_painter_get_edid_copy(evdi);
+
+	if (!edid) {
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		drm_connector_update_edid_property(connector, NULL);
+#else
+		drm_mode_connector_update_edid_property(connector, NULL);
+#endif
+		return 0;
+	}
+
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	ret = drm_connector_update_edid_property(connector, edid);
+#else
+	ret = drm_mode_connector_update_edid_property(connector, edid);
+#endif
+
+	if (ret) {
+		EVDI_ERROR("Failed to set edid property! error: %d\n", ret);
+		goto err;
+	}
+
+	ret = drm_add_edid_modes(connector, edid);
+	EVDI_INFO("(card%d) Edid property set\n", evdi->dev_index);
+err:
+	kfree(edid);
+	return ret;
+}
+
+static bool is_lowest_frequency_mode_of_given_resolution(
+	struct drm_connector *connector, const struct drm_display_mode *mode)
+{
+	struct drm_display_mode *modeptr;
+
+	list_for_each_entry(modeptr, &(connector->modes), head) {
+		if (modeptr->hdisplay == mode->hdisplay &&
+			modeptr->vdisplay == mode->vdisplay &&
+			drm_mode_vrefresh(modeptr) < drm_mode_vrefresh(mode)) {
+			return false;
+		}
+	}
+	return true;
+}
+
+static enum drm_mode_status evdi_mode_valid(struct drm_connector *connector,
+#if KERNEL_VERSION(6, 15, 0) <= LINUX_VERSION_CODE
+					    const struct drm_display_mode *mode)
+#else
+					    struct drm_display_mode *mode)
+#endif
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+	uint32_t area_limit = mode->hdisplay * mode->vdisplay;
+	uint32_t mode_limit = area_limit * drm_mode_vrefresh(mode);
+
+	if (evdi->pixel_per_second_limit == 0)
+		return MODE_OK;
+
+	if (area_limit > evdi->pixel_area_limit) {
+		EVDI_WARN(
+			"(card%d) Mode %dx%d@%d rejected. Reason: mode area too big\n",
+			evdi->dev_index,
+			mode->hdisplay,
+			mode->vdisplay,
+			drm_mode_vrefresh(mode));
+		return MODE_BAD;
+	}
+
+	if (mode_limit <= evdi->pixel_per_second_limit)
+		return MODE_OK;
+
+	if (is_lowest_frequency_mode_of_given_resolution(connector, mode)) {
+		EVDI_WARN(
+			"(card%d) Mode exceeds maximal frame rate for the device. Mode %dx%d@%d may have a limited output frame rate",
+			evdi->dev_index,
+			mode->hdisplay,
+			mode->vdisplay,
+			drm_mode_vrefresh(mode));
+		return MODE_OK;
+	}
+
+	EVDI_WARN(
+		"(card%d) Mode %dx%d@%d rejected. Reason: mode pixel clock too high\n",
+		evdi->dev_index,
+		mode->hdisplay,
+		mode->vdisplay,
+		drm_mode_vrefresh(mode));
+
+	return MODE_BAD;
+}
+
+static enum drm_connector_status
+evdi_detect(struct drm_connector *connector, __always_unused bool force)
+{
+	struct evdi_device *evdi = connector->dev->dev_private;
+
+	EVDI_CHECKPT();
+	if (evdi_painter_is_connected(evdi->painter)) {
+		EVDI_INFO("(card%d) Connector state: connected\n",
+			   evdi->dev_index);
+		return connector_status_connected;
+	}
+	EVDI_VERBOSE("(card%d) Connector state: disconnected\n",
+		   evdi->dev_index);
+	return connector_status_disconnected;
+}
+
+static void evdi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+	kfree(connector);
+}
+
+static struct drm_encoder *evdi_best_encoder(struct drm_connector *connector)
+{
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	struct drm_encoder *encoder;
+
+	drm_connector_for_each_possible_encoder(connector, encoder) {
+		return encoder;
+	}
+
+	return NULL;
+#else
+	return drm_encoder_find(connector->dev,
+				NULL,
+				connector->encoder_ids[0]);
+#endif
+}
+
+static struct drm_connector_helper_funcs evdi_connector_helper_funcs = {
+	.get_modes = evdi_get_modes,
+	.mode_valid = evdi_mode_valid,
+	.best_encoder = evdi_best_encoder,
+};
+
+static const struct drm_connector_funcs evdi_connector_funcs = {
+	.detect = evdi_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = evdi_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state
+};
+
+int evdi_connector_init(struct drm_device *dev, struct drm_encoder *encoder)
+{
+	struct drm_connector *connector;
+	struct evdi_device *evdi = dev->dev_private;
+
+	connector = kzalloc(sizeof(struct drm_connector), GFP_KERNEL);
+	if (!connector)
+		return -ENOMEM;
+
+	/* TODO: Initialize connector with actual connector type */
+	drm_connector_init(dev, connector, &evdi_connector_funcs,
+			   DRM_MODE_CONNECTOR_DVII);
+	drm_connector_helper_add(connector, &evdi_connector_helper_funcs);
+	connector->polled = DRM_CONNECTOR_POLL_HPD;
+
+	drm_connector_register(connector);
+
+	evdi->conn = connector;
+
+#if KERNEL_VERSION(4, 19, 0) <= LINUX_VERSION_CODE  || defined(EL8)
+	drm_connector_attach_encoder(connector, encoder);
+#else
+	drm_mode_connector_attach_encoder(connector, encoder);
+#endif
+	return 0;
+}
diff --git a/drivers/custom/evdi/module/evdi_cursor.c b/drivers/custom/evdi/module/evdi_cursor.c
new file mode 100644
index 000000000000..3450f2051554
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_cursor.c
@@ -0,0 +1,291 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * evdi_cursor.c
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2016 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/compiler.h>
+#include <linux/mutex.h>
+#include <linux/version.h>
+
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_crtc_helper.h>
+
+#include "evdi_cursor.h"
+#include "evdi_drm_drv.h"
+
+/*
+ * EVDI drm cursor private structure.
+ */
+struct evdi_cursor {
+	bool enabled;
+	int32_t x;
+	int32_t y;
+	uint32_t width;
+	uint32_t height;
+	int32_t hot_x;
+	int32_t hot_y;
+	uint32_t pixel_format;
+	uint32_t stride;
+	struct evdi_gem_object *obj;
+	struct mutex lock;
+};
+
+static void evdi_cursor_set_gem(struct evdi_cursor *cursor,
+				struct evdi_gem_object *obj)
+{
+	if (obj)
+		drm_gem_object_get(&obj->base);
+	if (cursor->obj)
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		drm_gem_object_put(&cursor->obj->base);
+#else
+		drm_gem_object_put_unlocked(&cursor->obj->base);
+#endif
+
+	cursor->obj = obj;
+}
+
+struct evdi_gem_object *evdi_cursor_gem(struct evdi_cursor *cursor)
+{
+	return cursor->obj;
+}
+
+int evdi_cursor_init(struct evdi_cursor **cursor)
+{
+	if (WARN_ON(*cursor))
+		return -EINVAL;
+
+	*cursor = kzalloc(sizeof(struct evdi_cursor), GFP_KERNEL);
+	if (*cursor) {
+		mutex_init(&(*cursor)->lock);
+		return 0;
+	} else {
+		return -ENOMEM;
+	}
+}
+
+void evdi_cursor_lock(struct evdi_cursor *cursor)
+{
+	mutex_lock(&cursor->lock);
+}
+
+void evdi_cursor_unlock(struct evdi_cursor *cursor)
+{
+	mutex_unlock(&cursor->lock);
+}
+
+void evdi_cursor_free(struct evdi_cursor *cursor)
+{
+	if (WARN_ON(!cursor))
+		return;
+	evdi_cursor_set_gem(cursor, NULL);
+	kfree(cursor);
+}
+
+bool evdi_cursor_enabled(struct evdi_cursor *cursor)
+{
+	return cursor->enabled;
+}
+
+void evdi_cursor_enable(struct evdi_cursor *cursor, bool enable)
+{
+	evdi_cursor_lock(cursor);
+	cursor->enabled = enable;
+	if (!enable)
+		evdi_cursor_set_gem(cursor, NULL);
+	evdi_cursor_unlock(cursor);
+}
+
+void evdi_cursor_set(struct evdi_cursor *cursor,
+		     struct evdi_gem_object *obj,
+		     uint32_t width, uint32_t height,
+		     int32_t hot_x, int32_t hot_y,
+		     uint32_t pixel_format, uint32_t stride)
+{
+	int err = 0;
+
+	evdi_cursor_lock(cursor);
+	if (obj && !obj->vmapping)
+		err = evdi_gem_vmap(obj);
+
+	if (err != 0) {
+		EVDI_ERROR("Failed to map cursor.\n");
+		obj = NULL;
+	}
+
+	cursor->enabled = obj != NULL;
+	cursor->width = width;
+	cursor->height = height;
+	cursor->hot_x = hot_x;
+	cursor->hot_y = hot_y;
+	cursor->pixel_format = pixel_format;
+	cursor->stride = stride;
+	evdi_cursor_set_gem(cursor, obj);
+
+	evdi_cursor_unlock(cursor);
+}
+
+void evdi_cursor_move(struct evdi_cursor *cursor, int32_t x, int32_t y)
+{
+	evdi_cursor_lock(cursor);
+	cursor->x = x;
+	cursor->y = y;
+	evdi_cursor_unlock(cursor);
+}
+
+static inline uint32_t blend_component(uint32_t pixel,
+				  uint32_t blend,
+				  uint32_t alpha)
+{
+	uint32_t pre_blend = (pixel * (255 - alpha) + blend * alpha);
+
+	return (pre_blend + ((pre_blend + 1) << 8)) >> 16;
+}
+
+static inline uint32_t blend_alpha(const uint32_t pixel_val32,
+				uint32_t blend_val32)
+{
+	uint32_t alpha = (blend_val32 >> 24);
+
+	return blend_component(pixel_val32 & 0xff,
+			       blend_val32 & 0xff, alpha) |
+			blend_component((pixel_val32 & 0xff00) >> 8,
+				(blend_val32 & 0xff00) >> 8, alpha) << 8 |
+			blend_component((pixel_val32 & 0xff0000) >> 16,
+				(blend_val32 & 0xff0000) >> 16, alpha) << 16;
+}
+
+static int evdi_cursor_compose_pixel(char __user *buffer,
+				     int const cursor_value,
+				     int const fb_value,
+				     int cmd_offset)
+{
+	int const composed_value = blend_alpha(fb_value, cursor_value);
+
+	return copy_to_user(buffer + cmd_offset, &composed_value, 4);
+}
+
+int evdi_cursor_compose_and_copy(struct evdi_cursor *cursor,
+				 struct evdi_framebuffer *efb,
+				 char __user *buffer,
+				 int buf_byte_stride)
+{
+	int x, y;
+	struct drm_framebuffer *fb = &efb->base;
+	const int h_cursor_w = cursor->width >> 1;
+	const int h_cursor_h = cursor->height >> 1;
+	uint32_t *cursor_buffer = NULL;
+	uint32_t bytespp = 0;
+
+	if (!cursor->enabled)
+		return 0;
+
+	if (!cursor->obj)
+		return -EINVAL;
+
+	if (!cursor->obj->vmapping)
+		return -EINVAL;
+
+	bytespp = evdi_fb_get_bpp(cursor->pixel_format);
+	bytespp = DIV_ROUND_UP(bytespp, 8);
+	if (bytespp != 4) {
+		EVDI_ERROR("Unsupported cursor format bpp=%u\n", bytespp);
+		return -EINVAL;
+	}
+
+	if (cursor->width * cursor->height * bytespp >
+	    cursor->obj->base.size){
+		EVDI_ERROR("Wrong cursor size\n");
+		return -EINVAL;
+	}
+
+	cursor_buffer = (uint32_t *)cursor->obj->vmapping;
+
+	for (y = -h_cursor_h; y < h_cursor_h; ++y) {
+		for (x = -h_cursor_w; x < h_cursor_w; ++x) {
+			uint32_t curs_val;
+			int *fbsrc;
+			int fb_value;
+			int cmd_offset;
+			int cursor_pix;
+			int const mouse_pix_x = cursor->x + x + h_cursor_w;
+			int const mouse_pix_y = cursor->y + y + h_cursor_h;
+			bool const is_pix_sane =
+				mouse_pix_x >= 0 &&
+				mouse_pix_y >= 0 &&
+				mouse_pix_x < (int)fb->width &&
+				mouse_pix_y < (int)fb->height;
+
+			if (!is_pix_sane)
+				continue;
+
+			cursor_pix = h_cursor_w+x +
+				    (h_cursor_h+y)*cursor->width;
+			curs_val = le32_to_cpu(cursor_buffer[cursor_pix]);
+			fbsrc = (int *)(efb->obj->vmapping + fb->offsets[0]);
+			fb_value = *(fbsrc + ((fb->pitches[0]>>2) *
+						  mouse_pix_y + mouse_pix_x));
+			cmd_offset = (buf_byte_stride * mouse_pix_y) +
+						       (mouse_pix_x * bytespp);
+			if (evdi_cursor_compose_pixel(buffer,
+						      curs_val,
+						      fb_value,
+						      cmd_offset)) {
+				EVDI_ERROR("Failed to compose cursor pixel\n");
+				return -EFAULT;
+			}
+		}
+	}
+
+	return 0;
+}
+
+void evdi_cursor_position(struct evdi_cursor *cursor, int32_t *x, int32_t *y)
+{
+	*x = cursor->x;
+	*y = cursor->y;
+}
+
+void evdi_cursor_hotpoint(struct evdi_cursor *cursor,
+			  int32_t *hot_x, int32_t *hot_y)
+{
+	*hot_x = cursor->hot_x;
+	*hot_y = cursor->hot_y;
+}
+
+void evdi_cursor_size(struct evdi_cursor *cursor,
+		      uint32_t *width, uint32_t *height)
+{
+	*width = cursor->width;
+	*height = cursor->height;
+}
+
+void evdi_cursor_format(struct evdi_cursor *cursor, uint32_t *format)
+{
+	*format = cursor->pixel_format;
+}
+
+void evdi_cursor_stride(struct evdi_cursor *cursor, uint32_t *stride)
+{
+	*stride = cursor->stride;
+}
+
diff --git a/drivers/custom/evdi/module/evdi_cursor.h b/drivers/custom/evdi/module/evdi_cursor.h
new file mode 100644
index 000000000000..13d8a8ab3687
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_cursor.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * evdi_cursor.h
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2016 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _EVDI_CURSOR_H_
+#define _EVDI_CURSOR_H_
+
+#include <linux/version.h>
+#include <linux/module.h>
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_crtc.h>
+
+struct evdi_cursor;
+struct evdi_framebuffer;
+struct evdi_gem_object;
+
+int evdi_cursor_init(struct evdi_cursor **cursor);
+void evdi_cursor_free(struct evdi_cursor *cursor);
+void evdi_cursor_lock(struct evdi_cursor *cursor);
+void evdi_cursor_unlock(struct evdi_cursor *cursor);
+bool evdi_cursor_enabled(struct evdi_cursor *cursor);
+void evdi_cursor_enable(struct evdi_cursor *cursor, bool enabled);
+void evdi_cursor_set(struct evdi_cursor *cursor,
+		     struct evdi_gem_object *obj,
+		     uint32_t width, uint32_t height,
+		     int32_t hot_x, int32_t hot_y,
+		     uint32_t pixel_format, uint32_t stride);
+
+void evdi_cursor_move(struct evdi_cursor *cursor, int32_t x, int32_t y);
+void evdi_cursor_position(struct evdi_cursor *cursor, int32_t *x, int32_t *y);
+void evdi_cursor_hotpoint(struct evdi_cursor *cursor,
+			  int32_t *hot_x, int32_t *hot_y);
+void evdi_cursor_size(struct evdi_cursor *cursor,
+		      uint32_t *width, uint32_t *height);
+void evdi_cursor_format(struct evdi_cursor *cursor, uint32_t *format);
+void evdi_cursor_stride(struct evdi_cursor *cursor, uint32_t *stride);
+struct evdi_gem_object *evdi_cursor_gem(struct evdi_cursor *cursor);
+
+int evdi_cursor_compose_and_copy(struct evdi_cursor *cursor,
+				 struct evdi_framebuffer *efb,
+				 char __user *buffer,
+				 int buf_byte_stride);
+#endif
diff --git a/drivers/custom/evdi/module/evdi_debug.c b/drivers/custom/evdi/module/evdi_debug.c
new file mode 100644
index 000000000000..0f941d35bebf
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_debug.c
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* Copyright (c) 2015 - 2019 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+
+#include "evdi_debug.h"
+
+void evdi_log_process(char *buf, size_t size)
+{
+	int task_pid = (int)task_pid_nr(current);
+	char task_comm[TASK_COMM_LEN] = { 0 };
+
+	get_task_comm(task_comm, current);
+
+	if (current->group_leader) {
+		char process_comm[TASK_COMM_LEN] = { 0 };
+
+		get_task_comm(process_comm, current->group_leader);
+		snprintf(buf, size, "Task %d (%s) of process %d (%s)",
+			  task_pid,
+			  task_comm,
+			  (int)task_pid_nr(current->group_leader),
+			  process_comm);
+	} else {
+		snprintf(buf, size, "Task %d (%s)",
+			  task_pid,
+			  task_comm);
+	}
+}
diff --git a/drivers/custom/evdi/module/evdi_debug.h b/drivers/custom/evdi/module/evdi_debug.h
new file mode 100644
index 000000000000..14000811e03b
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_debug.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (c) 2015 - 2019 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_DEBUG_H
+#define EVDI_DEBUG_H
+
+#include "evdi_params.h"
+
+#define EVDI_LOGLEVEL_FATAL   1
+#define EVDI_LOGLEVEL_ERROR   2
+#define EVDI_LOGLEVEL_WARN    3
+#define EVDI_LOGLEVEL_INFO    4
+#define EVDI_LOGLEVEL_DEBUG   5
+#define EVDI_LOGLEVEL_VERBOSE 6
+
+#define EVDI_PRINTK(KERN_LEVEL, LEVEL, FORMAT_STR, ...)	do { \
+	if (evdi_loglevel >= LEVEL) {\
+		printk(KERN_LEVEL "evdi: " FORMAT_STR, ##__VA_ARGS__); \
+	} \
+} while (0)
+
+#define EVDI_FATAL(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_CRIT, EVDI_LOGLEVEL_FATAL,\
+		    "[F] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_ERROR(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_ERR, EVDI_LOGLEVEL_ERROR,\
+		    "[E] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_WARN(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_WARNING, EVDI_LOGLEVEL_WARN,\
+		    "[W] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_INFO(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_INFO,\
+		    "[I] " FORMAT_STR, ##__VA_ARGS__)
+
+#define EVDI_DEBUG(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_DEBUG,\
+		    "[D] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_VERBOSE(FORMAT_STR, ...) \
+	EVDI_PRINTK(KERN_DEFAULT, EVDI_LOGLEVEL_VERBOSE,\
+		    "[V] %s:%d " FORMAT_STR, __func__, __LINE__, ##__VA_ARGS__)
+
+#define EVDI_CHECKPT() EVDI_VERBOSE("\n")
+#define EVDI_ENTER() EVDI_VERBOSE("enter\n")
+#define EVDI_EXIT() EVDI_VERBOSE("exit\n")
+
+void evdi_log_process(char *buf, size_t size);
+
+#endif /* EVDI_DEBUG_H */
diff --git a/drivers/custom/evdi/module/evdi_drm.h b/drivers/custom/evdi/module/evdi_drm.h
new file mode 100644
index 000000000000..501269379627
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_drm.h
@@ -0,0 +1,139 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
+ *
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef __UAPI_EVDI_DRM_H__
+#define __UAPI_EVDI_DRM_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <drm/drm.h>
+#else
+#include <stdint.h>
+#endif
+
+/* Output events sent from driver to evdi lib */
+#define DRM_EVDI_EVENT_UPDATE_READY  0x80000000
+#define DRM_EVDI_EVENT_DPMS          0x80000001
+#define DRM_EVDI_EVENT_MODE_CHANGED  0x80000002
+#define DRM_EVDI_EVENT_CRTC_STATE    0x80000003
+#define DRM_EVDI_EVENT_CURSOR_SET    0x80000004
+#define DRM_EVDI_EVENT_CURSOR_MOVE   0x80000005
+#define DRM_EVDI_EVENT_DDCCI_DATA    0x80000006
+
+struct drm_evdi_event_update_ready {
+	struct drm_event base;
+};
+
+struct drm_evdi_event_dpms {
+	struct drm_event base;
+	int32_t mode;
+};
+
+struct drm_evdi_event_mode_changed {
+	struct drm_event base;
+	int32_t hdisplay;
+	int32_t vdisplay;
+	int32_t vrefresh;
+	int32_t bits_per_pixel;
+	uint32_t pixel_format;
+};
+
+struct drm_evdi_event_crtc_state {
+	struct drm_event base;
+	int32_t state;
+};
+
+struct drm_evdi_connect {
+	int32_t connected;
+	int32_t dev_index;
+	const unsigned char * __user edid;
+	uint32_t edid_length;
+	uint32_t pixel_area_limit;
+	uint32_t pixel_per_second_limit;
+};
+
+struct drm_evdi_request_update {
+	int32_t reserved;
+};
+
+enum drm_evdi_grabpix_mode {
+	EVDI_GRABPIX_MODE_RECTS = 0,
+	EVDI_GRABPIX_MODE_DIRTY = 1,
+};
+
+struct drm_evdi_grabpix {
+	enum drm_evdi_grabpix_mode mode;
+	int32_t buf_width;
+	int32_t buf_height;
+	int32_t buf_byte_stride;
+	unsigned char __user *buffer;
+	int32_t num_rects;
+	struct drm_clip_rect __user *rects;
+};
+
+struct drm_evdi_event_cursor_set {
+	struct drm_event base;
+	int32_t hot_x;
+	int32_t hot_y;
+	uint32_t width;
+	uint32_t height;
+	uint8_t enabled;
+	uint32_t buffer_handle;
+	uint32_t buffer_length;
+	uint32_t pixel_format;
+	uint32_t stride;
+};
+
+struct drm_evdi_event_cursor_move {
+	struct drm_event base;
+	int32_t x;
+	int32_t y;
+};
+
+struct drm_evdi_ddcci_response {
+	const unsigned char * __user buffer;
+	uint32_t buffer_length;
+	uint8_t result;
+};
+
+struct drm_evdi_enable_cursor_events {
+	struct drm_event base;
+	uint8_t enable;
+};
+
+#define DDCCI_BUFFER_SIZE 64
+
+struct drm_evdi_event_ddcci_data {
+	struct drm_event base;
+	unsigned char buffer[DDCCI_BUFFER_SIZE];
+	uint32_t buffer_length;
+	uint16_t flags;
+	uint16_t address;
+};
+
+/* Input ioctls from evdi lib to driver */
+#define DRM_EVDI_CONNECT          0x00
+#define DRM_EVDI_REQUEST_UPDATE   0x01
+#define DRM_EVDI_GRABPIX          0x02
+#define DRM_EVDI_DDCCI_RESPONSE   0x03
+#define DRM_EVDI_ENABLE_CURSOR_EVENTS 0x04
+/* LAST_IOCTL 0x5F -- 96 driver specific ioctls to use */
+
+#define DRM_IOCTL_EVDI_CONNECT DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_CONNECT, struct drm_evdi_connect)
+#define DRM_IOCTL_EVDI_REQUEST_UPDATE DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_REQUEST_UPDATE, struct drm_evdi_request_update)
+#define DRM_IOCTL_EVDI_GRABPIX DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_GRABPIX, struct drm_evdi_grabpix)
+#define DRM_IOCTL_EVDI_DDCCI_RESPONSE DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_DDCCI_RESPONSE, struct drm_evdi_ddcci_response)
+#define DRM_IOCTL_EVDI_ENABLE_CURSOR_EVENTS DRM_IOWR(DRM_COMMAND_BASE +  \
+	DRM_EVDI_ENABLE_CURSOR_EVENTS, struct drm_evdi_enable_cursor_events)
+
+#endif /* __EVDI_UAPI_DRM_H__ */
diff --git a/drivers/custom/evdi/module/evdi_drm_drv.c b/drivers/custom/evdi/module/evdi_drm_drv.c
new file mode 100644
index 000000000000..dba8b4be2535
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_drm_drv.c
@@ -0,0 +1,311 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_ioctl.h>
+#include <drm/drm_file.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_vblank.h>
+#elif KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+#else
+#include <drm/drmP.h>
+#endif
+#if KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_probe_helper.h>
+#endif
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_managed.h>
+#endif
+#include <drm/drm_atomic_helper.h>
+#include "evdi_drm_drv.h"
+#include "evdi_platform_drv.h"
+#include "evdi_cursor.h"
+#include "evdi_debug.h"
+#include "evdi_drm.h"
+
+#if KERNEL_VERSION(6, 8, 0) <= LINUX_VERSION_CODE || defined(EL9)
+#define EVDI_DRM_UNLOCKED 0
+#else
+#define EVDI_DRM_UNLOCKED DRM_UNLOCKED
+#endif
+
+static struct drm_driver driver;
+
+struct drm_ioctl_desc evdi_painter_ioctls[] = {
+	DRM_IOCTL_DEF_DRV(EVDI_CONNECT, evdi_painter_connect_ioctl, EVDI_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_REQUEST_UPDATE, evdi_painter_request_update_ioctl, EVDI_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_GRABPIX, evdi_painter_grabpix_ioctl, EVDI_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_DDCCI_RESPONSE, evdi_painter_ddcci_response_ioctl, EVDI_DRM_UNLOCKED),
+	DRM_IOCTL_DEF_DRV(EVDI_ENABLE_CURSOR_EVENTS, evdi_painter_enable_cursor_events_ioctl, EVDI_DRM_UNLOCKED),
+};
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+static const struct vm_operations_struct evdi_gem_vm_ops = {
+	.fault = evdi_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+#endif
+
+static const struct file_operations evdi_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.mmap = evdi_drm_gem_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+	.unlocked_ioctl = drm_ioctl,
+	.release = drm_release,
+
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = evdi_compat_ioctl,
+#endif
+
+	.llseek = noop_llseek,
+
+#if defined(FOP_UNSIGNED_OFFSET)
+	.fop_flags = FOP_UNSIGNED_OFFSET,
+#endif
+};
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+static int evdi_enable_vblank(__always_unused struct drm_device *dev,
+			      __always_unused unsigned int pipe)
+{
+	return 1;
+}
+
+static void evdi_disable_vblank(__always_unused struct drm_device *dev,
+				__always_unused unsigned int pipe)
+{
+}
+#endif
+
+static struct drm_driver driver = {
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,
+#else
+	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME
+			 | DRIVER_ATOMIC,
+#endif
+
+	.open = evdi_driver_open,
+	.postclose = evdi_driver_postclose,
+
+#if KERNEL_VERSION(6, 15, 0) <= LINUX_VERSION_CODE
+#ifdef CONFIG_FB
+	.fbdev_probe = evdifb_create,
+#endif
+#endif
+
+	/* gem hooks */
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#elif KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE
+	.gem_free_object_unlocked = evdi_gem_free_object,
+#else
+	.gem_free_object = evdi_gem_free_object,
+#endif
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	.gem_vm_ops = &evdi_gem_vm_ops,
+#endif
+
+	.dumb_create = evdi_dumb_create,
+	.dumb_map_offset = evdi_gem_mmap,
+#if KERNEL_VERSION(5, 12, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	.dumb_destroy = drm_gem_dumb_destroy,
+#endif
+
+	.ioctls = evdi_painter_ioctls,
+	.num_ioctls = ARRAY_SIZE(evdi_painter_ioctls),
+
+	.fops = &evdi_driver_fops,
+
+	.gem_prime_import = drm_gem_prime_import,
+#if KERNEL_VERSION(6, 6, 0) <= LINUX_VERSION_CODE || defined(EL9)
+#else
+	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
+#endif
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	.preclose = evdi_driver_preclose,
+	.gem_prime_export = drm_gem_prime_export,
+	.gem_prime_get_sg_table = evdi_prime_get_sg_table,
+	.enable_vblank = evdi_enable_vblank,
+	.disable_vblank = evdi_disable_vblank,
+#endif
+	.gem_prime_import_sg_table = evdi_prime_import_sg_table,
+
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+#if KERNEL_VERSION(6, 14, 0) <= LINUX_VERSION_CODE
+#else
+	.date = DRIVER_DATE,
+#endif
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCH,
+};
+
+static void evdi_drm_device_release_cb(__always_unused struct drm_device *dev,
+				       __always_unused void *ptr)
+{
+	struct evdi_device *evdi = dev->dev_private;
+
+	evdi_cursor_free(evdi->cursor);
+	evdi_painter_cleanup(evdi->painter);
+	kfree(evdi);
+	dev->dev_private = NULL;
+	EVDI_INFO("Evdi drm_device removed.\n");
+
+	EVDI_TEST_HOOK(evdi_testhook_drm_device_destroyed());
+}
+
+static int evdi_drm_device_init(struct drm_device *dev)
+{
+	struct evdi_device *evdi;
+	int ret;
+
+	EVDI_CHECKPT();
+	evdi = kzalloc(sizeof(struct evdi_device), GFP_KERNEL);
+	if (!evdi)
+		return -ENOMEM;
+
+	evdi->ddev = dev;
+	evdi->dev_index = dev->primary->index;
+	evdi->cursor_events_enabled = false;
+	dev->dev_private = evdi;
+	ret = evdi_painter_init(evdi);
+	if (ret)
+		goto err_free;
+	ret =  evdi_cursor_init(&evdi->cursor);
+	if (ret)
+		goto err_free;
+
+	evdi_modeset_init(dev);
+#ifdef CONFIG_FB
+	ret = evdi_fbdev_init(dev);
+	if (ret)
+		goto err_init;
+#endif /* CONFIG_FB */
+
+	ret = drm_vblank_init(dev, 1);
+	if (ret)
+		goto err_init;
+	drm_kms_helper_poll_init(dev);
+
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	ret = drmm_add_action_or_reset(dev, evdi_drm_device_release_cb, NULL);
+	if (ret)
+		goto err_init;
+#endif
+
+	return 0;
+
+err_init:
+#ifdef CONFIG_FB
+	evdi_fbdev_cleanup(dev);
+#endif /* CONFIG_FB */
+err_free:
+	EVDI_ERROR("Failed to setup drm device %d\n", ret);
+	evdi_cursor_free(evdi->cursor);
+	kfree(evdi->painter);
+	kfree(evdi);
+	dev->dev_private = NULL;
+	return ret;
+}
+
+int evdi_driver_open(struct drm_device *dev, __always_unused struct drm_file *file)
+{
+	char buf[100];
+
+	evdi_log_process(buf, sizeof(buf));
+	EVDI_INFO("(card%d) Opened by %s\n", dev->primary->index, buf);
+	return 0;
+}
+
+static void evdi_driver_close(struct drm_device *drm_dev, struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+
+	EVDI_CHECKPT();
+	if (evdi)
+		evdi_painter_close(evdi, file);
+}
+
+void evdi_driver_preclose(struct drm_device *drm_dev, struct drm_file *file)
+{
+	evdi_driver_close(drm_dev, file);
+}
+
+void evdi_driver_postclose(struct drm_device *dev, struct drm_file *file)
+{
+	char buf[100];
+
+	evdi_log_process(buf, sizeof(buf));
+	evdi_driver_close(dev, file);
+	EVDI_INFO("(card%d) Closed by %s\n", dev->primary->index, buf);
+}
+
+struct drm_device *evdi_drm_device_create(struct device *parent)
+{
+	struct drm_device *dev = NULL;
+	int ret;
+
+	dev = drm_dev_alloc(&driver, parent);
+	if (IS_ERR(dev))
+		return dev;
+
+	ret = evdi_drm_device_init(dev);
+	if (ret)
+		goto err_free;
+
+	ret = drm_dev_register(dev, 0);
+	if (ret)
+		goto err_free;
+
+	return dev;
+
+err_free:
+	drm_dev_put(dev);
+	return ERR_PTR(ret);
+}
+
+static void evdi_drm_device_deinit(struct drm_device *dev)
+{
+	drm_kms_helper_poll_fini(dev);
+#ifdef CONFIG_FB
+	evdi_fbdev_unplug(dev);
+	evdi_fbdev_cleanup(dev);
+#endif /* CONFIG_FB */
+	evdi_modeset_cleanup(dev);
+	drm_atomic_helper_shutdown(dev);
+}
+
+int evdi_drm_device_remove(struct drm_device *dev)
+{
+	drm_dev_unplug(dev);
+	evdi_drm_device_deinit(dev);
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	evdi_drm_device_release_cb(dev, NULL);
+#endif
+	drm_dev_put(dev);
+	return 0;
+}
+
diff --git a/drivers/custom/evdi/module/evdi_drm_drv.h b/drivers/custom/evdi/module/evdi_drm_drv.h
new file mode 100644
index 000000000000..748046c7f38c
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_drm_drv.h
@@ -0,0 +1,195 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_DRV_H
+#define EVDI_DRV_H
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_drv.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_vblank.h>
+#else
+#include <drm/drmP.h>
+#endif
+#if KERNEL_VERSION(5, 15, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_framebuffer.h>
+#else
+#include <drm/drm_irq.h>
+#endif
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_rect.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_fb_helper.h>
+
+#include "evdi_debug.h"
+#include "tests/evdi_test.h"
+
+struct evdi_fbdev;
+struct evdi_painter;
+
+struct evdi_device {
+	struct drm_device *ddev;
+	struct drm_connector *conn;
+	struct evdi_cursor *cursor;
+	bool cursor_events_enabled;
+
+	uint32_t pixel_area_limit;
+	uint32_t pixel_per_second_limit;
+
+	struct evdi_fbdev *fbdev;
+	struct evdi_painter *painter;
+	struct i2c_adapter *i2c_adapter;
+
+	int dev_index;
+};
+
+struct evdi_gem_object {
+	struct drm_gem_object base;
+	struct page **pages;
+	unsigned int pages_pin_count;
+	struct mutex pages_lock;
+	void *vmapping;
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	bool vmap_is_iomem;
+#endif
+	struct sg_table *sg;
+	bool allow_sw_cursor_rect_updates;
+};
+
+#define to_evdi_bo(x) container_of(x, struct evdi_gem_object, base)
+
+struct evdi_framebuffer {
+	struct drm_framebuffer base;
+	struct evdi_gem_object *obj;
+	bool active;
+};
+
+#define to_evdi_fb(x) container_of(x, struct evdi_framebuffer, base)
+
+/* modeset */
+void evdi_modeset_init(struct drm_device *dev);
+void evdi_modeset_cleanup(struct drm_device *dev);
+int evdi_connector_init(struct drm_device *dev, struct drm_encoder *encoder);
+
+struct drm_encoder *evdi_encoder_init(struct drm_device *dev);
+
+int evdi_driver_open(struct drm_device *drm_dev, struct drm_file *file);
+void evdi_driver_preclose(struct drm_device *dev, struct drm_file *file_priv);
+void evdi_driver_postclose(struct drm_device *dev, struct drm_file *file_priv);
+
+#ifdef CONFIG_COMPAT
+long evdi_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+
+
+#ifdef CONFIG_FB
+int evdi_fbdev_init(struct drm_device *dev);
+void evdi_fbdev_cleanup(struct drm_device *dev);
+void evdi_fbdev_unplug(struct drm_device *dev);
+int evdifb_create(struct drm_fb_helper *helper,
+			 struct drm_fb_helper_surface_size *sizes);
+#endif /* CONFIG_FB */
+struct drm_framebuffer *evdi_fb_user_fb_create(
+				struct drm_device *dev,
+				struct drm_file *file,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+				const struct drm_format_info *info,
+#endif
+				const struct drm_mode_fb_cmd2 *mode_cmd);
+
+int evdi_dumb_create(struct drm_file *file_priv,
+		     struct drm_device *dev, struct drm_mode_create_dumb *args);
+int evdi_gem_mmap(struct drm_file *file_priv,
+		  struct drm_device *dev, uint32_t handle, uint64_t *offset);
+
+void evdi_gem_free_object(struct drm_gem_object *gem_obj);
+struct evdi_gem_object *evdi_gem_alloc_object(struct drm_device *dev,
+					      size_t size);
+uint32_t evdi_gem_object_handle_lookup(struct drm_file *filp,
+				      struct drm_gem_object *obj);
+
+struct sg_table *evdi_prime_get_sg_table(struct drm_gem_object *obj);
+struct drm_gem_object *
+evdi_prime_import_sg_table(struct drm_device *dev,
+			   struct dma_buf_attachment *attach,
+			   struct sg_table *sg);
+
+int evdi_gem_vmap(struct evdi_gem_object *obj);
+void evdi_gem_vunmap(struct evdi_gem_object *obj);
+int evdi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+
+#if KERNEL_VERSION(4, 17, 0) <= LINUX_VERSION_CODE
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf);
+#else
+int evdi_gem_fault(struct vm_fault *vmf);
+#endif
+
+bool evdi_painter_is_connected(struct evdi_painter *painter);
+void evdi_painter_close(struct evdi_device *evdi, struct drm_file *file);
+u8 *evdi_painter_get_edid_copy(struct evdi_device *evdi);
+int evdi_painter_get_num_dirts(struct evdi_painter *painter);
+void evdi_painter_mark_dirty(struct evdi_device *evdi,
+			     const struct drm_clip_rect *rect);
+void evdi_painter_set_vblank(struct evdi_painter *painter,
+			     struct drm_crtc *crtc,
+			     struct drm_pending_vblank_event *vblank);
+void evdi_painter_send_update_ready_if_needed(struct evdi_painter *painter);
+void evdi_painter_dpms_notify(struct evdi_painter *painter, int mode);
+void evdi_painter_mode_changed_notify(struct evdi_device *evdi,
+				      struct drm_display_mode *mode);
+unsigned int evdi_painter_poll(struct file *filp,
+			       struct poll_table_struct *wait);
+
+int evdi_painter_status_ioctl(struct drm_device *drm_dev, void *data,
+			      struct drm_file *file);
+int evdi_painter_connect_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file);
+int evdi_painter_grabpix_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file);
+int evdi_painter_request_update_ioctl(struct drm_device *drm_dev, void *data,
+				      struct drm_file *file);
+int evdi_painter_ddcci_response_ioctl(struct drm_device *drm_dev, void *data,
+				      struct drm_file *file);
+int evdi_painter_enable_cursor_events_ioctl(struct drm_device *drm_dev, void *data,
+					  struct drm_file *file);
+
+int evdi_painter_init(struct evdi_device *evdi);
+void evdi_painter_cleanup(struct evdi_painter *painter);
+void evdi_painter_set_scanout_buffer(struct evdi_painter *painter,
+				     struct evdi_framebuffer *buffer);
+
+struct drm_clip_rect evdi_framebuffer_sanitize_rect(
+			const struct evdi_framebuffer *fb,
+			const struct drm_clip_rect *rect);
+
+struct drm_device *evdi_drm_device_create(struct device *parent);
+int evdi_drm_device_remove(struct drm_device *dev);
+
+void evdi_painter_send_cursor_set(struct evdi_painter *painter,
+				  struct evdi_cursor *cursor);
+void evdi_painter_send_cursor_move(struct evdi_painter *painter,
+				   struct evdi_cursor *cursor);
+bool evdi_painter_needs_full_modeset(struct evdi_painter *painter);
+void evdi_painter_force_full_modeset(struct evdi_painter *painter);
+struct drm_clip_rect evdi_painter_framebuffer_size(struct evdi_painter *painter);
+bool evdi_painter_i2c_data_notify(struct evdi_painter *painter, struct i2c_msg *msg);
+
+int evdi_fb_get_bpp(uint32_t format);
+#endif
diff --git a/drivers/custom/evdi/module/evdi_encoder.c b/drivers/custom/evdi/module/evdi_encoder.c
new file mode 100644
index 000000000000..47fd19f29025
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_encoder.c
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_encoder.h>
+#include <drm/drm_modeset_helper_vtables.h>
+#include "evdi_drm_drv.h"
+
+/* dummy encoder */
+static void evdi_enc_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+	kfree(encoder);
+}
+
+static void evdi_encoder_enable(__always_unused struct drm_encoder *encoder)
+{
+}
+
+static void evdi_encoder_disable(__always_unused struct drm_encoder *encoder)
+{
+}
+
+static const struct drm_encoder_helper_funcs evdi_enc_helper_funcs = {
+	.enable = evdi_encoder_enable,
+	.disable = evdi_encoder_disable
+};
+
+static const struct drm_encoder_funcs evdi_enc_funcs = {
+	.destroy = evdi_enc_destroy,
+};
+
+struct drm_encoder *evdi_encoder_init(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+	int ret = 0;
+
+	encoder = kzalloc(sizeof(struct drm_encoder), GFP_KERNEL);
+	if (!encoder)
+		goto err;
+
+	ret = drm_encoder_init(dev, encoder, &evdi_enc_funcs,
+			       DRM_MODE_ENCODER_TMDS, "%s", dev_name(dev->dev));
+	if (ret) {
+		EVDI_ERROR("Failed to initialize encoder: %d\n", ret);
+		goto err_encoder;
+	}
+
+	drm_encoder_helper_add(encoder, &evdi_enc_helper_funcs);
+
+	encoder->possible_crtcs = 1;
+	return encoder;
+
+err_encoder:
+	kfree(encoder);
+err:
+	return NULL;
+}
diff --git a/drivers/custom/evdi/module/evdi_fb.c b/drivers/custom/evdi/module/evdi_fb.c
new file mode 100644
index 000000000000..e96ec9864d87
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_fb.c
@@ -0,0 +1,663 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/slab.h>
+#ifdef CONFIG_FB
+#include <linux/fb.h>
+#endif /* CONFIG_FB */
+#include <linux/dma-buf.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_atomic.h>
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_damage_helper.h>
+#endif
+#include "evdi_drm_drv.h"
+
+
+struct evdi_fbdev {
+	struct drm_fb_helper helper;
+	struct evdi_framebuffer efb;
+	struct list_head fbdev_list;
+	const struct fb_ops *fb_ops;
+	int fb_count;
+};
+
+struct drm_clip_rect evdi_framebuffer_sanitize_rect(
+				const struct evdi_framebuffer *fb,
+				const struct drm_clip_rect *dirty_rect)
+{
+	struct drm_clip_rect rect = *dirty_rect;
+
+	if (rect.x1 > rect.x2) {
+		unsigned short tmp = rect.x2;
+
+		EVDI_WARN("Wrong clip rect: x1 > x2\n");
+		rect.x2 = rect.x1;
+		rect.x1 = tmp;
+	}
+
+	if (rect.y1 > rect.y2) {
+		unsigned short tmp = rect.y2;
+
+		EVDI_WARN("Wrong clip rect: y1 > y2\n");
+		rect.y2 = rect.y1;
+		rect.y1 = tmp;
+	}
+
+
+	if (rect.x1 > fb->base.width) {
+		EVDI_DEBUG("Wrong clip rect: x1 > fb.width\n");
+		rect.x1 = fb->base.width;
+	}
+
+	if (rect.y1 > fb->base.height) {
+		EVDI_DEBUG("Wrong clip rect: y1 > fb.height\n");
+		rect.y1 = fb->base.height;
+	}
+
+	if (rect.x2 > fb->base.width) {
+		EVDI_DEBUG("Wrong clip rect: x2 > fb.width\n");
+		rect.x2 = fb->base.width;
+	}
+
+	if (rect.y2 > fb->base.height) {
+		EVDI_DEBUG("Wrong clip rect: y2 > fb.height\n");
+		rect.y2 = fb->base.height;
+	}
+
+	return rect;
+}
+
+#ifdef CONFIG_FB
+static int evdi_handle_damage(struct evdi_framebuffer *fb,
+		       int x, int y, int width, int height)
+{
+	const struct drm_clip_rect dirty_rect = { x, y, x + width, y + height };
+	const struct drm_clip_rect rect =
+		evdi_framebuffer_sanitize_rect(fb, &dirty_rect);
+	struct drm_device *dev = fb->base.dev;
+	struct evdi_device *evdi = dev->dev_private;
+
+	EVDI_CHECKPT();
+
+	if (!fb->active)
+		return 0;
+	evdi_painter_set_scanout_buffer(evdi->painter, fb);
+	evdi_painter_mark_dirty(evdi, &rect);
+
+	return 0;
+}
+
+static int evdi_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+	unsigned long start = vma->vm_start;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long page, pos;
+
+	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))
+		return -EINVAL;
+
+	if (offset > info->fix.smem_len ||
+	    size > info->fix.smem_len - offset)
+		return -EINVAL;
+
+	pos = (unsigned long)info->fix.smem_start + offset;
+
+	pr_notice("mmap() framebuffer addr:%lu size:%lu\n", pos, size);
+
+	while (size > 0) {
+		page = vmalloc_to_pfn((void *)pos);
+		if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		if (size > PAGE_SIZE)
+			size -= PAGE_SIZE;
+		else
+			size = 0;
+	}
+
+	return 0;
+}
+
+static void evdi_fb_fillrect(struct fb_info *info,
+			     const struct fb_fillrect *rect)
+{
+	struct evdi_fbdev *efbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_fillrect(info, rect);
+	evdi_handle_damage(&efbdev->efb, rect->dx, rect->dy, rect->width,
+			   rect->height);
+}
+
+static void evdi_fb_copyarea(struct fb_info *info,
+			     const struct fb_copyarea *region)
+{
+	struct evdi_fbdev *efbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_copyarea(info, region);
+	evdi_handle_damage(&efbdev->efb, region->dx, region->dy, region->width,
+			   region->height);
+}
+
+static void evdi_fb_imageblit(struct fb_info *info,
+			      const struct fb_image *image)
+{
+	struct evdi_fbdev *efbdev = info->par;
+
+	EVDI_CHECKPT();
+	sys_imageblit(info, image);
+	evdi_handle_damage(&efbdev->efb, image->dx, image->dy, image->width,
+			   image->height);
+}
+
+/*
+ * It's common for several clients to have framebuffer open simultaneously.
+ * e.g. both fbcon and X. Makes things interesting.
+ * Assumes caller is holding info->lock (for open and release at least)
+ */
+static int evdi_fb_open(struct fb_info *info, int user)
+{
+	struct evdi_fbdev *efbdev = info->par;
+
+	efbdev->fb_count++;
+	pr_notice("open /dev/fb%d user=%d fb_info=%p count=%d\n",
+		  info->node, user, info, efbdev->fb_count);
+
+	return 0;
+}
+
+/*
+ * Assumes caller is holding info->lock mutex (for open and release at least)
+ */
+static int evdi_fb_release(struct fb_info *info, int user)
+{
+	struct evdi_fbdev *efbdev = info->par;
+
+	efbdev->fb_count--;
+
+	pr_warn("released /dev/fb%d user=%d count=%d\n",
+		info->node, user, efbdev->fb_count);
+
+	return 0;
+}
+static const struct fb_ops evdifb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = drm_fb_helper_check_var,
+	.fb_set_par = drm_fb_helper_set_par,
+	.fb_fillrect = evdi_fb_fillrect,
+	.fb_copyarea = evdi_fb_copyarea,
+	.fb_imageblit = evdi_fb_imageblit,
+	.fb_pan_display = drm_fb_helper_pan_display,
+	.fb_blank = drm_fb_helper_blank,
+	.fb_setcmap = drm_fb_helper_setcmap,
+	.fb_debug_enter = drm_fb_helper_debug_enter,
+	.fb_debug_leave = drm_fb_helper_debug_leave,
+	.fb_mmap = evdi_fb_mmap,
+	.fb_open = evdi_fb_open,
+	.fb_release = evdi_fb_release,
+};
+#endif /* CONFIG_FB */
+
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+/*
+ * Function taken from
+ * https://lore.kernel.org/dri-devel/20180905233901.2321-5-drawat@vmware.com/
+ */
+static int evdi_user_framebuffer_dirty(
+		struct drm_framebuffer *fb,
+		__maybe_unused struct drm_file *file_priv,
+		__always_unused unsigned int flags,
+		__always_unused unsigned int color,
+		__always_unused struct drm_clip_rect *clips,
+		__always_unused unsigned int num_clips)
+{
+	struct evdi_framebuffer *efb = to_evdi_fb(fb);
+	struct drm_device *dev = efb->base.dev;
+	struct evdi_device *evdi = dev->dev_private;
+
+	struct drm_modeset_acquire_ctx ctx;
+	struct drm_atomic_state *state;
+	struct drm_plane *plane;
+	int ret = 0;
+	unsigned int i;
+
+	EVDI_CHECKPT();
+
+	drm_modeset_acquire_init(&ctx,
+		/*
+		 * When called from ioctl, we are interruptable,
+		 * but not when called internally (ie. defio worker)
+		 */
+		file_priv ? DRM_MODESET_ACQUIRE_INTERRUPTIBLE :	0);
+
+	state = drm_atomic_state_alloc(fb->dev);
+	if (!state) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	state->acquire_ctx = &ctx;
+
+	for (i = 0; i < num_clips; ++i)
+		evdi_painter_mark_dirty(evdi, &clips[i]);
+
+retry:
+
+	drm_for_each_plane(plane, fb->dev) {
+		struct drm_plane_state *plane_state;
+
+		if (plane->state->fb != fb)
+			continue;
+
+		/*
+		 * Even if it says 'get state' this function will create and
+		 * initialize state if it does not exists. We use this property
+		 * to force create state.
+		 */
+		plane_state = drm_atomic_get_plane_state(state, plane);
+		if (IS_ERR(plane_state)) {
+			ret = PTR_ERR(plane_state);
+			goto out;
+		}
+	}
+
+	ret = drm_atomic_commit(state);
+
+out:
+	if (ret == -EDEADLK) {
+		drm_atomic_state_clear(state);
+		ret = drm_modeset_backoff(&ctx);
+		if (!ret)
+			goto retry;
+	}
+
+	if (state)
+		drm_atomic_state_put(state);
+
+	drm_modeset_drop_locks(&ctx);
+	drm_modeset_acquire_fini(&ctx);
+
+	return ret;
+}
+#endif
+
+static int evdi_user_framebuffer_create_handle(struct drm_framebuffer *fb,
+					       struct drm_file *file_priv,
+					       unsigned int *handle)
+{
+	struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+	return drm_gem_handle_create(file_priv, &efb->obj->base, handle);
+}
+
+static void evdi_user_framebuffer_destroy(struct drm_framebuffer *fb)
+{
+	struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+	EVDI_CHECKPT();
+	if (efb->obj)
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		drm_gem_object_put(&efb->obj->base);
+#else
+		drm_gem_object_put_unlocked(&efb->obj->base);
+#endif
+	drm_framebuffer_cleanup(fb);
+	kfree(efb);
+}
+
+static const struct drm_framebuffer_funcs evdifb_funcs = {
+	.create_handle = evdi_user_framebuffer_create_handle,
+	.destroy = evdi_user_framebuffer_destroy,
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	.dirty = drm_atomic_helper_dirtyfb,
+#else
+	.dirty = evdi_user_framebuffer_dirty,
+#endif
+};
+
+static int
+evdi_framebuffer_init(struct drm_device *dev,
+		      struct evdi_framebuffer *efb,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+		      const struct drm_format_info *info,
+#endif
+		      const struct drm_mode_fb_cmd2 *mode_cmd,
+		      struct evdi_gem_object *obj)
+{
+	efb->obj = obj;
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+	if (info == NULL)
+		info = drm_get_format_info(dev, mode_cmd->pixel_format,
+					   mode_cmd->modifier[0]);
+#endif
+	drm_helper_mode_fill_fb_struct(dev, &efb->base,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+				       info,
+#endif
+				       mode_cmd);
+	return drm_framebuffer_init(dev, &efb->base, &evdifb_funcs);
+}
+
+#ifdef CONFIG_FB
+int evdifb_create(struct drm_fb_helper *helper,
+			 struct drm_fb_helper_surface_size *sizes)
+{
+	struct evdi_fbdev *efbdev = (struct evdi_fbdev *)helper;
+	struct drm_device *dev = efbdev->helper.dev;
+	struct fb_info *info;
+	struct device *device = dev->dev;
+	struct drm_framebuffer *fb;
+	struct drm_mode_fb_cmd2 mode_cmd;
+	struct evdi_gem_object *obj;
+	uint32_t size;
+	int ret = 0;
+
+	if (sizes->surface_bpp == 24) {
+		sizes->surface_bpp = 32;
+	} else if (sizes->surface_bpp != 32) {
+		EVDI_ERROR("Not supported pixel format (bpp=%d)\n",
+			   sizes->surface_bpp);
+		return -EINVAL;
+	}
+
+	mode_cmd.width = sizes->surface_width;
+	mode_cmd.height = sizes->surface_height;
+	mode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);
+
+	mode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,
+							  sizes->surface_depth);
+
+	size = mode_cmd.pitches[0] * mode_cmd.height;
+	size = ALIGN(size, PAGE_SIZE);
+
+	obj = evdi_gem_alloc_object(dev, size);
+	if (!obj)
+		goto out;
+
+	ret = evdi_gem_vmap(obj);
+	if (ret) {
+		DRM_ERROR("failed to vmap fb\n");
+		goto out_gfree;
+	}
+
+	info = framebuffer_alloc(0, device);
+	if (!info) {
+		ret = -ENOMEM;
+		goto out_gfree;
+	}
+	info->par = efbdev;
+
+	ret = evdi_framebuffer_init(dev, &efbdev->efb,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+				    NULL,
+#endif
+				    &mode_cmd, obj);
+	if (ret)
+		goto out_gfree;
+
+	fb = &efbdev->efb.base;
+
+	efbdev->helper.fb = fb;
+#if KERNEL_VERSION(6, 2, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+	efbdev->helper.info = info;
+#else
+	efbdev->helper.fbdev = info;
+#endif
+
+
+	strscpy(info->fix.id, "evdidrmfb", sizeof(info->fix.id));
+
+	info->screen_base = efbdev->efb.obj->vmapping;
+	info->fix.smem_len = size;
+	info->fix.smem_start = (unsigned long)efbdev->efb.obj->vmapping;
+
+#if KERNEL_VERSION(6, 4, 0) <= LINUX_VERSION_CODE || defined(EL9)
+#elif KERNEL_VERSION(4, 20, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	info->flags = FBINFO_DEFAULT;
+#else
+	info->flags = FBINFO_DEFAULT | FBINFO_CAN_FORCE_OUTPUT;
+#endif
+
+	efbdev->fb_ops = &evdifb_ops;
+	info->fbops = efbdev->fb_ops;
+
+#if KERNEL_VERSION(5, 2, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_fb_helper_fill_info(info, &efbdev->helper, sizes);
+#else
+	drm_fb_helper_fill_fix(info, fb->pitches[0], fb->format->depth);
+	drm_fb_helper_fill_var(info, &efbdev->helper, sizes->fb_width,
+			       sizes->fb_height);
+#endif
+
+	ret = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (ret) {
+		ret = -ENOMEM;
+		goto out_gfree;
+	}
+
+	DRM_DEBUG_KMS("allocated %dx%d vmal %p\n",
+		      fb->width, fb->height, efbdev->efb.obj->vmapping);
+
+	return ret;
+ out_gfree:
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_gem_object_put(&efbdev->efb.obj->base);
+#else
+	drm_gem_object_put_unlocked(&efbdev->efb.obj->base);
+#endif
+ out:
+	return ret;
+}
+
+#if KERNEL_VERSION(6, 15, 0) <= LINUX_VERSION_CODE
+#else
+static struct drm_fb_helper_funcs evdi_fb_helper_funcs = {
+	.fb_probe = evdifb_create,
+};
+#endif
+
+static void evdi_fbdev_destroy(__always_unused struct drm_device *dev,
+			       struct evdi_fbdev *efbdev)
+{
+	struct fb_info *info;
+
+#if KERNEL_VERSION(6, 2, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+	if (efbdev->helper.info) {
+		info = efbdev->helper.info;
+#else
+	if (efbdev->helper.fbdev) {
+		info = efbdev->helper.fbdev;
+#endif
+		unregister_framebuffer(info);
+		if (info->cmap.len)
+			fb_dealloc_cmap(&info->cmap);
+
+		framebuffer_release(info);
+	}
+	drm_fb_helper_fini(&efbdev->helper);
+	if (efbdev->efb.obj) {
+		drm_framebuffer_unregister_private(&efbdev->efb.base);
+		drm_framebuffer_cleanup(&efbdev->efb.base);
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		drm_gem_object_put(&efbdev->efb.obj->base);
+#else
+		drm_gem_object_put_unlocked(&efbdev->efb.obj->base);
+#endif
+	}
+}
+
+int evdi_fbdev_init(struct drm_device *dev)
+{
+	struct evdi_device *evdi;
+	struct evdi_fbdev *efbdev;
+	int ret;
+
+	evdi = dev->dev_private;
+	efbdev = kzalloc(sizeof(struct evdi_fbdev), GFP_KERNEL);
+	if (!efbdev)
+		return -ENOMEM;
+
+	evdi->fbdev = efbdev;
+#if KERNEL_VERSION(6, 15, 0) <= LINUX_VERSION_CODE
+	drm_fb_helper_prepare(dev, &efbdev->helper, 32, NULL);
+#elif KERNEL_VERSION(6, 3, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+	drm_fb_helper_prepare(dev, &efbdev->helper, 32, &evdi_fb_helper_funcs);
+#else
+	drm_fb_helper_prepare(dev, &efbdev->helper, &evdi_fb_helper_funcs);
+#endif
+
+#if KERNEL_VERSION(5, 7, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	ret = drm_fb_helper_init(dev, &efbdev->helper);
+#else
+	ret = drm_fb_helper_init(dev, &efbdev->helper, 1);
+#endif
+	if (ret) {
+		kfree(efbdev);
+		return ret;
+	}
+
+#if KERNEL_VERSION(5, 7, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	drm_fb_helper_single_add_all_connectors(&efbdev->helper);
+#endif
+
+#if KERNEL_VERSION(6, 3, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+	ret = drm_fb_helper_initial_config(&efbdev->helper);
+#else
+	ret = drm_fb_helper_initial_config(&efbdev->helper, 32);
+#endif
+
+	if (ret) {
+		drm_fb_helper_fini(&efbdev->helper);
+		kfree(efbdev);
+	}
+	return ret;
+}
+
+void evdi_fbdev_cleanup(struct drm_device *dev)
+{
+	struct evdi_device *evdi = dev->dev_private;
+
+	if (!evdi->fbdev)
+		return;
+
+	evdi_fbdev_destroy(dev, evdi->fbdev);
+	kfree(evdi->fbdev);
+	evdi->fbdev = NULL;
+}
+
+void evdi_fbdev_unplug(struct drm_device *dev)
+{
+	struct evdi_device *evdi = dev->dev_private;
+	struct evdi_fbdev *efbdev;
+
+	if (!evdi->fbdev)
+		return;
+
+	efbdev = evdi->fbdev;
+#if KERNEL_VERSION(6, 2, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+	if (efbdev->helper.info) {
+		struct fb_info *info;
+
+		info = efbdev->helper.info;
+#else
+	if (efbdev->helper.fbdev) {
+		struct fb_info *info;
+
+		info = efbdev->helper.fbdev;
+#endif
+#if KERNEL_VERSION(5, 6, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		unregister_framebuffer(info);
+#else
+		unlink_framebuffer(info);
+#endif
+	}
+}
+#endif /* CONFIG_FB */
+
+int evdi_fb_get_bpp(uint32_t format)
+{
+	const struct drm_format_info *info = drm_format_info(format);
+
+	if (!info)
+		return 0;
+	return info->cpp[0] * 8;
+}
+
+struct drm_framebuffer *evdi_fb_user_fb_create(
+					struct drm_device *dev,
+					struct drm_file *file,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+					const struct drm_format_info *info,
+#endif
+					const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	struct drm_gem_object *obj;
+	struct evdi_framebuffer *efb;
+	int ret;
+	uint32_t size;
+	int bpp = evdi_fb_get_bpp(mode_cmd->pixel_format);
+
+	if (bpp != 32) {
+		EVDI_ERROR("Unsupported bpp (%d)\n", bpp);
+		return ERR_PTR(-EINVAL);
+	}
+
+	obj = drm_gem_object_lookup(file, mode_cmd->handles[0]);
+	if (obj == NULL)
+		return ERR_PTR(-ENOENT);
+
+	size = mode_cmd->offsets[0] + mode_cmd->pitches[0] * mode_cmd->height;
+	size = ALIGN(size, PAGE_SIZE);
+
+	if (size > obj->size) {
+		DRM_ERROR("object size not sufficient for fb %d %zu %u %d %d\n",
+			  size, obj->size, mode_cmd->offsets[0],
+			  mode_cmd->pitches[0], mode_cmd->height);
+		goto err_no_mem;
+	}
+
+	efb = kzalloc(sizeof(*efb), GFP_KERNEL);
+	if (efb == NULL)
+		goto err_no_mem;
+	efb->base.obj[0] = obj;
+
+	ret = evdi_framebuffer_init(dev, efb,
+#if KERNEL_VERSION(6, 17, 0) <= LINUX_VERSION_CODE
+				    info,
+#endif
+				    mode_cmd, to_evdi_bo(obj));
+	if (ret)
+		goto err_inval;
+	return &efb->base;
+
+ err_no_mem:
+	drm_gem_object_put(obj);
+	return ERR_PTR(-ENOMEM);
+ err_inval:
+	kfree(efb);
+	drm_gem_object_put(obj);
+	return ERR_PTR(-EINVAL);
+}
diff --git a/drivers/custom/evdi/module/evdi_gem.c b/drivers/custom/evdi/module/evdi_gem.c
new file mode 100644
index 000000000000..f594d1b368bb
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_gem.c
@@ -0,0 +1,496 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/sched.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 18, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#elif KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE
+#include <linux/dma-buf-map.h>
+#endif
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_prime.h>
+#include <drm/drm_file.h>
+#elif KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+#else
+#include <drm/drmP.h>
+#endif
+#include "evdi_drm_drv.h"
+#include "evdi_params.h"
+#include <linux/shmem_fs.h>
+#include <linux/dma-buf.h>
+#include <drm/drm_cache.h>
+#include <linux/vmalloc.h>
+
+
+#if KERNEL_VERSION(6, 13, 0) <= LINUX_VERSION_CODE || defined(EL10)
+MODULE_IMPORT_NS("DMA_BUF");
+#elif KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL9)
+MODULE_IMPORT_NS(DMA_BUF);
+#endif
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+static int evdi_prime_pin(struct drm_gem_object *obj);
+static void evdi_prime_unpin(struct drm_gem_object *obj);
+
+static const struct vm_operations_struct evdi_gem_vm_ops = {
+	.fault = evdi_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
+static struct drm_gem_object_funcs gem_obj_funcs = {
+	.free = evdi_gem_free_object,
+	.pin = evdi_prime_pin,
+	.unpin = evdi_prime_unpin,
+	.vm_ops = &evdi_gem_vm_ops,
+	.export = drm_gem_prime_export,
+	.get_sg_table = evdi_prime_get_sg_table,
+};
+#endif
+
+static bool evdi_was_called_by_mutter(void)
+{
+	char task_comm[TASK_COMM_LEN] = { 0 };
+
+	get_task_comm(task_comm, current);
+
+	return strcmp(task_comm, "gnome-shell") == 0;
+}
+
+static bool evdi_drm_gem_object_use_import_attach(struct drm_gem_object *obj)
+{
+	if (!obj || !obj->import_attach || !obj->import_attach->dmabuf->owner)
+		return false;
+
+	return strcmp(obj->import_attach->dmabuf->owner->name, "amdgpu") != 0;
+}
+
+uint32_t evdi_gem_object_handle_lookup(struct drm_file *filp,
+				       struct drm_gem_object *obj)
+{
+	uint32_t it_handle = 0;
+	struct drm_gem_object *it_obj = NULL;
+
+	spin_lock(&filp->table_lock);
+	idr_for_each_entry(&filp->object_idr, it_obj, it_handle) {
+		if (it_obj == obj)
+			break;
+	}
+	spin_unlock(&filp->table_lock);
+
+	if (!it_obj)
+		it_handle = 0;
+
+	return it_handle;
+}
+
+struct evdi_gem_object *evdi_gem_alloc_object(struct drm_device *dev,
+					      size_t size)
+{
+	struct evdi_gem_object *obj;
+
+	obj = kzalloc(sizeof(*obj), GFP_KERNEL);
+	if (obj == NULL)
+		return NULL;
+
+	if (drm_gem_object_init(dev, &obj->base, size) != 0) {
+		kfree(obj);
+		return NULL;
+	}
+
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	obj->base.funcs = &gem_obj_funcs;
+#endif
+
+	obj->allow_sw_cursor_rect_updates = false;
+
+	mutex_init(&obj->pages_lock);
+
+	return obj;
+}
+
+static int
+evdi_gem_create(struct drm_file *file,
+		struct drm_device *dev, uint64_t size, uint32_t *handle_p)
+{
+	struct evdi_gem_object *obj;
+	int ret;
+	u32 handle;
+
+	size = roundup(size, PAGE_SIZE);
+
+	obj = evdi_gem_alloc_object(dev, size);
+	if (obj == NULL)
+		return -ENOMEM;
+
+	obj->allow_sw_cursor_rect_updates = evdi_was_called_by_mutter();
+	ret = drm_gem_handle_create(file, &obj->base, &handle);
+	if (ret) {
+		drm_gem_object_release(&obj->base);
+		kfree(obj);
+		return ret;
+	}
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_gem_object_put(&obj->base);
+#else
+	drm_gem_object_put_unlocked(&obj->base);
+#endif
+	*handle_p = handle;
+	return 0;
+}
+
+static int evdi_align_pitch(int width, int cpp)
+{
+	int aligned = width;
+	int pitch_mask = 0;
+
+	switch (cpp) {
+	case 1:
+		pitch_mask = 255;
+		break;
+	case 2:
+		pitch_mask = 127;
+		break;
+	case 3:
+	case 4:
+		pitch_mask = 63;
+		break;
+	}
+
+	aligned += pitch_mask;
+	aligned &= ~pitch_mask;
+	return aligned * cpp;
+}
+
+int evdi_dumb_create(struct drm_file *file,
+		     struct drm_device *dev, struct drm_mode_create_dumb *args)
+{
+	args->pitch = evdi_align_pitch(args->width, DIV_ROUND_UP(args->bpp, 8));
+
+	args->size = args->pitch * args->height;
+	return evdi_gem_create(file, dev, args->size, &args->handle);
+}
+
+int evdi_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
+
+	ret = drm_gem_mmap(filp, vma);
+	if (ret)
+		return ret;
+
+/* Some VMA modifier function patches present in 6.3 were reverted in EL8 kernels */
+#if KERNEL_VERSION(6, 3, 0) <= LINUX_VERSION_CODE || defined(EL9)
+	vm_flags_mod(vma, VM_MIXEDMAP, VM_PFNMAP);
+#else
+	vma->vm_flags &= ~VM_PFNMAP;
+	vma->vm_flags |= VM_MIXEDMAP;
+#endif
+
+	return ret;
+}
+
+#if KERNEL_VERSION(4, 17, 0) <= LINUX_VERSION_CODE
+vm_fault_t evdi_gem_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+#else
+int evdi_gem_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+#endif
+	struct evdi_gem_object *obj = to_evdi_bo(vma->vm_private_data);
+	struct page *page;
+	pgoff_t page_offset;
+	loff_t num_pages = obj->base.size >> PAGE_SHIFT;
+	int ret = 0;
+
+	page_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;
+
+	if (!obj->pages || page_offset >= (unsigned long)num_pages)
+		return VM_FAULT_SIGBUS;
+
+	page = obj->pages[page_offset];
+	ret = vm_insert_page(vma, vmf->address, page);
+	switch (ret) {
+	case -EAGAIN:
+	case 0:
+	case -ERESTARTSYS:
+	case -EBUSY:
+		return VM_FAULT_NOPAGE;
+	case -ENOMEM:
+		return VM_FAULT_OOM;
+	default:
+		return VM_FAULT_SIGBUS;
+	}
+	return VM_FAULT_SIGBUS;
+}
+
+static int evdi_gem_get_pages(struct evdi_gem_object *obj,
+			      __always_unused gfp_t gfpmask)
+{
+	struct page **pages;
+
+	if (obj->pages)
+		return 0;
+
+	pages = drm_gem_get_pages(&obj->base);
+
+	if (IS_ERR(pages))
+		return PTR_ERR(pages);
+
+	obj->pages = pages;
+
+#if defined(CONFIG_X86)
+	drm_clflush_pages(obj->pages, DIV_ROUND_UP(obj->base.size, PAGE_SIZE));
+#endif
+
+	return 0;
+}
+
+static void evdi_gem_put_pages(struct evdi_gem_object *obj)
+{
+	if (obj->base.import_attach) {
+		kvfree(obj->pages);
+		obj->pages = NULL;
+		return;
+	}
+
+	drm_gem_put_pages(&obj->base, obj->pages, false, false);
+	obj->pages = NULL;
+}
+
+static int evdi_pin_pages(struct evdi_gem_object *obj)
+{
+	int ret = 0;
+
+	mutex_lock(&obj->pages_lock);
+	if (obj->pages_pin_count++ == 0) {
+		ret = evdi_gem_get_pages(obj, GFP_KERNEL);
+		if (ret)
+			obj->pages_pin_count--;
+	}
+	mutex_unlock(&obj->pages_lock);
+	return ret;
+}
+
+static void evdi_unpin_pages(struct evdi_gem_object *obj)
+{
+	mutex_lock(&obj->pages_lock);
+	if (--obj->pages_pin_count == 0)
+		evdi_gem_put_pages(obj);
+	mutex_unlock(&obj->pages_lock);
+}
+
+int evdi_gem_vmap(struct evdi_gem_object *obj)
+{
+	int page_count = DIV_ROUND_UP(obj->base.size, PAGE_SIZE);
+	int ret;
+
+	if (evdi_drm_gem_object_use_import_attach(&obj->base)) {
+#if KERNEL_VERSION(5, 18, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+		struct iosys_map map = IOSYS_MAP_INIT_VADDR(NULL);
+#elif KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE
+		struct dma_buf_map map = DMA_BUF_MAP_INIT_VADDR(NULL);
+#endif
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+# if KERNEL_VERSION(6, 2, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+		ret = dma_buf_vmap_unlocked(obj->base.import_attach->dmabuf, &map);
+# else
+		ret = dma_buf_vmap(obj->base.import_attach->dmabuf, &map);
+# endif
+		if (ret)
+			return -ENOMEM;
+		obj->vmapping = map.vaddr;
+		obj->vmap_is_iomem = map.is_iomem;
+#else
+		obj->vmapping = dma_buf_vmap(obj->base.import_attach->dmabuf);
+		if (!obj->vmapping)
+			return -ENOMEM;
+#endif
+		return 0;
+	}
+
+	ret = evdi_pin_pages(obj);
+	if (ret)
+		return ret;
+
+	obj->vmapping = vmap(obj->pages, page_count, 0, PAGE_KERNEL);
+	if (!obj->vmapping)
+		return -ENOMEM;
+	return 0;
+}
+
+void evdi_gem_vunmap(struct evdi_gem_object *obj)
+{
+	if (evdi_drm_gem_object_use_import_attach(&obj->base)) {
+#if KERNEL_VERSION(5, 18, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+		struct iosys_map map = IOSYS_MAP_INIT_VADDR(NULL);
+
+		if (obj->vmap_is_iomem)
+			iosys_map_set_vaddr_iomem(&map, obj->vmapping);
+		else
+			iosys_map_set_vaddr(&map, obj->vmapping);
+
+# if KERNEL_VERSION(6, 2, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+		dma_buf_vunmap_unlocked(obj->base.import_attach->dmabuf, &map);
+# else
+		dma_buf_vunmap(obj->base.import_attach->dmabuf, &map);
+# endif
+
+#elif KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE
+		struct dma_buf_map map;
+
+		if (obj->vmap_is_iomem)
+			dma_buf_map_set_vaddr_iomem(&map, obj->vmapping);
+		else
+			dma_buf_map_set_vaddr(&map, obj->vmapping);
+
+		dma_buf_vunmap(obj->base.import_attach->dmabuf, &map);
+#else
+		dma_buf_vunmap(obj->base.import_attach->dmabuf, obj->vmapping);
+#endif
+		obj->vmapping = NULL;
+		return;
+	}
+
+	if (obj->vmapping) {
+		vunmap(obj->vmapping);
+		obj->vmapping = NULL;
+	}
+
+	evdi_unpin_pages(obj);
+}
+
+void evdi_gem_free_object(struct drm_gem_object *gem_obj)
+{
+	struct evdi_gem_object *obj = to_evdi_bo(gem_obj);
+
+	if (obj->vmapping)
+		evdi_gem_vunmap(obj);
+
+	if (gem_obj->import_attach)
+		drm_prime_gem_destroy(gem_obj, obj->sg);
+
+	if (obj->pages)
+		evdi_gem_put_pages(obj);
+
+	if (gem_obj->dev->vma_offset_manager)
+		drm_gem_free_mmap_offset(gem_obj);
+	mutex_destroy(&obj->pages_lock);
+	drm_gem_object_release(&obj->base);
+	kfree(obj);
+}
+
+/*
+ * the dumb interface doesn't work with the GEM straight MMAP
+ * interface, it expects to do MMAP on the drm fd, like normal
+ */
+int evdi_gem_mmap(struct drm_file *file,
+		  struct drm_device *dev, uint32_t handle, uint64_t *offset)
+{
+	struct evdi_gem_object *gobj;
+	struct drm_gem_object *obj;
+	int ret = 0;
+
+	mutex_lock(&dev->struct_mutex);
+	obj = drm_gem_object_lookup(file, handle);
+	if (obj == NULL) {
+		ret = -ENOENT;
+		goto unlock;
+	}
+	gobj = to_evdi_bo(obj);
+
+	ret = evdi_pin_pages(gobj);
+	if (ret)
+		goto out;
+
+	/* Don't allow imported objects to be mapped */
+	if (obj->import_attach) {
+		EVDI_WARN("Don't allow imported objects to be mapped: owner: %s\n",  obj->import_attach->dmabuf->owner->name);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = drm_gem_create_mmap_offset(obj);
+	if (ret)
+		goto out;
+
+	*offset = drm_vma_node_offset_addr(&gobj->base.vma_node);
+
+ out:
+	drm_gem_object_put(&gobj->base);
+ unlock:
+	mutex_unlock(&dev->struct_mutex);
+	return ret;
+}
+
+struct drm_gem_object *
+evdi_prime_import_sg_table(struct drm_device *dev,
+			   struct dma_buf_attachment *attach,
+			   struct sg_table *sg)
+{
+	struct evdi_gem_object *obj;
+	int npages;
+	bool called_by_mutter;
+
+	called_by_mutter = evdi_was_called_by_mutter();
+
+	obj = evdi_gem_alloc_object(dev, attach->dmabuf->size);
+	if (IS_ERR(obj))
+		return ERR_CAST(obj);
+
+	npages = DIV_ROUND_UP(attach->dmabuf->size, PAGE_SIZE);
+	DRM_DEBUG_PRIME("Importing %d pages\n", npages);
+	obj->pages = kvmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);
+	if (!obj->pages) {
+		evdi_gem_free_object(&obj->base);
+		return ERR_PTR(-ENOMEM);
+	}
+
+#if KERNEL_VERSION(5, 12, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_prime_sg_to_page_array(sg, obj->pages, npages);
+#else
+	drm_prime_sg_to_page_addr_arrays(sg, obj->pages, NULL, npages);
+#endif
+	obj->sg = sg;
+	obj->allow_sw_cursor_rect_updates = called_by_mutter;
+	return &obj->base;
+}
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(EL8)
+static int evdi_prime_pin(struct drm_gem_object *obj)
+{
+	struct evdi_gem_object *bo = to_evdi_bo(obj);
+
+	return evdi_pin_pages(bo);
+}
+
+static void evdi_prime_unpin(struct drm_gem_object *obj)
+{
+	struct evdi_gem_object *bo = to_evdi_bo(obj);
+
+	evdi_unpin_pages(bo);
+}
+#endif
+
+struct sg_table *evdi_prime_get_sg_table(struct drm_gem_object *obj)
+{
+	struct evdi_gem_object *bo = to_evdi_bo(obj);
+
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	return drm_prime_pages_to_sg(obj->dev, bo->pages, bo->base.size >> PAGE_SHIFT);
+#else
+	return drm_prime_pages_to_sg(bo->pages, bo->base.size >> PAGE_SHIFT);
+#endif
+}
+
diff --git a/drivers/custom/evdi/module/evdi_i2c.c b/drivers/custom/evdi/module/evdi_i2c.c
new file mode 100644
index 000000000000..1616c212cb2e
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_i2c.c
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include "evdi_i2c.h"
+#include "evdi_debug.h"
+#include "evdi_drm_drv.h"
+
+static int dli2c_access_master(struct i2c_adapter *adapter,
+	struct i2c_msg *msgs, int num)
+{
+	int i = 0, result = 0;
+	struct evdi_device *evdi = adapter->algo_data;
+	struct evdi_painter *painter = evdi->painter;
+
+	for (i = 0; i < num; i++) {
+		if (evdi_painter_i2c_data_notify(painter, &msgs[i]))
+			result++;
+	}
+
+	return result;
+}
+
+static u32 dli2c_func(__always_unused struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm dli2c_algorithm = {
+	.master_xfer = dli2c_access_master,
+	.functionality = dli2c_func,
+};
+
+int evdi_i2c_add(struct i2c_adapter *adapter, struct device *parent,
+	void *ddev)
+{
+	adapter->owner  = THIS_MODULE;
+#if KERNEL_VERSION(6, 8, 0) <= LINUX_VERSION_CODE || defined(EL9)
+#else
+	adapter->class  = I2C_CLASS_DDC;
+#endif
+	adapter->algo   = &dli2c_algorithm;
+	strscpy(adapter->name, "DisplayLink I2C Adapter", sizeof(adapter->name));
+	adapter->dev.parent = parent;
+	adapter->algo_data = ddev;
+
+	return i2c_add_adapter(adapter);
+}
+
+void evdi_i2c_remove(struct i2c_adapter *adapter)
+{
+	i2c_del_adapter(adapter);
+}
diff --git a/drivers/custom/evdi/module/evdi_i2c.h b/drivers/custom/evdi/module/evdi_i2c.h
new file mode 100644
index 000000000000..e8718c3f5292
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_i2c.h
@@ -0,0 +1,20 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_I2C_H
+#define EVDI_I2C_H
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+
+int evdi_i2c_add(struct i2c_adapter *adapter,
+		struct device *parent,
+		void *ddev);
+void evdi_i2c_remove(struct i2c_adapter *adapter);
+
+#endif  /* EVDI_I2C_H */
diff --git a/drivers/custom/evdi/module/evdi_ioc32.c b/drivers/custom/evdi/module/evdi_ioc32.c
new file mode 100644
index 000000000000..896b9d40c46e
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_ioc32.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * evdi_ioc32.c
+ *
+ * Copyright (c) 2016 The Chromium OS Authors
+ * Copyright (c) 2017 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/compat.h>
+
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_ioctl.h>
+#elif KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_edid.h>
+#include "evdi_drm.h"
+
+#include "evdi_drm_drv.h"
+
+struct drm_evdi_connect32 {
+	int32_t connected;
+	int32_t dev_index;
+	uint32_t edid_ptr32;
+	uint32_t edid_length;
+	uint32_t pixel_area_limit;
+	uint32_t pixel_per_second_limit;
+};
+
+struct drm_evdi_grabpix32 {
+	uint32_t mode;
+	int32_t buf_width;
+	int32_t buf_height;
+	int32_t buf_byte_stride;
+	uint32_t buffer_ptr32;
+	int32_t num_rects;
+	uint32_t rects_ptr32;
+};
+
+static int compat_evdi_connect(struct file *file,
+				unsigned int __always_unused cmd,
+				unsigned long arg)
+{
+	struct drm_evdi_connect32 req32;
+	struct drm_evdi_connect krequest;
+
+	if (copy_from_user(&req32, (void __user *)arg, sizeof(req32)))
+		return -EFAULT;
+
+	krequest.connected = req32.connected;
+	krequest.dev_index = req32.dev_index;
+	krequest.edid = compat_ptr(req32.edid_ptr32);
+	krequest.edid_length = req32.edid_length;
+	krequest.pixel_area_limit = req32.pixel_area_limit;
+	krequest.pixel_per_second_limit = req32.pixel_per_second_limit;
+
+	return drm_ioctl_kernel(file, evdi_painter_connect_ioctl, &krequest, 0);
+}
+
+static int compat_evdi_grabpix(struct file *file,
+				unsigned int __always_unused cmd,
+				unsigned long arg)
+{
+	struct drm_evdi_grabpix32 req32;
+	struct drm_evdi_grabpix krequest;
+	int ret;
+
+	if (copy_from_user(&req32, (void __user *)arg, sizeof(req32)))
+		return -EFAULT;
+
+	krequest.mode = req32.mode;
+	krequest.buf_width = req32.buf_width;
+	krequest.buf_height = req32.buf_height;
+	krequest.buf_byte_stride = req32.buf_byte_stride;
+	krequest.buffer = compat_ptr(req32.buffer_ptr32);
+	krequest.num_rects = req32.num_rects;
+	krequest.rects = compat_ptr(req32.rects_ptr32);
+
+	ret = drm_ioctl_kernel(file, evdi_painter_grabpix_ioctl, &krequest, 0);
+	if (ret)
+		return ret;
+
+	req32.num_rects = krequest.num_rects;
+	if (copy_to_user((void __user *)arg, &req32, sizeof(req32)))
+		return -EFAULT;
+	return 0;
+}
+
+static drm_ioctl_compat_t *evdi_compat_ioctls[] = {
+	[DRM_EVDI_CONNECT] = compat_evdi_connect,
+	[DRM_EVDI_GRABPIX] = compat_evdi_grabpix,
+};
+
+/*
+ * Called whenever a 32-bit process running under a 64-bit kernel
+ * performs an ioctl on /dev/dri/card<n>.
+ *
+ * \param filp file pointer.
+ * \param cmd command.
+ * \param arg user argument.
+ * \return zero on success or negative number on failure.
+ */
+long evdi_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	unsigned int nr = DRM_IOCTL_NR(cmd);
+	drm_ioctl_compat_t *fn = NULL;
+	int ret;
+
+	if (nr < DRM_COMMAND_BASE || nr >= DRM_COMMAND_END)
+		return drm_compat_ioctl(filp, cmd, arg);
+
+	if (nr < DRM_COMMAND_BASE + ARRAY_SIZE(evdi_compat_ioctls))
+		fn = evdi_compat_ioctls[nr - DRM_COMMAND_BASE];
+
+	if (fn != NULL)
+		ret = (*fn) (filp, cmd, arg);
+	else
+		ret = drm_ioctl(filp, cmd, arg);
+
+	return ret;
+}
diff --git a/drivers/custom/evdi/module/evdi_modeset.c b/drivers/custom/evdi/module/evdi_modeset.c
new file mode 100644
index 000000000000..cadd79104170
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_modeset.c
@@ -0,0 +1,549 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * Based on parts on udlfb.c:
+ * Copyright (C) 2009 its respective authors
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_vblank.h>
+#include <drm/drm_damage_helper.h>
+#elif KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE
+#include <drm/drm_damage_helper.h>
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_atomic.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include "evdi_drm.h"
+#include "evdi_drm_drv.h"
+#include "evdi_cursor.h"
+#include "evdi_params.h"
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_gem_atomic_helper.h>
+#else
+#include <drm/drm_gem_framebuffer_helper.h>
+#endif
+
+static void evdi_crtc_dpms(__always_unused struct drm_crtc *crtc,
+			   __always_unused int mode)
+{
+	EVDI_CHECKPT();
+}
+
+static void evdi_crtc_disable(__always_unused struct drm_crtc *crtc)
+{
+	EVDI_CHECKPT();
+	drm_crtc_vblank_off(crtc);
+}
+
+static void evdi_crtc_destroy(struct drm_crtc *crtc)
+{
+	EVDI_CHECKPT();
+	drm_crtc_cleanup(crtc);
+	kfree(crtc);
+}
+
+static void evdi_crtc_commit(__always_unused struct drm_crtc *crtc)
+{
+	EVDI_CHECKPT();
+}
+
+static void evdi_crtc_set_nofb(__always_unused struct drm_crtc *crtc)
+{
+}
+
+static void evdi_crtc_atomic_flush(
+	struct drm_crtc *crtc
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(RPI) || defined(EL8)
+	, struct drm_atomic_state *state
+#else
+	, __always_unused struct drm_crtc_state *old_state
+#endif
+	)
+{
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(RPI) || defined(EL8)
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc);
+#else
+	struct drm_crtc_state *crtc_state = crtc->state;
+#endif
+	struct evdi_device *evdi = crtc->dev->dev_private;
+	bool notify_mode_changed = crtc_state->active &&
+				   (crtc_state->mode_changed || evdi_painter_needs_full_modeset(evdi->painter));
+	bool notify_dpms = crtc_state->active_changed || evdi_painter_needs_full_modeset(evdi->painter);
+
+	if (notify_mode_changed)
+		evdi_painter_mode_changed_notify(evdi, &crtc_state->adjusted_mode);
+
+	if (notify_dpms)
+		evdi_painter_dpms_notify(evdi->painter,
+			crtc_state->active ? DRM_MODE_DPMS_ON : DRM_MODE_DPMS_OFF);
+
+	evdi_painter_set_vblank(evdi->painter, crtc, crtc_state->event);
+	evdi_painter_send_update_ready_if_needed(evdi->painter);
+	crtc_state->event = NULL;
+}
+
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+static void evdi_mark_full_screen_dirty(struct evdi_device *evdi)
+{
+	const struct drm_clip_rect rect =
+		evdi_painter_framebuffer_size(evdi->painter);
+
+	evdi_painter_mark_dirty(evdi, &rect);
+	evdi_painter_send_update_ready_if_needed(evdi->painter);
+}
+
+static int evdi_crtc_cursor_set(struct drm_crtc *crtc,
+				struct drm_file *file,
+				uint32_t handle,
+				uint32_t width,
+				uint32_t height,
+				int32_t hot_x,
+				int32_t hot_y)
+{
+	struct drm_device *dev = crtc->dev;
+	struct evdi_device *evdi = dev->dev_private;
+	struct drm_gem_object *obj = NULL;
+	struct evdi_gem_object *eobj = NULL;
+	/*
+	 * evdi_crtc_cursor_set is callback function using
+	 * deprecated cursor entry point.
+	 * There is no info about underlaying pixel format.
+	 * Hence we are assuming that it is in ARGB 32bpp format.
+	 * This format it the only one supported in cursor composition
+	 * function.
+	 * This format is also enforced during framebuffer creation.
+	 *
+	 * Proper format will be available when driver start support
+	 * universal planes for cursor.
+	 */
+	uint32_t format = DRM_FORMAT_ARGB8888;
+	uint32_t stride = 4 * width;
+
+	EVDI_CHECKPT();
+	if (handle) {
+		mutex_lock(&dev->struct_mutex);
+		obj = drm_gem_object_lookup(file, handle);
+		if (obj)
+			eobj = to_evdi_bo(obj);
+		else
+			EVDI_ERROR("Failed to lookup gem object.\n");
+		mutex_unlock(&dev->struct_mutex);
+	}
+
+	evdi_cursor_set(evdi->cursor,
+			eobj, width, height, hot_x, hot_y,
+			format, stride);
+	#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_gem_object_put(obj);
+	#else
+	drm_gem_object_put_unlocked(obj);
+	#endif
+
+	/*
+	 * For now we don't care whether the application wanted the mouse set,
+	 * or not.
+	 */
+	if (evdi->cursor_events_enabled)
+		evdi_painter_send_cursor_set(evdi->painter, evdi->cursor);
+	else
+		evdi_mark_full_screen_dirty(evdi);
+	return 0;
+}
+
+static int evdi_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
+{
+	struct drm_device *dev = crtc->dev;
+	struct evdi_device *evdi = dev->dev_private;
+
+	EVDI_CHECKPT();
+	evdi_cursor_move(evdi->cursor, x, y);
+
+	if (evdi->cursor_events_enabled)
+		evdi_painter_send_cursor_move(evdi->painter, evdi->cursor);
+	else
+		evdi_mark_full_screen_dirty(evdi);
+
+	return 0;
+}
+#endif
+
+static struct drm_crtc_helper_funcs evdi_helper_funcs = {
+	.mode_set_nofb  = evdi_crtc_set_nofb,
+	.atomic_flush   = evdi_crtc_atomic_flush,
+
+	.dpms           = evdi_crtc_dpms,
+	.commit         = evdi_crtc_commit,
+	.disable        = evdi_crtc_disable
+};
+
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(RPI) || defined(EL8)
+static int evdi_enable_vblank(__always_unused struct drm_crtc *crtc)
+{
+	return 1;
+}
+
+static void evdi_disable_vblank(__always_unused struct drm_crtc *crtc)
+{
+}
+#endif
+
+static const struct drm_crtc_funcs evdi_crtc_funcs = {
+	.reset                  = drm_atomic_helper_crtc_reset,
+	.destroy                = evdi_crtc_destroy,
+	.set_config             = drm_atomic_helper_set_config,
+	.page_flip              = drm_atomic_helper_page_flip,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state   = drm_atomic_helper_crtc_destroy_state,
+
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	.cursor_set2            = evdi_crtc_cursor_set,
+	.cursor_move            = evdi_crtc_cursor_move,
+#endif
+#if KERNEL_VERSION(5, 11, 0) <= LINUX_VERSION_CODE || defined(RPI) || defined(EL8)
+	.enable_vblank          = evdi_enable_vblank,
+	.disable_vblank         = evdi_disable_vblank,
+#endif
+};
+
+static void evdi_plane_atomic_update(struct drm_plane *plane,
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+				     struct drm_atomic_state *atom_state
+#else
+				     struct drm_plane_state *old_state
+#endif
+		)
+{
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(atom_state, plane);
+#else
+#endif
+	struct drm_plane_state *state;
+	struct evdi_device *evdi;
+	struct evdi_painter *painter;
+	struct drm_crtc *crtc;
+
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	struct drm_atomic_helper_damage_iter iter;
+	struct drm_rect rect;
+	struct drm_clip_rect clip_rect;
+#endif
+
+	if (!plane || !plane->state) {
+		EVDI_WARN("Plane state is null\n");
+		return;
+	}
+
+	if (!plane->dev || !plane->dev->dev_private) {
+		EVDI_WARN("Plane device is null\n");
+		return;
+	}
+
+	state = plane->state;
+	evdi = plane->dev->dev_private;
+	painter = evdi->painter;
+	crtc = state->crtc;
+
+	if (!old_state->crtc && state->crtc)
+		evdi_painter_dpms_notify(evdi->painter, DRM_MODE_DPMS_ON);
+	else if (old_state->crtc && !state->crtc)
+		evdi_painter_dpms_notify(evdi->painter, DRM_MODE_DPMS_OFF);
+
+	if (state->fb) {
+		struct drm_framebuffer *fb = state->fb;
+		struct drm_framebuffer *old_fb = old_state->fb;
+		struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+		const struct drm_clip_rect fullscreen_rect = {
+			0, 0, fb->width, fb->height
+		};
+
+		if (!old_fb && crtc)
+			evdi_painter_force_full_modeset(painter);
+
+		if (old_fb &&
+		    fb->format && old_fb->format &&
+		    fb->format->format != old_fb->format->format)
+			evdi_painter_force_full_modeset(painter);
+
+		if (fb != old_fb ||
+		    evdi_painter_needs_full_modeset(painter)) {
+
+			evdi_painter_set_scanout_buffer(painter, efb);
+
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+			state->visible = true;
+			state->src.x1 = 0;
+			state->src.y1 = 0;
+			state->src.x2 = fb->width << 16;
+			state->src.y2 = fb->height << 16;
+
+			drm_atomic_helper_damage_iter_init(&iter, old_state, state);
+			while (drm_atomic_helper_damage_iter_next(&iter, &rect)) {
+				clip_rect.x1 = rect.x1;
+				clip_rect.y1 = rect.y1;
+				clip_rect.x2 = rect.x2;
+				clip_rect.y2 = rect.y2;
+				evdi_painter_mark_dirty(evdi, &clip_rect);
+			}
+#endif
+
+		};
+
+		if (evdi_painter_get_num_dirts(painter) == 0)
+			evdi_painter_mark_dirty(evdi, &fullscreen_rect);
+	}
+}
+
+static void evdi_cursor_atomic_get_rect(struct drm_clip_rect *rect,
+					struct drm_plane_state *state)
+{
+	rect->x1 = (state->crtc_x < 0) ? 0 : state->crtc_x;
+	rect->y1 = (state->crtc_y < 0) ? 0 : state->crtc_y;
+	rect->x2 = state->crtc_x + state->crtc_w;
+	rect->y2 = state->crtc_y + state->crtc_h;
+}
+
+static void evdi_cursor_atomic_update(struct drm_plane *plane,
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+				     struct drm_atomic_state *atom_state
+#else
+				     struct drm_plane_state *old_state
+#endif
+		)
+{
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	struct drm_plane_state *old_state = drm_atomic_get_old_plane_state(atom_state, plane);
+
+#else
+#endif
+	if (plane && plane->state && plane->dev && plane->dev->dev_private) {
+		struct drm_plane_state *state = plane->state;
+		struct evdi_device *evdi = plane->dev->dev_private;
+		struct drm_framebuffer *fb = state->fb;
+		struct evdi_framebuffer *efb = to_evdi_fb(fb);
+
+		struct drm_clip_rect old_rect;
+		struct drm_clip_rect rect;
+		bool cursor_changed = false;
+		bool cursor_position_changed = false;
+		int32_t cursor_position_x = 0;
+		int32_t cursor_position_y = 0;
+
+		mutex_lock(&plane->dev->struct_mutex);
+
+		evdi_cursor_position(evdi->cursor, &cursor_position_x,
+		&cursor_position_y);
+		evdi_cursor_move(evdi->cursor, state->crtc_x, state->crtc_y);
+		cursor_position_changed = cursor_position_x != state->crtc_x ||
+					  cursor_position_y != state->crtc_y;
+
+		if (fb != old_state->fb) {
+			if (fb != NULL) {
+				uint32_t stride = 4 * fb->width;
+
+				evdi_cursor_set(evdi->cursor,
+						efb->obj,
+						fb->width,
+						fb->height,
+						0,
+						0,
+						fb->format->format,
+						stride);
+			}
+
+			evdi_cursor_enable(evdi->cursor, fb != NULL);
+			cursor_changed = true;
+		}
+
+		mutex_unlock(&plane->dev->struct_mutex);
+		if (!evdi->cursor_events_enabled) {
+			if (fb != NULL) {
+				if (efb->obj->allow_sw_cursor_rect_updates) {
+					evdi_cursor_atomic_get_rect(&old_rect, old_state);
+					evdi_cursor_atomic_get_rect(&rect, state);
+
+					evdi_painter_mark_dirty(evdi, &old_rect);
+				} else {
+					rect = evdi_painter_framebuffer_size(evdi->painter);
+				}
+				evdi_painter_mark_dirty(evdi, &rect);
+			}
+			return;
+		}
+
+		if (cursor_changed)
+			evdi_painter_send_cursor_set(evdi->painter,
+						     evdi->cursor);
+		if (cursor_position_changed)
+			evdi_painter_send_cursor_move(evdi->painter,
+						      evdi->cursor);
+	}
+}
+
+static const struct drm_plane_helper_funcs evdi_plane_helper_funcs = {
+	.atomic_update = evdi_plane_atomic_update,
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	.prepare_fb = drm_gem_plane_helper_prepare_fb
+#else
+	.prepare_fb = drm_gem_fb_prepare_fb
+#endif
+};
+
+static const struct drm_plane_helper_funcs evdi_cursor_helper_funcs = {
+	.atomic_update = evdi_cursor_atomic_update,
+#if KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	.prepare_fb = drm_gem_plane_helper_prepare_fb
+#else
+	.prepare_fb = drm_gem_fb_prepare_fb
+#endif
+};
+
+static const struct drm_plane_funcs evdi_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = drm_plane_cleanup,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static const uint32_t formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_ABGR8888,
+};
+
+static struct drm_plane *evdi_create_plane(
+		struct drm_device *dev,
+		enum drm_plane_type type,
+		const struct drm_plane_helper_funcs *helper_funcs)
+{
+	struct drm_plane *plane;
+	int ret;
+	char *plane_type = (type == DRM_PLANE_TYPE_CURSOR) ? "cursor" : "primary";
+
+	plane = kzalloc(sizeof(*plane), GFP_KERNEL);
+	if (plane == NULL) {
+		EVDI_ERROR("Failed to allocate %s plane\n", plane_type);
+		return NULL;
+	}
+	plane->format_default = true;
+
+	ret = drm_universal_plane_init(dev,
+				       plane,
+				       0xFF,
+				       &evdi_plane_funcs,
+				       formats,
+				       ARRAY_SIZE(formats),
+				       NULL,
+				       type,
+				       NULL
+				       );
+
+	if (ret) {
+		EVDI_ERROR("Failed to initialize %s plane\n", plane_type);
+		kfree(plane);
+		return NULL;
+	}
+
+	drm_plane_helper_add(plane, helper_funcs);
+
+	return plane;
+}
+
+static int evdi_crtc_init(struct drm_device *dev)
+{
+	struct drm_crtc *crtc = NULL;
+	struct drm_plane *primary_plane = NULL;
+	struct drm_plane *cursor_plane = NULL;
+	int status = 0;
+
+	EVDI_CHECKPT();
+	crtc = kzalloc(sizeof(struct drm_crtc), GFP_KERNEL);
+	if (crtc == NULL)
+		return -ENOMEM;
+
+	primary_plane = evdi_create_plane(dev, DRM_PLANE_TYPE_PRIMARY,
+					  &evdi_plane_helper_funcs);
+
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	cursor_plane = evdi_create_plane(dev, DRM_PLANE_TYPE_CURSOR,
+						&evdi_cursor_helper_funcs);
+#endif
+
+#if KERNEL_VERSION(5, 0, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	drm_plane_enable_fb_damage_clips(primary_plane);
+#endif
+
+	status = drm_crtc_init_with_planes(dev, crtc,
+					   primary_plane, cursor_plane,
+					   &evdi_crtc_funcs,
+					   NULL
+					   );
+
+	EVDI_DEBUG("drm_crtc_init: %d p%p\n", status, primary_plane);
+	drm_crtc_helper_add(crtc, &evdi_helper_funcs);
+
+	return 0;
+}
+
+static const struct drm_mode_config_funcs evdi_mode_funcs = {
+	.fb_create = evdi_fb_user_fb_create,
+#if KERNEL_VERSION(6, 11, 0) < LINUX_VERSION_CODE || defined(EL9)
+#else
+	.output_poll_changed = NULL,
+#endif
+	.atomic_commit = drm_atomic_helper_commit,
+	.atomic_check = drm_atomic_helper_check
+};
+
+void evdi_modeset_init(struct drm_device *dev)
+{
+	struct drm_encoder *encoder;
+
+	EVDI_CHECKPT();
+
+	drm_mode_config_init(dev);
+
+	dev->mode_config.min_width = 64;
+	dev->mode_config.min_height = 64;
+
+	dev->mode_config.max_width = 7680;
+	dev->mode_config.max_height = 4320;
+
+	dev->mode_config.prefer_shadow = 0;
+	dev->mode_config.preferred_depth = 24;
+
+	dev->mode_config.funcs = &evdi_mode_funcs;
+
+	evdi_crtc_init(dev);
+
+	encoder = evdi_encoder_init(dev);
+
+	evdi_connector_init(dev, encoder);
+
+	drm_mode_config_reset(dev);
+}
+
+void evdi_modeset_cleanup(__maybe_unused struct drm_device *dev)
+{
+#if KERNEL_VERSION(5, 8, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	drm_mode_config_cleanup(dev);
+#endif
+}
diff --git a/drivers/custom/evdi/module/evdi_painter.c b/drivers/custom/evdi/module/evdi_painter.c
new file mode 100644
index 000000000000..47e0acd43cc4
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_painter.c
@@ -0,0 +1,1429 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2013 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include "linux/thread_info.h"
+#include "linux/mm.h"
+#include <linux/version.h>
+#if KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL8) || defined(EL9)
+#include <drm/drm_file.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_ioctl.h>
+#elif KERNEL_VERSION(5, 5, 0) <= LINUX_VERSION_CODE
+#else
+#include <drm/drmP.h>
+#endif
+#include <drm/drm_edid.h>
+#include "evdi_drm.h"
+#include "evdi_drm_drv.h"
+#include "evdi_cursor.h"
+#include "evdi_params.h"
+#include "evdi_i2c.h"
+#include <linux/mutex.h>
+#include <linux/compiler.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+
+#include <linux/dma-buf.h>
+#include <linux/vt_kern.h>
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <linux/compiler_attributes.h>
+#endif
+
+/* Import of DMA_BUF namespace was reverted in EL8 */
+#if KERNEL_VERSION(6, 13, 0) <= LINUX_VERSION_CODE || defined(EL10)
+MODULE_IMPORT_NS("DMA_BUF");
+#elif KERNEL_VERSION(5, 16, 0) <= LINUX_VERSION_CODE || defined(EL9)
+MODULE_IMPORT_NS(DMA_BUF);
+#endif
+
+#if KERNEL_VERSION(5, 1, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#include <drm/drm_probe_helper.h>
+#endif
+
+struct evdi_event_cursor_set_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_cursor_set cursor_set;
+};
+
+struct evdi_event_cursor_move_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_cursor_move cursor_move;
+};
+
+struct evdi_event_update_ready_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_update_ready update_ready;
+};
+
+struct evdi_event_dpms_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_dpms dpms;
+};
+
+struct evdi_event_mode_changed_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_mode_changed mode_changed;
+};
+
+struct evdi_event_crtc_state_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_crtc_state crtc_state;
+};
+
+struct evdi_event_ddcci_data_pending {
+	struct drm_pending_event base;
+	struct drm_evdi_event_ddcci_data ddcci_data;
+};
+
+#define MAX_DIRTS 16
+#define EDID_EXT_BLOCK_SIZE 128
+#define MAX_EDID_SIZE (255 * EDID_EXT_BLOCK_SIZE + sizeof(struct edid))
+#define I2C_ADDRESS_DDCCI 0x37
+#define DDCCI_TIMEOUT_MS 50
+
+struct evdi_painter {
+	bool is_connected;
+	struct edid *edid;
+	unsigned int edid_length;
+
+	struct mutex lock;
+	struct drm_clip_rect dirty_rects[MAX_DIRTS];
+	int num_dirts;
+	struct evdi_framebuffer *scanout_fb;
+
+	struct drm_file *drm_filp;
+	struct drm_device *drm_device;
+
+	bool was_update_requested;
+	bool needs_full_modeset;
+	struct drm_crtc *crtc;
+	struct drm_pending_vblank_event *vblank;
+
+	struct list_head pending_events;
+	struct delayed_work send_events_work;
+
+	struct completion ddcci_response_received;
+	char *ddcci_buffer;
+	unsigned int ddcci_buffer_length;
+	struct notifier_block vt_notifier;
+	int fg_console;
+};
+
+static void expand_rect(struct drm_clip_rect *a, const struct drm_clip_rect *b)
+{
+	a->x1 = min(a->x1, b->x1);
+	a->y1 = min(a->y1, b->y1);
+	a->x2 = max(a->x2, b->x2);
+	a->y2 = max(a->y2, b->y2);
+}
+
+static int rect_area(const struct drm_clip_rect *r)
+{
+	return (r->x2 - r->x1) * (r->y2 - r->y1);
+}
+
+static void merge_dirty_rects(struct drm_clip_rect *rects, int *count)
+{
+	int a, b;
+
+	for (a = 0; a < *count - 1; ++a) {
+		for (b = a + 1; b < *count;) {
+			/* collapse to bounding rect if it is fewer pixels */
+			const int area_a = rect_area(&rects[a]);
+			const int area_b = rect_area(&rects[b]);
+			struct drm_clip_rect bounding_rect = rects[a];
+
+			expand_rect(&bounding_rect, &rects[b]);
+
+			if (rect_area(&bounding_rect) <= area_a + area_b) {
+				rects[a] = bounding_rect;
+				rects[b] = rects[*count - 1];
+				/* repass */
+				b = a + 1;
+				--*count;
+			} else {
+				++b;
+			}
+		}
+	}
+}
+
+static void collapse_dirty_rects(struct drm_clip_rect *rects, int *count)
+{
+	int i;
+
+	EVDI_VERBOSE("Not enough space for rects. They will be collapsed");
+
+	for (i = 1; i < *count; ++i)
+		expand_rect(&rects[0], &rects[i]);
+
+	*count = 1;
+}
+
+static int copy_primary_pixels(struct evdi_framebuffer *efb,
+			       char __user *buffer,
+			       int buf_byte_stride,
+			       int num_rects, struct drm_clip_rect *rects,
+			       int const max_x,
+			       int const max_y)
+{
+	struct drm_framebuffer *fb = &efb->base;
+	struct drm_clip_rect *r;
+
+	EVDI_CHECKPT();
+
+	for (r = rects; r != rects + num_rects; ++r) {
+		const int byte_offset = r->x1 * 4;
+		const int byte_span = (r->x2 - r->x1) * 4;
+		const int src_offset = fb->offsets[0] +
+				       fb->pitches[0] * r->y1 + byte_offset;
+		const char *src = (char *)efb->obj->vmapping + src_offset;
+		const int dst_offset = buf_byte_stride * r->y1 + byte_offset;
+		char __user *dst = buffer + dst_offset;
+		int y = r->y2 - r->y1;
+
+		/* rect size may correspond to previous resolution */
+		if (max_x < r->x2 || max_y < r->y2) {
+			EVDI_WARN("Rect size beyond expected dimensions\n");
+			return -EFAULT;
+		}
+
+		EVDI_VERBOSE("copy rect %d,%d-%d,%d\n", r->x1, r->y1, r->x2,
+			     r->y2);
+
+		for (; y > 0; --y) {
+			if (copy_to_user(dst, src, byte_span))
+				return -EFAULT;
+
+			src += fb->pitches[0];
+			dst += buf_byte_stride;
+		}
+	}
+
+	return 0;
+}
+
+static void copy_cursor_pixels(struct evdi_framebuffer *efb,
+			       char __user *buffer,
+			       int buf_byte_stride,
+			       struct evdi_cursor *cursor)
+{
+	evdi_cursor_lock(cursor);
+	if (evdi_cursor_compose_and_copy(cursor,
+					 efb,
+					 buffer,
+					 buf_byte_stride))
+		EVDI_ERROR("Failed to blend cursor\n");
+
+	evdi_cursor_unlock(cursor);
+}
+
+#define painter_lock(painter)                           \
+	do {                                            \
+		EVDI_VERBOSE("Painter lock\n");         \
+		mutex_lock(&painter->lock);             \
+	} while (0)
+
+#define painter_unlock(painter)                         \
+	do {                                            \
+		EVDI_VERBOSE("Painter unlock\n");       \
+		mutex_unlock(&painter->lock);           \
+	} while (0)
+
+bool evdi_painter_is_connected(struct evdi_painter *painter)
+{
+	return painter ? painter->is_connected : false;
+}
+
+u8 *evdi_painter_get_edid_copy(struct evdi_device *evdi)
+{
+	u8 *block = NULL;
+
+	EVDI_CHECKPT();
+
+	painter_lock(evdi->painter);
+	if (evdi_painter_is_connected(evdi->painter) &&
+		evdi->painter->edid &&
+		evdi->painter->edid_length) {
+		block = kmalloc(evdi->painter->edid_length, GFP_KERNEL);
+		if (block) {
+			memcpy(block,
+			       evdi->painter->edid,
+			       evdi->painter->edid_length);
+		}
+	}
+	painter_unlock(evdi->painter);
+	return block;
+}
+
+static bool is_evdi_event_squashable(struct drm_pending_event *event)
+{
+	return event->event->type == DRM_EVDI_EVENT_CURSOR_SET ||
+	       event->event->type == DRM_EVDI_EVENT_CURSOR_MOVE;
+}
+
+static void evdi_painter_add_event_to_pending_list(
+	struct evdi_painter *painter,
+	struct drm_pending_event *event)
+{
+	unsigned long flags;
+	struct drm_pending_event *last_event = NULL;
+	struct list_head *list = NULL;
+
+	spin_lock_irqsave(&painter->drm_device->event_lock, flags);
+
+	list = &painter->pending_events;
+	if (!list_empty(list)) {
+		last_event =
+		  list_last_entry(list, struct drm_pending_event, link);
+	}
+
+	if (last_event &&
+	    event->event->type == last_event->event->type &&
+	    is_evdi_event_squashable(event)) {
+		list_replace(&last_event->link, &event->link);
+		kfree(last_event);
+	} else
+		list_add_tail(&event->link, list);
+
+	spin_unlock_irqrestore(&painter->drm_device->event_lock, flags);
+}
+
+static bool evdi_painter_flush_pending_events(struct evdi_painter *painter)
+{
+	unsigned long flags;
+	struct drm_pending_event *event_to_be_sent = NULL;
+	struct list_head *list = NULL;
+	bool has_space = false;
+	bool flushed_all = false;
+
+	spin_lock_irqsave(&painter->drm_device->event_lock, flags);
+
+	list = &painter->pending_events;
+	while ((event_to_be_sent = list_first_entry_or_null(
+			list, struct drm_pending_event, link))) {
+		has_space = drm_event_reserve_init_locked(painter->drm_device,
+		    painter->drm_filp, event_to_be_sent,
+		    event_to_be_sent->event) == 0;
+		if (has_space) {
+			list_del_init(&event_to_be_sent->link);
+			drm_send_event_locked(painter->drm_device,
+					      event_to_be_sent);
+		} else
+			break;
+	}
+
+	flushed_all = list_empty(&painter->pending_events);
+	spin_unlock_irqrestore(&painter->drm_device->event_lock, flags);
+
+	return flushed_all;
+}
+
+static void evdi_painter_send_event(struct evdi_painter *painter,
+				    struct drm_pending_event *event)
+{
+	if (!event) {
+		EVDI_ERROR("Null drm event!\n");
+		return;
+	}
+
+	if (!painter->drm_filp) {
+		EVDI_VERBOSE("Painter is not connected!");
+		drm_event_cancel_free(painter->drm_device, event);
+		return;
+	}
+
+	if (!painter->drm_device) {
+		EVDI_WARN("Painter is not connected to drm device!\n");
+		drm_event_cancel_free(painter->drm_device, event);
+		return;
+	}
+
+	if (!painter->is_connected) {
+		EVDI_WARN("Painter is not connected!\n");
+		drm_event_cancel_free(painter->drm_device, event);
+		return;
+	}
+
+	evdi_painter_add_event_to_pending_list(painter, event);
+	if (delayed_work_pending(&painter->send_events_work))
+		return;
+
+	if (evdi_painter_flush_pending_events(painter))
+		return;
+
+	schedule_delayed_work(&painter->send_events_work, msecs_to_jiffies(5));
+}
+
+static struct drm_pending_event *create_update_ready_event(void)
+{
+	struct evdi_event_update_ready_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event) {
+		EVDI_ERROR("Failed to create update ready event\n");
+		return NULL;
+	}
+
+	event->update_ready.base.type = DRM_EVDI_EVENT_UPDATE_READY;
+	event->update_ready.base.length = sizeof(event->update_ready);
+	event->base.event = &event->update_ready.base;
+	return &event->base;
+}
+
+static void evdi_painter_send_update_ready(struct evdi_painter *painter)
+{
+	struct drm_pending_event *event = create_update_ready_event();
+
+	evdi_painter_send_event(painter, event);
+}
+
+static uint32_t evdi_painter_get_gem_handle(struct evdi_painter *painter,
+					   struct evdi_gem_object *obj)
+{
+	uint32_t handle = 0;
+
+	if (!obj)
+		return 0;
+
+	handle = evdi_gem_object_handle_lookup(painter->drm_filp, &obj->base);
+
+	if (handle)
+		return handle;
+
+	if (drm_gem_handle_create(painter->drm_filp,
+			      &obj->base, &handle)) {
+		EVDI_ERROR("Failed to create gem handle for %p\n",
+			painter->drm_filp);
+	}
+
+	return handle;
+}
+
+static struct drm_pending_event *create_cursor_set_event(
+		struct evdi_painter *painter,
+		struct evdi_cursor *cursor)
+{
+	struct evdi_event_cursor_set_pending *event;
+	struct evdi_gem_object *eobj = NULL;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event) {
+		EVDI_ERROR("Failed to create cursor set event\n");
+		return NULL;
+	}
+
+	event->cursor_set.base.type = DRM_EVDI_EVENT_CURSOR_SET;
+	event->cursor_set.base.length = sizeof(event->cursor_set);
+
+	evdi_cursor_lock(cursor);
+	event->cursor_set.enabled = evdi_cursor_enabled(cursor);
+	evdi_cursor_hotpoint(cursor, &event->cursor_set.hot_x,
+				     &event->cursor_set.hot_y);
+	evdi_cursor_size(cursor,
+		&event->cursor_set.width,
+		&event->cursor_set.height);
+	evdi_cursor_format(cursor, &event->cursor_set.pixel_format);
+	evdi_cursor_stride(cursor, &event->cursor_set.stride);
+	eobj = evdi_cursor_gem(cursor);
+	event->cursor_set.buffer_handle =
+		evdi_painter_get_gem_handle(painter, eobj);
+	if (eobj)
+		event->cursor_set.buffer_length = eobj->base.size;
+	if (!event->cursor_set.buffer_handle) {
+		event->cursor_set.enabled = false;
+		event->cursor_set.buffer_length = 0;
+	}
+	evdi_cursor_unlock(cursor);
+
+	event->base.event = &event->cursor_set.base;
+	return &event->base;
+}
+
+void evdi_painter_send_cursor_set(struct evdi_painter *painter,
+				  struct evdi_cursor *cursor)
+{
+	struct drm_pending_event *event =
+		create_cursor_set_event(painter, cursor);
+
+	evdi_painter_send_event(painter, event);
+}
+
+static struct drm_pending_event *create_cursor_move_event(
+		struct evdi_cursor *cursor)
+{
+	struct evdi_event_cursor_move_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event) {
+		EVDI_ERROR("Failed to create cursor move event\n");
+		return NULL;
+	}
+
+	event->cursor_move.base.type = DRM_EVDI_EVENT_CURSOR_MOVE;
+	event->cursor_move.base.length = sizeof(event->cursor_move);
+
+	evdi_cursor_lock(cursor);
+	evdi_cursor_position(
+		cursor,
+		&event->cursor_move.x,
+		&event->cursor_move.y);
+	evdi_cursor_unlock(cursor);
+
+	event->base.event = &event->cursor_move.base;
+	return &event->base;
+}
+
+void evdi_painter_send_cursor_move(struct evdi_painter *painter,
+				   struct evdi_cursor *cursor)
+{
+	struct drm_pending_event *event = create_cursor_move_event(cursor);
+
+	evdi_painter_send_event(painter, event);
+}
+
+static struct drm_pending_event *create_dpms_event(int mode)
+{
+	struct evdi_event_dpms_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event) {
+		EVDI_ERROR("Failed to create dpms event\n");
+		return NULL;
+	}
+
+	event->dpms.base.type = DRM_EVDI_EVENT_DPMS;
+	event->dpms.base.length = sizeof(event->dpms);
+	event->dpms.mode = mode;
+	event->base.event = &event->dpms.base;
+	return &event->base;
+}
+
+static void evdi_painter_send_dpms(struct evdi_painter *painter, int mode)
+{
+	struct drm_pending_event *event = create_dpms_event(mode);
+
+	EVDI_TEST_HOOK(evdi_testhook_painter_send_dpms(mode));
+	evdi_painter_send_event(painter, event);
+}
+
+static struct drm_pending_event *create_mode_changed_event(
+	struct drm_display_mode *current_mode,
+	int32_t bits_per_pixel,
+	uint32_t pixel_format)
+{
+	struct evdi_event_mode_changed_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event) {
+		EVDI_ERROR("Failed to create mode changed event\n");
+		return NULL;
+	}
+
+	event->mode_changed.base.type = DRM_EVDI_EVENT_MODE_CHANGED;
+	event->mode_changed.base.length = sizeof(event->mode_changed);
+
+	event->mode_changed.hdisplay = current_mode->hdisplay;
+	event->mode_changed.vdisplay = current_mode->vdisplay;
+	event->mode_changed.vrefresh = drm_mode_vrefresh(current_mode);
+	event->mode_changed.bits_per_pixel = bits_per_pixel;
+	event->mode_changed.pixel_format = pixel_format;
+
+	event->base.event = &event->mode_changed.base;
+	return &event->base;
+}
+
+static void evdi_painter_send_mode_changed(
+	struct evdi_painter *painter,
+	struct drm_display_mode *current_mode,
+	int32_t bits_per_pixel,
+	uint32_t pixel_format)
+{
+	struct drm_pending_event *event = create_mode_changed_event(
+		current_mode, bits_per_pixel, pixel_format);
+
+	evdi_painter_send_event(painter, event);
+}
+
+int evdi_painter_get_num_dirts(struct evdi_painter *painter)
+{
+	int num_dirts;
+
+	if (painter == NULL) {
+		EVDI_WARN("Painter is not connected!\n");
+		return 0;
+	}
+
+	painter_lock(painter);
+
+	num_dirts = painter->num_dirts;
+
+	painter_unlock(painter);
+
+	return num_dirts;
+}
+
+struct drm_clip_rect evdi_painter_framebuffer_size(
+	struct evdi_painter *painter)
+{
+	struct drm_clip_rect rect = {0, 0, 0, 0};
+	struct evdi_framebuffer *efb = NULL;
+
+	if (painter == NULL) {
+		EVDI_WARN("Painter is not connected!\n");
+		return rect;
+	}
+
+	painter_lock(painter);
+	efb = painter->scanout_fb;
+	if (!efb) {
+		if (painter->is_connected)
+			EVDI_WARN("Scanout buffer not set.\n");
+		goto unlock;
+	}
+	rect.x1 = 0;
+	rect.y1 = 0;
+	rect.x2 = efb->base.width;
+	rect.y2 = efb->base.height;
+unlock:
+	painter_unlock(painter);
+	return rect;
+}
+
+void evdi_painter_mark_dirty(struct evdi_device *evdi,
+			     const struct drm_clip_rect *dirty_rect)
+{
+	struct drm_clip_rect rect;
+	struct evdi_framebuffer *efb = NULL;
+	struct evdi_painter *painter = evdi->painter;
+
+	if (painter == NULL) {
+		EVDI_WARN("Painter is not connected!\n");
+		return;
+	}
+
+	painter_lock(painter);
+	efb = painter->scanout_fb;
+	if (!efb) {
+		if (painter->is_connected)
+			EVDI_WARN("(card%d) Skip clip rect. Scanout buffer not set.\n",
+			   evdi->dev_index);
+		goto unlock;
+	}
+
+	rect = evdi_framebuffer_sanitize_rect(efb, dirty_rect);
+
+	EVDI_VERBOSE("(card%d) %d,%d-%d,%d\n", evdi->dev_index, rect.x1,
+		     rect.y1, rect.x2, rect.y2);
+
+	if (painter->num_dirts == MAX_DIRTS)
+		merge_dirty_rects(&painter->dirty_rects[0],
+				  &painter->num_dirts);
+
+	if (painter->num_dirts == MAX_DIRTS)
+		collapse_dirty_rects(&painter->dirty_rects[0],
+				     &painter->num_dirts);
+
+	memcpy(&painter->dirty_rects[painter->num_dirts], &rect, sizeof(rect));
+	painter->num_dirts++;
+
+unlock:
+	painter_unlock(painter);
+}
+
+static void evdi_send_vblank(struct drm_crtc *crtc,
+			     struct drm_pending_vblank_event *vblank)
+{
+	if (crtc && vblank) {
+		unsigned long flags = 0;
+
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, vblank);
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+	}
+}
+
+static void evdi_painter_send_vblank(struct evdi_painter *painter)
+{
+	EVDI_CHECKPT();
+
+	evdi_send_vblank(painter->crtc, painter->vblank);
+
+	painter->crtc = NULL;
+	painter->vblank = NULL;
+}
+
+void evdi_painter_set_vblank(
+	struct evdi_painter *painter,
+	struct drm_crtc *crtc,
+	struct drm_pending_vblank_event *vblank)
+{
+	EVDI_CHECKPT();
+
+	if (painter) {
+		painter_lock(painter);
+
+		evdi_painter_send_vblank(painter);
+
+		if (painter->num_dirts > 0 && painter->is_connected) {
+			painter->crtc = crtc;
+			painter->vblank = vblank;
+		} else {
+			evdi_send_vblank(crtc, vblank);
+		}
+
+		painter_unlock(painter);
+	} else {
+		evdi_send_vblank(crtc, vblank);
+	}
+}
+
+void evdi_painter_send_update_ready_if_needed(struct evdi_painter *painter)
+{
+	EVDI_CHECKPT();
+	if (painter) {
+		painter_lock(painter);
+#if KERNEL_VERSION(5, 10, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		if (painter->was_update_requested && painter->num_dirts) {
+#else
+		if (painter->was_update_requested) {
+#endif
+			evdi_painter_send_update_ready(painter);
+			painter->was_update_requested = false;
+		}
+
+		painter_unlock(painter);
+	} else {
+		EVDI_WARN("Painter does not exist!\n");
+	}
+}
+
+static const char * const dpms_str[] = { "on", "standby", "suspend", "off" };
+
+void evdi_painter_dpms_notify(struct evdi_painter *painter, int mode)
+{
+	const char *mode_str;
+
+	if (!painter) {
+		EVDI_WARN("Painter does not exist!\n");
+		return;
+	}
+
+	if (!painter->is_connected)
+		return;
+
+	switch (mode) {
+	case DRM_MODE_DPMS_ON:
+		painter->fg_console = fg_console;
+#if KERNEL_VERSION(5, 4, 0) <= LINUX_VERSION_CODE || defined(EL8)
+		fallthrough;
+#else
+#endif
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	case DRM_MODE_DPMS_OFF:
+		mode_str = dpms_str[mode];
+		break;
+	default:
+		mode_str = "unknown";
+	};
+	EVDI_INFO("(card%d) Notifying display power state: %s\n",
+		   painter->drm_device->primary->index, mode_str);
+	evdi_painter_send_dpms(painter, mode);
+}
+
+static void evdi_log_pixel_format(uint32_t pixel_format,
+		char *buf, size_t size)
+{
+#if KERNEL_VERSION(5, 14, 0) <= LINUX_VERSION_CODE || defined(EL8)
+	snprintf(buf, size, "pixel format %p4cc", &pixel_format);
+#else
+	struct drm_format_name_buf format_name;
+
+	drm_get_format_name(pixel_format, &format_name);
+	snprintf(buf, size, "pixel format %s", format_name.str);
+#endif
+}
+
+void evdi_painter_mode_changed_notify(struct evdi_device *evdi,
+				      struct drm_display_mode *new_mode)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_framebuffer *fb;
+	int bits_per_pixel;
+	uint32_t pixel_format;
+	char buf[100];
+
+	if (painter == NULL)
+		return;
+
+	painter_lock(painter);
+	fb = &painter->scanout_fb->base;
+	if (fb == NULL) {
+		painter_unlock(painter);
+		return;
+	}
+
+	bits_per_pixel = fb->format->cpp[0] * 8;
+	pixel_format = fb->format->format;
+	painter_unlock(painter);
+
+	evdi_log_pixel_format(pixel_format, buf, sizeof(buf));
+	EVDI_INFO("(card%d) Notifying mode changed: %dx%d@%d; bpp %d; %s\n",
+		   evdi->dev_index, new_mode->hdisplay, new_mode->vdisplay,
+		   drm_mode_vrefresh(new_mode), bits_per_pixel, buf);
+
+	evdi_painter_send_mode_changed(painter,
+				       new_mode,
+				       bits_per_pixel,
+				       pixel_format);
+	painter->needs_full_modeset = false;
+}
+
+static void evdi_painter_events_cleanup(struct evdi_painter *painter)
+{
+	struct drm_pending_event *event, *temp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&painter->drm_device->event_lock, flags);
+	list_for_each_entry_safe(event, temp, &painter->pending_events, link) {
+		list_del(&event->link);
+		kfree(event);
+	}
+	spin_unlock_irqrestore(&painter->drm_device->event_lock, flags);
+
+	cancel_delayed_work_sync(&painter->send_events_work);
+}
+
+static void evdi_add_i2c_adapter(struct evdi_device *evdi)
+{
+	struct drm_device *ddev = evdi->ddev;
+	struct platform_device *platdev = to_platform_device(ddev->dev);
+	int result = 0;
+
+	evdi->i2c_adapter = kzalloc(sizeof(*evdi->i2c_adapter), GFP_KERNEL);
+
+	if (!evdi->i2c_adapter) {
+		EVDI_ERROR("(card%d) Failed to allocate for i2c adapter\n",
+			evdi->dev_index);
+		return;
+	}
+
+	result = evdi_i2c_add(evdi->i2c_adapter, &platdev->dev, ddev->dev_private);
+
+	if (result) {
+		kfree(evdi->i2c_adapter);
+		evdi->i2c_adapter = NULL;
+		EVDI_ERROR("(card%d) Failed to add i2c adapter, error %d\n",
+			evdi->dev_index, result);
+		return;
+	}
+
+	EVDI_INFO("(card%d) Added i2c adapter bus number %d\n",
+		evdi->dev_index, evdi->i2c_adapter->nr);
+
+	result = sysfs_create_link(&evdi->conn->kdev->kobj,
+			&evdi->i2c_adapter->dev.kobj, "ddc");
+
+	if (result) {
+		EVDI_ERROR("(card%d) Failed to create sysfs link, error %d\n",
+			evdi->dev_index, result);
+		return;
+	}
+}
+
+static void evdi_remove_i2c_adapter(struct evdi_device *evdi)
+{
+	if (evdi->i2c_adapter) {
+		EVDI_INFO("(card%d) Removing i2c adapter bus number %d\n",
+			evdi->dev_index, evdi->i2c_adapter->nr);
+
+		sysfs_remove_link(&evdi->conn->kdev->kobj, "ddc");
+
+		evdi_i2c_remove(evdi->i2c_adapter);
+
+		kfree(evdi->i2c_adapter);
+		evdi->i2c_adapter = NULL;
+	}
+}
+
+static int
+evdi_painter_connect(struct evdi_device *evdi,
+		     void const __user *edid_data, unsigned int edid_length,
+		     uint32_t pixel_area_limit,
+		     uint32_t pixel_per_second_limit,
+		     struct drm_file *file, __always_unused int dev_index)
+{
+	struct evdi_painter *painter = evdi->painter;
+	struct edid *new_edid = NULL;
+	unsigned int expected_edid_size = 0;
+	char buf[100];
+
+	evdi_log_process(buf, sizeof(buf));
+
+	if (edid_length < sizeof(struct edid)) {
+		EVDI_ERROR("Edid length too small\n");
+		return -EINVAL;
+	}
+
+	if (edid_length > MAX_EDID_SIZE) {
+		EVDI_ERROR("Edid length too large\n");
+		return -EINVAL;
+	}
+
+	new_edid = kzalloc(edid_length, GFP_KERNEL);
+	if (!new_edid)
+		return -ENOMEM;
+
+	if (copy_from_user(new_edid, edid_data, edid_length)) {
+		EVDI_ERROR("(card%d) Failed to read edid\n", evdi->dev_index);
+		kfree(new_edid);
+		return -EFAULT;
+	}
+
+	expected_edid_size = sizeof(struct edid) +
+			     new_edid->extensions * EDID_EXT_BLOCK_SIZE;
+	if (expected_edid_size != edid_length) {
+		EVDI_ERROR("Wrong edid size. Expected %d but is %d\n",
+			   expected_edid_size, edid_length);
+		kfree(new_edid);
+		return -EINVAL;
+	}
+
+	if (painter->drm_filp)
+		EVDI_WARN("(card%d) Double connect - replacing %p with %p\n",
+			  evdi->dev_index, painter->drm_filp, file);
+
+	painter_lock(painter);
+
+	evdi->pixel_area_limit = pixel_area_limit;
+	evdi->pixel_per_second_limit = pixel_per_second_limit;
+	painter->drm_filp = file;
+	kfree(painter->edid);
+	painter->edid_length = edid_length;
+	painter->edid = new_edid;
+	painter->is_connected = true;
+	painter->needs_full_modeset = true;
+
+	if (!evdi->i2c_adapter)
+		evdi_add_i2c_adapter(evdi);
+
+	painter_unlock(painter);
+
+	EVDI_INFO("(card%d) Connected with %s\n", evdi->dev_index, buf);
+
+	drm_helper_hpd_irq_event(evdi->ddev);
+
+	return 0;
+}
+
+static int evdi_painter_disconnect(struct evdi_device *evdi,
+	struct drm_file *file)
+{
+	struct evdi_painter *painter = evdi->painter;
+	char buf[100];
+
+	EVDI_CHECKPT();
+
+	painter_lock(painter);
+
+	if (file != painter->drm_filp) {
+		painter_unlock(painter);
+		return -EFAULT;
+	}
+
+	if (painter->scanout_fb) {
+		drm_framebuffer_put(&painter->scanout_fb->base);
+		painter->scanout_fb = NULL;
+	}
+
+	painter->is_connected = false;
+
+	evdi_log_process(buf, sizeof(buf));
+	EVDI_INFO("(card%d) Disconnected from %s\n", evdi->dev_index, buf);
+	evdi_painter_events_cleanup(painter);
+
+	evdi_painter_send_vblank(painter);
+
+	evdi_cursor_enable(evdi->cursor, false);
+
+	kfree(painter->ddcci_buffer);
+	painter->ddcci_buffer = NULL;
+	painter->ddcci_buffer_length = 0;
+
+	evdi_remove_i2c_adapter(evdi);
+
+	painter->drm_filp = NULL;
+
+	painter->was_update_requested = false;
+	evdi->cursor_events_enabled = false;
+
+	painter_unlock(painter);
+
+	// Signal anything waiting for ddc/ci response with NULL buffer
+	complete(&painter->ddcci_response_received);
+
+	drm_helper_hpd_irq_event(evdi->ddev);
+	return 0;
+}
+
+void evdi_painter_close(struct evdi_device *evdi, struct drm_file *file)
+{
+	EVDI_CHECKPT();
+
+	if (evdi->painter && file == evdi->painter->drm_filp)
+		evdi_painter_disconnect(evdi, file);
+}
+
+int evdi_painter_connect_ioctl(struct drm_device *drm_dev, void *data,
+			       struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_connect *cmd = data;
+	int ret;
+
+	EVDI_CHECKPT();
+	if (painter) {
+		if (cmd->connected)
+			ret = evdi_painter_connect(evdi,
+					     cmd->edid,
+					     cmd->edid_length,
+					     cmd->pixel_area_limit,
+					     cmd->pixel_per_second_limit,
+					     file,
+					     cmd->dev_index);
+		else
+			ret = evdi_painter_disconnect(evdi, file);
+
+		if (ret) {
+			EVDI_WARN("(card%d)(pid=%d) disconnect failed\n",
+				  evdi->dev_index, (int)task_pid_nr(current));
+		}
+		return ret;
+	}
+	EVDI_WARN("(card%d) Painter does not exist!\n", evdi->dev_index);
+	return -ENODEV;
+}
+
+int evdi_painter_grabpix_ioctl(struct drm_device *drm_dev, void *data,
+			       __always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_grabpix *cmd = data;
+	struct evdi_framebuffer *efb = NULL;
+	struct drm_clip_rect dirty_rects[MAX_DIRTS];
+	struct drm_crtc *crtc = NULL;
+	struct drm_pending_vblank_event *vblank = NULL;
+	int err;
+	int ret;
+	struct dma_buf_attachment *import_attach;
+
+	EVDI_CHECKPT();
+
+	if (cmd->mode != EVDI_GRABPIX_MODE_DIRTY) {
+		EVDI_ERROR("Unknown command mode\n");
+		return -EINVAL;
+	}
+
+	if (cmd->num_rects < 1) {
+		EVDI_ERROR("No space for clip rects\n");
+		return -EINVAL;
+	}
+
+	if (!painter)
+		return -ENODEV;
+
+	painter_lock(painter);
+
+	if (painter->was_update_requested) {
+		EVDI_WARN("(card%d) Update ready not sent,",
+			  evdi->dev_index);
+		EVDI_WARN(" but pixels are grabbed.\n");
+	}
+
+	if (painter->num_dirts < 0) {
+		err = -EAGAIN;
+		goto err_painter;
+	}
+
+	merge_dirty_rects(&painter->dirty_rects[0],
+			  &painter->num_dirts);
+	if (painter->num_dirts > cmd->num_rects)
+		collapse_dirty_rects(&painter->dirty_rects[0],
+				     &painter->num_dirts);
+
+	cmd->num_rects = painter->num_dirts;
+	memcpy(dirty_rects, painter->dirty_rects,
+	       painter->num_dirts * sizeof(painter->dirty_rects[0]));
+
+	efb = painter->scanout_fb;
+
+	if (!efb) {
+		EVDI_ERROR("Scanout buffer not set\n");
+		err = -EAGAIN;
+		goto err_painter;
+	}
+
+	painter->num_dirts = 0;
+
+	drm_framebuffer_get(&efb->base);
+
+	crtc = painter->crtc;
+	painter->crtc = NULL;
+
+	vblank = painter->vblank;
+	painter->vblank = NULL;
+
+
+	painter_unlock(painter);
+
+	if (!efb->obj->vmapping) {
+		if (evdi_gem_vmap(efb->obj) == -ENOMEM) {
+			EVDI_ERROR("Failed to map scanout buffer\n");
+			err = -EFAULT;
+			goto err_fb;
+		}
+		if (!efb->obj->vmapping) {
+			EVDI_ERROR("Inexistent vmapping\n");
+			err = -EFAULT;
+			goto err_fb;
+		}
+	}
+
+	if ((unsigned int)cmd->buf_width != efb->base.width ||
+		(unsigned int)cmd->buf_height != efb->base.height) {
+		EVDI_DEBUG("Invalid buffer dimension\n");
+		err = -EINVAL;
+		goto err_fb;
+	}
+
+	if (copy_to_user(cmd->rects, dirty_rects,
+		cmd->num_rects * sizeof(cmd->rects[0]))) {
+		err = -EFAULT;
+		goto err_fb;
+	}
+
+	import_attach = efb->obj->base.import_attach;
+	if (import_attach) {
+		ret = dma_buf_begin_cpu_access(import_attach->dmabuf,
+					       DMA_FROM_DEVICE);
+		if (ret) {
+			err = -EFAULT;
+			goto err_fb;
+		}
+	}
+
+	err = copy_primary_pixels(efb,
+				  cmd->buffer,
+				  cmd->buf_byte_stride,
+				  cmd->num_rects,
+				  dirty_rects,
+				  cmd->buf_width,
+				  cmd->buf_height);
+	if (err == 0 && !evdi->cursor_events_enabled)
+		copy_cursor_pixels(efb,
+				   cmd->buffer,
+				   cmd->buf_byte_stride,
+				   evdi->cursor);
+
+	if (import_attach)
+		dma_buf_end_cpu_access(import_attach->dmabuf,
+				       DMA_FROM_DEVICE);
+
+err_fb:
+	evdi_send_vblank(crtc, vblank);
+
+	drm_framebuffer_put(&efb->base);
+
+	return err;
+
+err_painter:
+	painter_unlock(painter);
+	return err;
+}
+
+int evdi_painter_request_update_ioctl(struct drm_device *drm_dev,
+				      __always_unused void *data,
+				      __always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	int result = 0;
+
+	if (painter) {
+		painter_lock(painter);
+
+		if (painter->was_update_requested) {
+			EVDI_WARN
+			  ("(card%d) Update was already requested - ignoring\n",
+			   evdi->dev_index);
+		} else {
+			if (painter->num_dirts > 0)
+				result = 1;
+			else
+				painter->was_update_requested = true;
+		}
+
+		painter_unlock(painter);
+
+		return result;
+	} else {
+		return -ENODEV;
+	}
+}
+
+static void evdi_send_events_work(struct work_struct *work)
+{
+	struct evdi_painter *painter =
+		container_of(work, struct evdi_painter,	send_events_work.work);
+
+	if (evdi_painter_flush_pending_events(painter))
+		return;
+
+	schedule_delayed_work(&painter->send_events_work, msecs_to_jiffies(5));
+}
+
+#define vt_notifier_block_to_evdi_painter(x) container_of(x, struct evdi_painter, vt_notifier)
+static int evdi_painter_vt_notifier_call(struct notifier_block *blk,
+			    __always_unused unsigned long code, __always_unused void *_param)
+{
+	struct evdi_painter *painter = vt_notifier_block_to_evdi_painter(blk);
+
+	if (painter->is_connected && fg_console != painter->fg_console && !painter->needs_full_modeset) {
+		EVDI_INFO("(card%d) VT switch detected\n", painter->drm_device->primary->index);
+		evdi_painter_dpms_notify(painter, DRM_MODE_DPMS_OFF);
+		evdi_painter_force_full_modeset(painter);
+	}
+
+	return NOTIFY_OK;
+}
+
+
+static void evdi_painter_register_to_vt(struct evdi_painter *painter)
+{
+	painter->vt_notifier.notifier_call = evdi_painter_vt_notifier_call;
+	register_vt_notifier(&painter->vt_notifier);
+
+	EVDI_TEST_HOOK(evdi_testhook_painter_vt_register(&painter->vt_notifier));
+}
+
+static void evdi_painter_unregister_from_vt(struct evdi_painter *painter)
+{
+	unregister_vt_notifier(&painter->vt_notifier);
+	painter->vt_notifier.notifier_call = NULL;
+
+	EVDI_TEST_HOOK(evdi_testhook_painter_vt_register(&painter->vt_notifier));
+}
+
+int evdi_painter_init(struct evdi_device *dev)
+{
+	EVDI_CHECKPT();
+	dev->painter = kzalloc(sizeof(*dev->painter), GFP_KERNEL);
+	if (dev->painter) {
+		mutex_init(&dev->painter->lock);
+		dev->painter->edid = NULL;
+		dev->painter->edid_length = 0;
+		dev->painter->needs_full_modeset = true;
+		dev->painter->crtc = NULL;
+		dev->painter->vblank = NULL;
+		dev->painter->drm_device = dev->ddev;
+		evdi_painter_register_to_vt(dev->painter);
+
+		INIT_LIST_HEAD(&dev->painter->pending_events);
+		INIT_DELAYED_WORK(&dev->painter->send_events_work,
+			evdi_send_events_work);
+		init_completion(&dev->painter->ddcci_response_received);
+		return 0;
+	}
+	return -ENOMEM;
+}
+
+void evdi_painter_cleanup(struct evdi_painter *painter)
+{
+	EVDI_CHECKPT();
+	if (!painter) {
+		EVDI_WARN("Painter does not exist\n");
+		return;
+	}
+
+	painter_lock(painter);
+	evdi_painter_unregister_from_vt(painter);
+	kfree(painter->edid);
+	painter->edid_length = 0;
+	painter->edid = NULL;
+	if (painter->scanout_fb)
+		drm_framebuffer_put(&painter->scanout_fb->base);
+	painter->scanout_fb = NULL;
+
+	evdi_painter_send_vblank(painter);
+
+	evdi_painter_events_cleanup(painter);
+
+	painter->drm_device = NULL;
+	painter_unlock(painter);
+	kfree(painter);
+}
+
+void evdi_painter_set_scanout_buffer(struct evdi_painter *painter,
+				     struct evdi_framebuffer *newfb)
+{
+	struct evdi_framebuffer *oldfb = NULL;
+
+	if (newfb)
+		drm_framebuffer_get(&newfb->base);
+
+	painter_lock(painter);
+
+	oldfb = painter->scanout_fb;
+	painter->scanout_fb = newfb;
+
+	painter_unlock(painter);
+
+	if (oldfb)
+		drm_framebuffer_put(&oldfb->base);
+}
+
+bool evdi_painter_needs_full_modeset(struct evdi_painter *painter)
+{
+	return painter ? painter->needs_full_modeset : false;
+}
+
+
+void evdi_painter_force_full_modeset(struct evdi_painter *painter)
+{
+	if (painter)
+		painter->needs_full_modeset = true;
+}
+
+static struct drm_pending_event *create_ddcci_data_event(struct i2c_msg *msg)
+{
+	struct evdi_event_ddcci_data_pending *event;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (!event || !msg) {
+		EVDI_ERROR("Failed to create ddcci data event\n");
+		return NULL;
+	}
+
+	event->ddcci_data.base.type = DRM_EVDI_EVENT_DDCCI_DATA;
+	event->ddcci_data.base.length = sizeof(event->ddcci_data);
+	// Truncate buffers to a maximum of 64 bytes
+	event->ddcci_data.buffer_length = min_t(__u16, msg->len,
+		sizeof(event->ddcci_data.buffer));
+	memcpy(event->ddcci_data.buffer, msg->buf,
+		event->ddcci_data.buffer_length);
+	event->ddcci_data.flags = msg->flags;
+	event->ddcci_data.address = msg->addr;
+
+	event->base.event = &event->ddcci_data.base;
+	return &event->base;
+}
+
+static void evdi_painter_ddcci_data(struct evdi_painter *painter, struct i2c_msg *msg)
+{
+	struct drm_pending_event *event = create_ddcci_data_event(msg);
+
+	reinit_completion(&painter->ddcci_response_received);
+	evdi_painter_send_event(painter, event);
+
+	if (wait_for_completion_interruptible_timeout(
+		&painter->ddcci_response_received,
+		msecs_to_jiffies(DDCCI_TIMEOUT_MS)) > 0) {
+
+		// Match expected buffer length including any truncation
+		const uint32_t expected_response_length = min_t(__u16, msg->len,
+								DDCCI_BUFFER_SIZE);
+
+		painter_lock(painter);
+
+		if (expected_response_length != painter->ddcci_buffer_length)
+			EVDI_WARN("DDCCI buffer length mismatch\n");
+		else if (painter->ddcci_buffer)
+			memcpy(msg->buf, painter->ddcci_buffer,
+			       painter->ddcci_buffer_length);
+		else
+			EVDI_WARN("Ignoring NULL DDCCI buffer\n");
+
+		painter_unlock(painter);
+	} else {
+		EVDI_WARN("DDCCI response timeout\n");
+	}
+}
+
+bool evdi_painter_i2c_data_notify(struct evdi_painter *painter, struct i2c_msg *msg)
+{
+	if (!evdi_painter_is_connected(painter)) {
+		EVDI_WARN("Painter not connected\n");
+		return false;
+	}
+
+	if (!msg) {
+		EVDI_WARN("Ignored NULL ddc/ci message\n");
+		return false;
+	}
+
+	if (msg->addr != I2C_ADDRESS_DDCCI) {
+		EVDI_WARN("Ignored ddc/ci data for address 0x%x\n", msg->addr);
+		return false;
+	}
+
+	evdi_painter_ddcci_data(painter, msg);
+	return true;
+}
+
+int evdi_painter_ddcci_response_ioctl(struct drm_device *drm_dev, void *data,
+				__always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct evdi_painter *painter = evdi->painter;
+	struct drm_evdi_ddcci_response *cmd = data;
+	int result = 0;
+
+	painter_lock(painter);
+
+	// Truncate any read to 64 bytes
+	painter->ddcci_buffer_length = min_t(uint32_t, cmd->buffer_length,
+					     DDCCI_BUFFER_SIZE);
+
+	kfree(painter->ddcci_buffer);
+	painter->ddcci_buffer = kzalloc(painter->ddcci_buffer_length, GFP_KERNEL);
+	if (!painter->ddcci_buffer) {
+		EVDI_ERROR("DDC buffer allocation failed\n");
+		result = -ENOMEM;
+		goto unlock;
+	}
+
+	if (copy_from_user(painter->ddcci_buffer, cmd->buffer,
+		painter->ddcci_buffer_length)) {
+		EVDI_ERROR("Failed to read ddcci_buffer\n");
+		kfree(painter->ddcci_buffer);
+		painter->ddcci_buffer = NULL;
+		result = -EFAULT;
+		goto unlock;
+	}
+
+	complete(&painter->ddcci_response_received);
+
+unlock:
+	painter_unlock(painter);
+	return result;
+}
+
+int evdi_painter_enable_cursor_events_ioctl(struct drm_device *drm_dev, void *data,
+					__always_unused struct drm_file *file)
+{
+	struct evdi_device *evdi = drm_dev->dev_private;
+	struct drm_evdi_enable_cursor_events *cmd = data;
+
+	evdi->cursor_events_enabled = cmd->enable;
+
+	return 0;
+}
diff --git a/drivers/custom/evdi/module/evdi_params.c b/drivers/custom/evdi/module/evdi_params.c
new file mode 100644
index 000000000000..6ef92862b470
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_params.c
@@ -0,0 +1,25 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "evdi_params.h"
+#include "evdi_debug.h"
+
+unsigned int evdi_loglevel __read_mostly = EVDI_LOGLEVEL_INFO;
+unsigned short int evdi_initial_device_count __read_mostly;
+
+module_param_named(initial_loglevel, evdi_loglevel, int, 0400);
+MODULE_PARM_DESC(initial_loglevel, "Initial log level");
+
+module_param_named(initial_device_count,
+		   evdi_initial_device_count, ushort, 0644);
+MODULE_PARM_DESC(initial_device_count, "Initial DRM device count (default: 0)");
+
diff --git a/drivers/custom/evdi/module/evdi_params.h b/drivers/custom/evdi/module/evdi_params.h
new file mode 100644
index 000000000000..5d67c6b712ab
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_params.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_PARAMS_H
+#define EVDI_PARAMS_H
+
+extern unsigned int evdi_loglevel;
+extern unsigned short int evdi_initial_device_count;
+
+#endif /* EVDI_PARAMS_H */
diff --git a/drivers/custom/evdi/module/evdi_platform_dev.c b/drivers/custom/evdi/module/evdi_platform_dev.c
new file mode 100644
index 000000000000..b47f2d6fd2b7
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_platform_dev.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "evdi_platform_dev.h"
+#include <linux/version.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "evdi_platform_drv.h"
+#include "evdi_debug.h"
+#include "evdi_drm_drv.h"
+
+struct evdi_platform_device_data {
+	struct drm_device *drm_dev;
+	struct device *parent;
+	bool symlinked;
+};
+
+struct platform_device *evdi_platform_dev_create(struct platform_device_info *info)
+{
+	struct platform_device *platform_dev = NULL;
+
+	platform_dev = platform_device_register_full(info);
+	if (dma_set_mask(&platform_dev->dev, DMA_BIT_MASK(64))) {
+		EVDI_WARN("Unable to change dma mask to 64 bit. ");
+		EVDI_WARN("Sticking with 32 bit\n");
+	}
+
+	EVDI_INFO("Evdi platform_device create\n");
+
+	return platform_dev;
+}
+
+void evdi_platform_dev_destroy(struct platform_device *dev)
+{
+	platform_device_unregister(dev);
+	EVDI_INFO("Evdi platform_device destroy\n");
+}
+
+int evdi_platform_device_probe(struct platform_device *pdev)
+{
+	struct drm_device *dev;
+	struct evdi_platform_device_data *data;
+
+	EVDI_CHECKPT();
+	data = kzalloc(sizeof(struct evdi_platform_device_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+#if KERNEL_VERSION(5, 9, 0) <= LINUX_VERSION_CODE || defined(EL8)
+#else
+	#if IS_ENABLED(CONFIG_IOMMU_API) && defined(CONFIG_INTEL_IOMMU)
+	/* Intel-IOMMU workaround: platform-bus unsupported, force ID-mapping */
+	#define INTEL_IOMMU_DUMMY_DOMAIN                ((void *)-1)
+	pdev->dev.archdata.iommu = INTEL_IOMMU_DUMMY_DOMAIN;
+	#endif
+#endif
+
+	dev = evdi_drm_device_create(&pdev->dev);
+	if (IS_ERR_OR_NULL(dev))
+		goto err_free;
+
+	data->drm_dev = dev;
+	data->symlinked = false;
+	platform_set_drvdata(pdev, data);
+	return PTR_ERR_OR_ZERO(dev);
+
+err_free:
+	kfree(data);
+	return PTR_ERR_OR_ZERO(dev);
+}
+
+/* EL9 kernel removed the callback that was returning void  */
+#if KERNEL_VERSION(6, 11, 0) <= LINUX_VERSION_CODE
+void evdi_platform_device_remove(struct platform_device *pdev)
+#else
+int evdi_platform_device_remove(struct platform_device *pdev)
+#endif
+{
+	struct evdi_platform_device_data *data = platform_get_drvdata(pdev);
+
+	EVDI_CHECKPT();
+
+	evdi_drm_device_remove(data->drm_dev);
+	kfree(data);
+#if KERNEL_VERSION(6, 11, 0) <= LINUX_VERSION_CODE
+#else
+	return 0;
+#endif
+}
+
+bool evdi_platform_device_is_free(struct platform_device *pdev)
+{
+	struct evdi_platform_device_data *data = platform_get_drvdata(pdev);
+	struct evdi_device *evdi = data->drm_dev->dev_private;
+
+	if (evdi && !evdi_painter_is_connected(evdi->painter) &&
+	    !data->symlinked)
+		return true;
+	return false;
+}
+
+void evdi_platform_device_link(struct platform_device *pdev,
+				      struct device *parent)
+{
+	struct evdi_platform_device_data *data = NULL;
+	int ret = 0;
+
+	if (!parent || !pdev)
+		return;
+
+	data = platform_get_drvdata(pdev);
+	if (!evdi_platform_device_is_free(pdev)) {
+		EVDI_FATAL("Device is already attached can't symlink again\n");
+		return;
+	}
+
+	ret = sysfs_create_link(&pdev->dev.kobj, &parent->kobj, "device");
+	if (ret) {
+		EVDI_FATAL("Failed to create sysfs link from evdi to parent device\n");
+	} else {
+		data->symlinked = true;
+		data->parent = parent;
+	}
+}
+
+void evdi_platform_device_unlink_if_linked_with(struct platform_device *pdev,
+				struct device *parent)
+{
+	struct evdi_platform_device_data *data = platform_get_drvdata(pdev);
+
+	if (parent && data->parent == parent) {
+		sysfs_remove_link(&pdev->dev.kobj, "device");
+		data->symlinked = false;
+		data->parent = NULL;
+		EVDI_INFO("Detached from parent device\n");
+	}
+}
diff --git a/drivers/custom/evdi/module/evdi_platform_dev.h b/drivers/custom/evdi/module/evdi_platform_dev.h
new file mode 100644
index 000000000000..5dddcbb72e62
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_platform_dev.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * evdi_platform_dev.h
+ *
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _EVDI_PLATFORM_DEV_H_
+#define _EVDI_PLATFORM_DEV_H_
+
+#include <linux/types.h>
+#include <linux/version.h>
+
+struct platform_device_info;
+struct platform_device;
+struct drm_driver;
+struct device;
+
+struct platform_device *evdi_platform_dev_create(struct platform_device_info *info);
+void evdi_platform_dev_destroy(struct platform_device *dev);
+
+int evdi_platform_device_probe(struct platform_device *pdev);
+/* EL9 kernel removed the callback that was returning void  */
+#if KERNEL_VERSION(6, 11, 0) <= LINUX_VERSION_CODE
+void evdi_platform_device_remove(struct platform_device *pdev);
+#else
+int evdi_platform_device_remove(struct platform_device *pdev);
+#endif
+bool evdi_platform_device_is_free(struct platform_device *pdev);
+void evdi_platform_device_link(struct platform_device *pdev,
+				struct device *parent);
+void evdi_platform_device_unlink_if_linked_with(struct platform_device *pdev,
+				struct device *parent);
+
+#endif
+
diff --git a/drivers/custom/evdi/module/evdi_platform_drv.c b/drivers/custom/evdi/module/evdi_platform_drv.c
new file mode 100644
index 000000000000..b83f12fe44e1
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_platform_drv.c
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2012 Red Hat
+ * Copyright (c) 2015 - 2020 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#ifdef CONFIG_USB_SUPPORT
+#include <linux/usb.h>
+#endif
+
+#include "evdi_params.h"
+#include "evdi_debug.h"
+#include "evdi_platform_drv.h"
+#include "evdi_platform_dev.h"
+#include "evdi_sysfs.h"
+
+MODULE_AUTHOR("DisplayLink (UK) Ltd.");
+MODULE_DESCRIPTION("Extensible Virtual Display Interface");
+MODULE_LICENSE("GPL");
+
+#define EVDI_DEVICE_COUNT_MAX 16
+
+static struct evdi_platform_drv_context {
+	struct device *root_dev;
+	unsigned int dev_count;
+	struct platform_device *devices[EVDI_DEVICE_COUNT_MAX];
+#ifdef CONFIG_USB_SUPPORT
+	struct notifier_block usb_notifier;
+#endif
+	struct mutex lock;
+} g_ctx;
+
+#define evdi_platform_drv_context_lock(ctx) \
+		mutex_lock(&ctx->lock)
+
+#define evdi_platform_drv_context_unlock(ctx) \
+		mutex_unlock(&ctx->lock)
+
+#ifdef CONFIG_USB_SUPPORT
+static int evdi_platform_drv_usb(__always_unused struct notifier_block *nb,
+		unsigned long action,
+		void *data)
+{
+	struct usb_device *usb_dev = (struct usb_device *)(data);
+	struct platform_device *pdev;
+	int i = 0;
+
+	if (!usb_dev)
+		return 0;
+	if (action != BUS_NOTIFY_DEL_DEVICE)
+		return 0;
+
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		pdev = g_ctx.devices[i];
+		if (!pdev)
+			continue;
+		evdi_platform_device_unlink_if_linked_with(pdev, &usb_dev->dev);
+		if (pdev->dev.parent == &usb_dev->dev) {
+			EVDI_INFO("Parent USB removed. Removing evdi.%d\n", i);
+			evdi_platform_dev_destroy(pdev);
+			evdi_platform_drv_context_lock((&g_ctx));
+			g_ctx.dev_count--;
+			g_ctx.devices[i] = NULL;
+			evdi_platform_drv_context_unlock((&g_ctx));
+		}
+	}
+	return 0;
+}
+#endif
+
+static int evdi_platform_drv_get_free_idx(struct evdi_platform_drv_context *ctx)
+{
+	int i;
+
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		if (ctx->devices[i] == NULL)
+			return i;
+	}
+	return -ENOMEM;
+}
+
+static struct platform_device *evdi_platform_drv_get_free_device(struct evdi_platform_drv_context *ctx)
+{
+	int i;
+	struct platform_device *pdev = NULL;
+
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		pdev = ctx->devices[i];
+		if (pdev && evdi_platform_device_is_free(pdev))
+			return pdev;
+	}
+	return NULL;
+}
+
+
+static struct platform_device *evdi_platform_drv_create_new_device(struct evdi_platform_drv_context *ctx)
+{
+	struct platform_device *pdev = NULL;
+	struct platform_device_info pdevinfo = {
+		.parent = NULL,
+		.name = DRIVER_NAME,
+		.id = evdi_platform_drv_get_free_idx(ctx),
+		.res = NULL,
+		.num_res = 0,
+		.data = NULL,
+		.size_data = 0,
+		.dma_mask = DMA_BIT_MASK(32),
+	};
+
+	if (pdevinfo.id < 0 || ctx->dev_count >= EVDI_DEVICE_COUNT_MAX) {
+		EVDI_ERROR("Evdi device add failed. Too many devices.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	pdev = evdi_platform_dev_create(&pdevinfo);
+	ctx->devices[pdevinfo.id] = pdev;
+	ctx->dev_count++;
+
+	return pdev;
+}
+
+int evdi_platform_device_add(struct device *device, struct device *parent)
+{
+	struct evdi_platform_drv_context *ctx =
+		(struct evdi_platform_drv_context *)dev_get_drvdata(device);
+	struct platform_device *pdev = NULL;
+
+	evdi_platform_drv_context_lock(ctx);
+	if (parent)
+		pdev = evdi_platform_drv_get_free_device(ctx);
+
+	if (IS_ERR_OR_NULL(pdev))
+		pdev = evdi_platform_drv_create_new_device(ctx);
+	evdi_platform_drv_context_unlock(ctx);
+
+	if (IS_ERR_OR_NULL(pdev))
+		return -EINVAL;
+
+	evdi_platform_device_link(pdev, parent);
+	return 0;
+}
+
+int evdi_platform_add_devices(struct device *device, unsigned int val)
+{
+	unsigned int dev_count = evdi_platform_device_count(device);
+
+	if (val == 0) {
+		EVDI_WARN("Adding 0 devices has no effect\n");
+		return 0;
+	}
+	if (val > EVDI_DEVICE_COUNT_MAX - dev_count) {
+		EVDI_ERROR("Evdi device add failed. Too many devices.\n");
+		return -EINVAL;
+	}
+
+	EVDI_INFO("Increasing device count to %u\n", dev_count + val);
+	while (val-- && evdi_platform_device_add(device, NULL) == 0)
+		;
+	return 0;
+}
+
+void evdi_platform_remove_all_devices(struct device *device)
+{
+	int i;
+	struct evdi_platform_drv_context *ctx =
+		(struct evdi_platform_drv_context *)dev_get_drvdata(device);
+
+	evdi_platform_drv_context_lock(ctx);
+	for (i = 0; i < EVDI_DEVICE_COUNT_MAX; ++i) {
+		if (ctx->devices[i]) {
+			EVDI_INFO("Removing evdi %d\n", i);
+			evdi_platform_dev_destroy(ctx->devices[i]);
+			g_ctx.dev_count--;
+			g_ctx.devices[i] = NULL;
+		}
+	}
+	ctx->dev_count = 0;
+	evdi_platform_drv_context_unlock(ctx);
+}
+
+unsigned int evdi_platform_device_count(struct device *device)
+{
+	unsigned int count = 0;
+	struct evdi_platform_drv_context *ctx = NULL;
+
+	ctx = (struct evdi_platform_drv_context *)dev_get_drvdata(device);
+	evdi_platform_drv_context_lock(ctx);
+	count = ctx->dev_count;
+	evdi_platform_drv_context_unlock(ctx);
+
+	return count;
+
+}
+
+static struct platform_driver evdi_platform_driver = {
+	.probe = evdi_platform_device_probe,
+	.remove = evdi_platform_device_remove,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .mod_name = KBUILD_MODNAME,
+		   .owner = THIS_MODULE,
+	}
+};
+
+static int __init evdi_init(void)
+{
+	int ret;
+
+	EVDI_INFO("Initialising logging on level %u\n", evdi_loglevel);
+	EVDI_INFO("Atomic driver: yes\n");
+
+	memset(&g_ctx, 0, sizeof(g_ctx));
+	g_ctx.root_dev = root_device_register(DRIVER_NAME);
+#ifdef CONFIG_USB_SUPPORT
+	g_ctx.usb_notifier.notifier_call = evdi_platform_drv_usb;
+#endif
+	mutex_init(&g_ctx.lock);
+	dev_set_drvdata(g_ctx.root_dev, &g_ctx);
+
+#ifdef CONFIG_USB_SUPPORT
+	usb_register_notify(&g_ctx.usb_notifier);
+#endif
+	evdi_sysfs_init(g_ctx.root_dev);
+	ret = platform_driver_register(&evdi_platform_driver);
+	if (ret)
+		return ret;
+
+	if (evdi_initial_device_count)
+		return evdi_platform_add_devices(
+			g_ctx.root_dev, evdi_initial_device_count);
+
+	return 0;
+}
+
+static void __exit evdi_exit(void)
+{
+	EVDI_CHECKPT();
+	evdi_platform_remove_all_devices(g_ctx.root_dev);
+	platform_driver_unregister(&evdi_platform_driver);
+
+	if (!PTR_ERR_OR_ZERO(g_ctx.root_dev)) {
+		evdi_sysfs_exit(g_ctx.root_dev);
+#ifdef CONFIG_USB_SUPPORT
+		usb_unregister_notify(&g_ctx.usb_notifier);
+#endif
+		dev_set_drvdata(g_ctx.root_dev, NULL);
+		root_device_unregister(g_ctx.root_dev);
+	}
+	EVDI_INFO("Exit %s driver\n", DRIVER_NAME);
+}
+
+module_init(evdi_init);
+module_exit(evdi_exit);
diff --git a/drivers/custom/evdi/module/evdi_platform_drv.h b/drivers/custom/evdi/module/evdi_platform_drv.h
new file mode 100644
index 000000000000..49171600a481
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_platform_drv.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * evdi_platform_drv.h
+ *
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _EVDI_PLATFORM_DRV_H_
+#define _EVDI_PLATFORM_DRV_H_
+
+#include <linux/version.h>
+
+struct device;
+struct platform_device_info;
+
+#define DRIVER_NAME   "evdi"
+#define DRIVER_DESC   "Extensible Virtual Display Interface"
+#if KERNEL_VERSION(6, 14, 0) <= LINUX_VERSION_CODE
+#else
+#define DRIVER_DATE   "20250630"
+#endif
+
+#define DRIVER_MAJOR 1
+#define DRIVER_MINOR 14
+#define DRIVER_PATCH 11
+
+void evdi_platform_remove_all_devices(struct device *device);
+unsigned int evdi_platform_device_count(struct device *device);
+int evdi_platform_add_devices(struct device *device, unsigned int val);
+int evdi_platform_device_add(struct device *device, struct device *parent);
+
+#endif
+
diff --git a/drivers/custom/evdi/module/evdi_sysfs.c b/drivers/custom/evdi/module/evdi_sysfs.c
new file mode 100644
index 000000000000..a643434dbb4d
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_sysfs.c
@@ -0,0 +1,267 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * evdi_sysfs.c
+ *
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+
+#include "evdi_sysfs.h"
+#include "evdi_params.h"
+#include "evdi_debug.h"
+#include "evdi_platform_drv.h"
+
+#define MAX_EVDI_USB_ADDR 10
+
+static ssize_t version_show(__always_unused struct device *dev,
+			    __always_unused struct device_attribute *attr,
+			    char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u.%u.%u\n", DRIVER_MAJOR,
+			DRIVER_MINOR, DRIVER_PATCH);
+}
+
+static ssize_t count_show(__always_unused struct device *dev,
+			  __always_unused struct device_attribute *attr,
+			  char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", evdi_platform_device_count(dev));
+}
+
+struct evdi_usb_addr {
+	int addr[MAX_EVDI_USB_ADDR];
+	int len;
+	struct usb_device *usb;
+};
+
+#ifdef CONFIG_USB_SUPPORT
+static int evdi_platform_device_attach(struct device *device,
+		struct evdi_usb_addr *parent_addr);
+
+static ssize_t add_device_with_usb_path(struct device *dev,
+			 const char *buf, size_t count)
+{
+	char *usb_path = kstrdup(buf, GFP_KERNEL);
+	char *temp_path = usb_path;
+	char *bus_token;
+	char *usb_token;
+	char *usb_token_copy = NULL;
+	char *token;
+	char *bus;
+	char *port;
+	struct evdi_usb_addr usb_addr;
+
+	if (!usb_path)
+		return -ENOMEM;
+
+	memset(&usb_addr, 0, sizeof(usb_addr));
+	temp_path = strnstr(temp_path, "usb:", count);
+	if (!temp_path)
+		goto err_parse_usb_path;
+
+
+	temp_path = strim(temp_path);
+
+	bus_token = strsep(&temp_path, ":");
+	if (!bus_token)
+		goto err_parse_usb_path;
+
+	usb_token = strsep(&temp_path, ":");
+	if (!usb_token)
+		goto err_parse_usb_path;
+
+	/* Separate trailing ':*' from usb_token */
+	strsep(&temp_path, ":");
+
+	token = usb_token_copy = kstrdup(usb_token, GFP_KERNEL);
+	bus = strsep(&token, "-");
+	if (!bus)
+		goto err_parse_usb_path;
+	if (kstrtouint(bus, 10, &usb_addr.addr[usb_addr.len++]))
+		goto err_parse_usb_path;
+
+	do {
+		port = strsep(&token, ".");
+		if (!port)
+			goto err_parse_usb_path;
+		if (kstrtouint(port, 10, &usb_addr.addr[usb_addr.len++]))
+			goto err_parse_usb_path;
+	} while (token && port && usb_addr.len < MAX_EVDI_USB_ADDR);
+
+	if (evdi_platform_device_attach(dev, &usb_addr) != 0) {
+		EVDI_ERROR("Unable to attach to: %s\n", buf);
+		kfree(usb_path);
+		kfree(usb_token_copy);
+		return -EINVAL;
+	}
+
+	EVDI_INFO("Attaching to %s:%s\n", bus_token, usb_token);
+	kfree(usb_path);
+	kfree(usb_token_copy);
+	return count;
+
+err_parse_usb_path:
+	EVDI_ERROR("Unable to parse usb path: %s", buf);
+	kfree(usb_path);
+	kfree(usb_token_copy);
+	return -EINVAL;
+}
+
+static int find_usb_device_at_path(struct usb_device *usb, void *data)
+{
+	struct evdi_usb_addr *find_path = (struct evdi_usb_addr *)(data);
+	struct usb_device *pdev = usb;
+	int port = 0;
+	int i;
+
+	i = find_path->len - 1;
+	while (pdev != NULL && i >= 0 && i < MAX_EVDI_USB_ADDR) {
+		port = pdev->portnum;
+		if (port == 0)
+			port = pdev->bus->busnum;
+
+		if (port != find_path->addr[i])
+			return 0;
+
+		if (pdev->parent == NULL && i == 0) {
+			find_path->usb = usb;
+			return 1;
+		}
+		pdev = pdev->parent;
+		i--;
+	}
+
+	return 0;
+}
+
+static int evdi_platform_device_attach(struct device *device,
+		struct evdi_usb_addr *parent_addr)
+{
+	struct device *parent = NULL;
+
+	if (!parent_addr)
+		return -EINVAL;
+
+	if (!usb_for_each_dev(parent_addr, find_usb_device_at_path) ||
+	    !parent_addr->usb)
+		return -EINVAL;
+
+	parent = &parent_addr->usb->dev;
+	return evdi_platform_device_add(device, parent);
+}
+
+#else /* !CONFIG_USB_SUPPORT */
+
+static ssize_t add_device_with_usb_path(struct device *dev,
+			 const char *buf, size_t count)
+{
+	return -EINVAL;
+}
+
+#endif /* CONFIG_USB_SUPPORT */
+
+static ssize_t add_store(struct device *dev,
+			 __always_unused struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	unsigned int val;
+	int ret;
+
+	if (strnstr(buf, "usb:", count))
+		return add_device_with_usb_path(dev, buf, count);
+
+	if (kstrtouint(buf, 10, &val)) {
+		EVDI_ERROR("Invalid device count \"%s\"\n", buf);
+		return -EINVAL;
+	}
+
+	ret = evdi_platform_add_devices(dev, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t remove_all_store(struct device *dev,
+				__always_unused struct device_attribute *attr,
+				__always_unused const char *buf,
+				size_t count)
+{
+	evdi_platform_remove_all_devices(dev);
+	return count;
+}
+
+static ssize_t loglevel_show(__always_unused struct device *dev,
+			     __always_unused struct device_attribute *attr,
+			     char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%u\n", evdi_loglevel);
+}
+
+static ssize_t loglevel_store(__always_unused struct device *dev,
+			      __always_unused struct device_attribute *attr,
+			      const char *buf,
+			      size_t count)
+{
+	unsigned int val;
+
+	if (kstrtouint(buf, 10, &val)) {
+		EVDI_ERROR("Unable to parse %u\n", val);
+		return -EINVAL;
+	}
+	if (val > EVDI_LOGLEVEL_VERBOSE) {
+		EVDI_ERROR("Invalid loglevel %u\n", val);
+		return -EINVAL;
+	}
+
+	EVDI_INFO("Setting loglevel to %u\n", val);
+	evdi_loglevel = val;
+	return count;
+}
+
+static struct device_attribute evdi_device_attributes[] = {
+	__ATTR_RO(count),
+	__ATTR_RO(version),
+	__ATTR_RW(loglevel),
+	__ATTR_WO(add),
+	__ATTR_WO(remove_all)
+};
+
+void evdi_sysfs_init(struct device *root)
+{
+	unsigned int i;
+
+	if (!PTR_ERR_OR_ZERO(root))
+		for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++)
+			device_create_file(root, &evdi_device_attributes[i]);
+}
+
+void evdi_sysfs_exit(struct device *root)
+{
+	unsigned int i;
+
+	if (PTR_ERR_OR_ZERO(root)) {
+		EVDI_ERROR("root device is null");
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(evdi_device_attributes); i++)
+		device_remove_file(root, &evdi_device_attributes[i]);
+}
+
diff --git a/drivers/custom/evdi/module/evdi_sysfs.h b/drivers/custom/evdi/module/evdi_sysfs.h
new file mode 100644
index 000000000000..9207bf77e3a0
--- /dev/null
+++ b/drivers/custom/evdi/module/evdi_sysfs.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * evdi_sysfs.h
+ *
+ * Copyright (c) 2020 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _EVDI_SYSFS_H_
+#define _EVDI_SYSFS_H_
+
+struct device;
+
+void evdi_sysfs_init(struct device *root);
+void evdi_sysfs_exit(struct device *root);
+
+#endif
diff --git a/drivers/custom/evdi/module/tests/Makefile b/drivers/custom/evdi/module/tests/Makefile
new file mode 100644
index 000000000000..5714ba7ac2c1
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/Makefile
@@ -0,0 +1,5 @@
+
+ccflags-$(CONFIG_DRM_EVDI_KUNIT_TEST) += -I$(srctree)/drivers/gpu/drm/evdi
+
+obj-$(CONFIG_DRM_EVDI_KUNIT_TEST) += evdi_test.o test_evdi_vt_switch.o evdi_fake_user_client.o evdi_fake_compositor.o
+
diff --git a/drivers/custom/evdi/module/tests/evdi_fake_compositor.c b/drivers/custom/evdi/module/tests/evdi_fake_compositor.c
new file mode 100644
index 000000000000..afa14735cf7f
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_fake_compositor.c
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+
+#include <linux/file.h>
+#include <linux/vt_kern.h>
+
+#include <drm/drm_fourcc.h>
+
+#include "evdi_drm_drv.h"
+#include "evdi_drm.h"
+#include "tests/evdi_test.h"
+#include "tests/evdi_fake_compositor.h"
+
+
+void evdi_fake_compositor_create(struct kunit *test)
+{
+	struct kunit_resource *resource;
+	struct evdi_fake_compositor_data *compositor_data;
+
+	resource = kunit_find_named_resource(test, "fake_wayland");
+	if (resource) {
+		KUNIT_FAIL(test, "fake_wayland data already exists");
+		return;
+	}
+
+	resource = kunit_kzalloc(test, sizeof(struct kunit_resource), GFP_KERNEL);
+	compositor_data = kunit_kzalloc(test, sizeof(struct evdi_fake_compositor_data), GFP_KERNEL);
+	kunit_add_named_resource(test, NULL, NULL, resource, "fake_wayland", compositor_data);
+
+	static const struct drm_display_mode default_mode = {
+			DRM_SIMPLE_MODE(640, 480, 64, 48)
+	};
+	struct evdi_framebuffer efb =  {
+		.base = {
+			.format = drm_format_info(DRM_FORMAT_XRGB8888),
+			.pitches = { 4*640, 0, 0 },
+			},
+		.obj = NULL,
+		.active = true
+	};
+
+	compositor_data->efb = kunit_kzalloc(test, sizeof(struct evdi_framebuffer), GFP_KERNEL);
+	memcpy(compositor_data->efb, &efb, sizeof(struct evdi_framebuffer));
+	memcpy(&compositor_data->mode, &default_mode, sizeof(default_mode));
+}
+
+void evdi_fake_compositor_connect(struct kunit *test, struct drm_device *device)
+{
+	struct kunit_resource *resource = kunit_find_named_resource(test, "fake_wayland");
+	struct evdi_fake_compositor_data *compositor_data = resource->data;
+	struct evdi_device *evdi = (struct evdi_device *)device->dev_private;
+
+	evdi_painter_set_scanout_buffer(evdi->painter, compositor_data->efb);
+	evdi_painter_mode_changed_notify(evdi, &compositor_data->mode);
+	evdi_painter_dpms_notify(evdi->painter, DRM_MODE_DPMS_ON);
+}
+
+void evdi_fake_compositor_disconnect(__maybe_unused struct kunit *test, __maybe_unused struct drm_device *device)
+{
+}
+
diff --git a/drivers/custom/evdi/module/tests/evdi_fake_compositor.h b/drivers/custom/evdi/module/tests/evdi_fake_compositor.h
new file mode 100644
index 000000000000..efe8354175a3
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_fake_compositor.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_FAKE_COMPOSITOR_H
+#define EVDI_FAKE_COMPOSITOR_H
+
+#ifdef CONFIG_DRM_EVDI_KUNIT_TEST
+
+
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+
+
+
+/* kunit tests helpers faking userspace compositor leveraging evdi to add virtual display.
+ * e.g. Xorg, gnome-wayland, kwin
+ */
+struct evdi_fake_compositor_data {
+	struct evdi_framebuffer *efb;
+	struct drm_display_mode mode;
+};
+
+void evdi_fake_compositor_create(struct kunit *test);
+void evdi_fake_compositor_connect(struct kunit *test, struct drm_device *device);
+void evdi_fake_compositor_disconnect(struct kunit *test, struct drm_device *device);
+
+
+#endif // CONFIG_DRM_EVDI_KUNIT_TEST
+#endif // EVDI_FAKE_COMPOSITOR_H
+
diff --git a/drivers/custom/evdi/module/tests/evdi_fake_user_client.c b/drivers/custom/evdi/module/tests/evdi_fake_user_client.c
new file mode 100644
index 000000000000..76e4c128830f
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_fake_user_client.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+
+#include <linux/file.h>
+#include <linux/vt_kern.h>
+
+#include <drm/drm_file.h>
+
+#include "evdi_drm_drv.h"
+#include "evdi_drm.h"
+#include "tests/evdi_test.h"
+#include "tests/evdi_fake_user_client.h"
+
+/* copied from drm/tests/drm_kunit_edid.h */
+static const unsigned char test_edid_dvi_1080p[] = {
+	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x31, 0xd8, 0x2a, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x01, 0x03, 0x81, 0xa0, 0x5a, 0x78,
+	0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38,
+	0x2d, 0x40, 0x58, 0x2c, 0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e,
+	0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x45, 0x44,
+	0x49, 0x44, 0x0a, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x32,
+	0x46, 0x1e, 0x46, 0x0f, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+	0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xab
+};
+
+void evdi_fake_user_client_create(struct kunit *test)
+{
+	struct kunit_resource *resource;
+	struct evdi_fake_user_data *user_data;
+
+	resource = kunit_find_named_resource(test, "fake_evdi_user");
+	if (resource) {
+		KUNIT_FAIL(test, "fake_evdi_user data already exists");
+		return;
+	}
+
+	resource = kunit_kzalloc(test, sizeof(struct kunit_resource), GFP_KERNEL);
+	user_data = kunit_kzalloc(test, sizeof(struct evdi_fake_user_data), GFP_KERNEL);
+	kunit_add_named_resource(test, NULL, NULL, resource, "fake_evdi_user", user_data);
+}
+
+void evdi_fake_user_client_connect(struct kunit *test, struct drm_device *device)
+{
+	struct kunit_resource *resource = kunit_find_named_resource(test, "fake_evdi_user");
+	struct evdi_fake_user_data *user_data = resource->data;
+
+	void __user *user_edid = evdi_kunit_alloc_usermem(test, sizeof(test_edid_dvi_1080p));
+	struct drm_evdi_connect connect_data = {
+		.connected = true,
+		.dev_index = device->primary->index,
+		.edid = user_edid,
+		.edid_length = sizeof(test_edid_dvi_1080p),
+		.pixel_area_limit = 1920 * 1080,
+		.pixel_per_second_limit = 1920 * 1080 * 60,
+	};
+
+	if (copy_to_user((unsigned char * __user)connect_data.edid, test_edid_dvi_1080p, sizeof(test_edid_dvi_1080p)))
+		KUNIT_FAIL(test, "Failed to copy edid to userspace memory");
+	user_data->file = mock_drm_getfile(device->primary, O_RDWR);
+
+	evdi_painter_connect_ioctl(device, &connect_data, user_data->file->private_data);
+}
+
+void evdi_fake_user_client_disconnect(struct kunit *test, struct drm_device *device)
+{
+	struct kunit_resource *resource = kunit_find_named_resource(test, "fake_evdi_user");
+	struct evdi_fake_user_data *user_data = resource->data;
+
+	if (user_data->file) {
+		fput(user_data->file);
+		user_data->file = NULL;
+		flush_delayed_fput();
+	}
+}
+
diff --git a/drivers/custom/evdi/module/tests/evdi_fake_user_client.h b/drivers/custom/evdi/module/tests/evdi_fake_user_client.h
new file mode 100644
index 000000000000..f8db226c2bcf
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_fake_user_client.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#ifndef EVDI_FAKE_USER_CLIENT_H
+#define EVDI_FAKE_USER_CLIENT_H
+
+#ifdef CONFIG_DRM_EVDI_KUNIT_TEST
+
+
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+
+#include <linux/file.h>
+#include <linux/compiler_types.h>
+#include <drm/drm_device.h>
+
+/* kunit tests helpers faking evdi userspace client, usually displaylink-driver daemon. */
+
+struct evdi_fake_user_data {
+	struct file *file;
+};
+void __user *evdi_kunit_alloc_usermem(struct kunit *test, unsigned int size);
+
+void evdi_fake_user_client_create(struct kunit *test);
+void evdi_fake_user_client_connect(struct kunit *test, struct drm_device *device);
+void evdi_fake_user_client_disconnect(struct kunit *test, struct drm_device *device);
+
+#endif // CONFIG_DRM_EVDI_KUNIT_TEST
+#endif // EVDI_FAKE_USER_CLIENT_H
+
diff --git a/drivers/custom/evdi/module/tests/evdi_test.c b/drivers/custom/evdi/module/tests/evdi_test.c
new file mode 100644
index 000000000000..4fbe566d223a
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_test.c
@@ -0,0 +1,121 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/jiffies.h>
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+#include <linux/mman.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/jiffies.h>
+#include "evdi_drm_drv.h"
+
+void __user *evdi_kunit_alloc_usermem(struct kunit *test, unsigned int size)
+{
+	void *kmem = kunit_kzalloc(test, size, GFP_KERNEL);
+	unsigned long user_addr;
+
+	KUNIT_ASSERT_NOT_ERR_OR_NULL(test, kmem);
+
+	user_addr = kunit_vm_mmap(test, NULL, 0, size,
+			    PROT_READ | PROT_WRITE | PROT_EXEC,
+			    MAP_ANONYMOUS | MAP_PRIVATE, 0);
+	KUNIT_ASSERT_NE_MSG(test, user_addr, 0,
+		"Could not create userspace mm");
+	KUNIT_ASSERT_LT_MSG(test, user_addr, (unsigned long)TASK_SIZE,
+		"Failed to allocate user memory");
+
+	return (void __user *)user_addr;
+}
+
+void evdi_testhook_painter_vt_register(struct notifier_block *vt_notifier)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_test_data *base = (struct evdi_test_data *)test->priv;
+
+	if (base && base->hooks.painter_vt_register)
+		base->hooks.painter_vt_register(vt_notifier);
+}
+
+void evdi_testhook_painter_send_dpms(int mode)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_test_data *base = (struct evdi_test_data *)test->priv;
+
+	if (base && base->hooks.painter_send_dpms)
+		base->hooks.painter_send_dpms(mode);
+}
+
+void evdi_testhook_drm_device_destroyed(void)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_test_data *base = (struct evdi_test_data *)test->priv;
+
+	if (base && base->hooks.drm_device_destroyed)
+		base->hooks.drm_device_destroyed();
+}
+
+static void testhook_drm_device_destroyed(void)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_test_data *base = (struct evdi_test_data *)test->priv;
+
+	complete(base->dev_destroyed);
+}
+
+void evdi_test_data_init(struct kunit *test, struct evdi_test_data *data)
+{
+	data->parent = kunit_device_register(test, "/dev/card1");
+	data->dev_destroyed = kunit_kzalloc(test, sizeof(struct completion), GFP_KERNEL);
+	init_completion(data->dev_destroyed);
+
+	data->hooks.drm_device_destroyed = testhook_drm_device_destroyed;
+	test->priv = (void *)data;
+}
+
+void evdi_test_data_exit(struct kunit *test, struct evdi_test_data *data)
+{
+	if (!wait_for_completion_timeout(data->dev_destroyed, msecs_to_jiffies(1000)))
+		KUNIT_FAIL(test, "Failed to wait for drm_device removal\n");
+
+	kunit_device_unregister(test, data->parent);
+}
+
+static void test_evdi_create_drm_device(struct kunit *test)
+{
+	struct evdi_test_data *data = kunit_kzalloc(test, sizeof(struct evdi_test_data), GFP_KERNEL);
+	struct drm_device *dev;
+
+	evdi_test_data_init(test, data);
+
+	dev = evdi_drm_device_create(data->parent);
+
+	KUNIT_EXPECT_NOT_NULL(test, dev);
+
+	evdi_drm_device_remove(dev);
+	evdi_test_data_exit(test, data);
+	kunit_kfree(test, test->priv);
+}
+
+static struct kunit_case evdi_test_cases[] = {
+	KUNIT_CASE(test_evdi_create_drm_device),
+	{}
+};
+
+static struct kunit_suite evdi_test_suite = {
+	.name = "drm_evdi_tests",
+	.test_cases = evdi_test_cases,
+};
+
+kunit_test_suite(evdi_test_suite);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/evdi/module/tests/evdi_test.h b/drivers/custom/evdi/module/tests/evdi_test.h
new file mode 100644
index 000000000000..e33ecaffd854
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/evdi_test.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ *
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+
+#ifndef EVDI_TEST_H
+#define EVDI_TEST_H
+
+#ifdef CONFIG_DRM_EVDI_KUNIT_TEST
+#define EVDI_TEST_HOOK(foo) foo
+#else
+#include <linux/printk.h>
+#define EVDI_TEST_HOOK(foo) no_printk(__stringify(foo))
+#endif
+
+#ifdef CONFIG_DRM_EVDI_KUNIT_TEST
+
+#include <linux/completion.h>
+
+/* evdi hooks for kunit tests */
+void evdi_testhook_painter_vt_register(struct notifier_block *vt_notifier);
+void evdi_testhook_painter_send_dpms(int mode);
+void evdi_testhook_drm_device_destroyed(void);
+
+struct evdi_test_hooks {
+	void (*painter_vt_register)(struct notifier_block *vt_notifier);
+	void (*painter_send_dpms)(int mode);
+	void (*drm_device_destroyed)(void);
+};
+
+/* evdi kunit base type for test private data */
+struct evdi_test_data {
+	struct device *parent;
+	struct drm_device *dev;
+	struct completion *dev_destroyed;
+	struct evdi_test_hooks hooks;
+};
+
+void evdi_test_data_init(struct kunit *test, struct evdi_test_data *data);
+void evdi_test_data_exit(struct kunit *test, struct evdi_test_data *data);
+
+/* evdi test utils */
+void __user *evdi_kunit_alloc_usermem(struct kunit *test, unsigned int size);
+
+#endif // CONFIG_DRM_EVDI_KUNIT_TEST
+#endif // EVDI_TEST_H
+
diff --git a/drivers/custom/evdi/module/tests/test_evdi_vt_switch.c b/drivers/custom/evdi/module/tests/test_evdi_vt_switch.c
new file mode 100644
index 000000000000..675325d1380e
--- /dev/null
+++ b/drivers/custom/evdi/module/tests/test_evdi_vt_switch.c
@@ -0,0 +1,176 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024 DisplayLink (UK) Ltd.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License v2. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+
+#include <kunit/test.h>
+#include <kunit/test-bug.h>
+#include <kunit/device.h>
+#include <linux/vt_kern.h>
+#include "evdi_drm_drv.h"
+#include "tests/evdi_test.h"
+#include "tests/evdi_fake_user_client.h"
+#include "tests/evdi_fake_compositor.h"
+
+
+struct evdi_vt_test {
+	struct evdi_test_data base;
+	struct notifier_block *vt_notifier;
+	int dpms_mode;
+};
+#define to_evdi_vt_test(x) container_of(x, struct evdi_vt_test, base)
+
+static void testhook_painter_vt_register(struct notifier_block *vt_notifier)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	data->vt_notifier = vt_notifier;
+}
+
+static void testhook_painter_send_dpms(int mode)
+{
+	struct kunit *test = kunit_get_current_test();
+	struct evdi_test_data *base = (struct evdi_test_data *)test->priv;
+	struct evdi_vt_test *data = to_evdi_vt_test(base);
+
+	data->dpms_mode = mode;
+}
+
+static int suite_test_vt_init(struct kunit *test)
+{
+	struct evdi_vt_test *data = kunit_kzalloc(test, sizeof(struct evdi_vt_test), GFP_KERNEL);
+
+	evdi_test_data_init(test, &data->base);
+	data->base.hooks.painter_vt_register = testhook_painter_vt_register;
+	data->base.hooks.painter_send_dpms = testhook_painter_send_dpms;
+	data->base.dev = evdi_drm_device_create(data->base.parent);
+
+	return 0;
+}
+
+static void suite_test_vt_exit(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	if (data->base.dev) {
+		evdi_drm_device_remove(data->base.dev);
+		data->base.dev = NULL;
+	}
+
+	evdi_test_data_exit(test, &data->base);
+	kunit_kfree(test, test->priv);
+}
+
+static int suite_test_vt_and_user_connected_init(struct kunit *test)
+{
+	int result = suite_test_vt_init(test);
+	struct evdi_vt_test *data = (struct evdi_vt_test *)test->priv;
+
+	KUNIT_EXPECT_EQ(test, result, 0);
+	evdi_fake_compositor_create(test);
+	evdi_fake_user_client_create(test);
+
+	KUNIT_EXPECT_NE(test, data->dpms_mode, DRM_MODE_DPMS_OFF);
+	evdi_fake_user_client_connect(test, data->base.dev);
+	evdi_fake_compositor_connect(test, data->base.dev);
+
+	return result;
+}
+
+static void suite_test_vt_and_user_connected_exit(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	evdi_fake_compositor_disconnect(test, data->base.dev);
+	evdi_fake_user_client_disconnect(test, data->base.dev);
+
+	return suite_test_vt_exit(test);
+}
+
+static void test_evdi_painter_registers_for_vt(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	KUNIT_EXPECT_NOT_NULL(test, data->vt_notifier->notifier_call);
+}
+
+static void test_evdi_painter_unregisters_for_vt_on_removal(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	evdi_drm_device_remove(data->base.dev);
+	data->base.dev = NULL;
+
+	KUNIT_EXPECT_NULL(test, data->vt_notifier->notifier_call);
+}
+
+static void test_evdi_painter_when_not_connected_does_not_send_dpms_off_event_on_fg_console_change(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+
+	KUNIT_EXPECT_NE(test, data->dpms_mode, DRM_MODE_DPMS_OFF);
+
+	data->vt_notifier->notifier_call(data->vt_notifier, 0, NULL);
+
+	KUNIT_EXPECT_NE(test, data->dpms_mode, DRM_MODE_DPMS_OFF);
+}
+
+static void test_evdi_painter_when_connected_does_not_send_dpms_off_event_when_fg_console_has_not_changed(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+	struct evdi_device *evdi = (struct evdi_device *)data->base.dev->dev_private;
+
+	data->vt_notifier->notifier_call(data->vt_notifier, 0, NULL);
+
+	KUNIT_EXPECT_EQ(test, data->dpms_mode, DRM_MODE_DPMS_ON);
+	KUNIT_EXPECT_FALSE(test, evdi_painter_needs_full_modeset(evdi->painter));
+}
+
+static void test_evdi_painter_when_connected_sends_dpms_off_event_on_fg_console_change(struct kunit *test)
+{
+	struct evdi_vt_test *data = to_evdi_vt_test(test->priv);
+	struct evdi_device *evdi = (struct evdi_device *)data->base.dev->dev_private;
+
+	fg_console = fg_console + 1;
+
+	data->vt_notifier->notifier_call(data->vt_notifier, 0, NULL);
+
+	KUNIT_EXPECT_EQ(test, data->dpms_mode, DRM_MODE_DPMS_OFF);
+	KUNIT_EXPECT_TRUE(test, evdi_painter_needs_full_modeset(evdi->painter));
+}
+
+static struct kunit_case evdi_test_cases[] = {
+	KUNIT_CASE(test_evdi_painter_registers_for_vt),
+	KUNIT_CASE(test_evdi_painter_unregisters_for_vt_on_removal),
+	KUNIT_CASE(test_evdi_painter_when_not_connected_does_not_send_dpms_off_event_on_fg_console_change),
+	{}
+};
+
+static struct kunit_case evdi_test_cases_with_user_connected[] = {
+	KUNIT_CASE(test_evdi_painter_when_connected_does_not_send_dpms_off_event_when_fg_console_has_not_changed),
+	KUNIT_CASE(test_evdi_painter_when_connected_sends_dpms_off_event_on_fg_console_change),
+	{}
+};
+
+static struct kunit_suite evdi_test_suite = {
+	.name = "drm_evdi_vt_tests",
+	.test_cases = evdi_test_cases,
+	.init = suite_test_vt_init,
+	.exit = suite_test_vt_exit,
+};
+
+static struct kunit_suite evdi_test_suite_with_connected_user = {
+	.name = "drm_evdi_vt_tests_with_connected_user",
+	.test_cases = evdi_test_cases_with_user_connected,
+	.init = suite_test_vt_and_user_connected_init,
+	.exit = suite_test_vt_and_user_connected_exit,
+};
+
+kunit_test_suite(evdi_test_suite_with_connected_user);
+kunit_test_suite(evdi_test_suite);
# ----------------------------------------
# Module: gcadapter_oc
# Version: 0a7d7027d0dc
# ----------------------------------------
diff --git a/drivers/custom/gcadapter_oc/Makefile b/drivers/custom/gcadapter_oc/Makefile
new file mode 100644
index 000000000000..aa794b3b8478
--- /dev/null
+++ b/drivers/custom/gcadapter_oc/Makefile
@@ -0,0 +1,10 @@
+obj-m += gcadapter_oc.o
+ccflags-y := -std=gnu99 -Wno-declaration-after-statement
+KERNEL_SOURCE_DIR := /lib/modules/$(shell uname -r)/build
+
+all:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" modules
+
+clean:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" clean
+	
diff --git a/drivers/custom/gcadapter_oc/gcadapter_oc.c b/drivers/custom/gcadapter_oc/gcadapter_oc.c
new file mode 100644
index 000000000000..dd4d98e34c84
--- /dev/null
+++ b/drivers/custom/gcadapter_oc/gcadapter_oc.c
@@ -0,0 +1,153 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/usb.h>
+
+#define GCADAPTER_VID 0x057e
+#define GCADAPTER_PID 0x0337
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Hannes Mann");
+MODULE_DESCRIPTION("Filter kernel module to set the polling rate of the Wii U/Mayflash GameCube Adapter to a custom value.");
+MODULE_VERSION("1.4");
+
+static struct usb_device* adapter_device = NULL;
+
+static unsigned short restore_interval = 8;
+static unsigned short configured_interval = 1;
+
+/* Patches all applicable endpoints. Returns the bInterval value used before patching. */
+static unsigned short patch_endpoints(unsigned short interval) {
+	static unsigned short old_interval = 8;
+
+	if(adapter_device != NULL && adapter_device->actconfig != NULL) {
+		struct usb_interface* interface = adapter_device->actconfig->interface[0];
+
+		if(interface != NULL) {
+			for(unsigned int altsetting = 0; altsetting < interface->num_altsetting; altsetting++) {
+				struct usb_host_interface* altsettingptr = &interface->altsetting[altsetting];
+
+				for(__u8 endpoint = 0; endpoint < altsettingptr->desc.bNumEndpoints; endpoint++) {
+					if(altsettingptr->endpoint[endpoint].desc.bEndpointAddress == 0x81 || altsettingptr->endpoint[endpoint].desc.bEndpointAddress == 0x02) {
+						old_interval = altsettingptr->endpoint[endpoint].desc.bInterval;
+						altsettingptr->endpoint[endpoint].desc.bInterval = interval;
+
+						printk(KERN_INFO "gcadapter_oc: bInterval value of endpoint 0x%.2x set to %u.\n", altsettingptr->endpoint[endpoint].desc.bEndpointAddress, interval);
+					}
+				}
+			}
+
+			/*
+			 * Attempt to lock the device.
+			 * This is required by the kernel documentation but it seems that some systems won't let you lock the USB device.
+			 * Older versions before 1.2 never called this function and still worked so we proceed even if locking fails.
+			 */
+			int ret = usb_lock_device_for_reset(adapter_device, NULL);
+			if(ret) {
+				printk(KERN_ERR "gcadapter_oc: Warning! Failed to acquire lock for USB device (error: %d). Resetting device anyway...\n", ret);
+			}
+			/* TODO: It might be possible to make the new bInterval value take effect without calling usb_reset_device? */
+			if(usb_reset_device(adapter_device)) {
+				printk(KERN_ERR "gcadapter_oc: Could not reset device (error: %d). bInterval value was NOT changed.\n", ret);
+			}
+			/* Only unlock the device if usb_lock_device_for_reset succeeded. */
+			if(!ret) {
+				usb_unlock_device(adapter_device);
+			}
+		}
+	}
+
+	return old_interval;
+}
+
+static int on_usb_notify(struct notifier_block* self, unsigned long action, void* _device) {
+	struct usb_device* device = _device;
+
+	switch(action) {
+		case USB_DEVICE_ADD:
+			if(device->descriptor.idVendor == GCADAPTER_VID && device->descriptor.idProduct == GCADAPTER_PID && adapter_device == NULL) {
+				adapter_device = device;
+				printk(KERN_INFO "gcadapter_oc: Adapter connected\n");
+
+				restore_interval = patch_endpoints(configured_interval);
+			}
+			break;
+
+		case USB_DEVICE_REMOVE:
+			if(adapter_device == device) {
+				adapter_device = NULL;
+				printk(KERN_INFO "gcadapter_oc: Adapter disconnected\n");
+			}
+			break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block usb_nb = { .notifier_call = on_usb_notify };
+
+static int usb_device_cb(struct usb_device* device, void* data) {
+	if(device->descriptor.idVendor == GCADAPTER_VID && device->descriptor.idProduct == GCADAPTER_PID && adapter_device == NULL) {
+		adapter_device = device;
+		printk(KERN_INFO "gcadapter_oc: Adapter connected\n");
+
+		restore_interval = patch_endpoints(configured_interval);
+	}
+
+	return 0;
+}
+
+static int __init on_module_init(void) {
+	if(configured_interval > 255) {
+		printk(KERN_WARNING "gcadapter_oc: Invalid interval parameter specified.\n");
+		configured_interval = 255;
+	}
+
+	if(configured_interval == 0) {
+		printk(KERN_WARNING "gcadapter_oc: Invalid interval parameter specified.\n");
+		configured_interval = 1;
+	}
+
+	usb_for_each_dev(NULL, &usb_device_cb);
+	usb_register_notify(&usb_nb);
+
+	return 0;
+}
+
+static void __exit on_module_exit(void) {
+	if(adapter_device != NULL) {
+		patch_endpoints(restore_interval);
+	}
+
+	usb_unregister_notify(&usb_nb);
+}
+
+module_init(on_module_init);
+module_exit(on_module_exit);
+
+static int on_interval_changed(const char* value, const struct kernel_param* kp) {
+	int ret = param_set_ushort(value, kp);
+
+	if(!ret) {
+		if(configured_interval > 255) {
+			printk(KERN_WARNING "gcadapter_oc: Invalid interval parameter specified.\n");
+			configured_interval = 255;
+		}
+		else if(configured_interval == 0) {
+			printk(KERN_WARNING "gcadapter_oc: Invalid interval parameter specified.\n");
+			configured_interval = 1;
+		}
+
+		patch_endpoints(configured_interval);
+	}
+
+	return ret;
+}
+
+static struct kernel_param_ops interval_ops = {
+	.set = &on_interval_changed,
+	.get = &param_get_ushort
+};
+
+module_param_cb(rate, &interval_ops, &configured_interval, 0644);
+MODULE_PARM_DESC(rate, "Polling rate (default: 1)");
# ----------------------------------------
# Module: zenergy
# Version: 310ed88b13c6
# ----------------------------------------
diff --git a/drivers/custom/zenergy/Makefile b/drivers/custom/zenergy/Makefile
new file mode 100644
index 000000000000..4bbb27788692
--- /dev/null
+++ b/drivers/custom/zenergy/Makefile
@@ -0,0 +1,37 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for AMD Energy driver
+#
+# Copyright (C) 2021 Advanced Micro Devices, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License version 2
+
+# If KDIR is not specified, assume the development source link
+# is in the modules directory for the running kernel
+KDIR ?= /lib/modules/`uname -r`/build
+obj-m := zenergy.o
+
+
+default:
+	export CONFIG_SENSOR_zenergy=m;	\
+	$(MAKE) -C $(KDIR) M=$$PWD modules
+
+modules: default
+
+modules_install:
+	$(MAKE) -C $(KDIR) M=$$PWD modules_install
+
+clean:
+	$(MAKE) -C $(KDIR) M=$$PWD clean
+
+help:
+	@echo "\nThe following make targets are supported:\n"
+	@echo "default\t\tBuild the driver module (or if no make target is supplied)"
+	@echo "modules\t\tSame as default"
+	@echo "modules_install\tBuild and install the driver module"
+	@echo "clean"
+	@echo
+
+.PHONY: default modules modules_install clean help
+
diff --git a/drivers/custom/zenergy/zenergy.c b/drivers/custom/zenergy/zenergy.c
new file mode 100644
index 000000000000..0ff97cdd7858
--- /dev/null
+++ b/drivers/custom/zenergy/zenergy.c
@@ -0,0 +1,454 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/*
+ * Copyright (C) 2020 Advanced Micro Devices, Inc.
+ * Edited by BouHaa (http://github.com/boukehaarsma23)
+ */
+#include <asm/cpu_device_id.h>
+
+#include <linux/bits.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/hwmon.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/processor.h>
+#include <linux/platform_device.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/topology.h>
+#include <linux/types.h>
+#include <linux/version.h>
+
+#define DRV_MODULE_DESCRIPTION	"AMD energy driver"
+#define DRV_MODULE_VERSION	"1.0"
+
+MODULE_VERSION(DRV_MODULE_VERSION);
+
+#define DRVNAME			"zenergy"
+
+#define ENERGY_PWR_UNIT_MSR	0xC0010299
+#define ENERGY_CORE_MSR		0xC001029A
+#define ENERGY_PKG_MSR		0xC001029B
+
+#define zenergy_UNIT_MASK	0x01F00
+#define zenergy_MASK		0xFFFFFFFF
+
+struct sensor_accumulator {
+	u64 energy_ctr;
+	u64 prev_value;
+	unsigned long cache_timeout;
+};
+
+struct zenergy_data {
+	struct hwmon_channel_info energy_info;
+	const struct hwmon_channel_info *info[2];
+	struct hwmon_chip_info chip;
+	struct task_struct *wrap_accumulate;
+	/* Lock around the accumulator */
+	struct mutex lock;
+	/* An accumulator for each core and socket */
+	struct sensor_accumulator *accums;
+	unsigned int timeout_ms;
+	/* Energy Status Units */
+	int energy_units;
+	int nr_cpus;
+	int nr_socks;
+	int core_id;
+	char (*label)[10];
+	bool do_not_accum;
+};
+
+static int zenergy_read_labels(struct device *dev,
+				  enum hwmon_sensor_types type,
+				  u32 attr, int channel,
+				  const char **str)
+{
+	struct zenergy_data *data = dev_get_drvdata(dev);
+
+	*str = data->label[channel];
+	return 0;
+}
+
+static void get_energy_units(struct zenergy_data *data)
+{
+	u64 rapl_units;
+
+#if KERNEL_VERSION(6, 16, 0) <= LINUX_VERSION_CODE
+	rdmsrq_safe(ENERGY_PWR_UNIT_MSR, &rapl_units);
+#else
+	rdmsrl_safe(ENERGY_PWR_UNIT_MSR, &rapl_units);
+#endif
+	data->energy_units = (rapl_units & zenergy_UNIT_MASK) >> 8;
+}
+
+static void __accumulate_delta(struct sensor_accumulator *accum,
+			       int cpu, u32 reg)
+{
+	u64 input;
+
+#if KERNEL_VERSION(6, 16, 0) <= LINUX_VERSION_CODE
+	rdmsrq_safe_on_cpu(cpu, reg, &input);
+#else
+	rdmsrl_safe_on_cpu(cpu, reg, &input);
+#endif
+	input &= zenergy_MASK;
+
+	if (input >= accum->prev_value)
+		accum->energy_ctr +=
+			input - accum->prev_value;
+	else
+		accum->energy_ctr += UINT_MAX -
+			accum->prev_value + input;
+
+	accum->prev_value = input;
+	accum->cache_timeout = (jiffies + HZ + get_random_long()) % HZ;
+}
+
+static void accumulate_delta(struct zenergy_data *data,
+			     int channel, int cpu, u32 reg)
+{
+	mutex_lock(&data->lock);
+	__accumulate_delta(&data->accums[channel], cpu, reg);
+	mutex_unlock(&data->lock);
+}
+
+static void read_accumulate(struct zenergy_data *data)
+{
+	int sock, scpu, cpu;
+
+	for (sock = 0; sock < data->nr_socks; sock++) {
+		scpu = cpumask_first_and(cpu_online_mask,
+					 cpumask_of_node(sock));
+
+		accumulate_delta(data, data->nr_cpus + sock,
+				 scpu, ENERGY_PKG_MSR);
+	}
+
+	if (data->core_id >= data->nr_cpus)
+		data->core_id = 0;
+
+	cpu = data->core_id;
+	if (cpu_online(cpu))
+		accumulate_delta(data, cpu, cpu, ENERGY_CORE_MSR);
+
+	data->core_id++;
+}
+
+static int zenergy_read(struct device *dev,
+			   enum hwmon_sensor_types type,
+			   u32 attr, int channel, long *val)
+{
+	struct zenergy_data *data = dev_get_drvdata(dev);
+	struct sensor_accumulator *accum;
+	u64 energy;
+	u32 reg;
+	int cpu;
+
+	if (channel >= data->nr_cpus) {
+		cpu = cpumask_first_and(cpu_online_mask,
+					cpumask_of_node
+					(channel - data->nr_cpus));
+		reg = ENERGY_PKG_MSR;
+	} else {
+		cpu = channel;
+		if (!cpu_online(cpu))
+			return -ENODEV;
+
+		reg = ENERGY_CORE_MSR;
+	}
+
+	accum = &data->accums[channel];
+
+	mutex_lock(&data->lock);
+	if (!accum->energy_ctr || time_after(jiffies, accum->cache_timeout))
+		__accumulate_delta(accum, cpu, reg);
+	energy = accum->energy_ctr;
+	mutex_unlock(&data->lock);
+
+	*val = div64_ul(energy * 1000000UL, BIT(data->energy_units));
+
+	return 0;
+}
+
+static umode_t zenergy_is_visible(const void *_data,
+				     enum hwmon_sensor_types type,
+				     u32 attr, int channel)
+{
+	return 0444;
+}
+
+static int energy_accumulator(void *p)
+{
+	struct zenergy_data *data = (struct zenergy_data *)p;
+	unsigned int timeout = data->timeout_ms;
+
+	while (!kthread_should_stop()) {
+		/*
+		 * Ignoring the conditions such as
+		 * cpu being offline or rdmsr failure
+		 */
+		read_accumulate(data);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (kthread_should_stop())
+			break;
+
+		schedule_timeout(msecs_to_jiffies(timeout));
+	}
+	return 0;
+}
+
+static const struct hwmon_ops zenergy_ops = {
+	.is_visible = zenergy_is_visible,
+	.read = zenergy_read,
+	.read_string = zenergy_read_labels,
+};
+
+static int amd_create_sensor(struct device *dev,
+			     struct zenergy_data *data,
+			     enum hwmon_sensor_types type, u32 config)
+{
+	struct hwmon_channel_info *info = &data->energy_info;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 9, 0)
+	struct cpuinfo_x86 *c = &boot_cpu_data;
+	int num_siblings;
+#endif
+	struct sensor_accumulator *accums;
+	int i, cpus, sockets;
+	u32 *s_config;
+	char (*label_l)[10];
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 9, 0)
+	/* Identify the number of siblings per core */
+	num_siblings = ((cpuid_ebx(0x8000001e) >> 8) & 0xff) + 1;
+
+	/*
+	 * Energy counter register is accessed at core level.
+	 * Hence, filterout the siblings.
+	 */
+	cpus = num_present_cpus() / num_siblings;
+
+	/*
+	 * topology_num_cores_per_package (or c->x86_max_cores prior to 6.9) is
+	 * the linux count of physical cores.
+	 * total physical cores/ core per socket gives total number of sockets.
+	 */
+
+	sockets = cpus / c->x86_max_cores;
+#else
+	cpus = num_present_cpus() / __max_threads_per_core;
+	sockets = cpus / topology_num_cores_per_package();
+#endif
+
+	s_config = devm_kcalloc(dev, cpus + sockets + 1,
+				sizeof(u32), GFP_KERNEL);
+	if (!s_config)
+		return -ENOMEM;
+
+	accums = devm_kcalloc(dev, cpus + sockets,
+			      sizeof(struct sensor_accumulator),
+			      GFP_KERNEL);
+	if (!accums)
+		return -ENOMEM;
+
+	label_l = devm_kcalloc(dev, cpus + sockets,
+			       sizeof(*label_l), GFP_KERNEL);
+	if (!label_l)
+		return -ENOMEM;
+
+	info->type = type;
+	info->config = s_config;
+
+	data->nr_cpus = cpus;
+	data->nr_socks = sockets;
+	data->accums = accums;
+	data->label = label_l;
+
+	for (i = 0; i < cpus + sockets; i++) {
+		s_config[i] = config;
+		if (i < cpus)
+			scnprintf(label_l[i], 10, "Ecore%03u", i);
+		else
+			scnprintf(label_l[i], 10, "Esocket%u", (i - cpus));
+	}
+
+	s_config[i] = 0;
+	return 0;
+}
+
+static const struct x86_cpu_id bit32_rapl_cpus[] = {
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x01, NULL),	/* Zen */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x08, NULL),	/* Zen+ */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x11, NULL),	/* Zen APU */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x18, NULL),	/* Picasso */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x20, NULL),	/* Picasso APU */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x31, NULL),	/* Zen2 Threadripper */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x60, NULL),	/* Renoir */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x68, NULL),	/* Lucienne */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x71, NULL),	/* Zen2 */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x01, NULL),	/* Zen3 Threadripper */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x21, NULL),	/* Zen3 */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x50, NULL),	/* Cezanne */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x44, NULL),	/* Rembrandt */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x60, NULL),	/* Rembrandt */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x1A, 0x44, NULL),	/* Granite Ridge */
+	// Zen4 (0x19, 0x61) features 64-bit registers for both Core::X86::Msr::CORE_ENERGY_STAT & L3::L3CT::L3PackageEnergyStatus),
+	// c.f., https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/56713-B1_3_05.zip
+	{}
+};
+
+static int zenergy_probe(struct platform_device *pdev)
+{
+	struct device *hwmon_dev;
+	struct zenergy_data *data;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	data = devm_kzalloc(dev,
+			    sizeof(struct zenergy_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->chip.ops = &zenergy_ops;
+	data->chip.info = data->info;
+
+	dev_set_drvdata(dev, data);
+	/* Populate per-core energy reporting */
+	data->info[0] = &data->energy_info;
+	ret = amd_create_sensor(dev, data, hwmon_energy,
+				HWMON_E_INPUT | HWMON_E_LABEL);
+	if (ret)
+		return ret;
+
+	mutex_init(&data->lock);
+	get_energy_units(data);
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, DRVNAME,
+							 data,
+							 &data->chip,
+							 NULL);
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	/*
+	 * On a system with peak wattage of 250W
+	 * timeout = 2 ^ 32 / 2 ^ energy_units / 250 secs
+	 */
+	data->timeout_ms = 1000 *
+			   BIT(min(28, 31 - data->energy_units)) / 250;
+
+	/*
+	 * For AMD platforms with 64-bit RAPL MSR registers, accumulation
+	 * of the energy counters are not necessary.
+	 */
+	if (!x86_match_cpu(bit32_rapl_cpus)) {
+		data->do_not_accum = true;
+		pr_info("CPU supports 64-bit RAPL MSR registers\n");
+		return 0;
+	}
+
+	data->wrap_accumulate = kthread_run(energy_accumulator, data,
+					    "%s", dev_name(hwmon_dev));
+	return PTR_ERR_OR_ZERO(data->wrap_accumulate);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int zenergy_remove(struct platform_device *pdev)
+#else
+static void zenergy_remove(struct platform_device *pdev)
+#endif
+{
+	struct zenergy_data *data = dev_get_drvdata(&pdev->dev);
+
+	if (data && data->wrap_accumulate)
+		kthread_stop(data->wrap_accumulate);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static const struct platform_device_id zenergy_ids[] = {
+	{ .name = DRVNAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(platform, zenergy_ids);
+
+static struct platform_driver zenergy_driver = {
+	.probe = zenergy_probe,
+	.remove	= zenergy_remove,
+	.id_table = zenergy_ids,
+	.driver = {
+		.name = DRVNAME,
+	},
+};
+
+static struct platform_device *zenergy_platdev;
+
+static const struct x86_cpu_id cpu_ids[] __initconst = {
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x01, NULL),	/* Zen */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x08, NULL),	/* Zen+ */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x11, NULL),	/* Zen APU */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x18, NULL),	/* Picasso */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x20, NULL),	/* Picasso APU */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x31, NULL),	/* Zen2 Threadripper */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x60, NULL),	/* Renoir */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x68, NULL),	/* Lucienne */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x17, 0x71, NULL),	/* Zen2 */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x01, NULL),	/* Zen3 Threadripper */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x21, NULL),	/* Zen3 */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x50, NULL),	/* Cezanne */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x44, NULL),	/* Rembrandt */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x60, NULL),	/* Rembrandt */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x19, 0x61, NULL),	/* Zen 4 */
+	X86_MATCH_VENDOR_FAM_MODEL(AMD, 0x1A, 0x44, NULL),	/* Zen 5 */
+	{}
+};
+MODULE_DEVICE_TABLE(x86cpu, cpu_ids);
+
+static int __init zenergy_init(void)
+{
+	int ret;
+
+	if (!x86_match_cpu(cpu_ids))
+		return -ENODEV;
+
+	ret = platform_driver_register(&zenergy_driver);
+	if (ret)
+		return ret;
+
+	zenergy_platdev = platform_device_alloc(DRVNAME, 0);
+	if (!zenergy_platdev) {
+		platform_driver_unregister(&zenergy_driver);
+		return -ENOMEM;
+	}
+
+	ret = platform_device_add(zenergy_platdev);
+	if (ret) {
+		platform_device_put(zenergy_platdev);
+		platform_driver_unregister(&zenergy_driver);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit zenergy_exit(void)
+{
+	platform_device_unregister(zenergy_platdev);
+	platform_driver_unregister(&zenergy_driver);
+}
+
+module_init(zenergy_init);
+module_exit(zenergy_exit);
+
+MODULE_DESCRIPTION("Driver for AMD Energy reporting from RAPL MSR via HWMON interface");
+MODULE_AUTHOR("Naveen Krishna Chatradhi <nchatrad@amd.com>");
+MODULE_LICENSE("GPL");
# ----------------------------------------
# Module: nct6687d
# Version: 80dc037bb5e1
# ----------------------------------------
diff --git a/drivers/custom/nct6687d/Makefile b/drivers/custom/nct6687d/Makefile
new file mode 100644
index 000000000000..33d58a2cdaef
--- /dev/null
+++ b/drivers/custom/nct6687d/Makefile
@@ -0,0 +1,10 @@
+obj-m += nct6687.o
+
+ccflags-y := -std=gnu99 -Wno-declaration-after-statement
+KERNEL_SOURCE_DIR := /lib/modules/$(shell uname -r)/build
+
+all:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" modules
+
+clean:
+	make -C "$(KERNEL_SOURCE_DIR)" M="$(PWD)" clean
\ No newline at end of file
diff --git a/drivers/custom/nct6687d/nct6687.c b/drivers/custom/nct6687d/nct6687.c
new file mode 100644
index 000000000000..ab43554631b1
--- /dev/null
+++ b/drivers/custom/nct6687d/nct6687.c
@@ -0,0 +1,1374 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * nct6687 - Driver for the hardware monitoring functionality of
+ *	       Nuvoton NCT6687 Super-I/O chips
+ *
+ * Copyright (C) 2020  Frederic Boltz <frederic.boltz@gmail.com>
+ *
+ * Derived from nct6683 driver
+ * Copyright (C) 2013  Guenter Roeck <linux@roeck-us.net>
+ * 
+ * Inspired of LibreHardwareMonitor
+ * https://github.com/LibreHardwareMonitor/LibreHardwareMonitor
+ * 
+ * Supports the following chips:
+ *
+ * Chip       #voltage   #fan    #pwm    #temp  chip ID
+ * nct6683    14(1)      8       8       7      0xc732  (partial support)
+ * nct6686d   21(1)      16      8       32(1)  0xd440
+ * nct6687    14(1)      8       8       7      0xd592
+ *
+ * Notes:
+ *	(1) Total number of voltage and 9 displayed.
+ */
+// #define DEBUG 1
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#ifndef MAX
+#define MAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+enum kinds
+{
+	nct6683,
+	nct6686,
+	nct6687
+};
+
+enum pwm_enable
+{
+	manual_mode = 1,
+	// There are multiple automatic modes, none of which is configurable by this module yet.
+	firmware_mode = 99,
+};
+
+static bool force;
+static bool manual;
+
+module_param(force, bool, 0);
+MODULE_PARM_DESC(force, "Set to one to enable support for unknown vendors");
+
+module_param(manual, bool, 0);
+MODULE_PARM_DESC(manual, "Set voltage input and voltage label configured with external sensors file");
+
+static const char *const nct6687_device_names[] = {
+	"nct6683",
+	"nct6686",
+	"nct6687",
+};
+
+static const char *const nct6687_chip_names[] = {
+	"NCT6683D",
+	"NCT6686D",
+	"NCT6687D",
+};
+
+#define DRVNAME "nct6687"
+
+/*
+ * Super-I/O constants and functions
+ */
+
+#define NCT6687_LD_ACPI 0x0a
+#define NCT6687_LD_HWM 0x0b
+#define NCT6687_LD_VID 0x0d
+
+#define SIO_REG_LDSEL 0x07		 /* Logical device select */
+#define SIO_REG_DEVID 0x20		 /* Device ID (2 bytes) */
+#define SIO_REG_DEVREVISION 0x21 /* Device ID (2 bytes) */
+#define SIO_REG_ENABLE 0x30		 /* Logical device enable */
+#define SIO_REG_ADDR 0x60		 /* Logical device address (2 bytes) */
+
+#define SIO_NCT6681_ID          0xb270  /* for later */
+#define SIO_NCT6683_ID          0xc730
+#define SIO_NCT6686_ID          0xd440
+#define SIO_NCT6687D_ID         0xd450  /* NCT6687 ???*/
+#define SIO_NCT6687_ID          0xd590
+#define SIO_ID_MASK             0xFFF0
+
+static inline void superio_outb(int ioreg, int reg, int val)
+{
+	outb(reg, ioreg);
+	outb(val, ioreg + 1);
+}
+
+static inline int superio_inb(int ioreg, int reg)
+{
+	outb(reg, ioreg);
+
+	return inb(ioreg + 1);
+}
+
+static inline void superio_select(int ioreg, int ld)
+{
+	outb(SIO_REG_LDSEL, ioreg);
+	outb(ld, ioreg + 1);
+}
+
+static inline int superio_enter(int ioreg)
+{
+	/*
+	 * Try to reserve <ioreg> and <ioreg + 1> for exclusive access.
+	 */
+	if (!request_muxed_region(ioreg, 2, DRVNAME))
+		return -EBUSY;
+
+	outb(0x87, ioreg);
+	outb(0x87, ioreg);
+
+	return 0;
+}
+
+static inline void superio_exit(int ioreg)
+{
+	outb(0xaa, ioreg);
+	outb(0x02, ioreg);
+	outb(0x02, ioreg + 1);
+
+	release_region(ioreg, 2);
+}
+
+/*
+ * ISA constants
+ */
+
+#define IOREGION_OFFSET 0 /* Use EC port 1 */
+#define IOREGION_LENGTH 4
+
+/* Common and NCT6687 specific data */
+
+#define NCT6687_NUM_REG_VOLTAGE (sizeof(nct6687_voltage_definition) / sizeof(struct voltage_reg))
+#define NCT6687_NUM_REG_TEMP 7
+#define NCT6687_NUM_REG_FAN 8
+#define NCT6687_NUM_REG_PWM 8
+
+#define NCT6687_REG_TEMP(x) (0x100 + (x)*2)
+#define NCT6687_REG_VOLTAGE(x) (0x120 + (x)*2)
+#define NCT6687_REG_FAN_RPM(x) (0x140 + (x)*2)
+#define NCT6687_REG_PWM(x) (0x160 + (x))
+#define NCT6687_REG_PWM_WRITE(x) (0xa28 + (x))
+
+#define NCT6687_HWM_CFG 0x180
+
+#define NCT6687_REG_MON_CFG(x) (0x1a0 + (x))
+#define NCT6687_REG_FANIN_CFG(x) (0xA00 + (x))
+#define NCT6687_REG_FANOUT_CFG(x) (0x1d0 + (x))
+
+#define NCT6687_REG_TEMP_HYST(x) (0x330 + (x))	/* 8 bit */
+#define NCT6687_REG_TEMP_MAX(x) (0x350 + (x))	/* 8 bit */
+#define NCT6687_REG_MON_HIGH(x) (0x370 + (x)*2) /* 8 bit */
+#define NCT6687_REG_MON_LOW(x) (0x371 + (x)*2)	/* 8 bit */
+
+#define NCT6687_REG_FAN_MIN(x) (0x3b8 + (x)*2) /* 16 bit */
+
+#define NCT6687_REG_FAN_CTRL_MODE(x) 0xA00
+#define NCT6687_REG_FAN_PWM_COMMAND(x) 0xA01
+#define NCT6687_FAN_CFG_REQ 0x80
+//#define NCT6687_FAN_CFG_DONE          0x40    //! for 6683 returns auto mode and clears 0xA00, 0xA28-0xA2F registers
+#define NCT6687_FAN_CFG_DONE            0x00    //! tested on 6683 6687
+
+#define NCT6687_REG_BUILD_YEAR 0x604
+#define NCT6687_REG_BUILD_MONTH 0x605
+#define NCT6687_REG_BUILD_DAY 0x606
+#define NCT6687_REG_SERIAL 0x607
+#define NCT6687_REG_VERSION_HI 0x608
+#define NCT6687_REG_VERSION_LO 0x609
+
+#define NCT6687_REG_CR_CASEOPEN 0xe8
+#define NCT6687_CR_CASEOPEN_MASK (1 << 7)
+
+#define NCT6687_REG_CR_BEEP 0xe0
+#define NCT6687_CR_BEEP_MASK (1 << 6)
+
+#define EC_SPACE_PAGE_REGISTER_OFFSET 0x04
+#define EC_SPACE_INDEX_REGISTER_OFFSET 0x05
+#define EC_SPACE_DATA_REGISTER_OFFSET 0x06
+#define EC_SPACE_PAGE_SELECT 0xFF
+
+struct voltage_reg
+{
+	u16 reg;
+	u16 multiplier;
+	const char *label;
+};
+
+static struct voltage_reg nct6687_voltage_definition[] = {
+	// +12V
+	{
+		.reg = 0,
+		.multiplier = 12,
+		.label = "+12V",
+	},
+	// + 5V
+	{
+		.reg = 1,
+		.multiplier = 5,
+		.label = "+5V",
+	},
+	// +3.3V
+	{
+		.reg = 11,
+		.multiplier = 1,
+		.label = "+3.3V",
+	},
+	// CPU SOC
+	{
+		.reg = 2,
+		.multiplier = 1,
+		.label = "CPU Soc",
+	},
+	// CPU Vcore
+	{
+		.reg = 4,
+		.multiplier = 1,
+		.label = "CPU Vcore",
+	},
+	// CPU 1P8
+	{
+		.reg = 9,
+		.multiplier = 1,
+		.label = "CPU 1P8",
+	},
+	// CPU VDDP
+	{
+		.reg = 10,
+		.multiplier = 1,
+		.label = "CPU VDDP",
+	},
+	// DRAM
+	{
+		.reg = 3,
+		.multiplier = 2,
+		.label = "DRAM",
+	},
+	// Chipset
+	{
+		.reg = 5,
+		.multiplier = 1,
+		.label = "Chipset",
+	},
+
+	// CPU SA
+	{
+		.reg = 6,
+		.multiplier = 1,
+		.label = "CPU SA",
+	},
+	// Voltage #2
+	{
+		.reg = 7,
+		.multiplier = 1,
+		.label = "Voltage #2",
+	},
+	// AVCC3
+	{
+		.reg = 8,
+		.multiplier = 1,
+		.label = "AVCC3",
+	},
+	// AVSB
+	{
+		.reg = 12,
+		.multiplier = 1,
+		.label = "AVSB",
+	},
+	// VBAT
+	{
+		.reg = 13,
+		.multiplier = 1,
+		.label = "VBat",
+	},
+
+};
+
+static const char *const nct6687_temp_label[] = {
+	"CPU",
+	"System",
+	"VRM MOS",
+	"PCH",
+	"CPU Socket",
+	"PCIe x1",
+	"M2_1",
+	NULL,
+};
+
+static const char *const nct6687_fan_label[] = {
+	"CPU Fan",
+	"Pump Fan",
+	"System Fan #1",
+	"System Fan #2",
+	"System Fan #3",
+	"System Fan #4",
+	"System Fan #5",
+	"System Fan #6",
+	NULL,
+};
+
+/* ------------------------------------------------------- */
+struct nct6687_data
+{
+	int addr;	/* IO base of EC space */
+	int sioreg; /* SIO register */
+	enum kinds kind;
+
+	struct device *hwmon_dev;
+	const struct attribute_group *groups[6];
+
+	struct mutex update_lock;	/* used to protect sensor updates */
+	struct mutex EC_io_lock;	/* used to protect EC io */
+	bool valid;					/* true if following fields are valid */
+	unsigned long last_updated; /* In jiffies */
+
+	/* Voltage values */
+	s16 voltage[3][NCT6687_NUM_REG_VOLTAGE]; // 0 = current 1 = min 2 = max
+
+	/* Temperature values */
+	s32 temperature[3][NCT6687_NUM_REG_TEMP]; // 0 = current 1 = min 2 = max
+
+	/* Fan attribute values */
+	u16 rpm[3][NCT6687_NUM_REG_FAN]; // 0 = current 1 = min 2 = max
+	u8 _initialFanControlMode[NCT6687_NUM_REG_FAN];
+	u8 _initialFanPwmCommand[NCT6687_NUM_REG_FAN];
+	bool _restoreDefaultFanControlRequired[NCT6687_NUM_REG_FAN];
+
+	u8 pwm[NCT6687_NUM_REG_PWM];
+	enum pwm_enable pwm_enable[NCT6687_NUM_REG_PWM];
+
+	/* Remember extra register values over suspend/resume */
+	u8 hwm_cfg;
+};
+
+struct nct6687_sio_data
+{
+	int sioreg;
+	enum kinds kind;
+};
+
+struct sensor_device_template
+{
+	struct device_attribute dev_attr;
+	union
+	{
+		struct
+		{
+			u8 nr;
+			u8 index;
+		} s;
+		int index;
+	} u;
+	bool s2; /* true if both index and nr are used */
+};
+
+struct sensor_device_attr_u
+{
+	union
+	{
+		struct sensor_device_attribute a1;
+		struct sensor_device_attribute_2 a2;
+	} u;
+	char name[32];
+};
+
+#define __TEMPLATE_ATTR(_template, _mode, _show, _store) \
+	{                                                    \
+		.attr = {.name = _template, .mode = _mode},      \
+		.show = _show,                                   \
+		.store = _store,                                 \
+	}
+
+#define SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store, _index) \
+	{                                                                   \
+		.dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store),   \
+		.u.index = _index,                                              \
+		.s2 = false                                                     \
+	}
+
+#define SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store,     \
+								 _nr, _index)                         \
+	{                                                                 \
+		.dev_attr = __TEMPLATE_ATTR(_template, _mode, _show, _store), \
+		.u.s.index = _index,                                          \
+		.u.s.nr = _nr,                                                \
+		.s2 = true                                                    \
+	}
+
+#define SENSOR_TEMPLATE(_name, _template, _mode, _show, _store, _index)                                                        \
+	static struct sensor_device_template sensor_dev_template_##_name = SENSOR_DEVICE_TEMPLATE(_template, _mode, _show, _store, \
+																							  _index)
+
+#define SENSOR_TEMPLATE_2(_name, _template, _mode, _show, _store,                                                                \
+						  _nr, _index)                                                                                           \
+	static struct sensor_device_template sensor_dev_template_##_name = SENSOR_DEVICE_TEMPLATE_2(_template, _mode, _show, _store, \
+																								_nr, _index)
+
+struct sensor_template_group
+{
+	struct sensor_device_template **templates;
+	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
+	int base;
+};
+
+static void nct6687_save_fan_control(struct nct6687_data *data, int index);
+
+static const char* nct6687_voltage_label(char* buf, int index)
+{
+	if (manual)
+		sprintf(buf, "in%d", index);
+	else
+		strcpy(buf, nct6687_voltage_definition[index].label);
+
+	return buf;
+}
+
+static struct attribute_group *nct6687_create_attr_group(struct device *dev, const struct sensor_template_group *tg, int repeat)
+{
+	struct sensor_device_attribute_2 *a2;
+	struct sensor_device_attribute *a;
+	struct sensor_device_template **t;
+	struct sensor_device_attr_u *su;
+	struct attribute_group *group;
+	struct attribute **attrs;
+	int i, j, count;
+
+	if (repeat <= 0)
+		return ERR_PTR(-EINVAL);
+
+	t = tg->templates;
+	for (count = 0; *t; t++, count++)
+		;
+
+	if (count == 0)
+		return ERR_PTR(-EINVAL);
+
+	group = devm_kzalloc(dev, sizeof(*group), GFP_KERNEL);
+	if (group == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	attrs = devm_kcalloc(dev, repeat * count + 1, sizeof(*attrs), GFP_KERNEL);
+	if (attrs == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	su = devm_kzalloc(dev, array3_size(repeat, count, sizeof(*su)), GFP_KERNEL);
+	if (su == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	group->attrs = attrs;
+	group->is_visible = tg->is_visible;
+
+	for (i = 0; i < repeat; i++)
+	{
+		t = tg->templates;
+
+		for (j = 0; *t != NULL; j++)
+		{
+			snprintf(su->name, sizeof(su->name), (*t)->dev_attr.attr.name, tg->base + i);
+
+			if ((*t)->s2)
+			{
+				a2 = &su->u.a2;
+				sysfs_attr_init(&a2->dev_attr.attr);
+				a2->dev_attr.attr.name = su->name;
+				a2->nr = (*t)->u.s.nr + i;
+				a2->index = (*t)->u.s.index;
+				a2->dev_attr.attr.mode = (*t)->dev_attr.attr.mode;
+				a2->dev_attr.show = (*t)->dev_attr.show;
+				a2->dev_attr.store = (*t)->dev_attr.store;
+				*attrs = &a2->dev_attr.attr;
+			}
+			else
+			{
+				a = &su->u.a1;
+				sysfs_attr_init(&a->dev_attr.attr);
+				a->dev_attr.attr.name = su->name;
+				a->index = (*t)->u.index + i;
+				a->dev_attr.attr.mode = (*t)->dev_attr.attr.mode;
+				a->dev_attr.show = (*t)->dev_attr.show;
+				a->dev_attr.store = (*t)->dev_attr.store;
+				*attrs = &a->dev_attr.attr;
+			}
+			attrs++;
+			su++;
+			t++;
+		}
+	}
+
+	return group;
+}
+
+static u16 nct6687_read(struct nct6687_data *data, u16 address)
+{
+	u8 page = (u8)(address >> 8);
+	u8 index = (u8)(address & 0xFF);
+	int res;
+	mutex_lock(&data->EC_io_lock);
+	outb_p(EC_SPACE_PAGE_SELECT, data->addr + EC_SPACE_PAGE_REGISTER_OFFSET);
+	outb_p(page, data->addr + EC_SPACE_PAGE_REGISTER_OFFSET);
+	outb_p(index, data->addr + EC_SPACE_INDEX_REGISTER_OFFSET);
+	mutex_unlock(&data->EC_io_lock);
+	res = inb_p(data->addr + EC_SPACE_DATA_REGISTER_OFFSET);
+
+	return res;
+}
+
+static u16 nct6687_read16(struct nct6687_data *data, u16 reg)
+{
+	return (nct6687_read(data, reg) << 8) | nct6687_read(data, reg + 1);
+}
+
+static void nct6687_write(struct nct6687_data *data, u16 address, u16 value)
+{
+	u8 page = (u8)(address >> 8);
+	u8 index = (u8)(address & 0xFF);
+	mutex_lock(&data->EC_io_lock);
+	outb_p(EC_SPACE_PAGE_SELECT, data->addr + EC_SPACE_PAGE_REGISTER_OFFSET);
+	outb_p(page, data->addr + EC_SPACE_PAGE_REGISTER_OFFSET);
+	outb_p(index, data->addr + EC_SPACE_INDEX_REGISTER_OFFSET);
+	outb_p(value, data->addr + EC_SPACE_DATA_REGISTER_OFFSET);
+	mutex_unlock(&data->EC_io_lock);
+}
+
+static void nct6687_update_temperatures(struct nct6687_data *data)
+{
+	int i;
+
+	for (i = 0; i < NCT6687_NUM_REG_TEMP; i++)
+	{
+		s32 value = (char)nct6687_read(data, NCT6687_REG_TEMP(i));
+		s32 half = (nct6687_read(data, NCT6687_REG_TEMP(i) + 1) >> 7) & 0x1;
+		s32 temperature = (value * 1000) + (500 * half);
+
+		data->temperature[0][i] = temperature;
+		data->temperature[1][i] = MIN(temperature, data->temperature[1][i]);
+		data->temperature[2][i] = MAX(temperature, data->temperature[2][i]);
+
+		pr_debug("nct6687_update_temperatures[%d]], addr=%04X, value=%d, half=%d, temperature=%d\n", i, NCT6687_REG_TEMP(i), value, half, temperature);
+	}
+}
+
+static void nct6687_update_voltage(struct nct6687_data *data)
+{
+	int index;
+	char buf[128];
+
+	/* Measured voltages and limits */
+	for (index = 0; index < NCT6687_NUM_REG_VOLTAGE; index++)
+	{
+		s16 reg = manual ? index : nct6687_voltage_definition[index].reg;
+		s16 high = nct6687_read(data, NCT6687_REG_VOLTAGE(reg)) * 16;
+		s16 low = ((u16)nct6687_read(data, NCT6687_REG_VOLTAGE(reg) + 1)) >> 4;
+		s16 value = low + high;
+		s16 voltage = manual ? value : value * nct6687_voltage_definition[index].multiplier;
+
+		data->voltage[0][index] = voltage;
+		data->voltage[1][index] = MIN(voltage, data->voltage[1][index]);
+		data->voltage[2][index] = MAX(voltage, data->voltage[2][index]);
+
+		pr_debug("nct6687_update_voltage[%d], %s, reg=%d, addr=0x%04x, value=%d, voltage=%d\n", index, nct6687_voltage_label(buf, index), reg, NCT6687_REG_VOLTAGE(index), value, voltage);
+	}
+
+	pr_debug("nct6687_update_voltage\n");
+}
+
+static enum pwm_enable nct6687_get_pwm_enable(struct nct6687_data *data, int index)
+{
+	u16 bitMask = 0x01 << index;
+	if (nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(index)) & bitMask)
+	{
+		return manual_mode;
+	}
+	return firmware_mode;
+}
+
+static void nct6687_update_fans(struct nct6687_data *data)
+{
+	int i;
+
+	for (i = 0; i < NCT6687_NUM_REG_FAN; i++)
+	{
+		s16 rmp = nct6687_read16(data, NCT6687_REG_FAN_RPM(i));
+
+		data->rpm[0][i] = rmp;
+		data->rpm[1][i] = MIN(rmp, data->rpm[1][i]);
+		data->rpm[2][i] = MAX(rmp, data->rpm[2][i]);
+
+		pr_debug("nct6687_update_fans[%d], rpm=%d min=%d, max=%d", i, rmp, data->rpm[1][i], data->rpm[2][i]);
+	}
+
+	for (i = 0; i < NCT6687_NUM_REG_PWM; i++)
+	{
+		data->pwm[i] = nct6687_read(data, NCT6687_REG_PWM(i));
+		data->pwm_enable[i] = nct6687_get_pwm_enable(data, i);
+
+		pr_debug("nct6687_update_fans[%d], pwm=%d", i, data->pwm[i]);
+	}
+}
+
+static struct nct6687_data *nct6687_update_device(struct device *dev)
+{
+	struct nct6687_data *data = dev_get_drvdata(dev);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ) || !data->valid)
+	{
+		/* Measured voltages and limits */
+		nct6687_update_voltage(data);
+
+		/* Measured temperatures and limits */
+		nct6687_update_temperatures(data);
+
+		/* Measured fan speeds and limits */
+		nct6687_update_fans(data);
+
+		data->last_updated = jiffies;
+		data->valid = true;
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return data;
+}
+
+/*
+ * Sysfs callback functions
+ */
+static ssize_t show_voltage_label(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);
+
+	if (manual)
+		return sprintf(buf, "in%d\n", sattr->index);
+	else
+		return sprintf(buf, "%s\n", nct6687_voltage_definition[sattr->index].label);
+}
+
+static ssize_t show_voltage_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct nct6687_data *data = nct6687_update_device(dev);
+
+	return sprintf(buf, "%d\n", data->voltage[sattr->index][sattr->nr]);
+}
+
+static umode_t nct6687_voltage_is_visible(struct kobject *kobj, struct attribute *attr, int index)
+{
+	pr_debug("nct6687_voltage_is_visible[%d], attr=0x%04X\n", index, attr->mode);
+	return attr->mode;
+}
+
+SENSOR_TEMPLATE(voltage_label, "in%d_label", S_IRUGO, show_voltage_label, NULL, 0);
+SENSOR_TEMPLATE_2(voltage_input, "in%d_input", S_IRUGO, show_voltage_value, NULL, 0, 0);
+SENSOR_TEMPLATE_2(voltage_min, "in%d_min", S_IRUGO, show_voltage_value, NULL, 0, 1);
+SENSOR_TEMPLATE_2(voltage_max, "in%d_max", S_IRUGO, show_voltage_value, NULL, 0, 2);
+
+static struct sensor_device_template *nct6687_attributes_voltage_template[] = {
+	&sensor_dev_template_voltage_label,
+	&sensor_dev_template_voltage_input,
+	&sensor_dev_template_voltage_min,
+	&sensor_dev_template_voltage_max,
+	NULL,
+};
+
+static const struct sensor_template_group nct6687_voltage_template_group = {
+	.templates = nct6687_attributes_voltage_template,
+	.is_visible = nct6687_voltage_is_visible,
+};
+
+static ssize_t show_fan_label(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);
+
+	return sprintf(buf, "%s\n", nct6687_fan_label[sattr->index]);
+}
+
+static ssize_t show_fan_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct nct6687_data *data = nct6687_update_device(dev);
+
+	return sprintf(buf, "%d\n", data->rpm[sattr->index][sattr->nr]);
+}
+
+static umode_t nct6687_fan_is_visible(struct kobject *kobj, struct attribute *attr, int index)
+{
+	return attr->mode;
+}
+
+SENSOR_TEMPLATE(fan_label, "fan%d_label", S_IRUGO, show_fan_label, NULL, 0);
+SENSOR_TEMPLATE_2(fan_input, "fan%d_input", S_IRUGO, show_fan_value, NULL, 0, 0);
+SENSOR_TEMPLATE_2(fan_min, "fan%d_min", S_IRUGO, show_fan_value, NULL, 0, 1);
+SENSOR_TEMPLATE_2(fan_max, "fan%d_max", S_IRUGO, show_fan_value, NULL, 0, 2);
+
+/*
+ * nct6687_fan_is_visible uses the index into the following array
+ * to determine if attributes should be created or not.
+ * Any change in order or content must be matched.
+ */
+static struct sensor_device_template *nct6687_attributes_fan_template[] = {
+	&sensor_dev_template_fan_label,
+	&sensor_dev_template_fan_input,
+	&sensor_dev_template_fan_min,
+	&sensor_dev_template_fan_max,
+	NULL,
+};
+
+static const struct sensor_template_group nct6687_fan_template_group = {
+	.templates = nct6687_attributes_fan_template,
+	.is_visible = nct6687_fan_is_visible,
+	.base = 1,
+};
+
+static ssize_t show_temperature_label(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute *sattr = to_sensor_dev_attr(attr);
+
+	return sprintf(buf, "%s\n", nct6687_temp_label[sattr->index]);
+}
+
+static ssize_t show_temperature_value(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct nct6687_data *data = nct6687_update_device(dev);
+
+	return sprintf(buf, "%d\n", data->temperature[sattr->index][sattr->nr]);
+}
+
+static umode_t nct6687_temp_is_visible(struct kobject *kobj, struct attribute *attr, int index)
+{
+	return attr->mode;
+}
+
+SENSOR_TEMPLATE(temp_label, "temp%d_label", S_IRUGO, show_temperature_label, NULL, 0);
+SENSOR_TEMPLATE_2(temp_input, "temp%d_input", S_IRUGO, show_temperature_value, NULL, 0, 0);
+SENSOR_TEMPLATE_2(temp_min, "temp%d_min", S_IRUGO, show_temperature_value, NULL, 0, 1);
+SENSOR_TEMPLATE_2(temp_max, "temp%d_max", S_IRUGO, show_temperature_value, NULL, 0, 2);
+
+/*
+ * nct6687_temp_is_visible uses the index into the following array
+ * to determine if attributes should be created or not.
+ * Any change in order or content must be matched.
+ */
+static struct sensor_device_template *nct6687_attributes_temp_template[] = {
+	&sensor_dev_template_temp_input,
+	&sensor_dev_template_temp_label,
+	&sensor_dev_template_temp_min,
+	&sensor_dev_template_temp_max,
+	NULL,
+};
+
+static const struct sensor_template_group nct6687_temp_template_group = {
+	.templates = nct6687_attributes_temp_template,
+	.is_visible = nct6687_temp_is_visible,
+	.base = 1,
+};
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct nct6687_data *data = nct6687_update_device(dev);
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	int index = sattr->index;
+
+	return sprintf(buf, "%d\n", data->pwm[index]);
+}
+
+static ssize_t store_pwm(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct nct6687_data *data = dev_get_drvdata(dev);
+	int index = sattr->index;
+	unsigned long val;
+	int retry;
+	u16 readback;
+	u16 mode;
+	u8 bitMask;
+
+	if (kstrtoul(buf, 10, &val) || val > 255 || index >= NCT6687_NUM_REG_FAN)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+
+	nct6687_save_fan_control(data, index);
+
+	mode = nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(index));
+	bitMask = (u8)(0x01 << index);
+
+	mode = (u8)(mode | bitMask);
+	nct6687_write(data, NCT6687_REG_FAN_CTRL_MODE(index), mode);
+
+	nct6687_write(data, NCT6687_REG_FAN_PWM_COMMAND(index), NCT6687_FAN_CFG_REQ);
+	msleep(50);
+	nct6687_write(data, NCT6687_REG_PWM_WRITE(index), val);
+	nct6687_write(data, NCT6687_REG_FAN_PWM_COMMAND(index), NCT6687_FAN_CFG_DONE);
+
+	for (retry = 0; retry < 20; retry++) {
+		msleep(50);
+
+		readback = nct6687_read(data, NCT6687_REG_PWM(index));
+		if (readback == val)
+			break;
+	}
+	data->pwm[index] = readback;
+	data->pwm_enable[index] = nct6687_get_pwm_enable(data, index);
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static ssize_t show_pwm_enable(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct nct6687_data *data = nct6687_update_device(dev);
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+
+	return sprintf(buf, "%d\n", data->pwm_enable[sattr->nr]);
+}
+
+static ssize_t store_pwm_enable(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sensor_device_attribute_2 *sattr = to_sensor_dev_attr_2(attr);
+	struct nct6687_data *data = dev_get_drvdata(dev);
+	int index = sattr->nr;
+	unsigned long val;
+	u16 mode;
+	u8 bitMask;
+
+	if (index >= NCT6687_NUM_REG_FAN || kstrtoul(buf, 10, &val))
+		return -EINVAL;
+	if (val != manual_mode && val != firmware_mode)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+
+	nct6687_save_fan_control(data, index);
+
+	mode = nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(index));
+
+	bitMask = (u8)(0x01 << index);
+	if (val == manual_mode)
+	{
+		mode = (u8)(mode | bitMask);
+	}
+	else if (val == firmware_mode)
+	{
+		mode = (u8)(mode & ~bitMask);
+	}
+
+	nct6687_write(data, NCT6687_REG_FAN_CTRL_MODE(index), mode);
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+SENSOR_TEMPLATE(pwm, "pwm%d", S_IRUGO, show_pwm, store_pwm, 0);
+SENSOR_TEMPLATE_2(pwm_enable, "pwm%d_enable", S_IRUGO, show_pwm_enable, store_pwm_enable, 0, 0);
+
+static void nct6687_save_fan_control(struct nct6687_data *data, int index)
+{
+	if (data->_restoreDefaultFanControlRequired[index] == false)
+	{
+		u16 reg = nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(index));
+		u16 bitMask = 0x01 << index;
+		u8 pwm = nct6687_read(data, NCT6687_REG_FAN_PWM_COMMAND(index));
+
+		data->_initialFanControlMode[index] = (u8)(reg & bitMask);
+		data->_initialFanPwmCommand[index] = pwm;
+
+		data->_restoreDefaultFanControlRequired[index] = true;
+	}
+}
+
+static void nct6687_restore_fan_control(struct nct6687_data *data, int index)
+{
+	if (data->_restoreDefaultFanControlRequired[index])
+	{
+		u8 mode = nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(index));
+		u8 bitMask = 0x01 << index;
+		mode = (u8)((mode & ~bitMask) | data->_initialFanControlMode[index]);
+
+		nct6687_write(data, NCT6687_REG_FAN_CTRL_MODE(index), mode);
+
+		nct6687_write(data, NCT6687_REG_FAN_PWM_COMMAND(index), NCT6687_FAN_CFG_REQ);
+		msleep(50);
+		nct6687_write(data, NCT6687_REG_PWM_WRITE(index), data->_initialFanPwmCommand[index]);
+		nct6687_write(data, NCT6687_REG_FAN_PWM_COMMAND(index), NCT6687_FAN_CFG_DONE);
+		msleep(50);
+
+		data->_restoreDefaultFanControlRequired[index] = false;
+
+		pr_debug("nct6687_restore_fan_control[%d], addr=%04X, ctrl=%04X, _initialFanPwmCommand=%d\n", index, NCT6687_REG_FAN_PWM_COMMAND(index), NCT6687_REG_PWM_WRITE(index), data->_initialFanPwmCommand[index]);
+	}
+}
+
+static umode_t nct6687_pwm_is_visible(struct kobject *kobj, struct attribute *attr, int index)
+{
+	return attr->mode | S_IWUSR;
+}
+
+static struct sensor_device_template *nct6687_attributes_pwm_template[] = {
+	&sensor_dev_template_pwm,
+	&sensor_dev_template_pwm_enable,
+	NULL,
+};
+
+static const struct sensor_template_group nct6687_pwm_template_group = {
+	.templates = nct6687_attributes_pwm_template,
+	.is_visible = nct6687_pwm_is_visible,
+	.base = 1,
+};
+
+/* Get the monitoring functions started */
+static inline void nct6687_init_device(struct nct6687_data *data)
+{
+	u8 tmp;
+
+	pr_debug("nct6687_init_device\n");
+
+	/* Start hardware monitoring if needed */
+	tmp = nct6687_read(data, NCT6687_HWM_CFG);
+	if (!(tmp & 0x80))
+	{
+		pr_debug("nct6687_init_device: 0x%04x\n", tmp);
+		nct6687_write(data, NCT6687_HWM_CFG, tmp | 0x80);
+	}
+
+	// enable SIO voltage
+	nct6687_write(data, 0x1BB, 0x61);
+	nct6687_write(data, 0x1BC, 0x62);
+	nct6687_write(data, 0x1BD, 0x63);
+	nct6687_write(data, 0x1BE, 0x64);
+	nct6687_write(data, 0x1BF, 0x65);
+}
+
+/*
+ * There are a total of 8 fan inputs.
+ */
+static void nct6687_setup_fans(struct nct6687_data *data)
+{
+	int i;
+
+	for (i = 0; i < NCT6687_NUM_REG_FAN; i++)
+	{
+		u16 reg = nct6687_read(data, NCT6687_REG_FAN_CTRL_MODE(i));
+		u16 bitMask = 0x01 << i;
+		u16 rpm = nct6687_read16(data, NCT6687_REG_FAN_RPM(i));
+
+		data->rpm[0][i] = rpm;
+		data->rpm[1][i] = rpm;
+		data->rpm[2][i] = rpm;
+		data->_initialFanControlMode[i] = (u8)(reg & bitMask);
+		data->_restoreDefaultFanControlRequired[i] = false;
+
+		pr_debug("nct6687_setup_fans[%d], %s - addr=%04X, ctrl=%04X, rpm=%d, _initialFanControlMode=%d\n", i, nct6687_fan_label[i], NCT6687_REG_FAN_CTRL_MODE(i), reg, rpm, data->_initialFanControlMode[i]);
+	}
+}
+
+static void nct6687_setup_voltages(struct nct6687_data *data)
+{
+	int index;
+	char buf[64];
+
+	/* Measured voltages and limits */
+	for (index = 0; index < NCT6687_NUM_REG_VOLTAGE; index++)
+	{
+		s16 reg = manual ? index : nct6687_voltage_definition[index].reg;
+		s16 high = nct6687_read(data, NCT6687_REG_VOLTAGE(reg)) * 16;
+		s16 low = ((u16)nct6687_read(data, NCT6687_REG_VOLTAGE(reg) + 1)) >> 4;
+		s16 value = low + high;
+		s16 voltage = manual ? value : value * nct6687_voltage_definition[index].multiplier;
+
+		data->voltage[0][index] = voltage;
+		data->voltage[1][index] = voltage;
+		data->voltage[2][index] = voltage;
+
+		pr_debug("nct6687_setup_voltages[%d], %s, addr=0x%04x, value=%d, voltage=%d\n", index, nct6687_voltage_label(buf, index), NCT6687_REG_VOLTAGE(index), value, voltage);
+	}
+}
+
+static void nct6687_setup_temperatures(struct nct6687_data *data)
+{
+	int i;
+
+	for (i = 0; i < NCT6687_NUM_REG_TEMP; i++)
+	{
+		s32 value = (char)nct6687_read(data, NCT6687_REG_TEMP(i));
+		s32 half = (nct6687_read(data, NCT6687_REG_TEMP(i) + 1) >> 7) & 0x1;
+		s32 temperature = (value * 1000) + (5 * half);
+
+		data->temperature[0][i] = temperature;
+		data->temperature[1][i] = temperature;
+		data->temperature[2][i] = temperature;
+
+		pr_debug("nct6687_setup_temperatures[%d]], addr=%04X, value=%d, half=%d, temperature=%d\n", i, NCT6687_REG_TEMP(i), value, half, temperature);
+	}
+}
+
+static void nct6687_setup_pwm(struct nct6687_data *data)
+{
+	int i;
+
+	for (i = 0; i < NCT6687_NUM_REG_PWM; i++)
+	{
+		data->_initialFanPwmCommand[i] = nct6687_read(data, NCT6687_REG_FAN_PWM_COMMAND(i));
+		data->pwm[i] = nct6687_read(data, NCT6687_REG_PWM(i));
+		data->pwm_enable[i] = nct6687_get_pwm_enable(data, i);
+
+		pr_debug("nct6687_setup_pwm[%d], addr=%04X, pwm=%d, pwm_enable=%d, _initialFanPwmCommand=%d\n",
+		         i,
+		         NCT6687_REG_FAN_PWM_COMMAND(i),
+		         data->pwm[i],
+		         data->pwm_enable[i],
+		         data->_initialFanPwmCommand[i]);
+	}
+}
+
+static int nct6687_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nct6687_data *data = dev_get_drvdata(dev);
+	int i;
+
+	mutex_lock(&data->update_lock);
+
+	for (i = 0; i < NCT6687_NUM_REG_FAN; i++)
+	{
+		nct6687_restore_fan_control(data, i);
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return 0;
+}
+
+static int nct6687_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nct6687_sio_data *sio_data = dev->platform_data;
+	struct attribute_group *group;
+	struct nct6687_data *data;
+	struct device *hwmon_dev;
+	struct resource *res;
+	int groups = 0;
+	char build[16];
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (!devm_request_region(dev, res->start, IOREGION_LENGTH, DRVNAME))
+		return -EBUSY;
+
+	data = devm_kzalloc(dev, sizeof(struct nct6687_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->kind = sio_data->kind;
+	data->sioreg = sio_data->sioreg;
+	data->addr = res->start;
+
+	pr_debug("nct6687_probe addr=0x%04X, sioreg=0x%04X\n", data->addr, data->sioreg);
+
+	mutex_init(&data->update_lock);
+	mutex_init(&data->EC_io_lock);
+	platform_set_drvdata(pdev, data);
+
+	nct6687_init_device(data);
+	nct6687_setup_fans(data);
+	nct6687_setup_pwm(data);
+	nct6687_setup_temperatures(data);
+	nct6687_setup_voltages(data);
+
+	/* Register sysfs hooks */
+
+	group = nct6687_create_attr_group(dev, &nct6687_pwm_template_group, NCT6687_NUM_REG_FAN);
+
+	if (IS_ERR(group))
+		return PTR_ERR(group);
+
+	data->groups[groups++] = group;
+
+	group = nct6687_create_attr_group(dev, &nct6687_voltage_template_group, NCT6687_NUM_REG_VOLTAGE);
+
+	if (IS_ERR(group))
+		return PTR_ERR(group);
+
+	data->groups[groups++] = group;
+
+	group = nct6687_create_attr_group(dev, &nct6687_fan_template_group, NCT6687_NUM_REG_FAN);
+
+	if (IS_ERR(group))
+		return PTR_ERR(group);
+
+	data->groups[groups++] = group;
+
+	group = nct6687_create_attr_group(dev, &nct6687_temp_template_group, NCT6687_NUM_REG_TEMP);
+
+	if (IS_ERR(group))
+		return PTR_ERR(group);
+
+	data->groups[groups++] = group;
+
+	scnprintf(build, sizeof(build), "%02d/%02d/%02d", nct6687_read(data, NCT6687_REG_BUILD_MONTH), nct6687_read(data, NCT6687_REG_BUILD_DAY), nct6687_read(data, NCT6687_REG_BUILD_YEAR));
+
+	dev_info(dev, "%s EC firmware version %d.%d build %s\n", nct6687_chip_names[data->kind], nct6687_read(data, NCT6687_REG_VERSION_HI), nct6687_read(data, NCT6687_REG_VERSION_LO), build);
+
+	hwmon_dev = devm_hwmon_device_register_with_groups(dev, nct6687_device_names[data->kind], data, data->groups);
+
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static int nct6687_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct nct6687_data *data = nct6687_update_device(&pdev->dev);
+
+	mutex_lock(&data->update_lock);
+	data->hwm_cfg = nct6687_read(data, NCT6687_HWM_CFG);
+	mutex_unlock(&data->update_lock);
+
+	return 0;
+}
+
+static int nct6687_resume(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct nct6687_data *data = dev_get_drvdata(dev);
+
+	mutex_lock(&data->update_lock);
+
+	nct6687_write(data, NCT6687_HWM_CFG, data->hwm_cfg);
+
+	/* Force re-reading all values */
+	data->valid = false;
+	mutex_unlock(&data->update_lock);
+
+	return 0;
+}
+
+// static const struct dev_pm_ops nct6687_dev_pm_ops = {
+// 	.suspend = nct6687_suspend,
+// 	.resume = nct6687_resume,
+// 	.freeze = nct6687_suspend,
+// 	.restore = nct6687_resume,
+// };
+
+#define NCT6687_DEV_PM_OPS NULL
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
+static struct platform_driver nct6687_driver = {
+	.driver = {
+		.name = DRVNAME,
+		.pm = NCT6687_DEV_PM_OPS,
+	},
+	.probe = nct6687_probe,
+	.remove = nct6687_remove,
+	.suspend = nct6687_suspend,
+	.resume = nct6687_resume,
+};
+#pragma GCC diagnostic pop
+
+static int __init nct6687_find(int sioaddr, struct nct6687_sio_data *sio_data)
+{
+	u16 address;
+	u16 verify;
+	u16 val;
+	int err;
+
+	err = superio_enter(sioaddr);
+	if (err)
+		return err;
+
+	val = (superio_inb(sioaddr, SIO_REG_DEVID) << 8) | superio_inb(sioaddr, SIO_REG_DEVREVISION);
+
+	pr_debug("found chip ID: 0x%04x\n", val);
+
+       switch (val & SIO_ID_MASK) {
+        case SIO_NCT6683_ID:
+                sio_data->kind = nct6683;
+                break;
+        case SIO_NCT6686_ID:
+                sio_data->kind = nct6686;
+                break;
+        case SIO_NCT6687D_ID:
+        case SIO_NCT6687_ID:
+                sio_data->kind = nct6687;
+                break;
+        default:
+		if (force){
+                 sio_data->kind = nct6687;
+                 break;
+		}
+                if (val != 0xffff)
+                        pr_debug("unsupported chip ID: 0x%04x\n", val);
+                goto fail;
+        }
+
+	/* We have a known chip, find the HWM I/O address */
+	superio_select(sioaddr, NCT6687_LD_HWM);
+	address = (superio_inb(sioaddr, SIO_REG_ADDR) << 8) | superio_inb(sioaddr, SIO_REG_ADDR + 1);
+	ssleep(1);
+	verify = (superio_inb(sioaddr, SIO_REG_ADDR) << 8) | superio_inb(sioaddr, SIO_REG_ADDR + 1);
+
+	if (address == 0 || address != verify)
+	{
+		pr_err("EC base I/O port unconfigured\n");
+		goto fail;
+	}
+
+	if ((address & 0x07) == 0x05)
+		address &= 0xFFF8;
+
+	if (address < 0x100 || (address & 0xF007) != 0)
+	{
+		pr_err("EC Invalid address: 0x%04X\n", address);
+		goto fail;
+	}
+
+	/* Activate logical device if needed */
+	val = superio_inb(sioaddr, SIO_REG_ENABLE);
+	if (!(val & 0x01))
+	{
+		pr_warn("Forcibly enabling EC access. Data may be unusable.\n");
+		superio_outb(sioaddr, SIO_REG_ENABLE, val | 0x01);
+	}
+
+	superio_exit(sioaddr);
+	pr_info("Found %s or compatible chip at 0x%04x:0x%04x\n", nct6687_chip_names[sio_data->kind], sioaddr, address);
+	sio_data->sioreg = sioaddr;
+
+	return address;
+
+fail:
+	superio_exit(sioaddr);
+	return -ENODEV;
+}
+
+/*
+ * when Super-I/O functions move to a separate file, the Super-I/O
+ * bus will manage the lifetime of the device and this module will only keep
+ * track of the nct6687 driver. But since we use platform_device_alloc(), we
+ * must keep track of the device
+ */
+static struct platform_device *pdev[2];
+
+static int __init sensors_nct6687_init(void)
+{
+	struct nct6687_sio_data sio_data;
+	int sioaddr[2] = {0x2e, 0x4e};
+	struct resource res;
+	bool found = false;
+	int address;
+	int i, err;
+
+	err = platform_driver_register(&nct6687_driver);
+	if (err)
+		return err;
+
+	/*
+	 * initialize sio_data->kind and sio_data->sioreg.
+	 *
+	 * when Super-I/O functions move to a separate file, the Super-I/O
+	 * driver will probe 0x2e and 0x4e and auto-detect the presence of a
+	 * nct6687 hardware monitor, and call probe()
+	 */
+	for (i = 0; i < ARRAY_SIZE(pdev); i++)
+	{
+		address = nct6687_find(sioaddr[i], &sio_data);
+		if (address <= 0)
+			continue;
+
+		found = true;
+
+		pdev[i] = platform_device_alloc(DRVNAME, address);
+		if (!pdev[i])
+		{
+			err = -ENOMEM;
+			goto exit_device_unregister;
+		}
+
+		err = platform_device_add_data(pdev[i], &sio_data, sizeof(struct nct6687_sio_data));
+		if (err)
+			goto exit_device_put;
+
+		memset(&res, 0, sizeof(res));
+
+		res.name = DRVNAME;
+		res.start = address + IOREGION_OFFSET;
+		res.end = address + IOREGION_OFFSET + IOREGION_LENGTH - 1;
+		res.flags = IORESOURCE_IO;
+
+		err = acpi_check_resource_conflict(&res);
+		if (err)
+		{
+			platform_device_put(pdev[i]);
+			pdev[i] = NULL;
+			continue;
+		}
+
+		err = platform_device_add_resources(pdev[i], &res, 1);
+		if (err)
+			goto exit_device_put;
+
+		/* platform_device_add calls probe() */
+		err = platform_device_add(pdev[i]);
+		if (err)
+			goto exit_device_put;
+	}
+
+	if (!found)
+	{
+		err = -ENODEV;
+		goto exit_unregister;
+	}
+
+	return 0;
+
+exit_device_put:
+	platform_device_put(pdev[i]);
+
+exit_device_unregister:
+	while (--i >= 0)
+	{
+		if (pdev[i])
+			platform_device_unregister(pdev[i]);
+	}
+
+exit_unregister:
+	platform_driver_unregister(&nct6687_driver);
+
+	return err;
+}
+
+static void __exit sensors_nct6687_exit(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pdev); i++)
+	{
+		if (pdev[i])
+			platform_device_unregister(pdev[i]);
+	}
+
+	platform_driver_unregister(&nct6687_driver);
+}
+
+MODULE_AUTHOR("Frederic Boltz <frederic.boltz@gmail.com>");
+MODULE_DESCRIPTION("Driver for NCT6687D");
+MODULE_LICENSE("GPL");
+
+module_init(sensors_nct6687_init);
+module_exit(sensors_nct6687_exit);
# ----------------------------------------
# Module: gpdfan
# Version: a678a9314a40
# ----------------------------------------
diff --git a/drivers/custom/gpdfan/Makefile b/drivers/custom/gpdfan/Makefile
new file mode 100644
index 000000000000..38845d773774
--- /dev/null
+++ b/drivers/custom/gpdfan/Makefile
@@ -0,0 +1,9 @@
+obj-m += gpd-fan.o
+
+KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build
+
+all default: modules
+install: modules_install
+
+modules modules_install help clean:
+	$(MAKE) -C $(KERNEL_SRC) M=$(shell pwd) $@
\ No newline at end of file
diff --git a/drivers/custom/gpdfan/gpd-fan.c b/drivers/custom/gpdfan/gpd-fan.c
new file mode 100644
index 000000000000..b3e7bc2efd79
--- /dev/null
+++ b/drivers/custom/gpdfan/gpd-fan.c
@@ -0,0 +1,952 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+/* Platform driver for GPD devices that expose fan control via hwmon sysfs.
+ *
+ * Fan control is provided via pwm interface in the range [0-255].
+ * Each model has a different range in the EC, the written value is scaled to
+ * accommodate for that.
+ *
+ * Based on this repo:
+ * https://github.com/Cryolitia/gpd-fan-driver
+ *
+ * Copyright (c) 2024 Cryolitia PukNgae
+ */
+
+#define OUT_OF_TREE
+
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/hwmon.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#ifdef OUT_OF_TREE
+#include <linux/debugfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/version.h>
+#endif
+
+#define DRIVER_NAME "gpdfan"
+#define GPD_PWM_CTR_OFFSET 0x1841
+
+static char *gpd_fan_board = "";
+module_param(gpd_fan_board, charp, 0444);
+
+// EC read/write locker
+// Should never access EC at the same time, otherwise system down.
+static DEFINE_MUTEX(gpd_fan_lock);
+
+enum gpd_board {
+	win_mini,
+	win4_6800u,
+	win_max_2,
+	duo,
+};
+
+enum FAN_PWM_ENABLE {
+	DISABLE		= 0,
+	MANUAL		= 1,
+	AUTOMATIC	= 2,
+};
+
+static struct {
+	enum FAN_PWM_ENABLE pwm_enable;
+	u8 pwm_value;
+
+#ifdef OUT_OF_TREE
+	u16 read_rpm_cached;
+	u8 read_pwm_cached;
+
+	// minium 1000 mill seconds
+	u32 update_interval_per_second;
+
+	unsigned long read_rpm_last_update;
+	unsigned long read_pwm_last_update;
+#endif
+
+	const struct gpd_fan_drvdata *drvdata;
+} gpd_driver_priv;
+
+struct gpd_fan_drvdata {
+	const char *board_name; /* Board name for module param comparison */
+	const enum gpd_board board;
+
+	const u8 addr_port;
+	const u8 data_port;
+	const u16 manual_control_enable;
+	const u16 rpm_read;
+	const u16 pwm_write;
+	const u16 pwm_max;
+};
+
+static struct gpd_fan_drvdata gpd_win_mini_drvdata = {
+	.board_name		= "win_mini",
+	.board			= win_mini,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x047A,
+	.rpm_read		= 0x0478,
+	.pwm_write		= 0x047A,
+	.pwm_max		= 244,
+};
+
+static struct gpd_fan_drvdata gpd_duo_drvdata = {
+	.board_name		= "duo",
+	.board			= duo,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x047A,
+	.rpm_read		= 0x0478,
+	.pwm_write		= 0x047A,
+	.pwm_max		= 244,
+};
+
+static struct gpd_fan_drvdata gpd_win4_drvdata = {
+	.board_name		= "win4",
+	.board			= win4_6800u,
+
+	.addr_port		= 0x2E,
+	.data_port		= 0x2F,
+	.manual_control_enable	= 0xC311,
+	.rpm_read		= 0xC880,
+	.pwm_write		= 0xC311,
+	.pwm_max		= 127,
+};
+
+static struct gpd_fan_drvdata gpd_wm2_drvdata = {
+	.board_name		= "wm2",
+	.board			= win_max_2,
+
+	.addr_port		= 0x4E,
+	.data_port		= 0x4F,
+	.manual_control_enable	= 0x0275,
+	.rpm_read		= 0x0218,
+	.pwm_write		= 0x1809,
+	.pwm_max		= 184,
+};
+
+static const struct dmi_system_id dmi_table[] = {
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen 8840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-01")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-02")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win Mini
+		// GPD Win Mini with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1617-02-L")
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Win 4 with AMD Ryzen 6800U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Default string"),
+		},
+		.driver_data = &gpd_win4_drvdata,
+	},
+	{
+		// GPD Win 4 with Ryzen 7840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Ver. 1.0"),
+		},
+		// Since 7840U, win4 uses the same drvdata as wm2
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win 4 with Ryzen 7840U (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1618-04"),
+			DMI_MATCH(DMI_BOARD_VERSION, "Ver.1.0"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win Max 2 with Ryzen 6800U
+		// GPD Win Max 2 2023 with Ryzen 7840U
+		// GPD Win Max 2 2024 with Ryzen 8840U
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-04"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Win Max 2 with AMD Ryzen HX370
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1619-05"),
+		},
+		.driver_data = &gpd_wm2_drvdata,
+	},
+	{
+		// GPD Duo
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1622-01"),
+		},
+		.driver_data = &gpd_duo_drvdata,
+	},
+	{
+		// GPD Duo (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1622-01-L"),
+		},
+		.driver_data = &gpd_duo_drvdata,
+	},
+	{
+		// GPD Pocket 4
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1628-04"),
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{
+		// GPD Pocket 4 (another)
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "GPD"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "G1628-04-L"),
+		},
+		.driver_data = &gpd_win_mini_drvdata,
+	},
+	{}
+};
+
+static const struct gpd_fan_drvdata *gpd_module_drvdata[] = {
+	&gpd_win_mini_drvdata, &gpd_win4_drvdata, &gpd_wm2_drvdata, NULL
+};
+
+/* Helper functions to handle EC read/write */
+static int gpd_ecram_read(const struct gpd_fan_drvdata *drvdata, u16 offset,
+			  u8 *val)
+{
+	int ret;
+	u16 addr_port = drvdata->addr_port;
+	u16 data_port = drvdata->data_port;
+
+	ret = mutex_lock_interruptible(&gpd_fan_lock);
+
+	if (ret)
+		return ret;
+
+	outb(0x2E, addr_port);
+	outb(0x11, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)((offset >> 8) & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x10, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)(offset & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x12, data_port);
+	outb(0x2F, addr_port);
+	*val = inb(data_port);
+
+	mutex_unlock(&gpd_fan_lock);
+	return 0;
+}
+
+static int gpd_ecram_write(const struct gpd_fan_drvdata *drvdata, u16 offset,
+			   u8 value)
+{
+	int ret;
+	u16 addr_port = drvdata->addr_port;
+	u16 data_port = drvdata->data_port;
+
+	ret = mutex_lock_interruptible(&gpd_fan_lock);
+
+	if (ret)
+		return ret;
+
+	outb(0x2E, addr_port);
+	outb(0x11, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)((offset >> 8) & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x10, data_port);
+	outb(0x2F, addr_port);
+	outb((u8)(offset & 0xFF), data_port);
+
+	outb(0x2E, addr_port);
+	outb(0x12, data_port);
+	outb(0x2F, addr_port);
+	outb(value, data_port);
+
+	mutex_unlock(&gpd_fan_lock);
+	return 0;
+}
+
+#ifdef OUT_OF_TREE
+
+static int gpd_read_pwm(void);
+static int gpd_read_rpm(void);
+
+#define DEFINE_GPD_READ_CACHED(name, type)                                          \
+	static int gpd_##name##_cached(void)                                        \
+	{                                                                           \
+		if (time_after(                                                     \
+			    jiffies,                                                \
+			    gpd_driver_priv.name##_last_update +                    \
+				    HZ * gpd_driver_priv                            \
+						    .update_interval_per_second)) { \
+			int ret = gpd_##name();                                     \
+			if (ret)                                                    \
+				return ret;                                         \
+			gpd_driver_priv.name##_cached = (type)ret;                  \
+			gpd_driver_priv.name##_last_update = jiffies;               \
+		}                                                                   \
+		return 0;                                                           \
+	}
+
+DEFINE_GPD_READ_CACHED(read_rpm, u16);
+DEFINE_GPD_READ_CACHED(read_pwm, u8);
+
+#endif
+
+static int gpd_generic_read_rpm(void)
+{
+	u8 high, low;
+	int ret;
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+
+	ret = gpd_ecram_read(drvdata, drvdata->rpm_read, &high);
+	if (ret)
+		return ret;
+
+	ret = gpd_ecram_read(drvdata, drvdata->rpm_read + 1, &low);
+	if (ret)
+		return ret;
+
+	return (u16)high << 8 | low;
+}
+
+static int gpd_win4_read_rpm(void)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 pwm_ctr_reg;
+	int ret;
+
+	gpd_ecram_read(drvdata, GPD_PWM_CTR_OFFSET, &pwm_ctr_reg);
+
+	if (pwm_ctr_reg != 0x7F)
+		gpd_ecram_write(drvdata, GPD_PWM_CTR_OFFSET, 0x7F);
+
+	ret = gpd_generic_read_rpm();
+
+	if (ret < 0)
+		return ret;
+
+	if (ret == 0) {
+		// re-init EC
+		u8 chip_id;
+
+		gpd_ecram_read(drvdata, 0x2000, &chip_id);
+		if (chip_id == 0x55) {
+			u8 chip_ver;
+
+			if (gpd_ecram_read(drvdata, 0x1060, &chip_ver))
+				gpd_ecram_write(drvdata, 0x1060,
+						chip_ver | 0x80);
+		}
+	}
+
+	return ret;
+}
+
+static int gpd_wm2_read_rpm(void)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+
+	for (u16 pwm_ctr_offset = GPD_PWM_CTR_OFFSET;
+	     pwm_ctr_offset <= GPD_PWM_CTR_OFFSET + 2; pwm_ctr_offset++) {
+		u8 PWMCTR;
+
+		gpd_ecram_read(drvdata, pwm_ctr_offset, &PWMCTR);
+
+		if (PWMCTR != 0xB8)
+			gpd_ecram_write(drvdata, pwm_ctr_offset, 0xB8);
+	}
+
+	return gpd_generic_read_rpm();
+}
+
+// Read value for fan1_input
+static int gpd_read_rpm(void)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case duo:
+		return gpd_generic_read_rpm();
+	case win4_6800u:
+		return gpd_win4_read_rpm();
+	case win_max_2:
+		return gpd_wm2_read_rpm();
+	}
+
+	return 0;
+}
+
+static int gpd_wm2_read_pwm(void)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 var;
+	int ret = gpd_ecram_read(drvdata, drvdata->pwm_write, &var);
+
+	if (ret < 0)
+		return ret;
+
+	return var * 255 / drvdata->pwm_max;
+}
+
+// Read value for pwm1
+static int gpd_read_pwm(void)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case duo:
+	case win4_6800u:
+		return gpd_driver_priv.pwm_value;
+	case win_max_2:
+		return gpd_wm2_read_pwm();
+	}
+	return 0;
+}
+
+static int gpd_generic_write_pwm(u8 val)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	u8 pwm_reg;
+
+	// PWM value's range in EC is 1 - pwm_max, cast 0 - 255 to it.
+	pwm_reg = val * (drvdata->pwm_max - 1) / 255 + 1;
+	return gpd_ecram_write(drvdata, drvdata->pwm_write, pwm_reg);
+}
+
+static int gpd_win_mini_write_pwm(u8 val)
+{
+	if (gpd_driver_priv.pwm_enable == MANUAL)
+		return gpd_generic_write_pwm(val);
+	else
+		return -EPERM;
+}
+
+static int gpd_duo_write_pwm_twice(u8 val)
+{
+	int ret;
+	ret = gpd_generic_write_pwm(val);
+
+	if (ret)
+		return ret;
+
+	return gpd_generic_write_pwm(val+1);
+}
+
+static int gpd_duo_write_pwm(u8 val)
+{
+	if (gpd_driver_priv.pwm_enable == MANUAL)
+		return gpd_duo_write_pwm_twice(val);
+	else
+		return -EPERM;
+}
+
+static int gpd_wm2_write_pwm(u8 val)
+{
+	if (gpd_driver_priv.pwm_enable != DISABLE)
+		return gpd_generic_write_pwm(val);
+	else
+		return -EPERM;
+}
+
+// Write value for pwm1
+static int gpd_write_pwm(u8 val)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+		return gpd_win_mini_write_pwm(val);
+	case duo:
+		return gpd_duo_write_pwm(val);
+	case win4_6800u:
+		return gpd_generic_write_pwm(val);
+	case win_max_2:
+		return gpd_wm2_write_pwm(val);
+	}
+
+	return 0;
+}
+
+static int gpd_win_mini_set_pwm_enable(enum FAN_PWM_ENABLE pwm_enable)
+{
+	const struct gpd_fan_drvdata *drvdata;
+
+	switch (pwm_enable) {
+	case DISABLE:
+		return gpd_generic_write_pwm(255);
+	case MANUAL:
+		return gpd_generic_write_pwm(gpd_driver_priv.pwm_value);
+	case AUTOMATIC:
+		drvdata = gpd_driver_priv.drvdata;
+		return gpd_ecram_write(drvdata, drvdata->pwm_write, 0);
+	}
+
+	return 0;
+}
+
+static int gpd_duo_set_pwm_enable(enum FAN_PWM_ENABLE pwm_enable)
+{
+	const struct gpd_fan_drvdata *drvdata;
+
+	switch (pwm_enable) {
+	case DISABLE:
+		return gpd_duo_write_pwm_twice(255);
+	case MANUAL:
+		return gpd_duo_write_pwm_twice(gpd_driver_priv.pwm_value);
+	case AUTOMATIC:
+		drvdata = gpd_driver_priv.drvdata;
+		return gpd_ecram_write(drvdata, drvdata->pwm_write, 0);
+	}
+
+	return 0;
+}
+
+static int gpd_wm2_set_pwm_enable(enum FAN_PWM_ENABLE enable)
+{
+	const struct gpd_fan_drvdata *const drvdata = gpd_driver_priv.drvdata;
+	int ret;
+
+	switch (enable) {
+	case DISABLE: {
+		ret = gpd_generic_write_pwm(255);
+
+		if (ret)
+			return ret;
+
+		return gpd_ecram_write(drvdata, drvdata->manual_control_enable,
+				       1);
+	}
+	case MANUAL: {
+		ret = gpd_generic_write_pwm(gpd_driver_priv.pwm_value);
+
+		if (ret)
+			return ret;
+
+		return gpd_ecram_write(drvdata, drvdata->manual_control_enable,
+				       1);
+	}
+	case AUTOMATIC: {
+		ret = gpd_ecram_write(drvdata, drvdata->manual_control_enable,
+				      0);
+
+		return ret;
+	}
+	}
+
+	return 0;
+}
+
+// Write value for pwm1_enable
+static int gpd_set_pwm_enable(enum FAN_PWM_ENABLE enable)
+{
+	switch (gpd_driver_priv.drvdata->board) {
+	case win_mini:
+	case win4_6800u:
+		return gpd_win_mini_set_pwm_enable(enable);
+	case duo:
+		return gpd_duo_set_pwm_enable(enable);
+	case win_max_2:
+		return gpd_wm2_set_pwm_enable(enable);
+	}
+
+	return 0;
+}
+
+static umode_t gpd_fan_hwmon_is_visible(__always_unused const void *drvdata,
+					enum hwmon_sensor_types type, u32 attr,
+					__always_unused int channel)
+{
+	if (type == hwmon_fan && attr == hwmon_fan_input) {
+		return 0444;
+	} else if (type == hwmon_pwm) {
+		switch (attr) {
+#ifdef OUT_OF_TREE
+		case hwmon_pwm_mode:
+			return 0444;
+#endif
+		case hwmon_pwm_enable:
+		case hwmon_pwm_input:
+			return 0644;
+		default:
+			return 0;
+		}
+	}
+#ifdef OUT_OF_TREE
+	if (type == hwmon_chip && attr == hwmon_chip_update_interval) {
+		return 0644;
+	}
+#endif
+	return 0;
+}
+
+static int gpd_fan_hwmon_read(__always_unused struct device *dev,
+			      enum hwmon_sensor_types type, u32 attr,
+			      __always_unused int channel, long *val)
+{
+	if (type == hwmon_fan) {
+		if (attr == hwmon_fan_input) {
+#ifdef OUT_OF_TREE
+			int ret = gpd_read_rpm_cached();
+#else
+			int ret = gpd_read_rpm();
+#endif
+
+			if (ret < 0)
+				return ret;
+
+			*val = ret;
+			return 0;
+		}
+		return -EOPNOTSUPP;
+	} else if (type == hwmon_pwm) {
+		int ret;
+		switch (attr) {
+#ifdef OUT_OF_TREE
+		case hwmon_pwm_mode:
+			*val = 1;
+			return 0;
+#endif
+		case hwmon_pwm_enable:
+			*val = gpd_driver_priv.pwm_enable;
+			return 0;
+		case hwmon_pwm_input:
+#ifdef OUT_OF_TREE
+			ret = gpd_read_pwm_cached();
+#else
+			ret = gpd_read_pwm();
+#endif
+
+			if (ret < 0)
+				return ret;
+
+			*val = ret;
+			return 0;
+		default:
+			return -EOPNOTSUPP;
+		}
+	}
+#ifdef OUT_OF_TREE
+	if (type == hwmon_chip && attr == hwmon_chip_update_interval) {
+		*val = 1000 * gpd_driver_priv.update_interval_per_second;
+		return 0;
+	}
+#endif
+
+	return -EOPNOTSUPP;
+}
+
+static int gpd_fan_hwmon_write(__always_unused struct device *dev,
+			       enum hwmon_sensor_types type, u32 attr,
+			       __always_unused int channel, long val)
+{
+	u8 var;
+
+	if (type == hwmon_pwm) {
+		switch (attr) {
+		case hwmon_pwm_enable:
+			if (!in_range(val, 0, 3))
+				return -EINVAL;
+
+			gpd_driver_priv.pwm_enable = val;
+
+			return gpd_set_pwm_enable(gpd_driver_priv.pwm_enable);
+		case hwmon_pwm_input:
+			var = clamp_val(val, 0, 255);
+
+			gpd_driver_priv.pwm_value = var;
+
+			return gpd_write_pwm(var);
+		default:
+			return -EOPNOTSUPP;
+		}
+	}
+#ifdef OUT_OF_TREE
+	if (type == hwmon_chip) {
+		if (attr == hwmon_chip_update_interval) {
+			int interval = val / 1000;
+			if (interval < 1)
+				interval = 1;
+			gpd_driver_priv.update_interval_per_second = interval;
+			return 0;
+		}
+	}
+#endif
+
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops gpd_fan_ops = {
+	.is_visible = gpd_fan_hwmon_is_visible,
+	.read = gpd_fan_hwmon_read,
+	.write = gpd_fan_hwmon_write,
+};
+
+static const struct hwmon_channel_info *gpd_fan_hwmon_channel_info[] = {
+#ifdef OUT_OF_TREE
+	HWMON_CHANNEL_INFO(chip, HWMON_C_UPDATE_INTERVAL),
+	HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE | HWMON_PWM_MODE),
+#else
+	HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT),
+	HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT | HWMON_PWM_ENABLE),
+#endif
+	NULL
+};
+
+static struct hwmon_chip_info gpd_fan_chip_info = {
+	.ops = &gpd_fan_ops,
+	.info = gpd_fan_hwmon_channel_info
+};
+
+#ifdef OUT_OF_TREE
+struct dentry *DEBUG_FS_ENTRY = NULL;
+
+static int debugfs_manual_control_get(void *data, u64 *val)
+{
+	const struct gpd_fan_drvdata *address = gpd_driver_priv.drvdata;
+	u8 u8_val;
+
+	int ret = gpd_ecram_read(address, address->manual_control_enable,
+				 &u8_val);
+	*val = (u64)u8_val;
+	return ret;
+}
+
+static int debugfs_manual_control_set(void *data, u64 val)
+{
+	const struct gpd_fan_drvdata *address = gpd_driver_priv.drvdata;
+	return gpd_ecram_write(address, address->manual_control_enable,
+			       clamp_val(val, 0, 255));
+}
+
+static int debugfs_pwm_get(void *data, u64 *val)
+{
+	const struct gpd_fan_drvdata *address = gpd_driver_priv.drvdata;
+	u8 u8_val;
+
+	int ret = gpd_ecram_read(address, address->pwm_write, &u8_val);
+	*val = (u64)u8_val;
+	return ret;
+}
+
+static int debugfs_pwm_set(void *data, u64 val)
+{
+	const struct gpd_fan_drvdata *address = gpd_driver_priv.drvdata;
+	return gpd_ecram_write(address, address->pwm_write,
+			       clamp_val(val, 0, 255));
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(debugfs_manual_control_fops,
+			 debugfs_manual_control_get, debugfs_manual_control_set,
+			 "%llu\n");
+DEFINE_DEBUGFS_ATTRIBUTE(debugfs_pwm_fops, debugfs_pwm_get, debugfs_pwm_set,
+			 "%llu\n");
+
+#endif
+
+static int gpd_fan_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct resource *res;
+	const struct device *hwdev;
+	const struct resource *region;
+
+	res = platform_get_resource(pdev, IORESOURCE_IO, 0);
+	if (IS_ERR(res))
+		return dev_err_probe(dev, PTR_ERR(res),
+				     "Failed to get platform resource\n");
+
+	region = devm_request_region(dev, res->start,
+				     resource_size(res), DRIVER_NAME);
+	if (IS_ERR(region))
+		return dev_err_probe(dev, PTR_ERR(region),
+				     "Failed to request region\n");
+
+	hwdev = devm_hwmon_device_register_with_info(dev,
+						     DRIVER_NAME,
+						     NULL,
+						     &gpd_fan_chip_info,
+						     NULL);
+	if (IS_ERR(hwdev))
+		return dev_err_probe(dev, PTR_ERR(region),
+				     "Failed to register hwmon device\n");
+
+#ifdef OUT_OF_TREE
+	struct dentry *debug_fs_entry = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (!IS_ERR(debug_fs_entry)) {
+		DEBUG_FS_ENTRY = debug_fs_entry;
+		debugfs_create_file_size("manual_control_reg",
+					 S_IRUSR | S_IWUSR, DEBUG_FS_ENTRY,
+					 NULL, &debugfs_manual_control_fops,
+					 sizeof(u8));
+		debugfs_create_file_size("pwm_reg", S_IRUSR | S_IWUSR,
+					 DEBUG_FS_ENTRY, NULL,
+					 &debugfs_pwm_fops, sizeof(u8));
+	}
+
+	pr_info("GPD Devices fan driver probed\n");
+#endif
+
+	return 0;
+}
+
+#ifdef OUT_OF_TREE
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int gpd_fan_remove(__always_unused struct platform_device *pdev)
+#else
+static void gpd_fan_remove(__always_unused struct platform_device *pdev)
+#endif
+#else
+static void gpd_fan_remove(__always_unused struct platform_device *pdev)
+#endif
+{
+	gpd_driver_priv.pwm_enable = AUTOMATIC;
+	gpd_set_pwm_enable(AUTOMATIC);
+#ifdef OUT_OF_TREE
+
+	if (!IS_ERR_OR_NULL(DEBUG_FS_ENTRY)) {
+		debugfs_remove_recursive(DEBUG_FS_ENTRY);
+		DEBUG_FS_ENTRY = NULL;
+	}
+
+	pr_info("GPD Devices fan driver removed\n");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+
+#endif
+}
+
+static struct platform_driver gpd_fan_driver = {
+	.probe = gpd_fan_probe,
+	.remove = gpd_fan_remove,
+	.driver = {
+		.name = KBUILD_MODNAME,
+	},
+};
+
+static struct platform_device *gpd_fan_platform_device;
+
+static int __init gpd_fan_init(void)
+{
+	const struct gpd_fan_drvdata *match = NULL;
+
+	for (const struct gpd_fan_drvdata **p = gpd_module_drvdata; *p; p++) {
+		if (strcmp(gpd_fan_board, (*p)->board_name) == 0) {
+			match = *p;
+			break;
+		}
+	}
+
+	if (!match) {
+		const struct dmi_system_id *dmi_match =
+			dmi_first_match(dmi_table);
+		if (dmi_match)
+			match = dmi_match->driver_data;
+	}
+
+#ifdef OUT_OF_TREE
+	if (!match) {
+		pr_err("GPD Devices not supported\n");
+		return -ENODEV;
+	} else {
+		pr_info("Loading GPD fan model quirk: %s\n", match->board_name);
+	}
+#else
+	if (!match)
+		return -ENODEV;
+#endif
+
+	gpd_driver_priv.pwm_enable = AUTOMATIC;
+	gpd_driver_priv.pwm_value = 255;
+	gpd_driver_priv.drvdata = match;
+
+#ifdef OUT_OF_TREE
+	gpd_driver_priv.read_pwm_cached = 0;
+	gpd_driver_priv.read_rpm_cached = 0;
+	gpd_driver_priv.update_interval_per_second = 1;
+	gpd_driver_priv.read_pwm_last_update = jiffies;
+	gpd_driver_priv.read_rpm_last_update = jiffies;
+#endif
+
+	struct resource gpd_fan_resources[] = {
+		{
+			.start = match->addr_port,
+			.end = match->data_port,
+			.flags = IORESOURCE_IO,
+		},
+	};
+
+	gpd_fan_platform_device = platform_create_bundle(&gpd_fan_driver,
+							 gpd_fan_probe,
+							 gpd_fan_resources,
+							 1, NULL, 0);
+
+	if (IS_ERR(gpd_fan_platform_device)) {
+		pr_warn("Failed to create platform device\n");
+		return PTR_ERR(gpd_fan_platform_device);
+	}
+
+#ifdef OUT_OF_TREE
+	pr_info("GPD Devices fan driver loaded\n");
+#endif
+
+	return 0;
+}
+
+static void __exit gpd_fan_exit(void)
+{
+	platform_device_unregister(gpd_fan_platform_device);
+	platform_driver_unregister(&gpd_fan_driver);
+#ifdef OUT_OF_TREE
+	pr_info("GPD Devices fan driver unloaded\n");
+#endif
+}
+
+MODULE_DEVICE_TABLE(dmi, dmi_table);
+
+module_init(gpd_fan_init);
+module_exit(gpd_fan_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cryolitia PukNgae <Cryolitia@gmail.com>");
+MODULE_DESCRIPTION("GPD Devices fan control driver");
# ----------------------------------------
# Module: lg4ff
# Version: v0.5.0
# ----------------------------------------
diff --git a/drivers/custom/lg4ff/Kbuild b/drivers/custom/lg4ff/Kbuild
new file mode 100644
index 000000000000..673c45615fa7
--- /dev/null
+++ b/drivers/custom/lg4ff/Kbuild
@@ -0,0 +1,6 @@
+obj-m := hid-logitech-new.o
+hid-logitech-new-y := hid-lg.o hid-lg4ff.o
+hid-logitech-new-$(CONFIG_LOGITECH_FF)      += hid-lgff.o
+hid-logitech-new-$(CONFIG_LOGIRUMBLEPAD2_FF)        += hid-lg2ff.o
+hid-logitech-new-$(CONFIG_LOGIG940_FF)      += hid-lg3ff.o
+ccflags-y := -Idrivers/hid
diff --git a/drivers/custom/lg4ff/Makefile b/drivers/custom/lg4ff/Makefile
new file mode 100644
index 000000000000..c97e309b3a91
--- /dev/null
+++ b/drivers/custom/lg4ff/Makefile
@@ -0,0 +1,27 @@
+KVERSION := `uname -r`
+KDIR := /lib/modules/${KVERSION}/build
+
+default:
+	$(MAKE) -C $(KDIR) M=$$PWD
+
+install: default
+	$(MAKE) -C $(KDIR) M=$$PWD modules_install
+	depmod -A
+
+remove:
+	rmmod hid-logitech 2> /dev/null || true
+	rmmod hid-logitech-new 2> /dev/null || true
+
+load: install remove
+	modprobe hid-logitech-new ${OPTIONS}
+
+load_debug: install remove
+	modprobe hid-logitech-new dyndbg=+p ${OPTIONS}
+
+unload:
+	rmmod hid-logitech-new
+	modprobe hid-logitech
+
+clean:
+	$(MAKE) -C $(KDIR) M=$$PWD clean
+
diff --git a/drivers/custom/lg4ff/hid-ids.h b/drivers/custom/lg4ff/hid-ids.h
new file mode 100644
index 000000000000..45071de0d3dd
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-ids.h
@@ -0,0 +1,1433 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ *  USB HID quirks support for Linux
+ *
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
+ *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
+ *  Copyright (c) 2006-2007 Jiri Kosina
+ */
+
+/*
+ */
+
+#ifndef HID_IDS_H_FILE
+#define HID_IDS_H_FILE
+
+#define USB_VENDOR_ID_258A		0x258a
+#define USB_DEVICE_ID_258A_6A88		0x6a88
+
+#define USB_VENDOR_ID_3M		0x0596
+#define USB_DEVICE_ID_3M1968		0x0500
+#define USB_DEVICE_ID_3M2256		0x0502
+#define USB_DEVICE_ID_3M3266		0x0506
+
+#define USB_VENDOR_ID_A4TECH		0x09da
+#define USB_DEVICE_ID_A4TECH_WCP32PU	0x0006
+#define USB_DEVICE_ID_A4TECH_X5_005D	0x000a
+#define USB_DEVICE_ID_A4TECH_RP_649	0x001a
+#define USB_DEVICE_ID_A4TECH_NB_95	0x022b
+
+#define USB_VENDOR_ID_AASHIMA		0x06d6
+#define USB_DEVICE_ID_AASHIMA_GAMEPAD	0x0025
+#define USB_DEVICE_ID_AASHIMA_PREDATOR	0x0026
+
+#define USB_VENDOR_ID_ACECAD		0x0460
+#define USB_DEVICE_ID_ACECAD_FLAIR	0x0004
+#define USB_DEVICE_ID_ACECAD_302	0x0008
+
+#define USB_VENDOR_ID_ACRUX		0x1a34
+
+#define USB_VENDOR_ID_ACTIONSTAR	0x2101
+#define USB_DEVICE_ID_ACTIONSTAR_1011	0x1011
+
+#define USB_VENDOR_ID_ADS_TECH		0x06e1
+#define USB_DEVICE_ID_ADS_TECH_RADIO_SI470X	0xa155
+
+#define USB_VENDOR_ID_AFATECH		0x15a4
+#define USB_DEVICE_ID_AFATECH_AF9016	0x9016
+
+#define USB_VENDOR_ID_AIPTEK		0x08ca
+#define USB_DEVICE_ID_AIPTEK_01		0x0001
+#define USB_DEVICE_ID_AIPTEK_10		0x0010
+#define USB_DEVICE_ID_AIPTEK_20		0x0020
+#define USB_DEVICE_ID_AIPTEK_21		0x0021
+#define USB_DEVICE_ID_AIPTEK_22		0x0022
+#define USB_DEVICE_ID_AIPTEK_23		0x0023
+#define USB_DEVICE_ID_AIPTEK_24		0x0024
+
+#define USB_VENDOR_ID_AIRCABLE		0x16CA
+#define USB_DEVICE_ID_AIRCABLE1		0x1502
+
+#define USB_VENDOR_ID_AIREN		0x1a2c
+#define USB_DEVICE_ID_AIREN_SLIMPLUS	0x0002
+
+#define USB_VENDOR_ID_AKAI		0x2011
+#define USB_DEVICE_ID_AKAI_MPKMINI2	0x0715
+
+#define USB_VENDOR_ID_AKAI_09E8		0x09E8
+#define USB_DEVICE_ID_AKAI_09E8_MIDIMIX	0x0031
+
+#define USB_VENDOR_ID_ALCOR		0x058f
+#define USB_DEVICE_ID_ALCOR_USBRS232	0x9720
+#define USB_DEVICE_ID_ALCOR_MALTRON_KB 0x9410
+
+#define USB_VENDOR_ID_ALPS		0x0433
+#define USB_DEVICE_ID_IBM_GAMEPAD	0x1101
+
+#define USB_VENDOR_ID_ALPS_JP		0x044E
+#define HID_DEVICE_ID_ALPS_U1_DUAL	0x120B
+#define HID_DEVICE_ID_ALPS_U1		0x1215
+#define HID_DEVICE_ID_ALPS_U1_UNICORN_LEGACY         0x121E
+#define HID_DEVICE_ID_ALPS_T4_BTNLESS	0x120C
+
+#define USB_VENDOR_ID_AMI		0x046b
+#define USB_DEVICE_ID_AMI_VIRT_KEYBOARD_AND_MOUSE	0xff10
+
+#define USB_VENDOR_ID_ANTON		0x1130
+#define USB_DEVICE_ID_ANTON_TOUCH_PAD	0x3101
+
+#define USB_VENDOR_ID_APPLE		0x05ac
+#define BT_VENDOR_ID_APPLE		0x004c
+#define USB_DEVICE_ID_APPLE_MIGHTYMOUSE	0x0304
+#define USB_DEVICE_ID_APPLE_MAGICMOUSE	0x030d
+#define USB_DEVICE_ID_APPLE_MAGICMOUSE2	0x0269
+#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD	0x030e
+#define USB_DEVICE_ID_APPLE_MAGICTRACKPAD2	0x0265
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI	0x020e
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_ISO	0x020f
+#define USB_DEVICE_ID_APPLE_GEYSER_ANSI	0x0214
+#define USB_DEVICE_ID_APPLE_GEYSER_ISO	0x0215
+#define USB_DEVICE_ID_APPLE_GEYSER_JIS	0x0216
+#define USB_DEVICE_ID_APPLE_GEYSER3_ANSI	0x0217
+#define USB_DEVICE_ID_APPLE_GEYSER3_ISO	0x0218
+#define USB_DEVICE_ID_APPLE_GEYSER3_JIS	0x0219
+#define USB_DEVICE_ID_APPLE_GEYSER4_ANSI	0x021a
+#define USB_DEVICE_ID_APPLE_GEYSER4_ISO	0x021b
+#define USB_DEVICE_ID_APPLE_GEYSER4_JIS	0x021c
+#define USB_DEVICE_ID_APPLE_ALU_MINI_ANSI	0x021d
+#define USB_DEVICE_ID_APPLE_ALU_MINI_ISO	0x021e
+#define USB_DEVICE_ID_APPLE_ALU_MINI_JIS	0x021f
+#define USB_DEVICE_ID_APPLE_ALU_ANSI	0x0220
+#define USB_DEVICE_ID_APPLE_ALU_ISO	0x0221
+#define USB_DEVICE_ID_APPLE_ALU_JIS	0x0222
+#define USB_DEVICE_ID_APPLE_WELLSPRING_ANSI	0x0223
+#define USB_DEVICE_ID_APPLE_WELLSPRING_ISO	0x0224
+#define USB_DEVICE_ID_APPLE_WELLSPRING_JIS	0x0225
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ANSI	0x0229
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_ISO	0x022a
+#define USB_DEVICE_ID_APPLE_GEYSER4_HF_JIS	0x022b
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ANSI	0x022c
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_ISO	0x022d
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_JIS	0x022e
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_ANSI	0x0230
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_ISO	0x0231
+#define USB_DEVICE_ID_APPLE_WELLSPRING2_JIS	0x0232
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_ANSI	0x0236
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_ISO	0x0237
+#define USB_DEVICE_ID_APPLE_WELLSPRING3_JIS	0x0238
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_ANSI	0x023f
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_ISO	0x0240
+#define USB_DEVICE_ID_APPLE_WELLSPRING4_JIS	0x0241
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ANSI	0x0242
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_ISO	0x0243
+#define USB_DEVICE_ID_APPLE_WELLSPRING4A_JIS	0x0244
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_ANSI	0x0245
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_ISO	0x0246
+#define USB_DEVICE_ID_APPLE_WELLSPRING5_JIS	0x0247
+#define USB_DEVICE_ID_APPLE_ALU_REVB_ANSI	0x024f
+#define USB_DEVICE_ID_APPLE_ALU_REVB_ISO	0x0250
+#define USB_DEVICE_ID_APPLE_ALU_REVB_JIS	0x0251
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ANSI	0x0252
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_ISO	0x0253
+#define USB_DEVICE_ID_APPLE_WELLSPRING5A_JIS	0x0254
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ANSI	0x0259
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_ISO	0x025a
+#define USB_DEVICE_ID_APPLE_WELLSPRING7A_JIS	0x025b
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ANSI	0x0249
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_ISO	0x024a
+#define USB_DEVICE_ID_APPLE_WELLSPRING6A_JIS	0x024b
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_ANSI	0x024c
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_ISO	0x024d
+#define USB_DEVICE_ID_APPLE_WELLSPRING6_JIS	0x024e
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_ANSI	0x0262
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_ISO	0x0263
+#define USB_DEVICE_ID_APPLE_WELLSPRING7_JIS	0x0264
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ANSI  0x0239
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_ISO   0x023a
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2009_JIS   0x023b
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ANSI  0x0255
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_ISO   0x0256
+#define USB_DEVICE_ID_APPLE_ALU_WIRELESS_2011_JIS   0x0257
+#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_2015   0x0267
+#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_2015   0x026c
+#define USB_DEVICE_ID_APPLE_WELLSPRING8_ANSI	0x0290
+#define USB_DEVICE_ID_APPLE_WELLSPRING8_ISO	0x0291
+#define USB_DEVICE_ID_APPLE_WELLSPRING8_JIS	0x0292
+#define USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI	0x0272
+#define USB_DEVICE_ID_APPLE_WELLSPRING9_ISO		0x0273
+#define USB_DEVICE_ID_APPLE_WELLSPRING9_JIS		0x0274
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J140K	0x027a
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J132	0x027b
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J680	0x027c
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J213	0x027d
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J214K	0x027e
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J223	0x027f
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J230K	0x0280
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J152F	0x0340
+#define USB_DEVICE_ID_APPLE_FOUNTAIN_TP_ONLY	0x030a
+#define USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY	0x030b
+#define USB_DEVICE_ID_APPLE_IRCONTROL	0x8240
+#define USB_DEVICE_ID_APPLE_IRCONTROL2	0x1440
+#define USB_DEVICE_ID_APPLE_IRCONTROL3	0x8241
+#define USB_DEVICE_ID_APPLE_IRCONTROL4	0x8242
+#define USB_DEVICE_ID_APPLE_IRCONTROL5	0x8243
+#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_2021   0x029c
+#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_FINGERPRINT_2021   0x029a
+#define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_2021   0x029f
+#define USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT 0x8102
+#define USB_DEVICE_ID_APPLE_TOUCHBAR_DISPLAY 0x8302
+
+#define USB_VENDOR_ID_ASUS		0x0486
+#define USB_DEVICE_ID_ASUS_T91MT	0x0185
+#define USB_DEVICE_ID_ASUSTEK_MULTITOUCH_YFO	0x0186
+
+#define USB_VENDOR_ID_ASUSTEK		0x0b05
+#define USB_DEVICE_ID_ASUSTEK_LCM	0x1726
+#define USB_DEVICE_ID_ASUSTEK_LCM2	0x175b
+#define USB_DEVICE_ID_ASUSTEK_T100TA_KEYBOARD	0x17e0
+#define USB_DEVICE_ID_ASUSTEK_T100TAF_KEYBOARD	0x1807
+#define USB_DEVICE_ID_ASUSTEK_T100CHI_KEYBOARD	0x8502
+#define USB_DEVICE_ID_ASUSTEK_T101HA_KEYBOARD	0x183d
+#define USB_DEVICE_ID_ASUSTEK_T304_KEYBOARD	0x184a
+#define USB_DEVICE_ID_ASUSTEK_I2C_KEYBOARD	0x8585
+#define USB_DEVICE_ID_ASUSTEK_I2C_TOUCHPAD	0x0101
+#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD1 0x1854
+#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD2 0x1837
+#define USB_DEVICE_ID_ASUSTEK_ROG_KEYBOARD3 0x1822
+#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD	0x1866
+#define USB_DEVICE_ID_ASUSTEK_ROG_NKEY_KEYBOARD2	0x19b6
+#define USB_DEVICE_ID_ASUSTEK_ROG_CLAYMORE_II_KEYBOARD	0x196b
+#define USB_DEVICE_ID_ASUSTEK_FX503VD_KEYBOARD	0x1869
+
+#define USB_VENDOR_ID_ATEN		0x0557
+#define USB_DEVICE_ID_ATEN_UC100KM	0x2004
+#define USB_DEVICE_ID_ATEN_CS124U	0x2202
+#define USB_DEVICE_ID_ATEN_2PORTKVM	0x2204
+#define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
+#define USB_DEVICE_ID_ATEN_4PORTKVMC	0x2208
+#define USB_DEVICE_ID_ATEN_CS682	0x2213
+#define USB_DEVICE_ID_ATEN_CS692	0x8021
+#define USB_DEVICE_ID_ATEN_CS1758	0x2220
+
+#define USB_VENDOR_ID_ATMEL		0x03eb
+#define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
+#define USB_DEVICE_ID_ATMEL_MXT_DIGITIZER	0x2118
+#define USB_VENDOR_ID_ATMEL_V_USB	0x16c0
+#define USB_DEVICE_ID_ATMEL_V_USB	0x05df
+
+#define USB_VENDOR_ID_AUREAL		0x0755
+#define USB_DEVICE_ID_AUREAL_W01RN	0x2626
+
+#define USB_VENDOR_ID_AVERMEDIA		0x07ca
+#define USB_DEVICE_ID_AVER_FM_MR800	0xb800
+
+#define USB_VENDOR_ID_AXENTIA		0x12cf
+#define USB_DEVICE_ID_AXENTIA_FM_RADIO	0x7111
+
+#define USB_VENDOR_ID_BAANTO		0x2453
+#define USB_DEVICE_ID_BAANTO_MT_190W2	0x0100
+
+#define USB_VENDOR_ID_BELKIN		0x050d
+#define USB_DEVICE_ID_FLIP_KVM		0x3201
+
+#define USB_VENDOR_ID_BERKSHIRE		0x0c98
+#define USB_DEVICE_ID_BERKSHIRE_PCWD	0x1140
+
+#define USB_VENDOR_ID_BETOP_2185BFM	0x11c2
+#define USB_VENDOR_ID_BETOP_2185PC	0x11c0
+#define USB_VENDOR_ID_BETOP_2185V2PC	0x8380
+#define USB_VENDOR_ID_BETOP_2185V2BFM	0x20bc
+
+#define USB_VENDOR_ID_BIGBEN	0x146b
+#define USB_DEVICE_ID_BIGBEN_PS3OFMINIPAD	0x0902
+
+#define USB_VENDOR_ID_BTC		0x046e
+#define USB_DEVICE_ID_BTC_EMPREX_REMOTE	0x5578
+#define USB_DEVICE_ID_BTC_EMPREX_REMOTE_2	0x5577
+
+#define USB_VENDOR_ID_CANDO		0x2087
+#define USB_DEVICE_ID_CANDO_PIXCIR_MULTI_TOUCH 0x0703
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH	0x0a01
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_10_1 0x0a02
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_11_6 0x0b03
+#define USB_DEVICE_ID_CANDO_MULTI_TOUCH_15_6 0x0f01
+
+#define USB_VENDOR_ID_CH		0x068e
+#define USB_DEVICE_ID_CH_PRO_THROTTLE	0x00f1
+#define USB_DEVICE_ID_CH_PRO_PEDALS	0x00f2
+#define USB_DEVICE_ID_CH_FIGHTERSTICK	0x00f3
+#define USB_DEVICE_ID_CH_COMBATSTICK	0x00f4
+#define USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE       0x0051
+#define USB_DEVICE_ID_CH_FLIGHT_SIM_YOKE	0x00ff
+#define USB_DEVICE_ID_CH_3AXIS_5BUTTON_STICK	0x00d3
+#define USB_DEVICE_ID_CH_AXIS_295	0x001c
+
+#define USB_VENDOR_ID_CHERRY		0x046a
+#define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
+#define USB_DEVICE_ID_CHERRY_CYMOTION_SOLAR	0x0027
+
+#define USB_VENDOR_ID_CHIC		0x05fe
+#define USB_DEVICE_ID_CHIC_GAMEPAD	0x0014
+
+#define USB_VENDOR_ID_CHICONY		0x04f2
+#define USB_DEVICE_ID_CHICONY_TACTICAL_PAD	0x0418
+#define USB_DEVICE_ID_CHICONY_MULTI_TOUCH	0xb19d
+#define USB_DEVICE_ID_CHICONY_WIRELESS	0x0618
+#define USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE	0x1053
+#define USB_DEVICE_ID_CHICONY_PIXART_USB_OPTICAL_MOUSE2	0x0939
+#define USB_DEVICE_ID_CHICONY_WIRELESS2	0x1123
+#define USB_DEVICE_ID_CHICONY_WIRELESS3	0x1236
+#define USB_DEVICE_ID_ASUS_AK1D		0x1125
+#define USB_DEVICE_ID_CHICONY_TOSHIBA_WT10A	0x1408
+#define USB_DEVICE_ID_CHICONY_ACER_SWITCH12	0x1421
+
+#define USB_VENDOR_ID_CHUNGHWAT		0x2247
+#define USB_DEVICE_ID_CHUNGHWAT_MULTITOUCH	0x0001
+
+#define USB_VENDOR_ID_CIDC		0x1677
+
+#define USB_VENDOR_ID_CJTOUCH		0x24b8
+#define USB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0020	0x0020
+#define USB_DEVICE_ID_CJTOUCH_MULTI_TOUCH_0040	0x0040
+
+#define USB_VENDOR_ID_CLAY_LOGIC	0x20a0
+#define USB_DEVICE_ID_NITROKEY_U2F	0x4287
+
+#define USB_VENDOR_ID_CMEDIA		0x0d8c
+#define USB_DEVICE_ID_CM109		0x000e
+#define USB_DEVICE_ID_CMEDIA_HS100B	0x0014
+#define USB_DEVICE_ID_CM6533		0x0022
+
+#define USB_VENDOR_ID_CODEMERCS		0x07c0
+#define USB_DEVICE_ID_CODEMERCS_IOW_FIRST	0x1500
+#define USB_DEVICE_ID_CODEMERCS_IOW_LAST	0x15ff
+
+#define USB_VENDOR_ID_CORSAIR		0x1b1c
+#define USB_DEVICE_ID_CORSAIR_K90	0x1b02
+#define USB_DEVICE_ID_CORSAIR_K70R      0x1b09
+#define USB_DEVICE_ID_CORSAIR_K95RGB    0x1b11
+#define USB_DEVICE_ID_CORSAIR_M65RGB    0x1b12
+#define USB_DEVICE_ID_CORSAIR_K70RGB    0x1b13
+#define USB_DEVICE_ID_CORSAIR_STRAFE    0x1b15
+#define USB_DEVICE_ID_CORSAIR_K65RGB    0x1b17
+#define USB_DEVICE_ID_CORSAIR_GLAIVE_RGB        0x1b34
+#define USB_DEVICE_ID_CORSAIR_K70RGB_RAPIDFIRE  0x1b38
+#define USB_DEVICE_ID_CORSAIR_K65RGB_RAPIDFIRE  0x1b39
+#define USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB  0x1b3e
+
+#define USB_VENDOR_ID_CREATIVELABS	0x041e
+#define USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51	0x322c
+#define USB_DEVICE_ID_PRODIKEYS_PCMIDI	0x2801
+#define USB_DEVICE_ID_CREATIVE_SB0540	0x3100
+
+#define USB_VENDOR_ID_CVTOUCH		0x1ff7
+#define USB_DEVICE_ID_CVTOUCH_SCREEN	0x0013
+
+#define USB_VENDOR_ID_CYGNAL		0x10c4
+#define USB_DEVICE_ID_CYGNAL_RADIO_SI470X	0x818a
+#define USB_DEVICE_ID_FOCALTECH_FTXXXX_MULTITOUCH	0x81b9
+#define USB_DEVICE_ID_CYGNAL_CP2112	0xea90
+#define USB_DEVICE_ID_U2F_ZERO		0x8acf
+
+#define USB_DEVICE_ID_CYGNAL_RADIO_SI4713       0x8244
+
+#define USB_VENDOR_ID_CYPRESS		0x04b4
+#define USB_DEVICE_ID_CYPRESS_MOUSE	0x0001
+#define USB_DEVICE_ID_CYPRESS_HIDCOM	0x5500
+#define USB_DEVICE_ID_CYPRESS_ULTRAMOUSE	0x7417
+#define USB_DEVICE_ID_CYPRESS_BARCODE_1	0xde61
+#define USB_DEVICE_ID_CYPRESS_BARCODE_2	0xde64
+#define USB_DEVICE_ID_CYPRESS_BARCODE_3	0xbca1
+#define USB_DEVICE_ID_CYPRESS_BARCODE_4	0xed81
+#define USB_DEVICE_ID_CYPRESS_TRUETOUCH	0xc001
+
+#define USB_DEVICE_ID_CYPRESS_VARMILO_VA104M_07B1   0X07b1
+
+#define USB_VENDOR_ID_DATA_MODUL	0x7374
+#define USB_VENDOR_ID_DATA_MODUL_EASYMAXTOUCH	0x1201
+
+#define USB_VENDOR_ID_DEALEXTREAME	0x10c5
+#define USB_DEVICE_ID_DEALEXTREAME_RADIO_SI4701	0x819a
+
+#define USB_VENDOR_ID_DELCOM		0x0fc5
+#define USB_DEVICE_ID_DELCOM_VISUAL_IND	0xb080
+
+#define USB_VENDOR_ID_DELL				0x413c
+#define USB_DEVICE_ID_DELL_PIXART_USB_OPTICAL_MOUSE	0x301a
+
+#define USB_VENDOR_ID_DELORME		0x1163
+#define USB_DEVICE_ID_DELORME_EARTHMATE	0x0100
+#define USB_DEVICE_ID_DELORME_EM_LT20	0x0200
+
+#define USB_VENDOR_ID_DMI		0x0c0b
+#define USB_DEVICE_ID_DMI_ENC		0x5fab
+
+#define USB_VENDOR_ID_DRAGONRISE		0x0079
+#define USB_DEVICE_ID_REDRAGON_SEYMUR2		0x0006
+#define USB_DEVICE_ID_DRAGONRISE_WIIU		0x1800
+#define USB_DEVICE_ID_DRAGONRISE_PS3		0x1801
+#define USB_DEVICE_ID_DRAGONRISE_DOLPHINBAR	0x1803
+#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE1	0x1843
+#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE2	0x1844
+#define USB_DEVICE_ID_DRAGONRISE_GAMECUBE3	0x1846
+
+#define USB_VENDOR_ID_DWAV		0x0eef
+#define USB_DEVICE_ID_EGALAX_TOUCHCONTROLLER	0x0001
+#define USB_DEVICE_ID_DWAV_TOUCHCONTROLLER	0x0002
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480D	0x480d
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_480E	0x480e
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7207	0x7207
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_720C	0x720c
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7224	0x7224
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_722A	0x722A
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_725E	0x725e
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7262	0x7262
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_726B	0x726b
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72A1	0x72a1
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72AA	0x72aa
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72C4	0x72c4
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72D0	0x72d0
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_72FA	0x72fa
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7302	0x7302
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_7349	0x7349
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_73F7	0x73f7
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_A001	0xa001
+#define USB_DEVICE_ID_DWAV_EGALAX_MULTITOUCH_C002	0xc002
+
+#define USB_VENDOR_ID_ELAN		0x04f3
+#define USB_DEVICE_ID_TOSHIBA_CLICK_L9W	0x0401
+#define USB_DEVICE_ID_HP_X2		0x074d
+#define USB_DEVICE_ID_HP_X2_10_COVER	0x0755
+#define I2C_DEVICE_ID_HP_ENVY_X360_15	0x2d05
+#define I2C_DEVICE_ID_HP_ENVY_X360_15T_DR100	0x29CF
+#define I2C_DEVICE_ID_HP_ENVY_X360_EU0009NV	0x2CF9
+#define I2C_DEVICE_ID_HP_SPECTRE_X360_15	0x2817
+#define I2C_DEVICE_ID_HP_SPECTRE_X360_13_AW0020NG  0x29DF
+#define I2C_DEVICE_ID_ASUS_TP420IA_TOUCHSCREEN 0x2BC8
+#define USB_DEVICE_ID_ASUS_UX550VE_TOUCHSCREEN	0x2544
+#define USB_DEVICE_ID_ASUS_UX550_TOUCHSCREEN	0x2706
+#define I2C_DEVICE_ID_SURFACE_GO_TOUCHSCREEN	0x261A
+#define I2C_DEVICE_ID_SURFACE_GO2_TOUCHSCREEN	0x2A1C
+#define I2C_DEVICE_ID_LENOVO_YOGA_C630_TOUCHSCREEN	0x279F
+
+#define USB_VENDOR_ID_ELECOM		0x056e
+#define USB_DEVICE_ID_ELECOM_BM084	0x0061
+#define USB_DEVICE_ID_ELECOM_M_XGL20DLBK	0x00e6
+#define USB_DEVICE_ID_ELECOM_M_XT3URBK	0x00fb
+#define USB_DEVICE_ID_ELECOM_M_XT3DRBK	0x00fc
+#define USB_DEVICE_ID_ELECOM_M_XT4DRBK	0x00fd
+#define USB_DEVICE_ID_ELECOM_M_DT1URBK	0x00fe
+#define USB_DEVICE_ID_ELECOM_M_DT1DRBK	0x00ff
+#define USB_DEVICE_ID_ELECOM_M_HT1URBK	0x010c
+#define USB_DEVICE_ID_ELECOM_M_HT1DRBK_010D	0x010d
+#define USB_DEVICE_ID_ELECOM_M_HT1DRBK_011C	0x011c
+
+#define USB_VENDOR_ID_DREAM_CHEEKY	0x1d34
+#define USB_DEVICE_ID_DREAM_CHEEKY_WN	0x0004
+#define USB_DEVICE_ID_DREAM_CHEEKY_FA	0x000a
+
+#define USB_VENDOR_ID_ELITEGROUP	0x03fc
+#define USB_DEVICE_ID_ELITEGROUP_05D8	0x05d8
+
+#define USB_VENDOR_ID_ELO		0x04E7
+#define USB_DEVICE_ID_ELO_TS2515	0x0022
+#define USB_DEVICE_ID_ELO_TS2700	0x0020
+#define USB_DEVICE_ID_ELO_ACCUTOUCH_2216	0x0050
+
+#define USB_VENDOR_ID_EMS		0x2006
+#define USB_DEVICE_ID_EMS_TRIO_LINKER_PLUS_II 0x0118
+
+#define USB_VENDOR_ID_EVISION           0x320f
+#define USB_DEVICE_ID_EVISION_ICL01     0x5041
+
+#define USB_VENDOR_ID_FLATFROG		0x25b5
+#define USB_DEVICE_ID_MULTITOUCH_3200	0x0002
+
+#define USB_VENDOR_ID_FUTABA            0x0547
+#define USB_DEVICE_ID_LED_DISPLAY       0x7000
+
+#define USB_VENDOR_ID_FUTURE_TECHNOLOGY	0x0403
+#define USB_DEVICE_ID_RETRODE2		0x97c1
+#define USB_DEVICE_ID_FT260             0x6030
+
+#define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
+#define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
+
+#define USB_VENDOR_ID_ETT		0x0664
+#define USB_DEVICE_ID_TC5UH		0x0309
+#define USB_DEVICE_ID_TC4UM		0x0306
+
+#define USB_VENDOR_ID_ETURBOTOUCH	0x22b9
+#define USB_DEVICE_ID_ETURBOTOUCH	0x0006
+#define USB_DEVICE_ID_ETURBOTOUCH_2968	0x2968
+
+#define USB_VENDOR_ID_EZKEY		0x0518
+#define USB_DEVICE_ID_BTC_8193		0x0002
+
+#define USB_VENDOR_ID_FORMOSA          0x147a
+#define USB_DEVICE_ID_FORMOSA_IR_RECEIVER      0xe03e
+
+#define USB_VENDOR_ID_FREESCALE		0x15A2
+#define USB_DEVICE_ID_FREESCALE_MX28	0x004F
+
+#define USB_VENDOR_ID_FRUCTEL	0x25B6
+#define USB_DEVICE_ID_GAMETEL_MT_MODE	0x0002
+
+#define USB_VENDOR_ID_GAMEVICE	0x27F8
+#define USB_DEVICE_ID_GAMEVICE_GV186	0x0BBE
+#define USB_DEVICE_ID_GAMEVICE_KISHI	0x0BBF
+
+#define USB_VENDOR_ID_GAMERON		0x0810
+#define USB_DEVICE_ID_GAMERON_DUAL_PSX_ADAPTOR	0x0001
+#define USB_DEVICE_ID_GAMERON_DUAL_PCS_ADAPTOR	0x0002
+
+#define USB_VENDOR_ID_GEMBIRD			0x11ff
+#define USB_DEVICE_ID_GEMBIRD_JPD_DUALFORCE2	0x3331
+
+#define USB_VENDOR_ID_GENERAL_TOUCH	0x0dfc
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN7_TWOFINGERS 0x0003
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PWT_TENFINGERS 0x0100
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0101 0x0101
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0102 0x0102
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_0106 0x0106
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_010A 0x010a
+#define USB_DEVICE_ID_GENERAL_TOUCH_WIN8_PIT_E100 0xe100
+
+#define USB_VENDOR_ID_GLORIOUS  0x258a
+#define USB_DEVICE_ID_GLORIOUS_MODEL_D 0x0033
+#define USB_DEVICE_ID_GLORIOUS_MODEL_O 0x0036
+
+#define I2C_VENDOR_ID_GOODIX		0x27c6
+#define I2C_DEVICE_ID_GOODIX_01F0	0x01f0
+
+#define USB_VENDOR_ID_GOODTOUCH		0x1aad
+#define USB_DEVICE_ID_GOODTOUCH_000f	0x000f
+
+#define USB_VENDOR_ID_GOOGLE		0x18d1
+#define USB_DEVICE_ID_GOOGLE_HAMMER	0x5022
+#define USB_DEVICE_ID_GOOGLE_TOUCH_ROSE	0x5028
+#define USB_DEVICE_ID_GOOGLE_STAFF	0x502b
+#define USB_DEVICE_ID_GOOGLE_WAND	0x502d
+#define USB_DEVICE_ID_GOOGLE_WHISKERS	0x5030
+#define USB_DEVICE_ID_GOOGLE_MASTERBALL	0x503c
+#define USB_DEVICE_ID_GOOGLE_MAGNEMITE	0x503d
+#define USB_DEVICE_ID_GOOGLE_MOONBALL	0x5044
+#define USB_DEVICE_ID_GOOGLE_DON	0x5050
+#define USB_DEVICE_ID_GOOGLE_EEL	0x5057
+
+#define USB_VENDOR_ID_GOTOP		0x08f2
+#define USB_DEVICE_ID_SUPER_Q2		0x007f
+#define USB_DEVICE_ID_GOGOPEN		0x00ce
+#define USB_DEVICE_ID_PENPOWER		0x00f4
+
+#define USB_VENDOR_ID_GREENASIA		0x0e8f
+#define USB_DEVICE_ID_GREENASIA_DUAL_SAT_ADAPTOR 0x3010
+#define USB_DEVICE_ID_GREENASIA_DUAL_USB_JOYPAD	0x3013
+
+#define USB_VENDOR_ID_GRETAGMACBETH	0x0971
+#define USB_DEVICE_ID_GRETAGMACBETH_HUEY	0x2005
+
+#define USB_VENDOR_ID_GRIFFIN		0x077d
+#define USB_DEVICE_ID_POWERMATE		0x0410
+#define USB_DEVICE_ID_SOUNDKNOB		0x04AA
+#define USB_DEVICE_ID_RADIOSHARK	0x627a
+
+#define USB_VENDOR_ID_GTCO		0x078c
+#define USB_DEVICE_ID_GTCO_90		0x0090
+#define USB_DEVICE_ID_GTCO_100		0x0100
+#define USB_DEVICE_ID_GTCO_101		0x0101
+#define USB_DEVICE_ID_GTCO_103		0x0103
+#define USB_DEVICE_ID_GTCO_104		0x0104
+#define USB_DEVICE_ID_GTCO_105		0x0105
+#define USB_DEVICE_ID_GTCO_106		0x0106
+#define USB_DEVICE_ID_GTCO_107		0x0107
+#define USB_DEVICE_ID_GTCO_108		0x0108
+#define USB_DEVICE_ID_GTCO_200		0x0200
+#define USB_DEVICE_ID_GTCO_201		0x0201
+#define USB_DEVICE_ID_GTCO_202		0x0202
+#define USB_DEVICE_ID_GTCO_203		0x0203
+#define USB_DEVICE_ID_GTCO_204		0x0204
+#define USB_DEVICE_ID_GTCO_205		0x0205
+#define USB_DEVICE_ID_GTCO_206		0x0206
+#define USB_DEVICE_ID_GTCO_207		0x0207
+#define USB_DEVICE_ID_GTCO_300		0x0300
+#define USB_DEVICE_ID_GTCO_301		0x0301
+#define USB_DEVICE_ID_GTCO_302		0x0302
+#define USB_DEVICE_ID_GTCO_303		0x0303
+#define USB_DEVICE_ID_GTCO_304		0x0304
+#define USB_DEVICE_ID_GTCO_305		0x0305
+#define USB_DEVICE_ID_GTCO_306		0x0306
+#define USB_DEVICE_ID_GTCO_307		0x0307
+#define USB_DEVICE_ID_GTCO_308		0x0308
+#define USB_DEVICE_ID_GTCO_309		0x0309
+#define USB_DEVICE_ID_GTCO_400		0x0400
+#define USB_DEVICE_ID_GTCO_401		0x0401
+#define USB_DEVICE_ID_GTCO_402		0x0402
+#define USB_DEVICE_ID_GTCO_403		0x0403
+#define USB_DEVICE_ID_GTCO_404		0x0404
+#define USB_DEVICE_ID_GTCO_405		0x0405
+#define USB_DEVICE_ID_GTCO_500		0x0500
+#define USB_DEVICE_ID_GTCO_501		0x0501
+#define USB_DEVICE_ID_GTCO_502		0x0502
+#define USB_DEVICE_ID_GTCO_503		0x0503
+#define USB_DEVICE_ID_GTCO_504		0x0504
+#define USB_DEVICE_ID_GTCO_1000		0x1000
+#define USB_DEVICE_ID_GTCO_1001		0x1001
+#define USB_DEVICE_ID_GTCO_1002		0x1002
+#define USB_DEVICE_ID_GTCO_1003		0x1003
+#define USB_DEVICE_ID_GTCO_1004		0x1004
+#define USB_DEVICE_ID_GTCO_1005		0x1005
+#define USB_DEVICE_ID_GTCO_1006		0x1006
+#define USB_DEVICE_ID_GTCO_1007		0x1007
+
+#define USB_VENDOR_ID_GYRATION		0x0c16
+#define USB_DEVICE_ID_GYRATION_REMOTE	0x0002
+#define USB_DEVICE_ID_GYRATION_REMOTE_2 0x0003
+#define USB_DEVICE_ID_GYRATION_REMOTE_3 0x0008
+
+#define I2C_VENDOR_ID_HANTICK		0x0911
+#define I2C_PRODUCT_ID_HANTICK_5288	0x5288
+
+#define USB_VENDOR_ID_HANWANG		0x0b57
+#define USB_DEVICE_ID_HANWANG_TABLET_FIRST	0x5000
+#define USB_DEVICE_ID_HANWANG_TABLET_LAST	0x8fff
+
+#define USB_VENDOR_ID_HANVON		0x20b3
+#define USB_DEVICE_ID_HANVON_MULTITOUCH	0x0a18
+
+#define USB_VENDOR_ID_HANVON_ALT	0x22ed
+#define USB_DEVICE_ID_HANVON_ALT_MULTITOUCH	0x1010
+
+#define USB_VENDOR_ID_HAPP		0x078b
+#define USB_DEVICE_ID_UGCI_DRIVING	0x0010
+#define USB_DEVICE_ID_UGCI_FLYING	0x0020
+#define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
+
+#define USB_VENDOR_ID_HP		0x03f0
+#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0A4A	0x0a4a
+#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE_0B4A	0x0b4a
+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE		0x134a
+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_094A	0x094a
+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_0941	0x0941
+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_0641	0x0641
+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE_1f4a	0x1f4a
+
+#define USB_VENDOR_ID_HUION		0x256c
+#define USB_DEVICE_ID_HUION_TABLET	0x006e
+#define USB_DEVICE_ID_HUION_TABLET2	0x006d
+
+#define USB_VENDOR_ID_IBM					0x04b3
+#define USB_DEVICE_ID_IBM_SCROLLPOINT_III			0x3100
+#define USB_DEVICE_ID_IBM_SCROLLPOINT_PRO			0x3103
+#define USB_DEVICE_ID_IBM_SCROLLPOINT_OPTICAL			0x3105
+#define USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL		0x3108
+#define USB_DEVICE_ID_IBM_SCROLLPOINT_800DPI_OPTICAL_PRO	0x3109
+
+#define USB_VENDOR_ID_IDEACOM		0x1cb6
+#define USB_DEVICE_ID_IDEACOM_IDC6650	0x6650
+#define USB_DEVICE_ID_IDEACOM_IDC6651	0x6651
+#define USB_DEVICE_ID_IDEACOM_IDC6680	0x6680
+
+#define USB_VENDOR_ID_ILITEK		0x222a
+#define USB_DEVICE_ID_ILITEK_MULTITOUCH	0x0001
+
+#define USB_VENDOR_ID_INTEL_0		0x8086
+#define USB_VENDOR_ID_INTEL_1		0x8087
+#define USB_DEVICE_ID_INTEL_HID_SENSOR_0	0x09fa
+#define USB_DEVICE_ID_INTEL_HID_SENSOR_1	0x0a04
+
+#define USB_VENDOR_ID_STM_0             0x0483
+#define USB_DEVICE_ID_STM_HID_SENSOR    0x91d1
+#define USB_DEVICE_ID_STM_HID_SENSOR_1  0x9100
+
+#define USB_VENDOR_ID_ION		0x15e4
+#define USB_DEVICE_ID_ICADE		0x0132
+
+#define USB_VENDOR_ID_HOLTEK		0x1241
+#define USB_DEVICE_ID_HOLTEK_ON_LINE_GRIP	0x5015
+
+#define USB_VENDOR_ID_HOLTEK_ALT		0x04d9
+#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD	0xa055
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A04A	0xa04a
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A067	0xa067
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A070	0xa070
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A072	0xa072
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A081	0xa081
+#define USB_DEVICE_ID_HOLTEK_ALT_MOUSE_A0C2	0xa0c2
+#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD_A096	0xa096
+#define USB_DEVICE_ID_HOLTEK_ALT_KEYBOARD_A293	0xa293
+
+#define USB_VENDOR_ID_IMATION		0x0718
+#define USB_DEVICE_ID_DISC_STAKKA	0xd000
+
+#define USB_VENDOR_ID_IRTOUCHSYSTEMS	0x6615
+#define USB_DEVICE_ID_IRTOUCH_INFRARED_USB	0x0070
+
+#define USB_VENDOR_ID_INNOMEDIA			0x1292
+#define USB_DEVICE_ID_INNEX_GENESIS_ATARI	0x4745
+
+#define USB_VENDOR_ID_ITE               0x048d
+#define I2C_VENDOR_ID_ITE		0x103c
+#define I2C_DEVICE_ID_ITE_VOYO_WINPAD_A15	0x184f
+#define USB_DEVICE_ID_ITE_LENOVO_YOGA   0x8386
+#define USB_DEVICE_ID_ITE_LENOVO_YOGA2  0x8350
+#define I2C_DEVICE_ID_ITE_LENOVO_LEGION_Y720	0x837a
+#define USB_DEVICE_ID_ITE_LENOVO_YOGA900	0x8396
+#define USB_DEVICE_ID_ITE8595		0x8595
+#define USB_DEVICE_ID_ITE_MEDION_E1239T	0xce50
+
+#define USB_VENDOR_ID_JABRA		0x0b0e
+#define USB_DEVICE_ID_JABRA_SPEAK_410	0x0412
+#define USB_DEVICE_ID_JABRA_SPEAK_510	0x0420
+#define USB_DEVICE_ID_JABRA_GN9350E	0x9350
+
+#define USB_VENDOR_ID_JESS		0x0c45
+#define USB_DEVICE_ID_JESS_YUREX	0x1010
+#define USB_DEVICE_ID_ASUS_MD_5112	0x5112
+#define USB_DEVICE_ID_REDRAGON_ASURA	0x760b
+
+#define USB_VENDOR_ID_JESS2		0x0f30
+#define USB_DEVICE_ID_JESS2_COLOR_RUMBLE_PAD 0x0111
+
+#define USB_VENDOR_ID_KBGEAR		0x084e
+#define USB_DEVICE_ID_KBGEAR_JAMSTUDIO	0x1001
+
+#define USB_VENDOR_ID_KENSINGTON	0x047d
+#define USB_DEVICE_ID_KS_SLIMBLADE	0x2041
+
+#define USB_VENDOR_ID_KWORLD		0x1b80
+#define USB_DEVICE_ID_KWORLD_RADIO_FM700	0xd700
+
+#define USB_VENDOR_ID_KEYTOUCH		0x0926
+#define USB_DEVICE_ID_KEYTOUCH_IEC	0x3333
+
+#define USB_VENDOR_ID_KYE		0x0458
+#define USB_DEVICE_ID_KYE_ERGO_525V	0x0087
+#define USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE	0x0138
+#define USB_DEVICE_ID_GENIUS_MANTICORE	0x0153
+#define USB_DEVICE_ID_GENIUS_GX_IMPERATOR	0x4018
+#define USB_DEVICE_ID_KYE_GPEN_560	0x5003
+#define USB_DEVICE_ID_KYE_EASYPEN_I405X	0x5010
+#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X	0x5011
+#define USB_DEVICE_ID_KYE_MOUSEPEN_I608X_V2	0x501a
+#define USB_DEVICE_ID_KYE_EASYPEN_M610X	0x5013
+#define USB_DEVICE_ID_KYE_PENSKETCH_M912	0x5015
+#define USB_DEVICE_ID_KYE_EASYPEN_M406XE	0x5019
+
+#define USB_VENDOR_ID_LABTEC		0x1020
+#define USB_DEVICE_ID_LABTEC_WIRELESS_KEYBOARD	0x0006
+
+#define USB_VENDOR_ID_LCPOWER		0x1241
+#define USB_DEVICE_ID_LCPOWER_LC1000	0xf767
+
+#define USB_VENDOR_ID_LD		0x0f11
+#define USB_DEVICE_ID_LD_CASSY		0x1000
+#define USB_DEVICE_ID_LD_CASSY2		0x1001
+#define USB_DEVICE_ID_LD_POCKETCASSY	0x1010
+#define USB_DEVICE_ID_LD_POCKETCASSY2	0x1011
+#define USB_DEVICE_ID_LD_MOBILECASSY	0x1020
+#define USB_DEVICE_ID_LD_MOBILECASSY2	0x1021
+#define USB_DEVICE_ID_LD_MICROCASSYVOLTAGE	0x1031
+#define USB_DEVICE_ID_LD_MICROCASSYCURRENT	0x1032
+#define USB_DEVICE_ID_LD_MICROCASSYTIME		0x1033
+#define USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE	0x1035
+#define USB_DEVICE_ID_LD_MICROCASSYPH		0x1038
+#define USB_DEVICE_ID_LD_POWERANALYSERCASSY	0x1040
+#define USB_DEVICE_ID_LD_CONVERTERCONTROLLERCASSY	0x1042
+#define USB_DEVICE_ID_LD_MACHINETESTCASSY	0x1043
+#define USB_DEVICE_ID_LD_JWM		0x1080
+#define USB_DEVICE_ID_LD_DMMP		0x1081
+#define USB_DEVICE_ID_LD_UMIP		0x1090
+#define USB_DEVICE_ID_LD_UMIC		0x10A0
+#define USB_DEVICE_ID_LD_UMIB		0x10B0
+#define USB_DEVICE_ID_LD_XRAY		0x1100
+#define USB_DEVICE_ID_LD_XRAY2		0x1101
+#define USB_DEVICE_ID_LD_XRAYCT		0x1110
+#define USB_DEVICE_ID_LD_VIDEOCOM	0x1200
+#define USB_DEVICE_ID_LD_MOTOR		0x1210
+#define USB_DEVICE_ID_LD_COM3LAB	0x2000
+#define USB_DEVICE_ID_LD_TELEPORT	0x2010
+#define USB_DEVICE_ID_LD_NETWORKANALYSER 0x2020
+#define USB_DEVICE_ID_LD_POWERCONTROL	0x2030
+#define USB_DEVICE_ID_LD_MACHINETEST	0x2040
+#define USB_DEVICE_ID_LD_MOSTANALYSER	0x2050
+#define USB_DEVICE_ID_LD_MOSTANALYSER2	0x2051
+#define USB_DEVICE_ID_LD_ABSESP		0x2060
+#define USB_DEVICE_ID_LD_AUTODATABUS	0x2070
+#define USB_DEVICE_ID_LD_MCT		0x2080
+#define USB_DEVICE_ID_LD_HYBRID		0x2090
+#define USB_DEVICE_ID_LD_HEATCONTROL	0x20A0
+
+#define USB_VENDOR_ID_LENOVO		0x17ef
+#define USB_DEVICE_ID_LENOVO_TPKBD	0x6009
+#define USB_DEVICE_ID_LENOVO_CUSBKBD	0x6047
+#define USB_DEVICE_ID_LENOVO_TPIIUSBKBD	0x60ee
+#define USB_DEVICE_ID_LENOVO_CBTKBD	0x6048
+#define USB_DEVICE_ID_LENOVO_TPIIBTKBD	0x60e1
+#define USB_DEVICE_ID_LENOVO_SCROLLPOINT_OPTICAL	0x6049
+#define USB_DEVICE_ID_LENOVO_TP10UBKBD	0x6062
+#define USB_DEVICE_ID_LENOVO_TPPRODOCK	0x6067
+#define USB_DEVICE_ID_LENOVO_X1_COVER	0x6085
+#define USB_DEVICE_ID_LENOVO_X1_TAB	0x60a3
+#define USB_DEVICE_ID_LENOVO_X1_TAB3	0x60b5
+#define USB_DEVICE_ID_LENOVO_X12_TAB	0x60fe
+#define USB_DEVICE_ID_LENOVO_OPTICAL_USB_MOUSE_600E	0x600e
+#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_608D	0x608d
+#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_6019	0x6019
+#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_602E	0x602e
+#define USB_DEVICE_ID_LENOVO_PIXART_USB_MOUSE_6093	0x6093
+
+#define USB_VENDOR_ID_LETSKETCH		0x6161
+#define USB_DEVICE_ID_WP9620N		0x4d15
+
+#define USB_VENDOR_ID_LG		0x1fd2
+#define USB_DEVICE_ID_LG_MULTITOUCH	0x0064
+#define USB_DEVICE_ID_LG_MELFAS_MT	0x6007
+#define I2C_DEVICE_ID_LG_8001		0x8001
+#define I2C_DEVICE_ID_LG_7010		0x7010
+
+#define USB_VENDOR_ID_LOGITECH		0x046d
+#define USB_DEVICE_ID_LOGITECH_Z_10_SPK	0x0a07
+#define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
+#define USB_DEVICE_ID_LOGITECH_T651	0xb00c
+#define USB_DEVICE_ID_LOGITECH_DINOVO_EDGE_KBD	0xb309
+#define USB_DEVICE_ID_LOGITECH_C007	0xc007
+#define USB_DEVICE_ID_LOGITECH_C077	0xc077
+#define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
+#define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
+#define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
+#define USB_DEVICE_ID_LOGITECH_HARMONY_PS3 0x0306
+#define USB_DEVICE_ID_LOGITECH_KEYBOARD_G710_PLUS 0xc24d
+#define USB_DEVICE_ID_LOGITECH_MOUSE_C01A	0xc01a
+#define USB_DEVICE_ID_LOGITECH_MOUSE_C05A	0xc05a
+#define USB_DEVICE_ID_LOGITECH_MOUSE_C06A	0xc06a
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD	0xc20a
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD	0xc211
+#define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
+#define USB_DEVICE_ID_LOGITECH_DUAL_ACTION	0xc216
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
+#define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
+#define USB_DEVICE_ID_LOGITECH_G15_LCD		0xc222
+#define USB_DEVICE_ID_LOGITECH_G11		0xc225
+#define USB_DEVICE_ID_LOGITECH_G15_V2_LCD	0xc227
+#define USB_DEVICE_ID_LOGITECH_G510		0xc22d
+#define USB_DEVICE_ID_LOGITECH_G510_USB_AUDIO	0xc22e
+#define USB_DEVICE_ID_LOGITECH_G29_WHEEL	0xc24f
+#define USB_DEVICE_ID_LOGITECH_G920_WHEEL	0xc262
+#define USB_DEVICE_ID_LOGITECH_G923_WHEEL	0xc266
+#define USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL	0xc267
+#define USB_DEVICE_ID_LOGITECH_G923_XBOX_WHEEL	0xc26e
+#define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
+#define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
+#define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
+#define USB_DEVICE_ID_LOGITECH_WINGMAN_FG	0xc20e
+#define USB_DEVICE_ID_LOGITECH_WINGMAN_FFG	0xc293
+#define USB_DEVICE_ID_LOGITECH_WHEEL	0xc294
+#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL	0xc295
+#define USB_DEVICE_ID_LOGITECH_DFP_WHEEL	0xc298
+#define USB_DEVICE_ID_LOGITECH_G25_WHEEL	0xc299
+#define USB_DEVICE_ID_LOGITECH_DFGT_WHEEL	0xc29a
+#define USB_DEVICE_ID_LOGITECH_G27_WHEEL	0xc29b
+#define USB_DEVICE_ID_LOGITECH_WII_WHEEL	0xc29c
+#define USB_DEVICE_ID_LOGITECH_ELITE_KBD	0xc30a
+#define USB_DEVICE_ID_LOGITECH_GROUP_AUDIO	0x0882
+#define USB_DEVICE_ID_S510_RECEIVER	0xc50c
+#define USB_DEVICE_ID_S510_RECEIVER_2	0xc517
+#define USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500	0xc512
+#define USB_DEVICE_ID_MX3000_RECEIVER	0xc513
+#define USB_DEVICE_ID_LOGITECH_27MHZ_MOUSE_RECEIVER	0xc51b
+#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER	0xc52b
+#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER		0xc52f
+#define USB_DEVICE_ID_LOGITECH_G700_RECEIVER		0xc531
+#define USB_DEVICE_ID_LOGITECH_UNIFYING_RECEIVER_2	0xc532
+#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_2		0xc534
+#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1	0xc539
+#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_LIGHTSPEED_1_1	0xc53f
+#define USB_DEVICE_ID_LOGITECH_NANO_RECEIVER_POWERPLAY	0xc53a
+#define USB_DEVICE_ID_SPACETRAVELLER	0xc623
+#define USB_DEVICE_ID_SPACENAVIGATOR	0xc626
+#define USB_DEVICE_ID_DINOVO_DESKTOP	0xc704
+#define USB_DEVICE_ID_MX5000_RECEIVER_MOUSE_DEV		0xc70a
+#define USB_DEVICE_ID_MX5000_RECEIVER_KBD_DEV		0xc70e
+#define USB_DEVICE_ID_DINOVO_EDGE_RECEIVER_KBD_DEV	0xc713
+#define USB_DEVICE_ID_DINOVO_EDGE_RECEIVER_MOUSE_DEV	0xc714
+#define USB_DEVICE_ID_MX5500_RECEIVER_KBD_DEV		0xc71b
+#define USB_DEVICE_ID_MX5500_RECEIVER_MOUSE_DEV		0xc71c
+#define USB_DEVICE_ID_DINOVO_MINI_RECEIVER_KBD_DEV	0xc71e
+#define USB_DEVICE_ID_DINOVO_MINI_RECEIVER_MOUSE_DEV	0xc71f
+#define USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2	0xca03
+#define USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL	0xca04
+
+#define USB_VENDOR_ID_LUMIO		0x202e
+#define USB_DEVICE_ID_CRYSTALTOUCH	0x0006
+#define USB_DEVICE_ID_CRYSTALTOUCH_DUAL	0x0007
+
+#define USB_VENDOR_ID_MADCATZ		0x0738
+#define USB_DEVICE_ID_MADCATZ_BEATPAD	0x4540
+#define USB_DEVICE_ID_MADCATZ_RAT5	0x1705
+#define USB_DEVICE_ID_MADCATZ_RAT9	0x1709
+#define USB_DEVICE_ID_MADCATZ_MMO7  0x1713
+
+#define USB_VENDOR_ID_MCC		0x09db
+#define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
+#define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
+
+#define USB_VENDOR_ID_MCS		0x16d0
+#define USB_DEVICE_ID_MCS_GAMEPADBLOCK	0x0bcc
+
+#define USB_VENDOR_MEGAWORLD		0x07b5
+#define USB_DEVICE_ID_MEGAWORLD_GAMEPAD	0x0312
+
+#define USB_VENDOR_ID_MGE		0x0463
+#define USB_DEVICE_ID_MGE_UPS		0xffff
+#define USB_DEVICE_ID_MGE_UPS1		0x0001
+
+#define USB_VENDOR_ID_MICROCHIP		0x04d8
+#define USB_DEVICE_ID_PICKIT1		0x0032
+#define USB_DEVICE_ID_PICKIT2		0x0033
+#define USB_DEVICE_ID_PICOLCD		0xc002
+#define USB_DEVICE_ID_PICOLCD_BOOTLOADER	0xf002
+#define USB_DEVICE_ID_PICK16F1454	0x0042
+#define USB_DEVICE_ID_PICK16F1454_V2	0xf2f7
+#define USB_DEVICE_ID_LUXAFOR		0xf372
+#define USB_DEVICE_ID_MCP2221		0x00dd
+
+#define USB_VENDOR_ID_MICROSOFT		0x045e
+#define USB_DEVICE_ID_SIDEWINDER_GV	0x003b
+#define USB_DEVICE_ID_MS_OFFICE_KB	0x0048
+#define USB_DEVICE_ID_WIRELESS_OPTICAL_DESKTOP_3_0 0x009d
+#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_7K 0x00b4
+#define USB_DEVICE_ID_MS_NE4K		0x00db
+#define USB_DEVICE_ID_MS_NE4K_JP	0x00dc
+#define USB_DEVICE_ID_MS_LK6K		0x00f9
+#define USB_DEVICE_ID_MS_PRESENTER_8K_BT	0x0701
+#define USB_DEVICE_ID_MS_PRESENTER_8K_USB	0x0713
+#define USB_DEVICE_ID_MS_NE7K		0x071d
+#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3K	0x0730
+#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_3KV1 0x0732
+#define USB_DEVICE_ID_MS_DIGITAL_MEDIA_600  0x0750
+#define USB_DEVICE_ID_MS_COMFORT_MOUSE_4500	0x076c
+#define USB_DEVICE_ID_MS_COMFORT_KEYBOARD 0x00e3
+#define USB_DEVICE_ID_MS_SURFACE_PRO_2   0x0799
+#define USB_DEVICE_ID_MS_TOUCH_COVER_2   0x07a7
+#define USB_DEVICE_ID_MS_TYPE_COVER_2    0x07a9
+#define USB_DEVICE_ID_MS_POWER_COVER     0x07da
+#define USB_DEVICE_ID_MS_SURFACE3_COVER		0x07de
+#define USB_DEVICE_ID_MS_XBOX_ONE_S_CONTROLLER	0x02fd
+#define USB_DEVICE_ID_MS_PIXART_MOUSE    0x00cb
+#define USB_DEVICE_ID_8BITDO_SN30_PRO_PLUS      0x02e0
+#define USB_DEVICE_ID_MS_MOUSE_0783      0x0783
+
+#define USB_VENDOR_ID_MOJO		0x8282
+#define USB_DEVICE_ID_RETRO_ADAPTER	0x3201
+
+#define USB_VENDOR_ID_MONTEREY		0x0566
+#define USB_DEVICE_ID_GENIUS_KB29E	0x3004
+
+#define USB_VENDOR_ID_MSI		0x1770
+#define USB_DEVICE_ID_MSI_GT683R_LED_PANEL 0xff00
+
+#define USB_VENDOR_ID_NATIONAL_SEMICONDUCTOR 0x0400
+#define USB_DEVICE_ID_N_S_HARMONY	0xc359
+
+#define USB_VENDOR_ID_NATSU		0x08b7
+#define USB_DEVICE_ID_NATSU_GAMEPAD	0x0001
+
+#define USB_VENDOR_ID_NCR		0x0404
+#define USB_DEVICE_ID_NCR_FIRST		0x0300
+#define USB_DEVICE_ID_NCR_LAST		0x03ff
+
+#define USB_VENDOR_ID_NEC		0x073e
+#define USB_DEVICE_ID_NEC_USB_GAME_PAD	0x0301
+
+#define USB_VENDOR_ID_NEXIO		0x1870
+#define USB_DEVICE_ID_NEXIO_MULTITOUCH_420	0x010d
+#define USB_DEVICE_ID_NEXIO_MULTITOUCH_PTI0750	0x0110
+
+#define USB_VENDOR_ID_NEXTWINDOW	0x1926
+#define USB_DEVICE_ID_NEXTWINDOW_TOUCHSCREEN	0x0003
+
+#define USB_VENDOR_ID_NINTENDO		0x057e
+#define USB_DEVICE_ID_NINTENDO_WIIMOTE	0x0306
+#define USB_DEVICE_ID_NINTENDO_WIIMOTE2	0x0330
+#define USB_DEVICE_ID_NINTENDO_JOYCONL	0x2006
+#define USB_DEVICE_ID_NINTENDO_JOYCONR	0x2007
+#define USB_DEVICE_ID_NINTENDO_PROCON	0x2009
+#define USB_DEVICE_ID_NINTENDO_CHRGGRIP	0x200E
+
+#define USB_VENDOR_ID_NOVATEK		0x0603
+#define USB_DEVICE_ID_NOVATEK_PCT	0x0600
+#define USB_DEVICE_ID_NOVATEK_MOUSE	0x1602
+
+#define USB_VENDOR_ID_NTI               0x0757
+#define USB_DEVICE_ID_USB_SUN           0x0a00
+
+#define USB_VENDOR_ID_NTRIG		0x1b96
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN   0x0001
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_1   0x0003
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_2   0x0004
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_3   0x0005
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_4   0x0006
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_5   0x0007
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_6   0x0008
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_7   0x0009
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_8   0x000A
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_9   0x000B
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_10   0x000C
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_11   0x000D
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_12   0x000E
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_13   0x000F
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_14   0x0010
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_15   0x0011
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_16   0x0012
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_17   0x0013
+#define USB_DEVICE_ID_NTRIG_TOUCH_SCREEN_18   0x0014
+#define USB_DEVICE_ID_NTRIG_DUOSENSE 0x1500
+
+#define USB_VENDOR_ID_ONTRAK		0x0a07
+#define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
+
+#define USB_VENDOR_ID_ORTEK		0x05a4
+#define USB_DEVICE_ID_ORTEK_PKB1700	0x1700
+#define USB_DEVICE_ID_ORTEK_WKB2000	0x2000
+#define USB_DEVICE_ID_ORTEK_IHOME_IMAC_A210S	0x8003
+
+#define USB_VENDOR_ID_PLANTRONICS	0x047f
+#define USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3210_SERIES	0xc055
+#define USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3220_SERIES	0xc056
+#define USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3215_SERIES	0xc057
+#define USB_DEVICE_ID_PLANTRONICS_BLACKWIRE_3225_SERIES	0xc058
+
+#define USB_VENDOR_ID_PANASONIC		0x04da
+#define USB_DEVICE_ID_PANABOARD_UBT780	0x1044
+#define USB_DEVICE_ID_PANABOARD_UBT880	0x104d
+
+#define USB_VENDOR_ID_PANJIT		0x134c
+
+#define USB_VENDOR_ID_PANTHERLORD	0x0810
+#define USB_DEVICE_ID_PANTHERLORD_TWIN_USB_JOYSTICK	0x0001
+
+#define USB_VENDOR_ID_PENMOUNT		0x14e1
+#define USB_DEVICE_ID_PENMOUNT_PCI	0x3500
+#define USB_DEVICE_ID_PENMOUNT_1610	0x1610
+#define USB_DEVICE_ID_PENMOUNT_1640	0x1640
+#define USB_DEVICE_ID_PENMOUNT_6000	0x6000
+
+#define USB_VENDOR_ID_PETALYNX		0x18b1
+#define USB_DEVICE_ID_PETALYNX_MAXTER_REMOTE	0x0037
+
+#define USB_VENDOR_ID_PETZL		0x2122
+#define USB_DEVICE_ID_PETZL_HEADLAMP	0x1234
+
+#define USB_VENDOR_ID_PHILIPS		0x0471
+#define USB_DEVICE_ID_PHILIPS_IEEE802154_DONGLE 0x0617
+
+#define USB_VENDOR_ID_PI_ENGINEERING	0x05f3
+#define USB_DEVICE_ID_PI_ENGINEERING_VEC_USB_FOOTPEDAL	0xff
+
+#define USB_VENDOR_ID_PIXART				0x093a
+#define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE_ID2	0x0137
+#define USB_DEVICE_ID_PIXART_USB_OPTICAL_MOUSE		0x2510
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN	0x8001
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1	0x8002
+#define USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2	0x8003
+
+#define USB_VENDOR_ID_PLAYDOTCOM	0x0b43
+#define USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII	0x0003
+
+#define USB_VENDOR_ID_POWERCOM		0x0d9f
+#define USB_DEVICE_ID_POWERCOM_UPS	0x0002
+
+#define USB_VENDOR_ID_PRODIGE		0x05af
+#define USB_DEVICE_ID_PRODIGE_CORDLESS	0x3062
+
+#define USB_VENDOR_ID_QUANTA		0x0408
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH		0x3000
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3001		0x3001
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3003		0x3003
+#define USB_DEVICE_ID_QUANTA_OPTICAL_TOUCH_3008		0x3008
+
+#define I2C_VENDOR_ID_RAYDIUM		0x2386
+#define I2C_PRODUCT_ID_RAYDIUM_4B33	0x4b33
+#define I2C_PRODUCT_ID_RAYDIUM_3118	0x3118
+
+#define USB_VENDOR_ID_RAZER            0x1532
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_ULTIMATE   0x010D
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW            0x010e
+#define USB_DEVICE_ID_RAZER_BLACKWIDOW_CLASSIC    0x011b
+#define USB_DEVICE_ID_RAZER_BLADE_14   0x011D
+
+#define USB_VENDOR_ID_REALTEK		0x0bda
+#define USB_DEVICE_ID_REALTEK_READER	0x0152
+
+#define USB_VENDOR_ID_REDOCTANE		0x1430
+#define USB_DEVICE_ID_REDOCTANE_GUITAR_DONGLE	0x474c
+#define USB_DEVICE_ID_REDOCTANE_PS4_GHLIVE_DONGLE	0x07bb
+
+#define USB_VENDOR_ID_RETROUSB		0xf000
+#define USB_DEVICE_ID_RETROUSB_SNES_RETROPAD	0x0003
+#define USB_DEVICE_ID_RETROUSB_SNES_RETROPORT	0x00f1
+
+#define USB_VENDOR_ID_ROCCAT		0x1e7d
+#define USB_DEVICE_ID_ROCCAT_ARVO	0x30d4
+#define USB_DEVICE_ID_ROCCAT_ISKU	0x319c
+#define USB_DEVICE_ID_ROCCAT_ISKUFX	0x3264
+#define USB_DEVICE_ID_ROCCAT_KONE	0x2ced
+#define USB_DEVICE_ID_ROCCAT_KONEPLUS	0x2d51
+#define USB_DEVICE_ID_ROCCAT_KONEPURE	0x2dbe
+#define USB_DEVICE_ID_ROCCAT_KONEPURE_OPTICAL	0x2db4
+#define USB_DEVICE_ID_ROCCAT_KONEXTD	0x2e22
+#define USB_DEVICE_ID_ROCCAT_KOVAPLUS	0x2d50
+#define USB_DEVICE_ID_ROCCAT_LUA	0x2c2e
+#define USB_DEVICE_ID_ROCCAT_PYRA_WIRED	0x2c24
+#define USB_DEVICE_ID_ROCCAT_PYRA_WIRELESS	0x2cf6
+#define USB_DEVICE_ID_ROCCAT_RYOS_MK	0x3138
+#define USB_DEVICE_ID_ROCCAT_RYOS_MK_GLOW	0x31ce
+#define USB_DEVICE_ID_ROCCAT_RYOS_MK_PRO	0x3232
+#define USB_DEVICE_ID_ROCCAT_SAVU	0x2d5a
+
+#define USB_VENDOR_ID_SAI		0x17dd
+
+#define USB_VENDOR_ID_SAITEK		0x06a3
+#define USB_DEVICE_ID_SAITEK_RUMBLEPAD	0xff17
+#define USB_DEVICE_ID_SAITEK_PS1000	0x0621
+#define USB_DEVICE_ID_SAITEK_RAT7_OLD	0x0ccb
+#define USB_DEVICE_ID_SAITEK_RAT7_CONTAGION	0x0ccd
+#define USB_DEVICE_ID_SAITEK_RAT7	0x0cd7
+#define USB_DEVICE_ID_SAITEK_RAT9	0x0cfa
+#define USB_DEVICE_ID_SAITEK_MMO7	0x0cd0
+#define USB_DEVICE_ID_SAITEK_X52	0x075c
+#define USB_DEVICE_ID_SAITEK_X52_2	0x0255
+#define USB_DEVICE_ID_SAITEK_X52_PRO	0x0762
+#define USB_DEVICE_ID_SAITEK_X65	0x0b6a
+
+#define USB_VENDOR_ID_SAMSUNG		0x0419
+#define USB_DEVICE_ID_SAMSUNG_IR_REMOTE	0x0001
+#define USB_DEVICE_ID_SAMSUNG_WIRELESS_KBD_MOUSE	0x0600
+
+#define USB_VENDOR_ID_SEMICO			0x1a2c
+#define USB_DEVICE_ID_SEMICO_USB_KEYKOARD	0x0023
+#define USB_DEVICE_ID_SEMICO_USB_KEYKOARD2	0x0027
+
+#define USB_VENDOR_ID_SEMITEK	0x1ea7
+#define USB_DEVICE_ID_SEMITEK_KEYBOARD	0x0907
+
+#define USB_VENDOR_ID_SENNHEISER	0x1395
+#define USB_DEVICE_ID_SENNHEISER_BTD500USB	0x002c
+
+#define USB_VENDOR_ID_SIGMA_MICRO	0x1c4f
+#define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD	0x0002
+#define USB_DEVICE_ID_SIGMA_MICRO_KEYBOARD2	0x0059
+
+#define USB_VENDOR_ID_SIGMATEL		0x066F
+#define USB_DEVICE_ID_SIGMATEL_STMP3780	0x3780
+
+#define USB_VENDOR_ID_SIS_TOUCH		0x0457
+#define USB_DEVICE_ID_SIS9200_TOUCH	0x9200
+#define USB_DEVICE_ID_SIS817_TOUCH	0x0817
+#define USB_DEVICE_ID_SIS_TS		0x1013
+#define USB_DEVICE_ID_SIS1030_TOUCH	0x1030
+
+#define USB_VENDOR_ID_SKYCABLE			0x1223
+#define	USB_DEVICE_ID_SKYCABLE_WIRELESS_PRESENTER	0x3F07
+
+#define USB_VENDOR_ID_SMK		0x0609
+#define USB_DEVICE_ID_SMK_PS3_BDREMOTE	0x0306
+#define USB_DEVICE_ID_SMK_NSG_MR5U_REMOTE       0x0368
+#define USB_DEVICE_ID_SMK_NSG_MR7U_REMOTE       0x0369
+
+
+#define USB_VENDOR_ID_SONY			0x054c
+#define USB_DEVICE_ID_SONY_VAIO_VGX_MOUSE	0x024b
+#define USB_DEVICE_ID_SONY_VAIO_VGP_MOUSE	0x0374
+#define USB_DEVICE_ID_SONY_PS3_BDREMOTE		0x0306
+#define USB_DEVICE_ID_SONY_PS3_CONTROLLER	0x0268
+#define USB_DEVICE_ID_SONY_PS4_CONTROLLER	0x05c4
+#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_2	0x09cc
+#define USB_DEVICE_ID_SONY_PS4_CONTROLLER_DONGLE	0x0ba0
+#define USB_DEVICE_ID_SONY_PS5_CONTROLLER	0x0ce6
+#define USB_DEVICE_ID_SONY_PS5_CONTROLLER_2	0x0df2
+#define USB_DEVICE_ID_SONY_MOTION_CONTROLLER	0x03d5
+#define USB_DEVICE_ID_SONY_NAVIGATION_CONTROLLER	0x042f
+#define USB_DEVICE_ID_SONY_BUZZ_CONTROLLER		0x0002
+#define USB_DEVICE_ID_SONY_WIRELESS_BUZZ_CONTROLLER	0x1000
+
+#define USB_VENDOR_ID_SONY_RHYTHM	0x12ba
+#define USB_DEVICE_ID_SONY_PS3WIIU_GHLIVE_DONGLE	0x074b
+#define USB_DEVICE_ID_SONY_PS3_GUITAR_DONGLE	0x0100
+
+#define USB_VENDOR_ID_SINO_LITE			0x1345
+#define USB_DEVICE_ID_SINO_LITE_CONTROLLER	0x3008
+
+#define USB_VENDOR_ID_SOLID_YEAR			0x060b
+#define USB_DEVICE_ID_MACALLY_IKEY_KEYBOARD		0x0001
+#define USB_DEVICE_ID_COUGAR_500K_GAMING_KEYBOARD	0x500a
+#define USB_DEVICE_ID_COUGAR_700K_GAMING_KEYBOARD	0x700a
+
+#define USB_VENDOR_ID_SOUNDGRAPH	0x15c2
+#define USB_DEVICE_ID_SOUNDGRAPH_IMON_FIRST	0x0034
+#define USB_DEVICE_ID_SOUNDGRAPH_IMON_LAST	0x0046
+
+#define USB_VENDOR_ID_STANTUM		0x1f87
+#define USB_DEVICE_ID_MTP		0x0002
+
+#define USB_VENDOR_ID_STANTUM_STM		0x0483
+#define USB_DEVICE_ID_MTP_STM		0x3261
+
+#define USB_VENDOR_ID_STANTUM_SITRONIX		0x1403
+#define USB_DEVICE_ID_MTP_SITRONIX		0x5001
+
+#define USB_VENDOR_ID_VALVE			0x28de
+#define USB_DEVICE_ID_STEAM_CONTROLLER		0x1102
+#define USB_DEVICE_ID_STEAM_CONTROLLER_WIRELESS	0x1142
+#define USB_DEVICE_ID_STEAM_DECK	0x1205
+
+#define USB_VENDOR_ID_STEELSERIES	0x1038
+#define USB_DEVICE_ID_STEELSERIES_SRWS1	0x1410
+
+#define USB_VENDOR_ID_SUN		0x0430
+#define USB_DEVICE_ID_RARITAN_KVM_DONGLE	0xcdab
+
+#define USB_VENDOR_ID_SUNPLUS		0x04fc
+#define USB_DEVICE_ID_SUNPLUS_WDESKTOP	0x05d8
+
+#define USB_VENDOR_ID_SYMBOL		0x05e0
+#define USB_DEVICE_ID_SYMBOL_SCANNER_1	0x0800
+#define USB_DEVICE_ID_SYMBOL_SCANNER_2	0x1300
+#define USB_DEVICE_ID_SYMBOL_SCANNER_3	0x1200
+
+#define I2C_VENDOR_ID_SYNAPTICS     0x06cb
+#define I2C_PRODUCT_ID_SYNAPTICS_SYNA2393   0x7a13
+
+#define USB_VENDOR_ID_SYNAPTICS		0x06cb
+#define USB_DEVICE_ID_SYNAPTICS_TP	0x0001
+#define USB_DEVICE_ID_SYNAPTICS_INT_TP	0x0002
+#define USB_DEVICE_ID_SYNAPTICS_CPAD	0x0003
+#define USB_DEVICE_ID_SYNAPTICS_TS	0x0006
+#define USB_DEVICE_ID_SYNAPTICS_STICK	0x0007
+#define USB_DEVICE_ID_SYNAPTICS_WP	0x0008
+#define USB_DEVICE_ID_SYNAPTICS_COMP_TP	0x0009
+#define USB_DEVICE_ID_SYNAPTICS_WTP	0x0010
+#define USB_DEVICE_ID_SYNAPTICS_DPAD	0x0013
+#define USB_DEVICE_ID_SYNAPTICS_LTS1	0x0af8
+#define USB_DEVICE_ID_SYNAPTICS_LTS2	0x1d10
+#define USB_DEVICE_ID_SYNAPTICS_HD	0x0ac3
+#define USB_DEVICE_ID_SYNAPTICS_QUAD_HD	0x1ac3
+#define USB_DEVICE_ID_SYNAPTICS_DELL_K12A	0x2819
+#define USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5_012	0x2968
+#define USB_DEVICE_ID_SYNAPTICS_TP_V103	0x5710
+#define USB_DEVICE_ID_SYNAPTICS_DELL_K15A	0x6e21
+#define USB_DEVICE_ID_SYNAPTICS_ACER_ONE_S1002	0x73f4
+#define USB_DEVICE_ID_SYNAPTICS_ACER_ONE_S1003	0x73f5
+#define USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5_017	0x73f6
+#define USB_DEVICE_ID_SYNAPTICS_ACER_SWITCH5	0x81a7
+
+#define USB_VENDOR_ID_TEXAS_INSTRUMENTS	0x2047
+#define USB_DEVICE_ID_TEXAS_INSTRUMENTS_LENOVO_YOGA	0x0855
+
+#define USB_VENDOR_ID_THINGM		0x27b8
+#define USB_DEVICE_ID_BLINK1		0x01ed
+
+#define USB_VENDOR_ID_THQ		0x20d6
+#define USB_DEVICE_ID_THQ_PS3_UDRAW	0xcb17
+
+#define USB_VENDOR_ID_THRUSTMASTER	0x044f
+
+#define USB_VENDOR_ID_TIVO		0x150a
+#define USB_DEVICE_ID_TIVO_SLIDE_BT	0x1200
+#define USB_DEVICE_ID_TIVO_SLIDE	0x1201
+#define USB_DEVICE_ID_TIVO_SLIDE_PRO	0x1203
+
+#define USB_VENDOR_ID_TOPRE			0x0853
+#define USB_DEVICE_ID_TOPRE_REALFORCE_R2_108			0x0148
+
+#define USB_VENDOR_ID_TOPSEED		0x0766
+#define USB_DEVICE_ID_TOPSEED_CYBERLINK	0x0204
+
+#define USB_VENDOR_ID_TOPSEED2		0x1784
+#define USB_DEVICE_ID_TOPSEED2_RF_COMBO	0x0004
+#define USB_DEVICE_ID_TOPSEED2_PERIPAD_701	0x0016
+
+#define USB_VENDOR_ID_TOPMAX		0x0663
+#define USB_DEVICE_ID_TOPMAX_COBRAPAD	0x0103
+
+#define USB_VENDOR_ID_TOUCH_INTL	0x1e5e
+#define USB_DEVICE_ID_TOUCH_INTL_MULTI_TOUCH	0x0313
+
+#define USB_VENDOR_ID_TOUCHPACK		0x1bfd
+#define USB_DEVICE_ID_TOUCHPACK_RTS	0x1688
+
+#define USB_VENDOR_ID_TPV		0x25aa
+#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN_8882	0x8882
+#define USB_DEVICE_ID_TPV_OPTICAL_TOUCHSCREEN_8883	0x8883
+
+#define USB_VENDOR_ID_TRUST             0x145f
+#define USB_DEVICE_ID_TRUST_PANORA_TABLET   0x0212
+
+#define USB_VENDOR_ID_TURBOX		0x062a
+#define USB_DEVICE_ID_TURBOX_KEYBOARD	0x0201
+#define USB_DEVICE_ID_ASUS_MD_5110	0x5110
+#define USB_DEVICE_ID_TURBOX_TOUCHSCREEN_MOSART	0x7100
+
+#define USB_VENDOR_ID_TWINHAN		0x6253
+#define USB_DEVICE_ID_TWINHAN_IR_REMOTE	0x0100
+
+#define USB_VENDOR_ID_UCLOGIC		0x5543
+#define USB_DEVICE_ID_UCLOGIC_TABLET_PF1209	0x0042
+#define USB_DEVICE_ID_UCLOGIC_TABLET_KNA5	0x6001
+#define USB_DEVICE_ID_UCLOGIC_TABLET_TWA60	0x0064
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP4030U	0x0003
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP5540U	0x0004
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP8060U	0x0005
+#define USB_DEVICE_ID_UCLOGIC_TABLET_WP1062	0x0064
+#define USB_DEVICE_ID_UCLOGIC_WIRELESS_TABLET_TWHL850	0x0522
+#define USB_DEVICE_ID_UCLOGIC_TABLET_TWHA60	0x0781
+#define USB_DEVICE_ID_UCLOGIC_DRAWIMAGE_G3	0x3031
+#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_81	0x0081
+#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_45	0x0045
+#define USB_DEVICE_ID_UCLOGIC_UGEE_TABLET_47	0x0047
+#define USB_DEVICE_ID_YIYNOVA_TABLET		0x004d
+
+#define USB_VENDOR_ID_UGEE		0x28bd
+#define USB_DEVICE_ID_UGEE_PARBLO_A610_PRO	0x1903
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_G540	0x0075
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_G640	0x0094
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01	0x0042
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO01_V2	0x0905
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_L	0x0935
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_MW	0x0934
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_S	0x0909
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_DECO_PRO_SW	0x0933
+#define USB_DEVICE_ID_UGEE_XPPEN_TABLET_STAR06	0x0078
+#define USB_DEVICE_ID_UGEE_TABLET_G5		0x0074
+#define USB_DEVICE_ID_UGEE_TABLET_EX07S		0x0071
+#define USB_DEVICE_ID_UGEE_TABLET_RAINBOW_CV720	0x0055
+
+#define USB_VENDOR_ID_UNITEC	0x227d
+#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0709	0x0709
+#define USB_DEVICE_ID_UNITEC_USB_TOUCH_0A19	0x0a19
+
+#define USB_VENDOR_ID_VELLEMAN		0x10cf
+#define USB_DEVICE_ID_VELLEMAN_K8055_FIRST	0x5500
+#define USB_DEVICE_ID_VELLEMAN_K8055_LAST	0x5503
+#define USB_DEVICE_ID_VELLEMAN_K8061_FIRST	0x8061
+#define USB_DEVICE_ID_VELLEMAN_K8061_LAST	0x8068
+
+#define USB_VENDOR_ID_VTL		0x0306
+#define USB_DEVICE_ID_VTL_MULTITOUCH_FF3F	0xff3f
+
+#define USB_VENDOR_ID_WACOM		0x056a
+#define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH	0x81
+#define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD
+
+#define USB_VENDOR_ID_WALTOP				0x172f
+#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH	0x0032
+#define USB_DEVICE_ID_WALTOP_SLIM_TABLET_12_1_INCH	0x0034
+#define USB_DEVICE_ID_WALTOP_Q_PAD			0x0037
+#define USB_DEVICE_ID_WALTOP_PID_0038			0x0038
+#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_10_6_INCH	0x0501
+#define USB_DEVICE_ID_WALTOP_MEDIA_TABLET_14_1_INCH	0x0500
+#define USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET	0x0502
+
+#define	USB_VENDOR_ID_WEIDA		0x2575
+#define	USB_DEVICE_ID_WEIDA_8752	0xC300
+#define	USB_DEVICE_ID_WEIDA_8755	0xC301
+
+#define USB_VENDOR_ID_WINBOND		0x0416
+#define USB_DEVICE_ID_TSTP_MTOUCH	0xc168
+
+#define USB_VENDOR_ID_WISEGROUP		0x0925
+#define USB_DEVICE_ID_SMARTJOY_PLUS	0x0005
+#define USB_DEVICE_ID_SUPER_JOY_BOX_3	0x8888
+#define USB_DEVICE_ID_QUAD_USB_JOYPAD	0x8800
+#define USB_DEVICE_ID_DUAL_USB_JOYPAD	0x8866
+
+#define USB_VENDOR_ID_WISEGROUP_LTD	0x6666
+#define USB_VENDOR_ID_WISEGROUP_LTD2	0x6677
+#define USB_DEVICE_ID_SMARTJOY_DUAL_PLUS 0x8802
+#define USB_DEVICE_ID_SUPER_JOY_BOX_3_PRO 0x8801
+#define USB_DEVICE_ID_SUPER_DUAL_BOX_PRO 0x8802
+#define USB_DEVICE_ID_SUPER_JOY_BOX_5_PRO 0x8804
+
+#define USB_VENDOR_ID_WISTRON		0x0fb8
+#define USB_DEVICE_ID_WISTRON_OPTICAL_TOUCH		0x1109
+
+#define USB_VENDOR_ID_X_TENSIONS               0x1ae7
+#define USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE    0x9001
+
+#define USB_VENDOR_ID_XAT	0x2505
+#define USB_DEVICE_ID_XAT_CSR	0x0220
+
+#define USB_VENDOR_ID_XIAOMI		0x2717
+#define USB_DEVICE_ID_MI_SILENT_MOUSE	0x5014
+
+#define USB_VENDOR_ID_XIN_MO			0x16c0
+#define USB_DEVICE_ID_XIN_MO_DUAL_ARCADE	0x05e1
+#define USB_DEVICE_ID_THT_2P_ARCADE		0x75e1
+
+#define USB_VENDOR_ID_XIROKU		0x1477
+#define USB_DEVICE_ID_XIROKU_SPX	0x1006
+#define USB_DEVICE_ID_XIROKU_MPX	0x1007
+#define USB_DEVICE_ID_XIROKU_CSR	0x100e
+#define USB_DEVICE_ID_XIROKU_SPX1	0x1021
+#define USB_DEVICE_ID_XIROKU_CSR1	0x1022
+#define USB_DEVICE_ID_XIROKU_MPX1	0x1023
+#define USB_DEVICE_ID_XIROKU_SPX2	0x1024
+#define USB_DEVICE_ID_XIROKU_CSR2	0x1025
+#define USB_DEVICE_ID_XIROKU_MPX2	0x1026
+
+#define USB_VENDOR_ID_YEALINK		0x6993
+#define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K	0xb001
+
+#define USB_VENDOR_ID_ZEROPLUS		0x0c12
+
+#define USB_VENDOR_ID_ZYDACRON	0x13EC
+#define USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL	0x0006
+
+#define USB_VENDOR_ID_ZYTRONIC		0x14c8
+#define USB_DEVICE_ID_ZYTRONIC_ZXY100	0x0005
+
+#define USB_VENDOR_ID_PRIMAX	0x0461
+#define USB_DEVICE_ID_PRIMAX_MOUSE_4D22	0x4d22
+#define USB_DEVICE_ID_PRIMAX_MOUSE_4E2A	0x4e2a
+#define USB_DEVICE_ID_PRIMAX_KEYBOARD	0x4e05
+#define USB_DEVICE_ID_PRIMAX_REZEL	0x4e72
+#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4D0F	0x4d0f
+#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4D65	0x4d65
+#define USB_DEVICE_ID_PRIMAX_PIXART_MOUSE_4E22	0x4e22
+
+
+#define USB_VENDOR_ID_RISO_KAGAKU	0x1294	/* Riso Kagaku Corp. */
+#define USB_DEVICE_ID_RI_KA_WEBMAIL	0x1320	/* Webmail Notifier */
+
+#define USB_VENDOR_ID_MULTIPLE_1781	0x1781
+#define USB_DEVICE_ID_RAPHNET_4NES4SNES_OLD	0x0a9d
+#define USB_DEVICE_ID_PHOENIXRC        0x0898
+
+#define USB_VENDOR_ID_DRACAL_RAPHNET	0x289b
+#define USB_DEVICE_ID_RAPHNET_2NES2SNES	0x0002
+#define USB_DEVICE_ID_RAPHNET_4NES4SNES	0x0003
+
+#define USB_VENDOR_ID_UGTIZER			0x2179
+#define USB_DEVICE_ID_UGTIZER_TABLET_GP0610	0x0053
+#define USB_DEVICE_ID_UGTIZER_TABLET_GT5040	0x0077
+#define USB_DEVICE_ID_UGTIZER_TABLET_WP5540	0x0004
+
+#define USB_VENDOR_ID_VIEWSONIC			0x0543
+#define USB_DEVICE_ID_VIEWSONIC_PD1011		0xe621
+
+#define USB_VENDOR_ID_SIGNOTEC			0x2133
+#define USB_DEVICE_ID_SIGNOTEC_VIEWSONIC_PD1011	0x0018
+
+#endif
diff --git a/drivers/custom/lg4ff/hid-lg.c b/drivers/custom/lg4ff/hid-lg.c
new file mode 100644
index 000000000000..ad114214d85e
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg.c
@@ -0,0 +1,958 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  HID driver for some logitech "special" devices
+ *
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2005 Vojtech Pavlik <vojtech@suse.cz>
+ *  Copyright (c) 2005 Michael Haboustak <mike-@cinci.rr.com> for Concept2, Inc
+ *  Copyright (c) 2006-2007 Jiri Kosina
+ *  Copyright (c) 2008 Jiri Slaby
+ *  Copyright (c) 2010 Hendrik Iben
+ */
+
+/*
+ */
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/module.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/usb.h>
+#include <linux/wait.h>
+#include <linux/version.h>
+
+#include "usbhid/usbhid.h"
+#include "hid-ids.h"
+#include "hid-lg.h"
+#include "hid-lg4ff.h"
+
+#define LG_RDESC		0x001
+#define LG_BAD_RELATIVE_KEYS	0x002
+#define LG_DUPLICATE_USAGES	0x004
+#define LG_EXPANDED_KEYMAP	0x010
+#define LG_IGNORE_DOUBLED_WHEEL	0x020
+#define LG_WIRELESS		0x040
+#define LG_INVERT_HWHEEL	0x080
+#define LG_NOGET		0x100
+#define LG_FF			0x200
+#define LG_FF2			0x400
+#define LG_RDESC_REL_ABS	0x800
+#define LG_FF3			0x1000
+#define LG_FF4			0x2000
+
+/* Size of the original descriptors of the Driving Force (and Pro) wheels */
+#define DF_RDESC_ORIG_SIZE	130
+#define DFP_RDESC_ORIG_SIZE	97
+#define FV_RDESC_ORIG_SIZE	130
+#define MOMO_RDESC_ORIG_SIZE	87
+#define MOMO2_RDESC_ORIG_SIZE	87
+#define FFG_RDESC_ORIG_SIZE	85
+#define FG_RDESC_ORIG_SIZE	82
+
+/* Fixed report descriptors for Logitech Driving Force (and Pro)
+ * wheel controllers
+ *
+ * The original descriptors hide the separate throttle and brake axes in
+ * a custom vendor usage page, providing only a combined value as
+ * GenericDesktop.Y.
+ * These descriptors remove the combined Y axis and instead report
+ * separate throttle (Y) and brake (RZ).
+ */
+static __u8 df_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),                   */
+0x09, 0x04,         /*  Usage (Joystick),                       */
+0xA1, 0x01,         /*  Collection (Application),               */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x0A,         /*          Report Size (10),               */
+0x14,               /*          Logical Minimum (0),            */
+0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),         */
+0x34,               /*          Physical Minimum (0),           */
+0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),        */
+0x09, 0x30,         /*          Usage (X),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x95, 0x0C,         /*          Report Count (12),              */
+0x75, 0x01,         /*          Report Size (1),                */
+0x25, 0x01,         /*          Logical Maximum (1),            */
+0x45, 0x01,         /*          Physical Maximum (1),           */
+0x05, 0x09,         /*          Usage (Buttons),                */
+0x19, 0x01,         /*          Usage Minimum (1),              */
+0x29, 0x0c,         /*          Usage Maximum (12),             */
+0x81, 0x02,         /*          Input (Variable),               */
+0x95, 0x02,         /*          Report Count (2),               */
+0x06, 0x00, 0xFF,   /*          Usage Page (Vendor: 65280),     */
+0x09, 0x01,         /*          Usage (?: 1),                   */
+0x81, 0x02,         /*          Input (Variable),               */
+0x05, 0x01,         /*          Usage Page (Desktop),           */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x81, 0x02,         /*          Input (Variable),               */
+0x25, 0x07,         /*          Logical Maximum (7),            */
+0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */
+0x75, 0x04,         /*          Report Size (4),                */
+0x65, 0x14,         /*          Unit (Degrees),                 */
+0x09, 0x39,         /*          Usage (Hat Switch),             */
+0x81, 0x42,         /*          Input (Variable, Null State),   */
+0x75, 0x01,         /*          Report Size (1),                */
+0x95, 0x04,         /*          Report Count (4),               */
+0x65, 0x00,         /*          Unit (none),                    */
+0x06, 0x00, 0xFF,   /*          Usage Page (Vendor: 65280),     */
+0x09, 0x01,         /*          Usage (?: 1),                   */
+0x25, 0x01,         /*          Logical Maximum (1),            */
+0x45, 0x01,         /*          Physical Maximum (1),           */
+0x81, 0x02,         /*          Input (Variable),               */
+0x05, 0x01,         /*          Usage Page (Desktop),           */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x09, 0x31,         /*          Usage (Y),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x09, 0x35,         /*          Usage (Rz),                     */
+0x81, 0x02,         /*          Input (Variable),               */
+0xC0,               /*      End Collection,                     */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x95, 0x07,         /*          Report Count (7),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x09, 0x03,         /*          Usage (?: 3),                   */
+0x91, 0x02,         /*          Output (Variable),              */
+0xC0,               /*      End Collection,                     */
+0xC0                /*  End Collection                          */
+};
+
+static __u8 dfp_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),                   */
+0x09, 0x04,         /*  Usage (Joystick),                       */
+0xA1, 0x01,         /*  Collection (Application),               */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x0E,         /*          Report Size (14),               */
+0x14,               /*          Logical Minimum (0),            */
+0x26, 0xFF, 0x3F,   /*          Logical Maximum (16383),        */
+0x34,               /*          Physical Minimum (0),           */
+0x46, 0xFF, 0x3F,   /*          Physical Maximum (16383),       */
+0x09, 0x30,         /*          Usage (X),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x95, 0x0E,         /*          Report Count (14),              */
+0x75, 0x01,         /*          Report Size (1),                */
+0x25, 0x01,         /*          Logical Maximum (1),            */
+0x45, 0x01,         /*          Physical Maximum (1),           */
+0x05, 0x09,         /*          Usage Page (Button),            */
+0x19, 0x01,         /*          Usage Minimum (01h),            */
+0x29, 0x0E,         /*          Usage Maximum (0Eh),            */
+0x81, 0x02,         /*          Input (Variable),               */
+0x05, 0x01,         /*          Usage Page (Desktop),           */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x04,         /*          Report Size (4),                */
+0x25, 0x07,         /*          Logical Maximum (7),            */
+0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */
+0x65, 0x14,         /*          Unit (Degrees),                 */
+0x09, 0x39,         /*          Usage (Hat Switch),             */
+0x81, 0x42,         /*          Input (Variable, Nullstate),    */
+0x65, 0x00,         /*          Unit,                           */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x75, 0x08,         /*          Report Size (8),                */
+0x81, 0x01,         /*          Input (Constant),               */
+0x09, 0x31,         /*          Usage (Y),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x09, 0x35,         /*          Usage (Rz),                     */
+0x81, 0x02,         /*          Input (Variable),               */
+0x81, 0x01,         /*          Input (Constant),               */
+0xC0,               /*      End Collection,                     */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x09, 0x02,         /*          Usage (02h),                    */
+0x95, 0x07,         /*          Report Count (7),               */
+0x91, 0x02,         /*          Output (Variable),              */
+0xC0,               /*      End Collection,                     */
+0xC0                /*  End Collection                          */
+};
+
+static __u8 fv_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),                   */
+0x09, 0x04,         /*  Usage (Joystick),                       */
+0xA1, 0x01,         /*  Collection (Application),               */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x0A,         /*          Report Size (10),               */
+0x15, 0x00,         /*          Logical Minimum (0),            */
+0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),         */
+0x35, 0x00,         /*          Physical Minimum (0),           */
+0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),        */
+0x09, 0x30,         /*          Usage (X),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x95, 0x0C,         /*          Report Count (12),              */
+0x75, 0x01,         /*          Report Size (1),                */
+0x25, 0x01,         /*          Logical Maximum (1),            */
+0x45, 0x01,         /*          Physical Maximum (1),           */
+0x05, 0x09,         /*          Usage Page (Button),            */
+0x19, 0x01,         /*          Usage Minimum (01h),            */
+0x29, 0x0C,         /*          Usage Maximum (0Ch),            */
+0x81, 0x02,         /*          Input (Variable),               */
+0x95, 0x02,         /*          Report Count (2),               */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */
+0x09, 0x01,         /*          Usage (01h),                    */
+0x81, 0x02,         /*          Input (Variable),               */
+0x09, 0x02,         /*          Usage (02h),                    */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x81, 0x02,         /*          Input (Variable),               */
+0x05, 0x01,         /*          Usage Page (Desktop),           */
+0x25, 0x07,         /*          Logical Maximum (7),            */
+0x46, 0x3B, 0x01,   /*          Physical Maximum (315),         */
+0x75, 0x04,         /*          Report Size (4),                */
+0x65, 0x14,         /*          Unit (Degrees),                 */
+0x09, 0x39,         /*          Usage (Hat Switch),             */
+0x81, 0x42,         /*          Input (Variable, Null State),   */
+0x75, 0x01,         /*          Report Size (1),                */
+0x95, 0x04,         /*          Report Count (4),               */
+0x65, 0x00,         /*          Unit,                           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),             */
+0x09, 0x01,         /*          Usage (01h),                    */
+0x25, 0x01,         /*          Logical Maximum (1),            */
+0x45, 0x01,         /*          Physical Maximum (1),           */
+0x81, 0x02,         /*          Input (Variable),               */
+0x05, 0x01,         /*          Usage Page (Desktop),           */
+0x95, 0x01,         /*          Report Count (1),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x09, 0x31,         /*          Usage (Y),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0x09, 0x32,         /*          Usage (Z),                      */
+0x81, 0x02,         /*          Input (Variable),               */
+0xC0,               /*      End Collection,                     */
+0xA1, 0x02,         /*      Collection (Logical),               */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),          */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),         */
+0x95, 0x07,         /*          Report Count (7),               */
+0x75, 0x08,         /*          Report Size (8),                */
+0x09, 0x03,         /*          Usage (03h),                    */
+0x91, 0x02,         /*          Output (Variable),              */
+0xC0,               /*      End Collection,                     */
+0xC0                /*  End Collection                          */
+};
+
+static __u8 momo_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),               */
+0x09, 0x04,         /*  Usage (Joystick),                   */
+0xA1, 0x01,         /*  Collection (Application),           */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x75, 0x0A,         /*          Report Size (10),           */
+0x15, 0x00,         /*          Logical Minimum (0),        */
+0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */
+0x35, 0x00,         /*          Physical Minimum (0),       */
+0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */
+0x09, 0x30,         /*          Usage (X),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x95, 0x08,         /*          Report Count (8),           */
+0x75, 0x01,         /*          Report Size (1),            */
+0x25, 0x01,         /*          Logical Maximum (1),        */
+0x45, 0x01,         /*          Physical Maximum (1),       */
+0x05, 0x09,         /*          Usage Page (Button),        */
+0x19, 0x01,         /*          Usage Minimum (01h),        */
+0x29, 0x08,         /*          Usage Maximum (08h),        */
+0x81, 0x02,         /*          Input (Variable),           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x75, 0x0E,         /*          Report Size (14),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */
+0x09, 0x00,         /*          Usage (00h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0x05, 0x01,         /*          Usage Page (Desktop),       */
+0x75, 0x08,         /*          Report Size (8),            */
+0x09, 0x31,         /*          Usage (Y),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x09, 0x32,         /*          Usage (Z),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x09, 0x01,         /*          Usage (01h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0xC0,               /*      End Collection,                 */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x09, 0x02,         /*          Usage (02h),                */
+0x95, 0x07,         /*          Report Count (7),           */
+0x91, 0x02,         /*          Output (Variable),          */
+0xC0,               /*      End Collection,                 */
+0xC0                /*  End Collection                      */
+};
+
+static __u8 momo2_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),               */
+0x09, 0x04,         /*  Usage (Joystick),                   */
+0xA1, 0x01,         /*  Collection (Application),           */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x75, 0x0A,         /*          Report Size (10),           */
+0x15, 0x00,         /*          Logical Minimum (0),        */
+0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */
+0x35, 0x00,         /*          Physical Minimum (0),       */
+0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */
+0x09, 0x30,         /*          Usage (X),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x95, 0x0A,         /*          Report Count (10),          */
+0x75, 0x01,         /*          Report Size (1),            */
+0x25, 0x01,         /*          Logical Maximum (1),        */
+0x45, 0x01,         /*          Physical Maximum (1),       */
+0x05, 0x09,         /*          Usage Page (Button),        */
+0x19, 0x01,         /*          Usage Minimum (01h),        */
+0x29, 0x0A,         /*          Usage Maximum (0Ah),        */
+0x81, 0x02,         /*          Input (Variable),           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x09, 0x00,         /*          Usage (00h),                */
+0x95, 0x04,         /*          Report Count (4),           */
+0x81, 0x02,         /*          Input (Variable),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x75, 0x08,         /*          Report Size (8),            */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */
+0x09, 0x01,         /*          Usage (01h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0x05, 0x01,         /*          Usage Page (Desktop),       */
+0x09, 0x31,         /*          Usage (Y),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x09, 0x32,         /*          Usage (Z),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x09, 0x00,         /*          Usage (00h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0xC0,               /*      End Collection,                 */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x09, 0x02,         /*          Usage (02h),                */
+0x95, 0x07,         /*          Report Count (7),           */
+0x91, 0x02,         /*          Output (Variable),          */
+0xC0,               /*      End Collection,                 */
+0xC0                /*  End Collection                      */
+};
+
+static __u8 ffg_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),               */
+0x09, 0x04,         /*  Usage (Joystik),                    */
+0xA1, 0x01,         /*  Collection (Application),           */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x75, 0x0A,         /*          Report Size (10),           */
+0x15, 0x00,         /*          Logical Minimum (0),        */
+0x26, 0xFF, 0x03,   /*          Logical Maximum (1023),     */
+0x35, 0x00,         /*          Physical Minimum (0),       */
+0x46, 0xFF, 0x03,   /*          Physical Maximum (1023),    */
+0x09, 0x30,         /*          Usage (X),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x95, 0x06,         /*          Report Count (6),           */
+0x75, 0x01,         /*          Report Size (1),            */
+0x25, 0x01,         /*          Logical Maximum (1),        */
+0x45, 0x01,         /*          Physical Maximum (1),       */
+0x05, 0x09,         /*          Usage Page (Button),        */
+0x19, 0x01,         /*          Usage Minimum (01h),        */
+0x29, 0x06,         /*          Usage Maximum (06h),        */
+0x81, 0x02,         /*          Input (Variable),           */
+0x95, 0x01,         /*          Report Count (1),           */
+0x75, 0x08,         /*          Report Size (8),            */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x09, 0x01,         /*          Usage (01h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0x05, 0x01,         /*          Usage Page (Desktop),       */
+0x81, 0x01,         /*          Input (Constant),           */
+0x09, 0x31,         /*          Usage (Y),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x09, 0x32,         /*          Usage (Z),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x06, 0x00, 0xFF,   /*          Usage Page (FF00h),         */
+0x09, 0x01,         /*          Usage (01h),                */
+0x81, 0x02,         /*          Input (Variable),           */
+0xC0,               /*      End Collection,                 */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x09, 0x02,         /*          Usage (02h),                */
+0x95, 0x07,         /*          Report Count (7),           */
+0x91, 0x02,         /*          Output (Variable),          */
+0xC0,               /*      End Collection,                 */
+0xC0                /*  End Collection                      */
+};
+
+static __u8 fg_rdesc_fixed[] = {
+0x05, 0x01,         /*  Usage Page (Desktop),               */
+0x09, 0x04,         /*  Usage (Joystik),                    */
+0xA1, 0x01,         /*  Collection (Application),           */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x15, 0x00,         /*          Logical Minimum (0),        */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
+0x35, 0x00,         /*          Physical Minimum (0),       */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */
+0x75, 0x08,         /*          Report Size (8),            */
+0x95, 0x01,         /*          Report Count (1),           */
+0x09, 0x30,         /*          Usage (X),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0xA4,               /*  Push,                               */
+0x25, 0x01,         /*          Logical Maximum (1),        */
+0x45, 0x01,         /*          Physical Maximum (1),       */
+0x75, 0x01,         /*          Report Size (1),            */
+0x95, 0x02,         /*          Report Count (2),           */
+0x81, 0x01,         /*          Input (Constant),           */
+0x95, 0x06,         /*          Report Count (6),           */
+0x05, 0x09,         /*          Usage Page (Button),        */
+0x19, 0x01,         /*          Usage Minimum (01h),        */
+0x29, 0x06,         /*          Usage Maximum (06h),        */
+0x81, 0x02,         /*          Input (Variable),           */
+0x05, 0x01,         /*          Usage Page (Desktop),       */
+0xB4,               /*  Pop,                                */
+0x81, 0x02,         /*          Input (Constant),           */
+0x09, 0x31,         /*          Usage (Y),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0x09, 0x32,         /*          Usage (Z),                  */
+0x81, 0x02,         /*          Input (Variable),           */
+0xC0,               /*      End Collection,                 */
+0xA1, 0x02,         /*      Collection (Logical),           */
+0x26, 0xFF, 0x00,   /*          Logical Maximum (255),      */
+0x46, 0xFF, 0x00,   /*          Physical Maximum (255),     */
+0x75, 0x08,         /*          Report Size (8),            */
+0x95, 0x04,         /*          Report Count (4),           */
+0x09, 0x02,         /*          Usage (02h),                */
+0xB1, 0x02,         /*          Feature (Variable),         */
+0xC0,               /*      End Collection,                 */
+0xC0                /*  End Collection,                     */
+};
+
+/*
+ * Certain Logitech keyboards send in report #3 keys which are far
+ * above the logical maximum described in descriptor. This extends
+ * the original value of 0x28c of logical maximum to 0x104d
+ */
+static
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,12,0)
+const
+#endif
+__u8 *lg_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+		unsigned int *rsize)
+{
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+
+	if ((drv_data->quirks & LG_RDESC) && *rsize >= 91 && rdesc[83] == 0x26 &&
+			rdesc[84] == 0x8c && rdesc[85] == 0x02) {
+		hid_info(hdev,
+			 "fixing up Logitech keyboard report descriptor\n");
+		rdesc[84] = rdesc[89] = 0x4d;
+		rdesc[85] = rdesc[90] = 0x10;
+	}
+	if ((drv_data->quirks & LG_RDESC_REL_ABS) && *rsize >= 51 &&
+			rdesc[32] == 0x81 && rdesc[33] == 0x06 &&
+			rdesc[49] == 0x81 && rdesc[50] == 0x06) {
+		hid_info(hdev,
+			 "fixing up rel/abs in Logitech report descriptor\n");
+		rdesc[33] = rdesc[50] = 0x02;
+	}
+
+	switch (hdev->product) {
+
+	case USB_DEVICE_ID_LOGITECH_WINGMAN_FG:
+		if (*rsize == FG_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Wingman Formula GP report descriptor\n");
+			rdesc = fg_rdesc_fixed;
+			*rsize = sizeof(fg_rdesc_fixed);
+		} else {
+			hid_info(hdev,
+				"rdesc size test failed for formula gp\n");
+		}
+		break;
+
+
+	case USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:
+		if (*rsize == FFG_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Wingman Formula Force GP report descriptor\n");
+			rdesc = ffg_rdesc_fixed;
+			*rsize = sizeof(ffg_rdesc_fixed);
+		}
+		break;
+
+	/* Several wheels report as this id when operating in emulation mode. */
+	case USB_DEVICE_ID_LOGITECH_WHEEL:
+		if (*rsize == DF_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Driving Force report descriptor\n");
+			rdesc = df_rdesc_fixed;
+			*rsize = sizeof(df_rdesc_fixed);
+		}
+		break;
+
+	case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:
+		if (*rsize == MOMO_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Momo Force (Red) report descriptor\n");
+			rdesc = momo_rdesc_fixed;
+			*rsize = sizeof(momo_rdesc_fixed);
+		}
+		break;
+
+	case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:
+		if (*rsize == MOMO2_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Momo Racing Force (Black) report descriptor\n");
+			rdesc = momo2_rdesc_fixed;
+			*rsize = sizeof(momo2_rdesc_fixed);
+		}
+		break;
+
+	case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:
+		if (*rsize == FV_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Formula Vibration report descriptor\n");
+			rdesc = fv_rdesc_fixed;
+			*rsize = sizeof(fv_rdesc_fixed);
+		}
+		break;
+
+	case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+		if (*rsize == DFP_RDESC_ORIG_SIZE) {
+			hid_info(hdev,
+				"fixing up Logitech Driving Force Pro report descriptor\n");
+			rdesc = dfp_rdesc_fixed;
+			*rsize = sizeof(dfp_rdesc_fixed);
+		}
+		break;
+
+	case USB_DEVICE_ID_LOGITECH_WII_WHEEL:
+		if (*rsize >= 101 && rdesc[41] == 0x95 && rdesc[42] == 0x0B &&
+				rdesc[47] == 0x05 && rdesc[48] == 0x09) {
+			hid_info(hdev, "fixing up Logitech Speed Force Wireless report descriptor\n");
+			rdesc[41] = 0x05;
+			rdesc[42] = 0x09;
+			rdesc[47] = 0x95;
+			rdesc[48] = 0x0B;
+		}
+		break;
+	}
+
+	return rdesc;
+}
+
+#define lg_map_key_clear(c)	hid_map_usage_clear(hi, usage, bit, max, \
+		EV_KEY, (c))
+
+static int lg_ultrax_remote_mapping(struct hid_input *hi,
+		struct hid_usage *usage, unsigned long **bit, int *max)
+{
+	if ((usage->hid & HID_USAGE_PAGE) != HID_UP_LOGIVENDOR)
+		return 0;
+
+	set_bit(EV_REP, hi->input->evbit);
+	switch (usage->hid & HID_USAGE) {
+	/* Reported on Logitech Ultra X Media Remote */
+	case 0x004: lg_map_key_clear(KEY_AGAIN);	break;
+	case 0x00d: lg_map_key_clear(KEY_HOME);		break;
+	case 0x024: lg_map_key_clear(KEY_SHUFFLE);	break;
+	case 0x025: lg_map_key_clear(KEY_TV);		break;
+	case 0x026: lg_map_key_clear(KEY_MENU);		break;
+	case 0x031: lg_map_key_clear(KEY_AUDIO);	break;
+	case 0x032: lg_map_key_clear(KEY_TEXT);		break;
+	case 0x033: lg_map_key_clear(KEY_LAST);		break;
+	case 0x047: lg_map_key_clear(KEY_MP3);		break;
+	case 0x048: lg_map_key_clear(KEY_DVD);		break;
+	case 0x049: lg_map_key_clear(KEY_MEDIA);	break;
+	case 0x04a: lg_map_key_clear(KEY_VIDEO);	break;
+	case 0x04b: lg_map_key_clear(KEY_ANGLE);	break;
+	case 0x04c: lg_map_key_clear(KEY_LANGUAGE);	break;
+	case 0x04d: lg_map_key_clear(KEY_SUBTITLE);	break;
+	case 0x051: lg_map_key_clear(KEY_RED);		break;
+	case 0x052: lg_map_key_clear(KEY_CLOSE);	break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static int lg_wireless_mapping(struct hid_input *hi, struct hid_usage *usage,
+		unsigned long **bit, int *max)
+{
+	if ((usage->hid & HID_USAGE_PAGE) != HID_UP_CONSUMER)
+		return 0;
+
+	switch (usage->hid & HID_USAGE) {
+	case 0x1001: lg_map_key_clear(KEY_MESSENGER);		break;
+	case 0x1003: lg_map_key_clear(KEY_SOUND);		break;
+	case 0x1004: lg_map_key_clear(KEY_VIDEO);		break;
+	case 0x1005: lg_map_key_clear(KEY_AUDIO);		break;
+	case 0x100a: lg_map_key_clear(KEY_DOCUMENTS);		break;
+	/* The following two entries are Playlist 1 and 2 on the MX3200 */
+	case 0x100f: lg_map_key_clear(KEY_FN_1);		break;
+	case 0x1010: lg_map_key_clear(KEY_FN_2);		break;
+	case 0x1011: lg_map_key_clear(KEY_PREVIOUSSONG);	break;
+	case 0x1012: lg_map_key_clear(KEY_NEXTSONG);		break;
+	case 0x1013: lg_map_key_clear(KEY_CAMERA);		break;
+	case 0x1014: lg_map_key_clear(KEY_MESSENGER);		break;
+	case 0x1015: lg_map_key_clear(KEY_RECORD);		break;
+	case 0x1016: lg_map_key_clear(KEY_PLAYER);		break;
+	case 0x1017: lg_map_key_clear(KEY_EJECTCD);		break;
+	case 0x1018: lg_map_key_clear(KEY_MEDIA);		break;
+	case 0x1019: lg_map_key_clear(KEY_PROG1);		break;
+	case 0x101a: lg_map_key_clear(KEY_PROG2);		break;
+	case 0x101b: lg_map_key_clear(KEY_PROG3);		break;
+	case 0x101c: lg_map_key_clear(KEY_CYCLEWINDOWS);	break;
+	case 0x101f: lg_map_key_clear(KEY_ZOOMIN);		break;
+	case 0x1020: lg_map_key_clear(KEY_ZOOMOUT);		break;
+	case 0x1021: lg_map_key_clear(KEY_ZOOMRESET);		break;
+	case 0x1023: lg_map_key_clear(KEY_CLOSE);		break;
+	case 0x1027: lg_map_key_clear(KEY_MENU);		break;
+	/* this one is marked as 'Rotate' */
+	case 0x1028: lg_map_key_clear(KEY_ANGLE);		break;
+	case 0x1029: lg_map_key_clear(KEY_SHUFFLE);		break;
+	case 0x102a: lg_map_key_clear(KEY_BACK);		break;
+	case 0x102b: lg_map_key_clear(KEY_CYCLEWINDOWS);	break;
+	case 0x102d: lg_map_key_clear(KEY_WWW);			break;
+	/* The following two are 'Start/answer call' and 'End/reject call'
+	   on the MX3200 */
+	case 0x1031: lg_map_key_clear(KEY_OK);			break;
+	case 0x1032: lg_map_key_clear(KEY_CANCEL);		break;
+	case 0x1041: lg_map_key_clear(KEY_BATTERY);		break;
+	case 0x1042: lg_map_key_clear(KEY_WORDPROCESSOR);	break;
+	case 0x1043: lg_map_key_clear(KEY_SPREADSHEET);		break;
+	case 0x1044: lg_map_key_clear(KEY_PRESENTATION);	break;
+	case 0x1045: lg_map_key_clear(KEY_UNDO);		break;
+	case 0x1046: lg_map_key_clear(KEY_REDO);		break;
+	case 0x1047: lg_map_key_clear(KEY_PRINT);		break;
+	case 0x1048: lg_map_key_clear(KEY_SAVE);		break;
+	case 0x1049: lg_map_key_clear(KEY_PROG1);		break;
+	case 0x104a: lg_map_key_clear(KEY_PROG2);		break;
+	case 0x104b: lg_map_key_clear(KEY_PROG3);		break;
+	case 0x104c: lg_map_key_clear(KEY_PROG4);		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static int lg_input_mapping(struct hid_device *hdev, struct hid_input *hi,
+		struct hid_field *field, struct hid_usage *usage,
+		unsigned long **bit, int *max)
+{
+	/* extended mapping for certain Logitech hardware (Logitech cordless
+	   desktop LX500) */
+	static const u8 e_keymap[] = {
+		  0,216,  0,213,175,156,  0,  0,  0,  0,
+		144,  0,  0,  0,  0,  0,  0,  0,  0,212,
+		174,167,152,161,112,  0,  0,  0,154,  0,
+		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+		  0,  0,  0,  0,  0,183,184,185,186,187,
+		188,189,190,191,192,193,194,  0,  0,  0
+	};
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+	unsigned int hid = usage->hid;
+
+	if (hdev->product == USB_DEVICE_ID_LOGITECH_RECEIVER &&
+			lg_ultrax_remote_mapping(hi, usage, bit, max))
+		return 1;
+
+	if ((drv_data->quirks & LG_WIRELESS) && lg_wireless_mapping(hi, usage, bit, max))
+		return 1;
+
+	if ((hid & HID_USAGE_PAGE) != HID_UP_BUTTON)
+		return 0;
+
+	hid &= HID_USAGE;
+
+	/* Special handling for Logitech Cordless Desktop */
+	if (field->application == HID_GD_MOUSE) {
+		if ((drv_data->quirks & LG_IGNORE_DOUBLED_WHEEL) &&
+				(hid == 7 || hid == 8))
+			return -1;
+	} else {
+		if ((drv_data->quirks & LG_EXPANDED_KEYMAP) &&
+				hid < ARRAY_SIZE(e_keymap) &&
+				e_keymap[hid] != 0) {
+			hid_map_usage(hi, usage, bit, max, EV_KEY,
+					e_keymap[hid]);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int lg_input_mapped(struct hid_device *hdev, struct hid_input *hi,
+		struct hid_field *field, struct hid_usage *usage,
+		unsigned long **bit, int *max)
+{
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+
+	if ((drv_data->quirks & LG_BAD_RELATIVE_KEYS) && usage->type == EV_KEY &&
+			(field->flags & HID_MAIN_ITEM_RELATIVE))
+		field->flags &= ~HID_MAIN_ITEM_RELATIVE;
+
+	if ((drv_data->quirks & LG_DUPLICATE_USAGES) && (usage->type == EV_KEY ||
+			 usage->type == EV_REL || usage->type == EV_ABS))
+		clear_bit(usage->code, *bit);
+
+	/* Ensure that Logitech wheels are not given a default fuzz/flat value */
+	if (usage->type == EV_ABS && (usage->code == ABS_X ||
+			usage->code == ABS_Y || usage->code == ABS_Z ||
+			usage->code == ABS_RZ)) {
+		switch (hdev->product) {
+		case USB_DEVICE_ID_LOGITECH_G29_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G923_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_WINGMAN_FG:
+		case USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:
+		case USB_DEVICE_ID_LOGITECH_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_WII_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:
+		case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL:
+			field->application = HID_GD_MULTIAXIS;
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int lg_event(struct hid_device *hdev, struct hid_field *field,
+		struct hid_usage *usage, __s32 value)
+{
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+
+	if ((drv_data->quirks & LG_INVERT_HWHEEL) && usage->code == REL_HWHEEL) {
+		input_event(field->hidinput->input, usage->type, usage->code,
+				-value);
+		return 1;
+	}
+	if (drv_data->quirks & LG_FF4) {
+		return lg4ff_adjust_input_event(hdev, field, usage, value, drv_data);
+	}
+
+	return 0;
+}
+
+static int lg_raw_event(struct hid_device *hdev, struct hid_report *report,
+		u8 *rd, int size)
+{
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+
+	if (drv_data->quirks & LG_FF4)
+		return lg4ff_raw_event(hdev, report, rd, size, drv_data);
+
+	return 0;
+}
+
+static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	struct usb_interface *iface;
+	__u8 iface_num;
+	unsigned int connect_mask = HID_CONNECT_DEFAULT;
+	struct lg_drv_data *drv_data;
+	int ret;
+
+	if (!hid_is_usb(hdev))
+		return -EINVAL;
+
+	iface = to_usb_interface(hdev->dev.parent);
+	iface_num = iface->cur_altsetting->desc.bInterfaceNumber;
+
+	/* G29 and G923 only work with the 1st interface */
+	if ((hdev->product == USB_DEVICE_ID_LOGITECH_G29_WHEEL ||
+		hdev->product == USB_DEVICE_ID_LOGITECH_G923_WHEEL ||
+		hdev->product == USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL) &&
+	    (iface_num != 0)) {
+		dbg_hid("%s: ignoring ifnum %d\n", __func__, iface_num);
+		return -ENODEV;
+	}
+
+	drv_data = kzalloc(sizeof(struct lg_drv_data), GFP_KERNEL);
+	if (!drv_data) {
+		hid_err(hdev, "Insufficient memory, cannot allocate driver data\n");
+		return -ENOMEM;
+	}
+	drv_data->quirks = id->driver_data;
+
+	hid_set_drvdata(hdev, (void *)drv_data);
+
+	if (drv_data->quirks & LG_NOGET)
+		hdev->quirks |= HID_QUIRK_NOGET;
+
+	ret = hid_parse(hdev);
+	if (ret) {
+		hid_err(hdev, "parse failed\n");
+		goto err_free;
+	}
+
+	if (drv_data->quirks & (LG_FF | LG_FF2 | LG_FF3 | LG_FF4))
+		connect_mask &= ~HID_CONNECT_FF;
+
+	ret = hid_hw_start(hdev, connect_mask);
+	if (ret) {
+		hid_err(hdev, "hw start failed\n");
+		goto err_free;
+	}
+
+	/* Setup wireless link with Logitech Wii wheel */
+	if (hdev->product == USB_DEVICE_ID_LOGITECH_WII_WHEEL) {
+		static const unsigned char cbuf[] = {
+			0x00, 0xAF,  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+		};
+		u8 *buf = kmemdup(cbuf, sizeof(cbuf), GFP_KERNEL);
+
+		if (!buf) {
+			ret = -ENOMEM;
+			goto err_stop;
+		}
+
+		ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),
+					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+		if (ret >= 0) {
+			/* insert a little delay of 10 jiffies ~ 40ms */
+			wait_queue_head_t wait;
+			init_waitqueue_head (&wait);
+			wait_event_interruptible_timeout(wait, 0,
+							 msecs_to_jiffies(40));
+
+			/* Select random Address */
+			buf[1] = 0xB2;
+			get_random_bytes(&buf[2], 2);
+
+			ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),
+					HID_FEATURE_REPORT, HID_REQ_SET_REPORT);
+		}
+		kfree(buf);
+	}
+
+	if (drv_data->quirks & LG_FF)
+		ret = lgff_init(hdev);
+	else if (drv_data->quirks & LG_FF2)
+		ret = lg2ff_init(hdev);
+	else if (drv_data->quirks & LG_FF3)
+		ret = lg3ff_init(hdev);
+	else if (drv_data->quirks & LG_FF4)
+		ret = lg4ff_init(hdev);
+
+	if (ret)
+		goto err_stop;
+
+	return 0;
+
+err_stop:
+	hid_hw_stop(hdev);
+err_free:
+	kfree(drv_data);
+	return ret;
+}
+
+static void lg_remove(struct hid_device *hdev)
+{
+	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
+	if (drv_data->quirks & LG_FF4)
+		lg4ff_deinit(hdev);
+	hid_hw_stop(hdev);
+	kfree(drv_data);
+}
+
+static const struct hid_device_id lg_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_S510_RECEIVER),
+		.driver_data = LG_RDESC | LG_WIRELESS },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RECEIVER),
+		.driver_data = LG_BAD_RELATIVE_KEYS },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_DINOVO_DESKTOP),
+		.driver_data = LG_DUPLICATE_USAGES },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_ELITE_KBD),
+		.driver_data = LG_IGNORE_DOUBLED_WHEEL | LG_EXPANDED_KEYMAP },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500),
+		.driver_data = LG_IGNORE_DOUBLED_WHEEL | LG_EXPANDED_KEYMAP },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_EXTREME_3D),
+		.driver_data = LG_NOGET },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DUAL_ACTION),
+		.driver_data = LG_NOGET },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WHEEL),
+		.driver_data = LG_NOGET | LG_FF4 },
+
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD),
+		.driver_data = LG_FF2 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD),
+		.driver_data = LG_FF },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2),
+		.driver_data = LG_FF },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G29_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G923_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_F3D),
+		.driver_data = LG_FF },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FORCE3D_PRO),
+		.driver_data = LG_FF },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL),
+		.driver_data = LG_NOGET | LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL),
+		.driver_data = LG_FF2 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFGT_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G27_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DFP_WHEEL),
+		.driver_data = LG_NOGET | LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WII_WHEEL),
+		.driver_data = LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FG),
+		.driver_data = LG_NOGET },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WINGMAN_FFG),
+		.driver_data = LG_NOGET | LG_FF4 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2),
+		.driver_data = LG_NOGET | LG_FF2 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940),
+		.driver_data = LG_FF3 },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACENAVIGATOR),
+		.driver_data = LG_RDESC_REL_ABS },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER),
+		.driver_data = LG_RDESC_REL_ABS },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(hid, lg_devices);
+
+static struct hid_driver lg_driver = {
+	.name = "logitech",
+	.id_table = lg_devices,
+	.report_fixup = lg_report_fixup,
+	.input_mapping = lg_input_mapping,
+	.input_mapped = lg_input_mapped,
+	.event = lg_event,
+	.raw_event = lg_raw_event,
+	.probe = lg_probe,
+	.remove = lg_remove,
+};
+module_hid_driver(lg_driver);
+
+#ifdef CONFIG_LOGIWHEELS_FF
+int lg4ff_no_autoswitch = 0;
+module_param_named(lg4ff_no_autoswitch, lg4ff_no_autoswitch, int, S_IRUGO);
+MODULE_PARM_DESC(lg4ff_no_autoswitch, "Do not switch multimode wheels to their native mode automatically");
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION(VERSION);
diff --git a/drivers/custom/lg4ff/hid-lg.h b/drivers/custom/lg4ff/hid-lg.h
new file mode 100644
index 000000000000..df1f83ea9783
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __HID_LG_H
+#define __HID_LG_H
+
+#define VERSION "0.5.0"
+
+struct lg_drv_data {
+	unsigned long quirks;
+	void *device_props;	/* Device specific properties */
+};
+
+#ifdef CONFIG_LOGITECH_FF
+int lgff_init(struct hid_device *hdev);
+#else
+static inline int lgff_init(struct hid_device *hdev) { return -1; }
+#endif
+
+#ifdef CONFIG_LOGIRUMBLEPAD2_FF
+int lg2ff_init(struct hid_device *hdev);
+#else
+static inline int lg2ff_init(struct hid_device *hdev) { return -1; }
+#endif
+
+#ifdef CONFIG_LOGIG940_FF
+int lg3ff_init(struct hid_device *hdev);
+#else
+static inline int lg3ff_init(struct hid_device *hdev) { return -1; }
+#endif
+
+#endif
diff --git a/drivers/custom/lg4ff/hid-lg2ff.c b/drivers/custom/lg4ff/hid-lg2ff.c
new file mode 100644
index 000000000000..73d07e35f12a
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg2ff.c
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  Force feedback support for Logitech RumblePad and Rumblepad 2
+ *
+ *  Copyright (c) 2008 Anssi Hannula <anssi.hannula@gmail.com>
+ */
+
+/*
+ */
+
+
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/hid.h>
+
+#include "hid-lg.h"
+
+struct lg2ff_device {
+	struct hid_report *report;
+};
+
+static int play_effect(struct input_dev *dev, void *data,
+			 struct ff_effect *effect)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct lg2ff_device *lg2ff = data;
+	int weak, strong;
+
+	strong = effect->u.rumble.strong_magnitude;
+	weak = effect->u.rumble.weak_magnitude;
+
+	if (weak || strong) {
+		weak = weak * 0xff / 0xffff;
+		strong = strong * 0xff / 0xffff;
+
+		lg2ff->report->field[0]->value[0] = 0x51;
+		lg2ff->report->field[0]->value[2] = weak;
+		lg2ff->report->field[0]->value[4] = strong;
+	} else {
+		lg2ff->report->field[0]->value[0] = 0xf3;
+		lg2ff->report->field[0]->value[2] = 0x00;
+		lg2ff->report->field[0]->value[4] = 0x00;
+	}
+
+	hid_hw_request(hid, lg2ff->report, HID_REQ_SET_REPORT);
+	return 0;
+}
+
+int lg2ff_init(struct hid_device *hid)
+{
+	struct lg2ff_device *lg2ff;
+	struct hid_report *report;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
+	int error;
+
+	if (list_empty(&hid->inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	dev = hidinput->input;
+
+	/* Check that the report looks ok */
+	report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);
+	if (!report)
+		return -ENODEV;
+
+	lg2ff = kmalloc(sizeof(struct lg2ff_device), GFP_KERNEL);
+	if (!lg2ff)
+		return -ENOMEM;
+
+	set_bit(FF_RUMBLE, dev->ffbit);
+
+	error = input_ff_create_memless(dev, lg2ff, play_effect);
+	if (error) {
+		kfree(lg2ff);
+		return error;
+	}
+
+	lg2ff->report = report;
+	report->field[0]->value[0] = 0xf3;
+	report->field[0]->value[1] = 0x00;
+	report->field[0]->value[2] = 0x00;
+	report->field[0]->value[3] = 0x00;
+	report->field[0]->value[4] = 0x00;
+	report->field[0]->value[5] = 0x00;
+	report->field[0]->value[6] = 0x00;
+
+	hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+
+	hid_info(hid, "Force feedback for Logitech variant 2 rumble devices by Anssi Hannula <anssi.hannula@gmail.com>\n");
+
+	return 0;
+}
diff --git a/drivers/custom/lg4ff/hid-lg3ff.c b/drivers/custom/lg4ff/hid-lg3ff.c
new file mode 100644
index 000000000000..b7e1949f3cf7
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg3ff.c
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  Force feedback support for Logitech Flight System G940
+ *
+ *  Copyright (c) 2009 Gary Stein <LordCnidarian@gmail.com>
+ */
+
+/*
+ */
+
+
+#include <linux/input.h>
+#include <linux/hid.h>
+
+#include "hid-lg.h"
+
+/*
+ * G940 Theory of Operation (from experimentation)
+ *
+ * There are 63 fields (only 3 of them currently used)
+ * 0 - seems to be command field
+ * 1 - 30 deal with the x axis
+ * 31 -60 deal with the y axis
+ *
+ * Field 1 is x axis constant force
+ * Field 31 is y axis constant force
+ *
+ * other interesting fields 1,2,3,4 on x axis
+ * (same for 31,32,33,34 on y axis)
+ *
+ * 0 0 127 127 makes the joystick autocenter hard
+ *
+ * 127 0 127 127 makes the joystick loose on the right,
+ * but stops all movemnt left
+ *
+ * -127 0 -127 -127 makes the joystick loose on the left,
+ * but stops all movement right
+ *
+ * 0 0 -127 -127 makes the joystick rattle very hard
+ *
+ * I'm sure these are effects that I don't know enough about them
+ */
+
+struct lg3ff_device {
+	struct hid_report *report;
+};
+
+static int hid_lg3ff_play(struct input_dev *dev, void *data,
+			 struct ff_effect *effect)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report = list_entry(report_list->next, struct hid_report, list);
+	int x, y;
+
+/*
+ * Available values in the field should always be 63, but we only use up to
+ * 35. Instead, clear the entire area, however big it is.
+ */
+	memset(report->field[0]->value, 0,
+	       sizeof(__s32) * report->field[0]->report_count);
+
+	switch (effect->type) {
+	case FF_CONSTANT:
+/*
+ * Already clamped in ff_memless
+ * 0 is center (different then other logitech)
+ */
+		x = effect->u.ramp.start_level;
+		y = effect->u.ramp.end_level;
+
+		/* send command byte */
+		report->field[0]->value[0] = 0x51;
+
+/*
+ * Sign backwards from other Force3d pro
+ * which get recast here in two's complement 8 bits
+ */
+		report->field[0]->value[1] = (unsigned char)(-x);
+		report->field[0]->value[31] = (unsigned char)(-y);
+
+		hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+		break;
+	}
+	return 0;
+}
+static void hid_lg3ff_set_autocenter(struct input_dev *dev, u16 magnitude)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report = list_entry(report_list->next, struct hid_report, list);
+
+/*
+ * Auto Centering probed from device
+ * NOTE: deadman's switch on G940 must be covered
+ * for effects to work
+ */
+	report->field[0]->value[0] = 0x51;
+	report->field[0]->value[1] = 0x00;
+	report->field[0]->value[2] = 0x00;
+	report->field[0]->value[3] = 0x7F;
+	report->field[0]->value[4] = 0x7F;
+	report->field[0]->value[31] = 0x00;
+	report->field[0]->value[32] = 0x00;
+	report->field[0]->value[33] = 0x7F;
+	report->field[0]->value[34] = 0x7F;
+
+	hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+}
+
+
+static const signed short ff3_joystick_ac[] = {
+	FF_CONSTANT,
+	FF_AUTOCENTER,
+	-1
+};
+
+int lg3ff_init(struct hid_device *hid)
+{
+	struct hid_input *hidinput;
+	struct input_dev *dev;
+	const signed short *ff_bits = ff3_joystick_ac;
+	int error;
+	int i;
+
+	if (list_empty(&hid->inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	dev = hidinput->input;
+
+	/* Check that the report looks ok */
+	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))
+		return -ENODEV;
+
+	/* Assume single fixed device G940 */
+	for (i = 0; ff_bits[i] >= 0; i++)
+		set_bit(ff_bits[i], dev->ffbit);
+
+	error = input_ff_create_memless(dev, NULL, hid_lg3ff_play);
+	if (error)
+		return error;
+
+	if (test_bit(FF_AUTOCENTER, dev->ffbit))
+		dev->ff->set_autocenter = hid_lg3ff_set_autocenter;
+
+	hid_info(hid, "Force feedback for Logitech Flight System G940 by Gary Stein <LordCnidarian@gmail.com>\n");
+	return 0;
+}
+
diff --git a/drivers/custom/lg4ff/hid-lg4ff.c b/drivers/custom/lg4ff/hid-lg4ff.c
new file mode 100644
index 000000000000..b7721fbcb34c
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg4ff.c
@@ -0,0 +1,2571 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  Force feedback support for Logitech Gaming Wheels
+ *
+ *  Including G27, G25, DFP, DFGT, FFEX, Momo, Momo2 &
+ *  Speed Force Wireless (WiiWheel)
+ *
+ *  Copyright (c) 2010 Simon Wood <simon@mungewell.org>
+ *  Copyright (c) 2019 Bernat Arlandis <berarma@hotmail.com>
+ */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/usb.h>
+#include <linux/hid.h>
+#include <linux/fixp-arith.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/version.h>
+
+#include "usbhid/usbhid.h"
+#include "hid-lg.h"
+#include "hid-lg4ff.h"
+#include "hid-ids.h"
+
+#define LG4FF_MMODE_IS_MULTIMODE 0
+#define LG4FF_MMODE_SWITCHED 1
+#define LG4FF_MMODE_NOT_MULTIMODE 2
+
+/* Device has a "friction" effect in firmware */
+#define LG4FF_CAP_FRICTION 1
+
+#define LG4FF_MODE_NATIVE_IDX 0
+#define LG4FF_MODE_DFEX_IDX 1
+#define LG4FF_MODE_DFP_IDX 2
+#define LG4FF_MODE_G25_IDX 3
+#define LG4FF_MODE_DFGT_IDX 4
+#define LG4FF_MODE_G27_IDX 5
+#define LG4FF_MODE_G29_IDX 6
+#define LG4FF_MODE_G923_PS_IDX 7
+#define LG4FF_MODE_G923_IDX 8
+#define LG4FF_MODE_MAX_IDX 9
+
+#define LG4FF_MODE_NATIVE BIT(LG4FF_MODE_NATIVE_IDX)
+#define LG4FF_MODE_DFEX BIT(LG4FF_MODE_DFEX_IDX)
+#define LG4FF_MODE_DFP BIT(LG4FF_MODE_DFP_IDX)
+#define LG4FF_MODE_G25 BIT(LG4FF_MODE_G25_IDX)
+#define LG4FF_MODE_DFGT BIT(LG4FF_MODE_DFGT_IDX)
+#define LG4FF_MODE_G27 BIT(LG4FF_MODE_G27_IDX)
+#define LG4FF_MODE_G29 BIT(LG4FF_MODE_G29_IDX)
+#define LG4FF_MODE_G923_PS BIT(LG4FF_MODE_G923_PS_IDX)
+#define LG4FF_MODE_G923 BIT(LG4FF_MODE_G923_IDX)
+
+#define LG4FF_DFEX_TAG "DF-EX"
+#define LG4FF_DFEX_NAME "Driving Force / Formula EX"
+#define LG4FF_DFP_TAG "DFP"
+#define LG4FF_DFP_NAME "Driving Force Pro"
+#define LG4FF_G25_TAG "G25"
+#define LG4FF_G25_NAME "G25 Racing Wheel"
+#define LG4FF_G27_TAG "G27"
+#define LG4FF_G27_NAME "G27 Racing Wheel"
+#define LG4FF_G29_TAG "G29"
+#define LG4FF_G29_NAME "G29 Racing Wheel"
+#define LG4FF_G923_TAG "G923"
+#define LG4FF_G923_NAME "G923 Racing Wheel"
+#define LG4FF_G923_PS_TAG "G923"
+#define LG4FF_G923_PS_NAME "G923 Racing Wheel (Playstation mode)"
+#define LG4FF_DFGT_TAG "DFGT"
+#define LG4FF_DFGT_NAME "Driving Force GT"
+
+#define LG4FF_FFEX_REV_MAJ 0x21
+#define LG4FF_FFEX_REV_MIN 0x00
+
+#define DEBUG(...) pr_debug("lg4ff: " __VA_ARGS__)
+#define time_diff(a,b) ({ \
+		typecheck(unsigned long, a); \
+		typecheck(unsigned long, b); \
+		((a) - (long)(b)); })
+#define CLAMP_VALUE_U16(x) ((unsigned short)((x) > 0xffff ? 0xffff : (x)))
+#define CLAMP_VALUE_S16(x) ((unsigned short)((x) <= -0x8000 ? -0x8000 : ((x) > 0x7fff ? 0x7fff : (x))))
+#define SCALE_VALUE_U16(x, bits) (CLAMP_VALUE_U16(x) >> (16 - bits))
+#define SCALE_COEFF(x, bits) SCALE_VALUE_U16(abs(x) * 2, bits)
+#define TRANSLATE_FORCE(x) ((CLAMP_VALUE_S16(x) + 0x8000) >> 8)
+#define STOP_EFFECT(state) ((state)->flags = 0)
+#define JIFFIES2MS(jiffies) ((jiffies) * 1000 / HZ)
+#undef fixp_sin16
+#define fixp_sin16(v) (((v % 360) > 180)? -(fixp_sin32((v % 360) - 180) >> 16) : fixp_sin32(v) >> 16)
+
+#define DEFAULT_TIMER_PERIOD 2
+#define LG4FF_MAX_EFFECTS 16
+
+#define FF_EFFECT_STARTED 0
+#define FF_EFFECT_ALLSET 1
+#define FF_EFFECT_PLAYING 2
+#define FF_EFFECT_UPDATING 3
+
+struct lg4ff_effect_state {
+	struct ff_effect effect;
+	struct ff_envelope *envelope;
+	unsigned long start_at;
+	unsigned long play_at;
+	unsigned long stop_at;
+	unsigned long flags;
+	unsigned long time_playing;
+	unsigned long updated_at;
+	unsigned int phase;
+	unsigned int phase_adj;
+	unsigned int count;
+	unsigned int cmd;
+	unsigned int cmd_start_time;
+	unsigned int cmd_start_count;
+	int direction_gain;
+	int slope;
+	unsigned int slot;
+};
+
+struct lg4ff_effect_parameters {
+	int level;
+	int d1;
+	int d2;
+	int k1;
+	int k2;
+	unsigned int clip;
+};
+
+struct lg4ff_slot {
+	int id;
+	struct lg4ff_effect_parameters parameters;
+	u8 current_cmd[7];
+	int cmd_op;
+	int is_updated;
+	int effect_type;
+};
+
+struct lg4ff_wheel_data {
+	const u32 product_id;
+	u16 combine;
+	u16 range;
+	u16 autocenter;
+	u16 master_gain;
+	u16 gain;
+	const u16 min_range;
+	const u16 max_range;
+#ifdef CONFIG_LEDS_CLASS
+	u8  led_state;
+	struct led_classdev *led[5];
+#endif
+	const u32 alternate_modes;
+	const char * const real_tag;
+	const char * const real_name;
+	const u16 real_product_id;
+	const u16 capabilities;
+
+	void (*set_range)(struct hid_device *hid, u16 range);
+};
+
+struct lg4ff_device_entry {
+	spinlock_t report_lock; /* Protect output HID report */
+	spinlock_t timer_lock;
+	struct hid_report *report;
+	struct lg4ff_wheel_data wdata;
+	struct hid_device *hid;
+	struct timer_list timer;
+	struct hrtimer hrtimer;
+	struct lg4ff_slot slots[4];
+	struct lg4ff_effect_state states[LG4FF_MAX_EFFECTS];
+	unsigned peak_ffb_level;
+	int effects_used;
+#ifdef CONFIG_LEDS_CLASS
+	int has_leds;
+#endif
+};
+
+static const signed short lg4ff_wheel_effects[] = {
+	FF_CONSTANT,
+	FF_SPRING,
+	FF_DAMPER,
+	FF_AUTOCENTER,
+	FF_PERIODIC,
+	FF_SINE,
+	FF_SQUARE,
+	FF_TRIANGLE,
+	FF_SAW_UP,
+	FF_SAW_DOWN,
+	FF_RAMP,
+	FF_FRICTION,
+	FF_INERTIA,
+	-1
+};
+
+static const signed short no_wheel_effects[] = {
+	-1
+};
+
+struct lg4ff_wheel {
+	const u32 product_id;
+	const signed short *ff_effects;
+	const u16 min_range;
+	const u16 max_range;
+	const u16 capabilities;
+	void (*set_range)(struct hid_device *hid, u16 range);
+};
+
+struct lg4ff_compat_mode_switch {
+	const u8 cmd_count;	/* Number of commands to send */
+	const u8 cmd[];
+};
+
+struct lg4ff_wheel_ident_info {
+	const u32 modes;
+	const u16 mask;
+	const u16 result;
+	const u16 real_product_id;
+};
+
+struct lg4ff_multimode_wheel {
+	const u16 product_id;
+	const u32 alternate_modes;
+	const char *real_tag;
+	const char *real_name;
+};
+
+struct lg4ff_alternate_mode {
+	const u16 product_id;
+	const char *tag;
+	const char *name;
+};
+
+static void lg4ff_set_range_dfp(struct hid_device *hid, u16 range);
+static void lg4ff_set_range_g25(struct hid_device *hid, u16 range);
+#ifdef CONFIG_LEDS_CLASS
+static void lg4ff_set_leds(struct hid_device *hid, u8 leds);
+#endif
+
+static const struct lg4ff_wheel lg4ff_devices[] = {
+	{USB_DEVICE_ID_LOGITECH_WINGMAN_FG,
+		no_wheel_effects,    40, 180, 0,                  NULL},
+	{USB_DEVICE_ID_LOGITECH_WINGMAN_FFG,
+		lg4ff_wheel_effects, 40, 180, 0,                  NULL},
+	{USB_DEVICE_ID_LOGITECH_WHEEL,
+		lg4ff_wheel_effects, 40, 270, 0,                  NULL},
+	{USB_DEVICE_ID_LOGITECH_MOMO_WHEEL,
+		lg4ff_wheel_effects, 40, 270, 0,                  NULL},
+	{USB_DEVICE_ID_LOGITECH_DFP_WHEEL,
+		lg4ff_wheel_effects, 40, 900, LG4FF_CAP_FRICTION, lg4ff_set_range_dfp},
+	{USB_DEVICE_ID_LOGITECH_G25_WHEEL,
+		lg4ff_wheel_effects, 40, 900, LG4FF_CAP_FRICTION, lg4ff_set_range_g25},
+	{USB_DEVICE_ID_LOGITECH_DFGT_WHEEL,
+		lg4ff_wheel_effects, 40, 900, LG4FF_CAP_FRICTION, lg4ff_set_range_g25},
+	{USB_DEVICE_ID_LOGITECH_G27_WHEEL,
+		lg4ff_wheel_effects, 40, 900, LG4FF_CAP_FRICTION, lg4ff_set_range_g25},
+	{USB_DEVICE_ID_LOGITECH_G29_WHEEL,
+		lg4ff_wheel_effects, 40, 900, 0,                  lg4ff_set_range_g25},
+	{USB_DEVICE_ID_LOGITECH_G923_WHEEL,
+		lg4ff_wheel_effects, 40, 900, 0,                  lg4ff_set_range_g25},
+	{USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2,
+		lg4ff_wheel_effects, 40, 270, 0,                  NULL},
+	{USB_DEVICE_ID_LOGITECH_WII_WHEEL,
+		lg4ff_wheel_effects, 40, 270, 0,                  NULL}
+};
+
+static const struct lg4ff_multimode_wheel lg4ff_multimode_wheels[] = {
+	{USB_DEVICE_ID_LOGITECH_DFP_WHEEL,
+	 LG4FF_MODE_NATIVE | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	 LG4FF_DFP_TAG, LG4FF_DFP_NAME},
+	{USB_DEVICE_ID_LOGITECH_G25_WHEEL,
+	 LG4FF_MODE_NATIVE | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	 LG4FF_G25_TAG, LG4FF_G25_NAME},
+	{USB_DEVICE_ID_LOGITECH_DFGT_WHEEL,
+	 LG4FF_MODE_NATIVE | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	 LG4FF_DFGT_TAG, LG4FF_DFGT_NAME},
+	{USB_DEVICE_ID_LOGITECH_G27_WHEEL,
+	 LG4FF_MODE_NATIVE | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	 LG4FF_G27_TAG, LG4FF_G27_NAME},
+	{USB_DEVICE_ID_LOGITECH_G29_WHEEL,
+	 LG4FF_MODE_NATIVE | LG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	 LG4FF_G29_TAG, LG4FF_G29_NAME},
+	{USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL,
+	 LG4FF_MODE_G923_PS | LG4FF_MODE_G923,
+	 LG4FF_G923_PS_TAG, LG4FF_G923_PS_NAME},
+	{USB_DEVICE_ID_LOGITECH_G923_WHEEL,
+	 LG4FF_MODE_G923,
+	 LG4FF_G923_TAG, LG4FF_G923_NAME},
+};
+
+static const struct lg4ff_alternate_mode lg4ff_alternate_modes[] = {
+	[LG4FF_MODE_NATIVE_IDX] = {0, "native", ""},
+	[LG4FF_MODE_DFEX_IDX] = {USB_DEVICE_ID_LOGITECH_WHEEL, LG4FF_DFEX_TAG, LG4FF_DFEX_NAME},
+	[LG4FF_MODE_DFP_IDX] = {USB_DEVICE_ID_LOGITECH_DFP_WHEEL, LG4FF_DFP_TAG, LG4FF_DFP_NAME},
+	[LG4FF_MODE_G25_IDX] = {USB_DEVICE_ID_LOGITECH_G25_WHEEL, LG4FF_G25_TAG, LG4FF_G25_NAME},
+	[LG4FF_MODE_DFGT_IDX] = {USB_DEVICE_ID_LOGITECH_DFGT_WHEEL, LG4FF_DFGT_TAG, LG4FF_DFGT_NAME},
+	[LG4FF_MODE_G27_IDX] = {USB_DEVICE_ID_LOGITECH_G27_WHEEL, LG4FF_G27_TAG, LG4FF_G27_NAME},
+	[LG4FF_MODE_G29_IDX] = {USB_DEVICE_ID_LOGITECH_G29_WHEEL, LG4FF_G29_TAG, LG4FF_G29_NAME},
+	[LG4FF_MODE_G923_PS_IDX] = {USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL, LG4FF_G923_PS_TAG, LG4FF_G923_PS_NAME},
+	[LG4FF_MODE_G923_IDX] = {USB_DEVICE_ID_LOGITECH_G923_WHEEL, LG4FF_G923_TAG, LG4FF_G923_NAME},
+};
+
+/* Multimode wheel identificators */
+static const struct lg4ff_wheel_ident_info lg4ff_dfp_ident_info = {
+	LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xf000,
+	0x1000,
+	USB_DEVICE_ID_LOGITECH_DFP_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_g25_ident_info = {
+	LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xff00,
+	0x1200,
+	USB_DEVICE_ID_LOGITECH_G25_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_g27_ident_info = {
+	LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xfff0,
+	0x1230,
+	USB_DEVICE_ID_LOGITECH_G27_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_dfgt_ident_info = {
+	LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xff00,
+	0x1300,
+	USB_DEVICE_ID_LOGITECH_DFGT_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_g29_ident_info = {
+	LG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xfff8,
+	0x1350,
+	USB_DEVICE_ID_LOGITECH_G29_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_g29_ident_info2 = {
+	LG4FF_MODE_G29 | LG4FF_MODE_G27 | LG4FF_MODE_G25 | LG4FF_MODE_DFGT | LG4FF_MODE_DFP | LG4FF_MODE_DFEX,
+	0xff00,
+	0x8900,
+	USB_DEVICE_ID_LOGITECH_G29_WHEEL
+};
+
+static const struct lg4ff_wheel_ident_info lg4ff_g923_ident_info = {
+	LG4FF_MODE_G923_PS | LG4FF_MODE_G923,
+	0xff00,
+	0x3800,
+	USB_DEVICE_ID_LOGITECH_G923_WHEEL
+};
+
+
+/* Multimode wheel identification checklists */
+static const struct lg4ff_wheel_ident_info *lg4ff_main_checklist[] = {
+	&lg4ff_g29_ident_info,
+	&lg4ff_g29_ident_info2,
+	&lg4ff_g923_ident_info,
+	&lg4ff_dfgt_ident_info,
+	&lg4ff_g27_ident_info,
+	&lg4ff_g25_ident_info,
+	&lg4ff_dfp_ident_info
+};
+
+/* Compatibility mode switching commands */
+/* EXT_CMD9 - Understood by G27 and DFGT */
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfex = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00}	/* Switch mode to DF-EX with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfp = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00}	/* Switch mode to DFP with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g25 = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x02, 0x01, 0x00, 0x00, 0x00}	/* Switch mode to G25 with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_dfgt = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x03, 0x01, 0x00, 0x00, 0x00}	/* Switch mode to DFGT with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g27 = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x04, 0x01, 0x00, 0x00, 0x00}	/* Switch mode to G27 with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g29 = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x05, 0x01, 0x01, 0x00, 0x00}	/* Switch mode to G29 with detach */
+};
+
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext09_g923 = {
+	2,
+	{0xf8, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,	/* Revert mode upon USB reset */
+	 0xf8, 0x09, 0x07, 0x01, 0x01, 0x00, 0x00}	/* Switch mode to G923 with detach */
+};
+
+/* EXT_CMD1 - Understood by DFP, G25, G27 and DFGT */
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext01_dfp = {
+	1,
+	{0xf8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}
+};
+
+/* EXT_CMD16 - Understood by G25 and G27 */
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_ext16_g25 = {
+	1,
+	{0xf8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00}
+};
+
+/* 0x30 - PS mode - Understood by G923 PS */
+// Report ID must be 0x30
+static const struct lg4ff_compat_mode_switch lg4ff_mode_switch_30_g923 = {
+	1,
+	{0xf8, 0x09, 0x07, 0x01, 0x01, 0x00, 0x00}	/* Switch mode to G923 with detach */
+};
+
+static int timer_msecs = DEFAULT_TIMER_PERIOD;
+module_param(timer_msecs, int, 0660);
+MODULE_PARM_DESC(timer_msecs, "Timer resolution in msecs.");
+
+static int fixed_loop = 0;
+module_param(fixed_loop, int, 0);
+MODULE_PARM_DESC(fixed_loop, "Put the device into fixed loop mode.");
+
+static int timer_mode = 2;
+module_param(timer_mode, int, 0660);
+MODULE_PARM_DESC(timer_mode, "Timer mode: 0) fixed, 1) static, 2) dynamic (default).");
+
+static int profile = 0;
+module_param(profile, int, 0660);
+MODULE_PARM_DESC(profile, "Enable profile debug messages.");
+
+#ifdef CONFIG_LEDS_CLASS
+static int ffb_leds = 0;
+module_param(ffb_leds, int, 0);
+MODULE_PARM_DESC(ffb_leds, "Use leds to display FFB levels for calibration.");
+#endif
+
+static int spring_level = 30;
+module_param(spring_level, int, 0);
+MODULE_PARM_DESC(spring_level, "Level of spring force (0-100).");
+
+static int damper_level = 30;
+module_param(damper_level, int, 0);
+MODULE_PARM_DESC(damper_level, "Level of damper force (0-100).");
+
+static int friction_level = 30;
+module_param(friction_level, int, 0);
+MODULE_PARM_DESC(friction_level, "Level of friction force (0-100).");
+
+static struct lg4ff_device_entry *lg4ff_get_device_entry(struct hid_device *hid)
+{
+	struct lg_drv_data *drv_data;
+	struct lg4ff_device_entry *entry;
+	if (!hid) {
+		hid_err(hid, "HID not found!\n");
+		return NULL;
+	}
+	drv_data = hid_get_drvdata(hid);
+	if (!drv_data) {
+		hid_err(hid, "Private driver data not found!\n");
+		return NULL;
+	}
+
+	entry = drv_data->device_props;
+	if (!entry) {
+		hid_err(hid, "Device properties not found!\n");
+		return NULL;
+	}
+
+	return entry;
+}
+
+static void lg4ff_send_cmd_with_id(struct lg4ff_device_entry *entry, u8 *cmd, u8 id) {
+	unsigned long flags;
+	s32 *value = entry->report->field[0]->value;
+
+	spin_lock_irqsave(&entry->report_lock, flags);
+	entry->report->id = id;
+	value[0] = cmd[0];
+	value[1] = cmd[1];
+	value[2] = cmd[2];
+	value[3] = cmd[3];
+	value[4] = cmd[4];
+	value[5] = cmd[5];
+	value[6] = cmd[6];
+	hid_hw_request(entry->hid, entry->report, HID_REQ_SET_REPORT);
+	spin_unlock_irqrestore(&entry->report_lock, flags);
+	DEBUG("send_cmd: %02X %02X %02X %02X %02X %02X %02X %02X\n", id, cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6]);
+}
+
+static void lg4ff_send_cmd(struct lg4ff_device_entry *entry, u8 *cmd)
+{
+	unsigned long flags;
+	s32 *value = entry->report->field[0]->value;
+
+	spin_lock_irqsave(&entry->report_lock, flags);
+	value[0] = cmd[0];
+	value[1] = cmd[1];
+	value[2] = cmd[2];
+	value[3] = cmd[3];
+	value[4] = cmd[4];
+	value[5] = cmd[5];
+	value[6] = cmd[6];
+	hid_hw_request(entry->hid, entry->report, HID_REQ_SET_REPORT);
+	spin_unlock_irqrestore(&entry->report_lock, flags);
+	DEBUG("send_cmd: %02X %02X %02X %02X %02X %02X %02X", cmd[0], cmd[1], cmd[2], cmd[3], cmd[4], cmd[5], cmd[6]);
+}
+
+static void lg4ff_update_slot(struct lg4ff_slot *slot, struct lg4ff_effect_parameters *parameters)
+{
+	u8 original_cmd[7];
+	int d1;
+	int d2;
+	int k1;
+	int k2;
+	int s1;
+	int s2;
+
+	memcpy(original_cmd, slot->current_cmd, sizeof(original_cmd));
+
+	if ((original_cmd[0] & 0xf) == 1) {
+		original_cmd[0] = (original_cmd[0] & 0xf0) + 0xc;
+	}
+
+	if (slot->effect_type == FF_CONSTANT) {
+		if (slot->cmd_op == 0) {
+			slot->cmd_op = 1;
+		} else {
+			slot->cmd_op = 0xc;
+		}
+	} else {
+		if (parameters->clip == 0 || slot->effect_type == 0) {
+			slot->cmd_op = 3;
+		} else if (slot->cmd_op == 3) {
+			slot->cmd_op = 1;
+		} else {
+			slot->cmd_op = 0xc;
+		}
+	}
+
+	slot->current_cmd[0] = (0x10 << slot->id) + slot->cmd_op;
+
+	if (slot->cmd_op == 3) {
+		slot->current_cmd[1] = 0;
+		slot->current_cmd[2] = 0;
+		slot->current_cmd[3] = 0;
+		slot->current_cmd[4] = 0;
+		slot->current_cmd[5] = 0;
+		slot->current_cmd[6] = 0;
+	} else {
+		switch (slot->effect_type) {
+			case FF_CONSTANT:
+				slot->current_cmd[1] = 0x00;
+				slot->current_cmd[2] = 0;
+				slot->current_cmd[3] = 0;
+				slot->current_cmd[4] = 0;
+				slot->current_cmd[5] = 0;
+				slot->current_cmd[6] = 0;
+				slot->current_cmd[2 + slot->id] = TRANSLATE_FORCE(parameters->level);
+				break;
+			case FF_SPRING:
+				d1 = SCALE_VALUE_U16(((parameters->d1) + 0x8000) & 0xffff, 11);
+				d2 = SCALE_VALUE_U16(((parameters->d2) + 0x8000) & 0xffff, 11);
+				s1 = parameters->k1 < 0;
+				s2 = parameters->k2 < 0;
+				k1 = abs(parameters->k1);
+				k2 = abs(parameters->k2);
+				if (k1 < 2048) {
+					d1 = 0;
+				} else {
+					k1 -= 2048;
+				}
+				if (k2 < 2048) {
+					d2 = 2047;
+				} else {
+					k2 -= 2048;
+				}
+				slot->current_cmd[1] = 0x0b;
+				slot->current_cmd[2] = d1 >> 3;
+				slot->current_cmd[3] = d2 >> 3;
+				slot->current_cmd[4] = (SCALE_COEFF(k2, 4) << 4) + SCALE_COEFF(k1, 4);
+				slot->current_cmd[5] = ((d2 & 7) << 5) + ((d1 & 7) << 1) + (s2 << 4) + s1;
+				slot->current_cmd[6] = SCALE_VALUE_U16(parameters->clip, 8);
+				break;
+			case FF_DAMPER:
+				s1 = parameters->k1 < 0;
+				s2 = parameters->k2 < 0;
+				slot->current_cmd[1] = 0x0c;
+				slot->current_cmd[2] = SCALE_COEFF(parameters->k1, 4);
+				slot->current_cmd[3] = s1;
+				slot->current_cmd[4] = SCALE_COEFF(parameters->k2, 4);
+				slot->current_cmd[5] = s2;
+				slot->current_cmd[6] = SCALE_VALUE_U16(parameters->clip, 8);
+				break;
+			case FF_FRICTION:
+				s1 = parameters->k1 < 0;
+				s2 = parameters->k2 < 0;
+				slot->current_cmd[1] = 0x0e;
+				slot->current_cmd[2] = SCALE_COEFF(parameters->k1, 8);
+				slot->current_cmd[3] = SCALE_COEFF(parameters->k2, 8);
+				slot->current_cmd[4] = SCALE_VALUE_U16(parameters->clip, 8);
+				slot->current_cmd[5] = (s2 << 4) + s1;
+				slot->current_cmd[6] = 0;
+				break;
+		}
+	}
+
+	if (memcmp(original_cmd, slot->current_cmd, sizeof(original_cmd))) {
+		slot->is_updated = 1;
+	}
+}
+
+static __always_inline int lg4ff_calculate_constant(struct lg4ff_effect_state *state)
+{
+	int level_sign;
+	int level = state->effect.u.constant.level;
+	int d, t;
+
+	if (state->time_playing < state->envelope->attack_length) {
+		level_sign = level < 0 ? -1 : 1;
+		d = level - level_sign * state->envelope->attack_level;
+		level = level_sign * state->envelope->attack_level + d * state->time_playing / state->envelope->attack_length;
+	} else if (state->effect.replay.length) {
+		t = state->time_playing - state->effect.replay.length + state->envelope->fade_length;
+		if (t > 0) {
+			level_sign = level < 0 ? -1 : 1;
+			d = level - level_sign * state->envelope->fade_level;
+			level = level - d * t / state->envelope->fade_length;
+		}
+	}
+
+	return state->direction_gain * level / 0x7fff;
+}
+
+static __always_inline int lg4ff_calculate_ramp(struct lg4ff_effect_state *state)
+{
+	struct ff_ramp_effect *ramp = &state->effect.u.ramp;
+	int level_sign;
+	int level = INT_MAX;
+	int d, t;
+
+	if (state->time_playing < state->envelope->attack_length) {
+		level = ramp->start_level;
+		level_sign =  level < 0 ? -1 : 1;
+		t = state->envelope->attack_length - state->time_playing;
+		d = level - level_sign * state->envelope->attack_level;
+		level = level_sign * state->envelope->attack_level + d * t / state->envelope->attack_length;
+	} else if (state->effect.replay.length && state->time_playing >= state->effect.replay.length - state->envelope->fade_length) {
+		level = ramp->end_level;
+		level_sign = level < 0 ? -1 : 1;
+		t = state->time_playing - state->effect.replay.length + state->envelope->fade_length;
+		d = level_sign * state->envelope->fade_level - level;
+		level = level - d * t / state->envelope->fade_length;
+	} else {
+		t = state->time_playing - state->envelope->attack_length;
+		level = ramp->start_level + ((t * state->slope) >> 16);
+	}
+
+	return state->direction_gain * level / 0x7fff;
+}
+
+static __always_inline int lg4ff_calculate_periodic(struct lg4ff_effect_state *state)
+{
+	struct ff_periodic_effect *periodic = &state->effect.u.periodic;
+	int magnitude = periodic->magnitude;
+	int magnitude_sign = magnitude < 0 ? -1 : 1;
+	int level = periodic->offset;
+	int d, t;
+
+	if (state->time_playing < state->envelope->attack_length) {
+		d = magnitude - magnitude_sign * state->envelope->attack_level;
+		magnitude = magnitude_sign * state->envelope->attack_level + d * state->time_playing / state->envelope->attack_length;
+	} else if (state->effect.replay.length) {
+		t = state->time_playing - state->effect.replay.length + state->envelope->fade_length;
+		if (t > 0) {
+			d = magnitude - magnitude_sign * state->envelope->fade_level;
+			magnitude = magnitude - d * t / state->envelope->fade_length;
+		}
+	}
+
+	switch (periodic->waveform) {
+		case FF_SINE:
+			level += fixp_sin16(state->phase) * magnitude / 0x7fff;
+			break;
+		case FF_SQUARE:
+			level += (state->phase < 180 ? 1 : -1) * magnitude;
+			break;
+		case FF_TRIANGLE:
+			level += abs(state->phase * magnitude * 2 / 360 - magnitude) * 2 - magnitude;
+			break;
+		case FF_SAW_UP:
+			level += state->phase * magnitude * 2 / 360 - magnitude;
+			break;
+		case FF_SAW_DOWN:
+			level += magnitude - state->phase * magnitude * 2 / 360;
+			break;
+	}
+
+	return state->direction_gain * level / 0x7fff;
+}
+
+static __always_inline void lg4ff_calculate_spring(struct lg4ff_effect_state *state, struct lg4ff_effect_parameters *parameters)
+{
+	struct ff_condition_effect *condition = &state->effect.u.condition[0];
+
+	parameters->d1 = ((int)condition->center) - condition->deadband / 2;
+	parameters->d2 = ((int)condition->center) + condition->deadband / 2;
+	parameters->k1 = condition->left_coeff;
+	parameters->k2 = condition->right_coeff;
+	parameters->clip = (unsigned)condition->right_saturation;
+}
+
+static __always_inline void lg4ff_calculate_resistance(struct lg4ff_effect_state *state, struct lg4ff_effect_parameters *parameters)
+{
+	struct ff_condition_effect *condition = &state->effect.u.condition[0];
+
+	parameters->k1 = condition->left_coeff;
+	parameters->k2 = condition->right_coeff;
+	parameters->clip = (unsigned)condition->right_saturation;
+}
+
+static __always_inline struct ff_envelope *lg4ff_effect_envelope(struct ff_effect *effect)
+{
+	switch (effect->type) {
+		case FF_CONSTANT:
+			return &effect->u.constant.envelope;
+		case FF_RAMP:
+			return &effect->u.ramp.envelope;
+		case FF_PERIODIC:
+			return &effect->u.periodic.envelope;
+	}
+
+	return NULL;
+}
+
+static __always_inline void lg4ff_update_state(struct lg4ff_effect_state *state, const unsigned long now)
+{
+	struct ff_effect *effect = &state->effect;
+	unsigned long phase_time;
+
+	if (!__test_and_set_bit(FF_EFFECT_ALLSET, &state->flags)) {
+		state->play_at = state->start_at + effect->replay.delay;
+		if (!test_bit(FF_EFFECT_UPDATING, &state->flags)) {
+			state->updated_at = state->play_at;
+		}
+		state->direction_gain = fixp_sin16(effect->direction * 360 / 0x10000);
+		if (effect->type == FF_PERIODIC) {
+			state->phase_adj = effect->u.periodic.phase * 360 / effect->u.periodic.period;
+		}
+		if (effect->replay.length) {
+			state->stop_at = state->play_at + effect->replay.length;
+		}
+	}
+
+	if (__test_and_clear_bit(FF_EFFECT_UPDATING, &state->flags)) {
+		__clear_bit(FF_EFFECT_PLAYING, &state->flags);
+		state->play_at = state->updated_at + effect->replay.delay;
+		state->direction_gain = fixp_sin16(effect->direction * 360 / 0x10000);
+		if (effect->replay.length) {
+			state->stop_at = state->updated_at + effect->replay.length;
+		}
+		if (effect->type == FF_PERIODIC) {
+			state->phase_adj = state->phase;
+		}
+	}
+
+	state->envelope = lg4ff_effect_envelope(effect);
+
+	state->slope = 0;
+	if (effect->type == FF_RAMP && effect->replay.length) {
+		state->slope = ((effect->u.ramp.end_level - effect->u.ramp.start_level) << 16) / (effect->replay.length - state->envelope->attack_length - state->envelope->fade_length);
+	}
+
+	if (!test_bit(FF_EFFECT_PLAYING, &state->flags) && time_after_eq(now,
+				state->play_at) && (effect->replay.length == 0 ||
+					time_before(now, state->stop_at))) {
+		__set_bit(FF_EFFECT_PLAYING, &state->flags);
+	}
+
+	if (test_bit(FF_EFFECT_PLAYING, &state->flags)) {
+		state->time_playing = time_diff(now, state->play_at);
+		if (effect->type == FF_PERIODIC) {
+			phase_time = time_diff(now, state->updated_at);
+			state->phase = (phase_time % effect->u.periodic.period) * 360 / effect->u.periodic.period;
+			state->phase += state->phase_adj % 360;
+		}
+	}
+}
+
+static __always_inline int lg4ff_timer(struct lg4ff_device_entry *entry)
+{
+	struct usbhid_device *usbhid = entry->hid->driver_data;
+	struct lg4ff_slot *slot;
+	struct lg4ff_effect_state *state;
+	struct lg4ff_effect_parameters parameters[4];
+	unsigned long jiffies_now = jiffies;
+	unsigned long now = JIFFIES2MS(jiffies_now);
+	unsigned long flags;
+	unsigned gain;
+	int current_period;
+	int count;
+	int effect_id;
+	int i;
+	int ffb_level;
+#ifdef CONFIG_LEDS_CLASS
+	static int leds_timer = 0;
+	static int leds_level = 0;
+	u8 led_states;
+#endif
+
+	if (timer_mode > 0 && usbhid->outhead != usbhid->outtail) {
+		current_period = timer_msecs;
+		if (timer_mode == 1) {
+			timer_msecs *= 2;
+			hid_info(entry->hid, "Commands stacking up, increasing timer period to %d ms.", timer_msecs);
+		} else {
+			DEBUG("Commands stacking up, delaying timer.");
+		}
+		return current_period;
+	}
+
+	memset(parameters, 0, sizeof(parameters));
+
+	gain = (unsigned)entry->wdata.master_gain * entry->wdata.gain / 0xffff;
+
+	spin_lock_irqsave(&entry->timer_lock, flags);
+
+	count = entry->effects_used;
+
+	for (effect_id = 0; effect_id < LG4FF_MAX_EFFECTS; effect_id++) {
+
+		if (!count) {
+			break;
+		}
+
+		state = &entry->states[effect_id];
+
+		if (!test_bit(FF_EFFECT_STARTED, &state->flags)) {
+			continue;
+		}
+
+		count--;
+
+		if (test_bit(FF_EFFECT_ALLSET, &state->flags)) {
+			if (state->effect.replay.length && time_after_eq(now, state->stop_at)) {
+				STOP_EFFECT(state);
+				if (!--state->count) {
+					entry->effects_used--;
+					continue;
+				}
+				__set_bit(FF_EFFECT_STARTED, &state->flags);
+				state->start_at = state->stop_at;
+			}
+		}
+
+		lg4ff_update_state(state, now);
+
+		if (!test_bit(FF_EFFECT_PLAYING, &state->flags)) {
+			continue;
+		}
+
+		switch (state->effect.type) {
+			case FF_CONSTANT:
+				parameters[0].level += lg4ff_calculate_constant(state);
+				break;
+			case FF_RAMP:
+				parameters[0].level += lg4ff_calculate_ramp(state);
+				break;
+			case FF_PERIODIC:
+				parameters[0].level += lg4ff_calculate_periodic(state);
+				break;
+			case FF_SPRING:
+				if (state->slot != 0) {
+					lg4ff_calculate_spring(state, &parameters[state->slot]);
+				}
+				break;
+			case FF_DAMPER:
+			case FF_FRICTION:
+			case FF_INERTIA:
+				if (state->slot != 0) {
+					lg4ff_calculate_resistance(state, &parameters[state->slot]);
+				}
+		}
+	}
+
+	spin_unlock_irqrestore(&entry->timer_lock, flags);
+
+	parameters[0].level = (long)parameters[0].level * gain / 0xffff;
+
+	ffb_level = abs(parameters[0].level);
+	for (i = 1; i < 4; i++) {
+		parameters[i].k1 = (long)parameters[i].k1 * gain / 0xffff;
+		parameters[i].k2 = (long)parameters[i].k2 * gain / 0xffff;
+		switch (entry->slots[i].effect_type) {
+			case FF_SPRING:
+				parameters[i].clip = parameters[i].clip * spring_level / 100;
+				break;
+			case FF_DAMPER:
+				parameters[i].clip = parameters[i].clip * damper_level / 100;
+				break;
+			case FF_FRICTION:
+				parameters[i].clip = parameters[i].clip * friction_level / 100;
+				break;
+		}
+		parameters[i].clip = parameters[i].clip * gain / 0xffff;
+		ffb_level += parameters[i].clip * 0x7fff / 0xffff;
+	}
+	if (ffb_level > entry->peak_ffb_level) {
+		entry->peak_ffb_level = ffb_level;
+	}
+
+	for (i = 0; i < 4; i++) {
+		slot = &entry->slots[i];
+		lg4ff_update_slot(slot, &parameters[i]);
+		if (slot->is_updated) {
+			lg4ff_send_cmd(entry, slot->current_cmd);
+			slot->is_updated = 0;
+		}
+	}
+
+#ifdef CONFIG_LEDS_CLASS
+	if (ffb_leds || leds_level > 0) {
+		if (ffb_level > leds_level) {
+			leds_level = ffb_level;
+		}
+		if (!ffb_leds || entry->effects_used == 0) {
+			leds_timer = 0;
+			leds_level = 0;
+		}
+		if (leds_timer == 0) {
+			leds_timer = 480 / timer_msecs;
+			if (leds_level < 2458) { // < 7.5%
+				led_states = 0;
+			} else if (leds_level < 8192) { // < 25%
+				led_states = 1;
+			} else if (leds_level < 16384) { // < 50%
+				led_states = 3;
+			} else if (leds_level < 24576) { // < 75%
+				led_states = 7;
+			} else if (leds_level < 29491) { // < 90%
+				led_states = 15;
+			} else if (leds_level <= 32768) { // <= 100%
+				led_states = 31;
+			} else if (leds_level < 36045) { // < 110%
+				led_states = 30;
+			} else if (leds_level < 40960) { // < 125%
+				led_states = 28;
+			} else if (leds_level < 49152) { // < 150%
+				led_states = 24;
+			} else {
+				led_states = 16;
+			}
+			lg4ff_set_leds(entry->hid, led_states);
+			leds_level = 0;
+		}
+		leds_timer--;
+	}
+#endif
+
+	return 0;
+}
+
+static enum hrtimer_restart lg4ff_timer_hires(struct hrtimer *t)
+{
+	struct lg4ff_device_entry *entry = container_of(t, struct lg4ff_device_entry, hrtimer);
+	int delay_timer;
+	int overruns;
+
+	delay_timer = lg4ff_timer(entry);
+
+	if (delay_timer) {
+		hrtimer_forward_now(&entry->hrtimer, ms_to_ktime(delay_timer));
+		return HRTIMER_RESTART;
+	}
+
+	if (entry->effects_used) {
+		overruns = hrtimer_forward_now(&entry->hrtimer, ms_to_ktime(timer_msecs));
+		overruns--;
+		if (unlikely(profile && overruns > 0))
+			DEBUG("Overruns: %d", overruns);
+		return HRTIMER_RESTART;
+	} else {
+		if (unlikely(profile))
+			DEBUG("Stop timer.");
+		return HRTIMER_NORESTART;
+	}
+}
+
+static void lg4ff_init_slots(struct lg4ff_device_entry *entry)
+{
+	struct lg4ff_effect_parameters parameters;
+	u8 cmd[8] = {0};
+	int i;
+
+	// Set/unset fixed loop mode
+	cmd[0] = 0x0d;
+	cmd[1] = fixed_loop ? 1 : 0;
+	lg4ff_send_cmd(entry, cmd);
+
+	memset(&entry->states, 0, sizeof(entry->states));
+	memset(&entry->slots, 0, sizeof(entry->slots));
+	memset(&parameters, 0, sizeof(parameters));
+
+	entry->slots[0].effect_type = FF_CONSTANT;
+
+	for (i = 0; i < 4; i++) {
+		entry->slots[i].id = i;
+		lg4ff_update_slot(&entry->slots[i], &parameters);
+		lg4ff_send_cmd(entry, entry->slots[i].current_cmd);
+		entry->slots[i].is_updated = 0;
+	}
+}
+
+static void lg4ff_stop_effects(struct lg4ff_device_entry *entry)
+{
+	u8 cmd[7] = {0};
+
+	cmd[0] = 0xf3;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+static int lg4ff_upload_effect(struct input_dev *dev, struct ff_effect *effect, struct ff_effect *old)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct lg4ff_device_entry *entry;
+	struct lg4ff_effect_state *state;
+	unsigned long now = JIFFIES2MS(jiffies);
+	unsigned long flags;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (effect->type == FF_PERIODIC && effect->u.periodic.period == 0) {
+		return -EINVAL;
+	}
+
+	state = &entry->states[effect->id];
+
+	if (test_bit(FF_EFFECT_STARTED, &state->flags) && effect->type != state->effect.type) {
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&entry->timer_lock, flags);
+
+	state->effect = *effect;
+
+	if (test_bit(FF_EFFECT_STARTED, &state->flags)) {
+		__set_bit(FF_EFFECT_UPDATING, &state->flags);
+		state->updated_at = now;
+	}
+
+	spin_unlock_irqrestore(&entry->timer_lock, flags);
+
+	return 0;
+}
+
+static int lg4ff_play_effect(struct input_dev *dev, int effect_id, int value)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct lg4ff_device_entry *entry;
+	struct lg4ff_effect_state *state;
+	unsigned long now = JIFFIES2MS(jiffies);
+	unsigned long flags;
+	int i;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	state = &entry->states[effect_id];
+
+	spin_lock_irqsave(&entry->timer_lock, flags);
+
+	if (value > 0) {
+		if (test_bit(FF_EFFECT_STARTED, &state->flags)) {
+			STOP_EFFECT(state);
+		} else {
+			entry->effects_used++;
+			if (!hrtimer_active(&entry->hrtimer)) {
+				hrtimer_start(&entry->hrtimer, ms_to_ktime(timer_msecs), HRTIMER_MODE_REL);
+				if (unlikely(profile))
+					DEBUG("Start timer.");
+			}
+			if ((state->effect.type == FF_SPRING || state->effect.type == FF_DAMPER
+					|| state->effect.type == FF_FRICTION || state->effect.type == FF_INERTIA)
+					&& state->slot == 0) {
+				/* Find a free slot */
+				for (i = 1; i < 4 && entry->slots[i].effect_type != 0; i++);
+				if (i < 4) {
+					state->slot = i;
+					entry->slots[i].effect_type = state->effect.type;
+
+					/* Cast unsupported effect types to "damper": this is what the Windows
+					* driver does.
+					* This is not physically plausible, but we are working with toy-strength
+					* wheels that won't let you feel more than "big value = wheel stuck" */
+					if (state->effect.type == FF_INERTIA
+							|| (state->effect.type == FF_FRICTION && !(entry->wdata.capabilities & LG4FF_CAP_FRICTION))) {
+						entry->slots[i].effect_type = FF_DAMPER;
+					}
+				}
+			}
+		}
+		__set_bit(FF_EFFECT_STARTED, &state->flags);
+		state->start_at = now;
+		state->count = value;
+	} else {
+		if (test_bit(FF_EFFECT_STARTED, &state->flags)) {
+			STOP_EFFECT(state);
+			entry->effects_used--;
+			if (state->slot) {
+				entry->slots[state->slot].effect_type = 0;
+				state->slot = 0;
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&entry->timer_lock, flags);
+
+	return 0;
+}
+
+/* Recalculates X axis value accordingly to currently selected range */
+static s32 lg4ff_adjust_dfp_x_axis(s32 value, u16 range)
+{
+	u16 max_range;
+	s32 new_value;
+
+	if (range == 900)
+		return value;
+	else if (range == 200)
+		return value;
+	else if (range < 200)
+		max_range = 200;
+	else
+		max_range = 900;
+
+	new_value = 8192 + mult_frac(value - 8192, max_range, range);
+	if (new_value < 0)
+		return 0;
+	else if (new_value > 16383)
+		return 16383;
+	else
+		return new_value;
+}
+
+int lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,
+			     struct hid_usage *usage, s32 value, struct lg_drv_data *drv_data)
+{
+	struct lg4ff_device_entry *entry = drv_data->device_props;
+	s32 new_value = 0;
+
+	if (!entry) {
+		hid_err(hid, "Device properties not found");
+		return 0;
+	}
+
+	switch (entry->wdata.product_id) {
+	case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+		switch (usage->code) {
+		case ABS_X:
+			new_value = lg4ff_adjust_dfp_x_axis(value, entry->wdata.range);
+			input_event(field->hidinput->input, usage->type, usage->code, new_value);
+			return 1;
+		default:
+			return 0;
+		}
+	default:
+		return 0;
+	}
+}
+
+int lg4ff_raw_event(struct hid_device *hdev, struct hid_report *report,
+		u8 *rd, int size, struct lg_drv_data *drv_data)
+{
+	int offset;
+	struct lg4ff_device_entry *entry = drv_data->device_props;
+
+	if (!entry)
+		return 0;
+
+	/* adjust HID report present combined pedals data */
+	if (entry->wdata.combine == 1) {
+		switch (entry->wdata.product_id) {
+		case USB_DEVICE_ID_LOGITECH_WHEEL:
+			rd[5] = rd[3];
+			rd[6] = 0x7F;
+			return 1;
+		case USB_DEVICE_ID_LOGITECH_WINGMAN_FG:
+		case USB_DEVICE_ID_LOGITECH_WINGMAN_FFG:
+		case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:
+			rd[4] = rd[3];
+			rd[5] = 0x7F;
+			return 1;
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			rd[5] = rd[4];
+			rd[6] = 0x7F;
+			return 1;
+		case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+			offset = 5;
+			break;
+		case USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G29_WHEEL:
+		case USB_DEVICE_ID_LOGITECH_G923_WHEEL:
+			offset = 6;
+			break;
+		case USB_DEVICE_ID_LOGITECH_WII_WHEEL:
+			offset = 3;
+			break;
+		default:
+			return 0;
+		}
+
+		/* Compute a combined axis when wheel does not supply it */
+		rd[offset] = (0xFF + rd[offset] - rd[offset+1]) >> 1;
+		rd[offset+1] = 0x7F;
+		return 1;
+	}
+
+	if (entry->wdata.combine == 2) {
+		switch (entry->wdata.product_id) {
+			case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+			case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+				offset = 5;
+				break;
+			case USB_DEVICE_ID_LOGITECH_G29_WHEEL:
+			case USB_DEVICE_ID_LOGITECH_G923_WHEEL:
+				offset = 6;
+				break;
+			default:
+				return 0;
+		}
+
+		/* Compute a combined axis when wheel does not supply it */
+		rd[offset] = (0xFF + rd[offset] - rd[offset+2]) >> 1;
+		rd[offset+2] = 0x7F;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void lg4ff_init_wheel_data(struct lg4ff_wheel_data * const wdata, const struct lg4ff_wheel *wheel,
+				  const struct lg4ff_multimode_wheel *mmode_wheel,
+				  const u16 real_product_id)
+{
+	u32 alternate_modes = 0;
+	const char *real_tag = NULL;
+	const char *real_name = NULL;
+
+	if (mmode_wheel) {
+		alternate_modes = mmode_wheel->alternate_modes;
+		real_tag = mmode_wheel->real_tag;
+		real_name = mmode_wheel->real_name;
+	}
+
+	{
+		struct lg4ff_wheel_data t_wdata =  { .product_id = wheel->product_id,
+						     .real_product_id = real_product_id,
+						     .combine = 0,
+						     .min_range = wheel->min_range,
+						     .max_range = wheel->max_range,
+						     .set_range = wheel->set_range,
+						     .alternate_modes = alternate_modes,
+						     .real_tag = real_tag,
+						     .real_name = real_name,
+						     .capabilities = wheel->capabilities };
+
+		memcpy(wdata, &t_wdata, sizeof(t_wdata));
+	}
+}
+
+/* Sends default autocentering command compatible with
+ * all wheels except Formula Force EX */
+static void lg4ff_set_autocenter_default(struct input_dev *dev, u16 magnitude)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	u8 cmd[7];
+	u32 expand_a, expand_b;
+	struct lg4ff_device_entry *entry;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return;
+	}
+
+	entry->wdata.autocenter = magnitude;
+
+	/* De-activate Auto-Center */
+	if (magnitude == 0) {
+		cmd[0] = 0xf5;
+		cmd[1] = 0x00;
+		cmd[2] = 0x00;
+		cmd[3] = 0x00;
+		cmd[4] = 0x00;
+		cmd[5] = 0x00;
+		cmd[6] = 0x00;
+		lg4ff_send_cmd(entry, cmd);
+		return;
+	}
+
+	if (magnitude <= 0xaaaa) {
+		expand_a = 0x0c * magnitude;
+		expand_b = 0x80 * magnitude;
+	} else {
+		expand_a = (0x0c * 0xaaaa) + 0x06 * (magnitude - 0xaaaa);
+		expand_b = (0x80 * 0xaaaa) + 0xff * (magnitude - 0xaaaa);
+	}
+
+	/* Adjust for non-MOMO wheels */
+	switch (entry->wdata.product_id) {
+	case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL:
+	case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2:
+		break;
+	default:
+		expand_a = expand_a >> 1;
+		break;
+	}
+
+	cmd[0] = 0xfe;
+	cmd[1] = 0x0d;
+	cmd[2] = expand_a / 0xaaaa;
+	cmd[3] = expand_a / 0xaaaa;
+	cmd[4] = expand_b / 0xaaaa;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+	lg4ff_send_cmd(entry, cmd);
+
+	/* Activate Auto-Center */
+	cmd[0] = 0x14;
+	cmd[1] = 0x00;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+	cmd[4] = 0x00;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+/* Sends autocentering command compatible with Formula Force EX */
+static void lg4ff_set_autocenter_ffex(struct input_dev *dev, u16 magnitude)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct lg4ff_device_entry *entry;
+	u8 cmd[7];
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return;
+	}
+
+	entry->wdata.autocenter = magnitude;
+
+	magnitude = magnitude * 90 / 65535;
+
+	cmd[0] = 0xfe;
+	cmd[1] = 0x03;
+	cmd[2] = magnitude >> 14;
+	cmd[3] = magnitude >> 14;
+	cmd[4] = magnitude;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+/* Sends command to set range compatible with G25/G27/Driving Force GT */
+static void lg4ff_set_range_g25(struct hid_device *hid, u16 range)
+{
+	struct lg4ff_device_entry *entry;
+	struct lg_drv_data *drv_data;
+	u8 cmd[7];
+
+	drv_data = hid_get_drvdata(hid);
+	entry = drv_data->device_props;
+
+	dbg_hid("G25/G27/DFGT: setting range to %u\n", range);
+
+	cmd[0] = 0xf8;
+	cmd[1] = 0x81;
+	cmd[2] = range & 0x00ff;
+	cmd[3] = (range & 0xff00) >> 8;
+	cmd[4] = 0x00;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+/* Sends commands to set range compatible with Driving Force Pro wheel */
+static void lg4ff_set_range_dfp(struct hid_device *hid, u16 range)
+{
+	struct lg4ff_device_entry *entry;
+	struct lg_drv_data *drv_data;
+	int start_left, start_right, full_range;
+	u8 cmd[7];
+
+	drv_data = hid_get_drvdata(hid);
+	entry = drv_data->device_props;
+
+	dbg_hid("Driving Force Pro: setting range to %u\n", range);
+
+	/* Prepare "coarse" limit command */
+	cmd[0] = 0xf8;
+	cmd[1] = 0x00;	/* Set later */
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+	cmd[4] = 0x00;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+
+	if (range > 200) {
+		cmd[1] = 0x03;
+		full_range = 900;
+	} else {
+		cmd[1] = 0x02;
+		full_range = 200;
+	}
+	lg4ff_send_cmd(entry, cmd);
+
+	/* Prepare "fine" limit command */
+	cmd[0] = 0x81;
+	cmd[1] = 0x0b;
+	cmd[2] = 0x00;
+	cmd[3] = 0x00;
+	cmd[4] = 0x00;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+
+	if (range == 200 || range == 900) {	/* Do not apply any fine limit */
+		lg4ff_send_cmd(entry, cmd);
+		return;
+	}
+
+	/* Construct fine limit command */
+	start_left = (((full_range - range + 1) * 2047) / full_range);
+	start_right = 0xfff - start_left;
+
+	cmd[2] = start_left >> 4;
+	cmd[3] = start_right >> 4;
+	cmd[4] = 0xff;
+	cmd[5] = (start_right & 0xe) << 4 | (start_left & 0xe);
+	cmd[6] = 0xff;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+static void lg4ff_set_gain(struct input_dev *dev, u16 gain)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct lg4ff_device_entry *entry;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return;
+	}
+
+	entry->wdata.gain = gain;
+}
+
+static const struct lg4ff_compat_mode_switch *lg4ff_get_mode_switch_command(const u16 real_product_id, const u16 target_product_id)
+{
+	switch (real_product_id) {
+	case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			return &lg4ff_mode_switch_ext01_dfp;
+		/* DFP can only be switched to its native mode */
+		default:
+			return NULL;
+		}
+		break;
+	case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			return &lg4ff_mode_switch_ext01_dfp;
+		case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+			return &lg4ff_mode_switch_ext16_g25;
+		/* G25 can only be switched to DFP mode or its native mode */
+		default:
+			return NULL;
+		}
+		break;
+	case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfex;
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfp;
+		case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+			return &lg4ff_mode_switch_ext09_g25;
+		case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+			return &lg4ff_mode_switch_ext09_g27;
+		/* G27 can only be switched to DF-EX, DFP, G25 or its native mode */
+		default:
+			return NULL;
+		}
+		break;
+	case USB_DEVICE_ID_LOGITECH_G29_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfp;
+		case USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfgt;
+		case USB_DEVICE_ID_LOGITECH_G25_WHEEL:
+			return &lg4ff_mode_switch_ext09_g25;
+		case USB_DEVICE_ID_LOGITECH_G27_WHEEL:
+			return &lg4ff_mode_switch_ext09_g27;
+		case USB_DEVICE_ID_LOGITECH_G29_WHEEL:
+			return &lg4ff_mode_switch_ext09_g29;
+		/* G29 can only be switched to DF-EX, DFP, DFGT, G25, G27 or its native mode */
+		default:
+			return NULL;
+		}
+		break;
+	case USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_G923_WHEEL:
+			return &lg4ff_mode_switch_30_g923;
+		/* We can only switch from PS mode to Classic. */
+		default:
+			return NULL;
+		}
+		break;
+	case USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:
+		switch (target_product_id) {
+		case USB_DEVICE_ID_LOGITECH_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfex;
+		case USB_DEVICE_ID_LOGITECH_DFP_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfp;
+		case USB_DEVICE_ID_LOGITECH_DFGT_WHEEL:
+			return &lg4ff_mode_switch_ext09_dfgt;
+		/* DFGT can only be switched to DF-EX, DFP or its native mode */
+		default:
+			return NULL;
+		}
+		break;
+	/* No other wheels have multiple modes */
+	default:
+		return NULL;
+	}
+}
+
+static int lg4ff_switch_compatibility_mode(struct hid_device *hid, const struct lg4ff_compat_mode_switch *s)
+{
+	struct lg4ff_device_entry *entry;
+	u8 cmd[7];
+	u8 i;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < s->cmd_count; i++) {
+		u8 j;
+
+		for (j = 0; j < 7; j++)
+			cmd[j] = s->cmd[j + (7*i)];
+
+		lg4ff_send_cmd(entry, cmd);
+	}
+	hid_hw_wait(hid);
+	return 0;
+}
+
+/* For switching from PS mode we need to set report id to 0x30 */
+static int lg4ff_switch_from_ps_mode(struct hid_device *hid, const struct lg4ff_compat_mode_switch *s)
+{
+	struct lg4ff_device_entry *entry;
+	u8 cmd[7];
+	u8 i;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < s->cmd_count; i++) {
+		u8 j;
+
+		for (j = 0; j < 7; j++)
+			cmd[j] = s->cmd[j + (7*i)];
+
+		lg4ff_send_cmd_with_id(entry, cmd, 0x30);
+	}
+	hid_hw_wait(hid);
+	return 0;
+}
+
+static ssize_t lg4ff_alternate_modes_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	ssize_t count = 0;
+	int i;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (!entry->wdata.real_name) {
+		hid_err(hid, "NULL pointer to string\n");
+		return 0;
+	}
+
+	for (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {
+		if (entry->wdata.alternate_modes & BIT(i)) {
+			/* Print tag and full name */
+			count += scnprintf(buf + count, PAGE_SIZE - count, "%s: %s",
+					   lg4ff_alternate_modes[i].tag,
+					   !lg4ff_alternate_modes[i].product_id ? entry->wdata.real_name : lg4ff_alternate_modes[i].name);
+			if (count >= PAGE_SIZE - 1)
+				return count;
+
+			/* Mark the currently active mode with an asterisk */
+			if (lg4ff_alternate_modes[i].product_id == entry->wdata.product_id ||
+			    (lg4ff_alternate_modes[i].product_id == 0 && entry->wdata.product_id == entry->wdata.real_product_id))
+				count += scnprintf(buf + count, PAGE_SIZE - count, " *\n");
+			else
+				count += scnprintf(buf + count, PAGE_SIZE - count, "\n");
+
+			if (count >= PAGE_SIZE - 1)
+				return count;
+		}
+	}
+
+	return count;
+}
+
+static ssize_t lg4ff_alternate_modes_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	const struct lg4ff_compat_mode_switch *s;
+	u16 target_product_id = 0;
+	int i, ret;
+	char *lbuf;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	/* Allow \n at the end of the input parameter */
+	lbuf = kasprintf(GFP_KERNEL, "%s", buf);
+	if (!lbuf)
+		return -ENOMEM;
+
+	i = strlen(lbuf);
+
+	if (i == 0) {
+		kfree(lbuf);
+		return -EINVAL;
+	}
+
+	if (lbuf[i-1] == '\n') {
+		if (i == 1) {
+			kfree(lbuf);
+			return -EINVAL;
+		}
+		lbuf[i-1] = '\0';
+	}
+
+	for (i = 0; i < LG4FF_MODE_MAX_IDX; i++) {
+		const u16 mode_product_id = lg4ff_alternate_modes[i].product_id;
+		const char *tag = lg4ff_alternate_modes[i].tag;
+
+		if (entry->wdata.alternate_modes & BIT(i)) {
+			if (!strcmp(tag, lbuf)) {
+				if (!mode_product_id)
+					target_product_id = entry->wdata.real_product_id;
+				else
+					target_product_id = mode_product_id;
+				break;
+			}
+		}
+	}
+
+	if (i == LG4FF_MODE_MAX_IDX) {
+		hid_info(hid, "Requested mode \"%s\" is not supported by the device\n", lbuf);
+		kfree(lbuf);
+		return -EINVAL;
+	}
+	kfree(lbuf); /* Not needed anymore */
+
+	if (target_product_id == entry->wdata.product_id) /* Nothing to do */
+		return count;
+
+	/* Automatic switching has to be disabled for the switch to DF-EX mode to work correctly */
+	if (target_product_id == USB_DEVICE_ID_LOGITECH_WHEEL && !lg4ff_no_autoswitch) {
+		hid_info(hid, "\"%s\" cannot be switched to \"DF-EX\" mode. Load the \"hid_logitech\" module with \"lg4ff_no_autoswitch=1\" parameter set and try again\n",
+			 entry->wdata.real_name);
+		return -EINVAL;
+	}
+
+	/* Take care of hardware limitations */
+	if ((entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_DFP_WHEEL || entry->wdata.real_product_id == USB_DEVICE_ID_LOGITECH_G25_WHEEL) &&
+	    entry->wdata.product_id > target_product_id) {
+		hid_info(hid, "\"%s\" cannot be switched back into \"%s\" mode\n", entry->wdata.real_name, lg4ff_alternate_modes[i].name);
+		return -EINVAL;
+	}
+
+	s = lg4ff_get_mode_switch_command(entry->wdata.real_product_id, target_product_id);
+	if (!s) {
+		hid_err(hid, "Invalid target product ID %X\n", target_product_id);
+		return -EINVAL;
+	}
+
+	ret = lg4ff_switch_compatibility_mode(hid, s);
+	return (ret == 0 ? count : ret);
+}
+static DEVICE_ATTR(alternate_modes, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_alternate_modes_show, lg4ff_alternate_modes_store);
+
+static ssize_t lg4ff_combine_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", entry->wdata.combine);
+	return count;
+}
+
+static ssize_t lg4ff_combine_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	u16 combine = simple_strtoul(buf, NULL, 10);
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (combine > 2)
+		combine = 2;
+
+	entry->wdata.combine = combine;
+	return count;
+}
+static DEVICE_ATTR(combine_pedals, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_combine_show, lg4ff_combine_store);
+
+/* Export the currently set range of the wheel */
+static ssize_t lg4ff_range_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", entry->wdata.range);
+	return count;
+}
+
+/* Set range to user specified value, call appropriate function
+ * according to the type of the wheel */
+static ssize_t lg4ff_range_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	u16 range = simple_strtoul(buf, NULL, 10);
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (range == 0)
+		range = entry->wdata.max_range;
+
+	/* Check if the wheel supports range setting
+	 * and that the range is within limits for the wheel */
+	if (entry->wdata.set_range && range >= entry->wdata.min_range && range <= entry->wdata.max_range) {
+		entry->wdata.set_range(hid, range);
+		entry->wdata.range = range;
+	}
+
+	return count;
+}
+static DEVICE_ATTR(range, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_range_show, lg4ff_range_store);
+
+static ssize_t lg4ff_real_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (!entry->wdata.real_tag || !entry->wdata.real_name) {
+		hid_err(hid, "NULL pointer to string\n");
+		return 0;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%s: %s\n", entry->wdata.real_tag, entry->wdata.real_name);
+	return count;
+}
+
+static ssize_t lg4ff_real_id_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	/* Real ID is a read-only value */
+	return -EPERM;
+}
+static DEVICE_ATTR(real_id, S_IRUGO, lg4ff_real_id_show, lg4ff_real_id_store);
+
+/* Export the currently set gain of the wheel */
+static ssize_t lg4ff_gain_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", entry->wdata.master_gain);
+	return count;
+}
+
+/* Set gain to user specified value, call appropriate function
+ * according to the type of the wheel */
+static ssize_t lg4ff_gain_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	u16 gain = simple_strtoul(buf, NULL, 10);
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	if (gain > 0xffff) {
+		gain = 0xffff;
+	}
+
+	entry->wdata.master_gain = gain;
+
+	return count;
+}
+static DEVICE_ATTR(gain, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_gain_show, lg4ff_gain_store);
+
+/* Export the currently set autocenter of the wheel */
+static ssize_t lg4ff_autocenter_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", entry->wdata.autocenter);
+	return count;
+}
+
+/* Set autocenter to user specified value, call appropriate function
+ * according to the type of the wheel */
+static ssize_t lg4ff_autocenter_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	struct input_dev *inputdev = hidinput->input;
+	u16 autocenter = simple_strtoul(buf, NULL, 10);
+
+	if (autocenter > 0xffff) {
+		autocenter = 0xffff;
+	}
+
+	inputdev->ff->set_autocenter(inputdev, autocenter);
+
+	return count;
+}
+static DEVICE_ATTR(autocenter, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_autocenter_show, lg4ff_autocenter_store);
+
+static ssize_t lg4ff_spring_level_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	size_t count;
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", spring_level);
+
+	return count;
+}
+
+static ssize_t lg4ff_spring_level_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned value = simple_strtoul(buf, NULL, 10);
+
+	if (value > 100) {
+		value = 100;
+	}
+
+	spring_level = value;
+
+	return count;
+}
+static DEVICE_ATTR(spring_level, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_spring_level_show, lg4ff_spring_level_store);
+
+static ssize_t lg4ff_damper_level_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	size_t count;
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", damper_level);
+
+	return count;
+}
+
+static ssize_t lg4ff_damper_level_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned value = simple_strtoul(buf, NULL, 10);
+
+	if (value > 100) {
+		value = 100;
+	}
+
+	damper_level = value;
+
+	return count;
+}
+static DEVICE_ATTR(damper_level, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_damper_level_show, lg4ff_damper_level_store);
+
+static ssize_t lg4ff_friction_level_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	size_t count;
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", friction_level);
+
+	return count;
+}
+
+static ssize_t lg4ff_friction_level_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned value = simple_strtoul(buf, NULL, 10);
+
+	if (value > 100) {
+		value = 100;
+	}
+
+	friction_level = value;
+
+	return count;
+}
+static DEVICE_ATTR(friction_level, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_friction_level_show, lg4ff_friction_level_store);
+
+static ssize_t lg4ff_peak_ffb_level_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	size_t count;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	count = scnprintf(buf, PAGE_SIZE, "%u\n", entry->peak_ffb_level);
+
+	return count;
+}
+
+static ssize_t lg4ff_peak_ffb_level_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	entry->peak_ffb_level = value;
+
+	return count;
+}
+static DEVICE_ATTR(peak_ffb_level, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_peak_ffb_level_show, lg4ff_peak_ffb_level_store);
+
+#ifdef CONFIG_LEDS_CLASS
+
+static ssize_t lg4ff_ffb_leds_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	size_t count;
+
+	count = scnprintf(buf, PAGE_SIZE, "%d\n", ffb_leds);
+
+	return count;
+}
+
+static ssize_t lg4ff_ffb_leds_store(struct device *dev, struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+
+	ffb_leds = value;
+
+	return count;
+}
+static DEVICE_ATTR(ffb_leds, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH, lg4ff_ffb_leds_show, lg4ff_ffb_leds_store);
+
+static void lg4ff_set_leds(struct hid_device *hid, u8 leds)
+{
+	struct lg4ff_device_entry *entry;
+	u8 cmd[7];
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return;
+	}
+
+	cmd[0] = 0xf8;
+	cmd[1] = 0x12;
+	cmd[2] = leds;
+	cmd[3] = 0x00;
+	cmd[4] = 0x00;
+	cmd[5] = 0x00;
+	cmd[6] = 0x00;
+	lg4ff_send_cmd(entry, cmd);
+}
+
+static void lg4ff_led_set_brightness(struct led_classdev *led_cdev,
+			enum led_brightness value)
+{
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	int i, state = 0;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return;
+	}
+
+	for (i = 0; i < 5; i++) {
+		if (led_cdev != entry->wdata.led[i])
+			continue;
+		state = (entry->wdata.led_state >> i) & 1;
+		if (value == LED_OFF && state) {
+			entry->wdata.led_state &= ~(1 << i);
+			if (!ffb_leds) {
+				lg4ff_set_leds(hid, entry->wdata.led_state);
+			}
+		} else if (value != LED_OFF && !state) {
+			entry->wdata.led_state |= 1 << i;
+			if (!ffb_leds) {
+				lg4ff_set_leds(hid, entry->wdata.led_state);
+			}
+		}
+		break;
+	}
+}
+
+static enum led_brightness lg4ff_led_get_brightness(struct led_classdev *led_cdev)
+{
+	struct device *dev = led_cdev->dev->parent;
+	struct hid_device *hid = to_hid_device(dev);
+	struct lg4ff_device_entry *entry;
+	int i, value = 0;
+
+	entry = lg4ff_get_device_entry(hid);
+	if (entry == NULL) {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < 5; i++)
+		if (led_cdev == entry->wdata.led[i]) {
+			value = (entry->wdata.led_state >> i) & 1;
+			break;
+		}
+
+	return value ? LED_FULL : LED_OFF;
+}
+
+static void lg4ff_init_leds(struct hid_device *hid, struct lg4ff_device_entry *entry, int i)
+{
+	int error, j;
+
+	/* register led subsystem - G27/G29/G923 only */
+	entry->wdata.led_state = 0;
+	for (j = 0; j < 5; j++)
+		entry->wdata.led[j] = NULL;
+
+	{
+		struct led_classdev *led;
+		size_t name_sz;
+		char *name;
+
+		lg4ff_set_leds(hid, 0);
+
+		name_sz = strlen(dev_name(&hid->dev)) + 8;
+
+		for (j = 0; j < 5; j++) {
+			led = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);
+			if (!led) {
+				hid_err(hid, "can't allocate memory for LED %d\n", j);
+				goto err_leds;
+			}
+
+			name = (void *)(&led[1]);
+			snprintf(name, name_sz, "%s::RPM%d", dev_name(&hid->dev), j+1);
+			led->name = name;
+			led->brightness = 0;
+			led->max_brightness = 1;
+			led->brightness_get = lg4ff_led_get_brightness;
+			led->brightness_set = lg4ff_led_set_brightness;
+
+			entry->wdata.led[j] = led;
+			error = led_classdev_register(&hid->dev, led);
+
+			if (error) {
+				hid_err(hid, "failed to register LED %d. Aborting.\n", j);
+err_leds:
+				/* Deregister LEDs (if any) */
+				for (j = 0; j < 5; j++) {
+					led = entry->wdata.led[j];
+					entry->wdata.led[j] = NULL;
+					if (!led)
+						continue;
+					led_classdev_unregister(led);
+					kfree(led);
+				}
+				goto out;	/* Let the driver continue without LEDs */
+			}
+		}
+	}
+out:
+	return;
+}
+#endif
+
+static u16 lg4ff_identify_multimode_wheel(struct hid_device *hid, const u16 reported_product_id, const u16 bcdDevice)
+{
+	u32 current_mode;
+	int i;
+
+	/* identify current mode from USB PID */
+	for (i = 1; i < ARRAY_SIZE(lg4ff_alternate_modes); i++) {
+		dbg_hid("Testing whether PID is %X\n", lg4ff_alternate_modes[i].product_id);
+		if (reported_product_id == lg4ff_alternate_modes[i].product_id)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(lg4ff_alternate_modes))
+		return 0;
+
+	current_mode = BIT(i);
+
+	for (i = 0; i < ARRAY_SIZE(lg4ff_main_checklist); i++) {
+		const u16 mask = lg4ff_main_checklist[i]->mask;
+		const u16 result = lg4ff_main_checklist[i]->result;
+		const u16 real_product_id = lg4ff_main_checklist[i]->real_product_id;
+
+		if ((current_mode & lg4ff_main_checklist[i]->modes) && \
+				(bcdDevice & mask) == result) {
+			dbg_hid("Found wheel with real PID %X whose reported PID is %X\n", real_product_id, reported_product_id);
+			return real_product_id;
+		}
+	}
+
+	/* No match found. This is either Driving Force or an unknown
+	 * wheel model, do not touch it */
+	dbg_hid("Wheel with bcdDevice %X was not recognized as multimode wheel, leaving in its current mode\n", bcdDevice);
+	return 0;
+}
+
+static int lg4ff_handle_multimode_wheel(struct hid_device *hid, u16 *real_product_id, const u16 bcdDevice)
+{
+	const u16 reported_product_id = hid->product;
+	int ret;
+
+	*real_product_id = lg4ff_identify_multimode_wheel(hid, reported_product_id, bcdDevice);
+	/* Probed wheel is not a multimode wheel */
+	if (!*real_product_id) {
+		*real_product_id = reported_product_id;
+		dbg_hid("Wheel is not a multimode wheel\n");
+		return LG4FF_MMODE_NOT_MULTIMODE;
+	}
+
+	/* Switch from "Driving Force" mode to native mode automatically.
+	 * Otherwise keep the wheel in its current mode */
+	if (reported_product_id == USB_DEVICE_ID_LOGITECH_WHEEL &&
+	    reported_product_id != *real_product_id &&
+	    !lg4ff_no_autoswitch) {
+		const struct lg4ff_compat_mode_switch *s = lg4ff_get_mode_switch_command(*real_product_id, *real_product_id);
+
+		if (!s) {
+			hid_err(hid, "Invalid product id %X\n", *real_product_id);
+			return LG4FF_MMODE_NOT_MULTIMODE;
+		}
+
+		ret = lg4ff_switch_compatibility_mode(hid, s);
+		if (ret) {
+			/* Wheel could not have been switched to native mode,
+			 * leave it in "Driving Force" mode and continue */
+			hid_err(hid, "Unable to switch wheel mode, errno %d\n", ret);
+			return LG4FF_MMODE_IS_MULTIMODE;
+		}
+		return LG4FF_MMODE_SWITCHED;
+	}
+
+	/* Switch from "G923 PS" mode to native mode automatically. */
+	/* Users could use lg4ff_no_autoswitch option if they want to manually change modes */
+	if ((reported_product_id == USB_DEVICE_ID_LOGITECH_G923_PS_WHEEL) &&
+		reported_product_id != *real_product_id) {
+		const struct lg4ff_compat_mode_switch *s = &lg4ff_mode_switch_30_g923;
+		if (lg4ff_no_autoswitch) {
+			hid_err(hid, "This device should switch mode. Load the \"hid_logitech\" module with \"lg4ff_no_autoswitch=0\" parameter set and try again.\n");
+			return -EINVAL;
+		}
+		if (!s) {
+			hid_err(hid, "Invalid product id %X\n", *real_product_id);
+			return LG4FF_MMODE_NOT_MULTIMODE;
+		}
+
+		ret = lg4ff_switch_from_ps_mode(hid, s);
+		if (ret) {
+			/* Wheel could not have been switched to Classic mode,
+			 * leave it in "PS" mode and continue */
+			hid_err(hid, "Unable to switch wheel mode, errno %d\n", ret);
+			return LG4FF_MMODE_IS_MULTIMODE;
+		}
+		return LG4FF_MMODE_SWITCHED;
+	}
+
+	return LG4FF_MMODE_IS_MULTIMODE;
+}
+
+static void lg4ff_destroy(struct ff_device *ff)
+{
+}
+
+int lg4ff_init(struct hid_device *hid)
+{
+	struct hid_input *hidinput;
+	struct input_dev *dev;
+	struct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report = list_entry(report_list->next, struct hid_report, list);
+	const struct usb_device_descriptor *udesc = &(hid_to_usb_dev(hid)->descriptor);
+	const u16 bcdDevice = le16_to_cpu(udesc->bcdDevice);
+	const struct lg4ff_multimode_wheel *mmode_wheel = NULL;
+	struct lg4ff_device_entry *entry;
+	struct lg_drv_data *drv_data;
+	int error, i, j;
+	int mmode_ret, mmode_idx = -1;
+	u16 real_product_id;
+	struct ff_device *ff;
+
+	if (list_empty(&hid->inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	dev = hidinput->input;
+
+	/* Check that the report looks ok */
+	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
+		return -1;
+
+	drv_data = hid_get_drvdata(hid);
+	if (!drv_data) {
+		hid_err(hid, "Cannot add device, private driver data not allocated\n");
+		return -1;
+	}
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	spin_lock_init(&entry->report_lock);
+	entry->hid = hid;
+	entry->report = report;
+	drv_data->device_props = entry;
+
+	/* Check if a multimode wheel has been connected and
+	 * handle it appropriately */
+	mmode_ret = lg4ff_handle_multimode_wheel(hid, &real_product_id, bcdDevice);
+
+	/* Wheel has been told to switch to native mode. There is no point in going on
+	 * with the initialization as the wheel will do a USB reset when it switches mode
+	 */
+	if (mmode_ret == LG4FF_MMODE_SWITCHED) {
+		error = 0;
+		goto err_init;
+	} else if (mmode_ret < 0) {
+		hid_err(hid, "Unable to switch device mode during initialization, errno %d\n", mmode_ret);
+		error = mmode_ret;
+		goto err_init;
+	}
+
+	/* Check what wheel has been connected */
+	for (i = 0; i < ARRAY_SIZE(lg4ff_devices); i++) {
+		if (hid->product == lg4ff_devices[i].product_id) {
+			dbg_hid("Found compatible device, product ID %04X\n", lg4ff_devices[i].product_id);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(lg4ff_devices)) {
+		hid_err(hid, "This device is flagged to be handled by the lg4ff module but this module does not know how to handle it. "
+			     "Please report this as a bug to LKML, Simon Wood <simon@mungewell.org> or "
+			     "Michal Maly <madcatxster@devoid-pointer.net>\n");
+		error = -1;
+		goto err_init;
+	}
+
+	if (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {
+		for (mmode_idx = 0; mmode_idx < ARRAY_SIZE(lg4ff_multimode_wheels); mmode_idx++) {
+			if (real_product_id == lg4ff_multimode_wheels[mmode_idx].product_id)
+				break;
+		}
+
+		if (mmode_idx == ARRAY_SIZE(lg4ff_multimode_wheels)) {
+			hid_err(hid, "Device product ID %X is not listed as a multimode wheel", real_product_id);
+			error = -1;
+			goto err_init;
+		}
+	}
+
+	/* Set supported force feedback capabilities */
+	for (j = 0; lg4ff_devices[i].ff_effects[j] >= 0; j++)
+		set_bit(lg4ff_devices[i].ff_effects[j], dev->ffbit);
+
+	error = input_ff_create(dev, LG4FF_MAX_EFFECTS);
+
+	//__clear_bit(FF_RUMBLE, dev->ffbit);
+
+	if (error)
+		goto err_init;
+
+	ff = dev->ff;
+	ff->upload = lg4ff_upload_effect;
+	ff->playback = lg4ff_play_effect;
+	ff->set_gain = lg4ff_set_gain;
+	ff->destroy = lg4ff_destroy;
+
+	/* Initialize device properties */
+	if (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {
+		BUG_ON(mmode_idx == -1);
+		mmode_wheel = &lg4ff_multimode_wheels[mmode_idx];
+	}
+	lg4ff_init_wheel_data(&entry->wdata, &lg4ff_devices[i], mmode_wheel, real_product_id);
+
+	set_bit(FF_GAIN, dev->ffbit);
+
+	/* Check if autocentering is available and
+	 * set the centering force to zero by default */
+	if (test_bit(FF_AUTOCENTER, dev->ffbit)) {
+		/* Formula Force EX expects different autocentering command */
+		if ((bcdDevice >> 8) == LG4FF_FFEX_REV_MAJ &&
+		    (bcdDevice & 0xff) == LG4FF_FFEX_REV_MIN)
+			dev->ff->set_autocenter = lg4ff_set_autocenter_ffex;
+		else
+			dev->ff->set_autocenter = lg4ff_set_autocenter_default;
+
+		dev->ff->set_autocenter(dev, 0);
+	}
+
+#ifdef CONFIG_LEDS_CLASS
+	if (lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G27_WHEEL ||
+			lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G29_WHEEL ||
+			lg4ff_devices[i].product_id == USB_DEVICE_ID_LOGITECH_G923_WHEEL) {
+		entry->has_leds = 1;
+		lg4ff_init_leds(hid, entry, i);
+	} else {
+		ffb_leds = 0;
+	}
+#endif
+
+	/* Create sysfs interface */
+	error = device_create_file(&hid->dev, &dev_attr_combine_pedals);
+	if (error)
+		hid_warn(hid, "Unable to create sysfs interface for \"combine\", errno %d\n", error);
+	error = device_create_file(&hid->dev, &dev_attr_range);
+	if (error)
+		hid_warn(hid, "Unable to create sysfs interface for \"range\", errno %d\n", error);
+	if (mmode_ret == LG4FF_MMODE_IS_MULTIMODE) {
+		error = device_create_file(&hid->dev, &dev_attr_real_id);
+		if (error)
+			hid_warn(hid, "Unable to create sysfs interface for \"real_id\", errno %d\n", error);
+		error = device_create_file(&hid->dev, &dev_attr_alternate_modes);
+		if (error)
+			hid_warn(hid, "Unable to create sysfs interface for \"alternate_modes\", errno %d\n", error);
+	}
+
+	if (test_bit(FF_CONSTANT, dev->ffbit)) {
+		error = device_create_file(&hid->dev, &dev_attr_gain);
+		if (error)
+			hid_warn(hid, "Unable to create sysfs interface for \"gain\", errno %d\n", error);
+		if (test_bit(FF_AUTOCENTER, dev->ffbit)) {
+			error = device_create_file(&hid->dev, &dev_attr_autocenter);
+			if (error)
+				hid_warn(hid, "Unable to create sysfs interface for \"autocenter\", errno %d\n", error);
+		}
+		error = device_create_file(&hid->dev, &dev_attr_peak_ffb_level);
+		if (error)
+			hid_warn(hid, "Unable to create sysfs interface for \"peak_ffb_level\", errno %d\n", error);
+		if (test_bit(FF_SPRING, dev->ffbit)) {
+			error = device_create_file(&hid->dev, &dev_attr_spring_level);
+			if (error)
+				hid_warn(hid, "Unable to create sysfs interface for \"spring_level\", errno %d\n", error);
+		}
+		if (test_bit(FF_DAMPER, dev->ffbit)) {
+			error = device_create_file(&hid->dev, &dev_attr_damper_level);
+			if (error)
+				hid_warn(hid, "Unable to create sysfs interface for \"damper_level\", errno %d\n", error);
+		}
+		if (test_bit(FF_FRICTION, dev->ffbit) && (entry->wdata.capabilities & LG4FF_CAP_FRICTION)) {
+			error = device_create_file(&hid->dev, &dev_attr_friction_level);
+			if (error)
+				hid_warn(hid, "Unable to create sysfs interface for \"friction_level\", errno %d\n", error);
+		}
+	}
+
+#ifdef CONFIG_LEDS_CLASS
+	if (entry->has_leds) {
+		error = device_create_file(&hid->dev, &dev_attr_ffb_leds);
+		if (error)
+			hid_warn(hid, "Unable to create sysfs interface for \"ffb_leds\", errno %d\n", error);
+	}
+#endif
+
+	dbg_hid("sysfs interface created\n");
+
+	/* Set the maximum range to start with */
+	entry->wdata.range = entry->wdata.max_range;
+	if (entry->wdata.set_range)
+		entry->wdata.set_range(hid, entry->wdata.range);
+
+	lg4ff_init_slots(entry);
+
+	entry->effects_used = 0;
+	entry->wdata.master_gain = 0xffff;
+	entry->wdata.gain = 0xffff;
+
+	spin_lock_init(&entry->timer_lock);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 15, 0)
+	hrtimer_init(&entry->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	entry->hrtimer.function = lg4ff_timer_hires;
+#else
+	hrtimer_setup(&entry->hrtimer, lg4ff_timer_hires, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+#endif
+
+	hid_info(hid, "Force feedback support for Logitech Gaming Wheels (%s)\n", VERSION);
+
+	hid_info(hid, "Hires timer: period = %d ms", timer_msecs);
+
+	return 0;
+
+err_init:
+	drv_data->device_props = NULL;
+	kfree(entry);
+	return error;
+}
+
+int lg4ff_deinit(struct hid_device *hid)
+{
+	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	struct input_dev *dev = hidinput->input;
+	struct lg4ff_device_entry *entry;
+	struct lg_drv_data *drv_data;
+
+	drv_data = hid_get_drvdata(hid);
+	if (!drv_data) {
+		hid_err(hid, "Error while deinitializing device, no private driver data.\n");
+		return -1;
+	}
+	entry = drv_data->device_props;
+	if (!entry)
+		goto out; /* Nothing more to do */
+
+	hrtimer_cancel(&entry->hrtimer);
+
+	/* Multimode devices will have at least the "MODE_NATIVE" bit set */
+	if (entry->wdata.alternate_modes) {
+		device_remove_file(&hid->dev, &dev_attr_real_id);
+		device_remove_file(&hid->dev, &dev_attr_alternate_modes);
+	}
+
+	device_remove_file(&hid->dev, &dev_attr_combine_pedals);
+	device_remove_file(&hid->dev, &dev_attr_range);
+
+	if (test_bit(FF_CONSTANT, dev->ffbit)) {
+		device_remove_file(&hid->dev, &dev_attr_gain);
+		if (test_bit(FF_AUTOCENTER, dev->ffbit)) {
+			device_remove_file(&hid->dev, &dev_attr_autocenter);
+		}
+		device_remove_file(&hid->dev, &dev_attr_peak_ffb_level);
+		if (test_bit(FF_SPRING, dev->ffbit)) {
+			device_remove_file(&hid->dev, &dev_attr_spring_level);
+		}
+		if (test_bit(FF_DAMPER, dev->ffbit)) {
+			device_remove_file(&hid->dev, &dev_attr_damper_level);
+		}
+		if (test_bit(FF_FRICTION, dev->ffbit)
+				&& (entry->wdata.capabilities & LG4FF_CAP_FRICTION)) {
+			device_remove_file(&hid->dev, &dev_attr_friction_level);
+		}
+	}
+
+	lg4ff_stop_effects(entry);
+
+#ifdef CONFIG_LEDS_CLASS
+	if (entry->has_leds) {
+		int j;
+		struct led_classdev *led;
+
+		device_remove_file(&hid->dev, &dev_attr_ffb_leds);
+
+		/* Deregister LEDs (if any) */
+		for (j = 0; j < 5; j++) {
+
+			led = entry->wdata.led[j];
+			entry->wdata.led[j] = NULL;
+			if (!led)
+				continue;
+			led_classdev_unregister(led);
+			kfree(led);
+		}
+	}
+#endif
+
+	drv_data->device_props = NULL;
+
+	kfree(entry);
+out:
+	dbg_hid("Device successfully unregistered\n");
+	return 0;
+}
diff --git a/drivers/custom/lg4ff/hid-lg4ff.h b/drivers/custom/lg4ff/hid-lg4ff.h
new file mode 100644
index 000000000000..e5c55d515ac2
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lg4ff.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __HID_LG4FF_H
+#define __HID_LG4FF_H
+
+#ifdef CONFIG_LOGIWHEELS_FF
+extern int lg4ff_no_autoswitch; /* From hid-lg.c */
+
+int lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,
+			     struct hid_usage *usage, s32 value, struct lg_drv_data *drv_data);
+int lg4ff_raw_event(struct hid_device *hdev, struct hid_report *report,
+		u8 *rd, int size, struct lg_drv_data *drv_data);
+int lg4ff_init(struct hid_device *hdev);
+int lg4ff_deinit(struct hid_device *hdev);
+#else
+static inline int lg4ff_adjust_input_event(struct hid_device *hid, struct hid_field *field,
+					   struct hid_usage *usage, s32 value, struct lg_drv_data *drv_data) { return 0; }
+static inline int lg4ff_raw_event(struct hid_device *hdev, struct hid_report *report,
+		u8 *rd, int size, struct lg_drv_data *drv_data) { return 0; }
+static inline int lg4ff_init(struct hid_device *hdev) { return -1; }
+static inline int lg4ff_deinit(struct hid_device *hdev) { return -1; }
+#endif
+
+#endif
diff --git a/drivers/custom/lg4ff/hid-lgff.c b/drivers/custom/lg4ff/hid-lgff.c
new file mode 100644
index 000000000000..aed4ddc397a9
--- /dev/null
+++ b/drivers/custom/lg4ff/hid-lgff.c
@@ -0,0 +1,156 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Force feedback support for hid-compliant for some of the devices from
+ * Logitech, namely:
+ * - WingMan Cordless RumblePad
+ * - WingMan Force 3D
+ *
+ *  Copyright (c) 2002-2004 Johann Deneux
+ *  Copyright (c) 2006 Anssi Hannula <anssi.hannula@gmail.com>
+ */
+
+/*
+ *
+ * Should you need to contact me, the author, you can do so by
+ * e-mail - mail your message to <johann.deneux@it.uu.se>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/input.h>
+#include <linux/hid.h>
+
+#include "hid-lg.h"
+
+struct dev_type {
+	u16 idVendor;
+	u16 idProduct;
+	const signed short *ff;
+};
+
+static const signed short ff_rumble[] = {
+	FF_RUMBLE,
+	-1
+};
+
+static const signed short ff_joystick[] = {
+	FF_CONSTANT,
+	-1
+};
+
+static const signed short ff_joystick_ac[] = {
+	FF_CONSTANT,
+	FF_AUTOCENTER,
+	-1
+};
+
+static const struct dev_type devices[] = {
+	{ 0x046d, 0xc211, ff_rumble },
+	{ 0x046d, 0xc219, ff_rumble },
+	{ 0x046d, 0xc283, ff_joystick },
+	{ 0x046d, 0xc286, ff_joystick_ac },
+	{ 0x046d, 0xc287, ff_joystick_ac },
+	{ 0x046d, 0xc293, ff_joystick },
+	{ 0x046d, 0xc295, ff_joystick },
+};
+
+static int hid_lgff_play(struct input_dev *dev, void *data, struct ff_effect *effect)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report = list_entry(report_list->next, struct hid_report, list);
+	int x, y;
+	unsigned int left, right;
+
+#define CLAMP(x) if (x < 0) x = 0; if (x > 0xff) x = 0xff
+
+	switch (effect->type) {
+	case FF_CONSTANT:
+		x = effect->u.ramp.start_level + 0x7f;	/* 0x7f is center */
+		y = effect->u.ramp.end_level + 0x7f;
+		CLAMP(x);
+		CLAMP(y);
+		report->field[0]->value[0] = 0x51;
+		report->field[0]->value[1] = 0x08;
+		report->field[0]->value[2] = x;
+		report->field[0]->value[3] = y;
+		dbg_hid("(x, y)=(%04x, %04x)\n", x, y);
+		hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+		break;
+
+	case FF_RUMBLE:
+		right = effect->u.rumble.strong_magnitude;
+		left = effect->u.rumble.weak_magnitude;
+		right = right * 0xff / 0xffff;
+		left = left * 0xff / 0xffff;
+		CLAMP(left);
+		CLAMP(right);
+		report->field[0]->value[0] = 0x42;
+		report->field[0]->value[1] = 0x00;
+		report->field[0]->value[2] = left;
+		report->field[0]->value[3] = right;
+		dbg_hid("(left, right)=(%04x, %04x)\n", left, right);
+		hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+		break;
+	}
+	return 0;
+}
+
+static void hid_lgff_set_autocenter(struct input_dev *dev, u16 magnitude)
+{
+	struct hid_device *hid = input_get_drvdata(dev);
+	struct list_head *report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report = list_entry(report_list->next, struct hid_report, list);
+	__s32 *value = report->field[0]->value;
+	magnitude = (magnitude >> 12) & 0xf;
+	*value++ = 0xfe;
+	*value++ = 0x0d;
+	*value++ = magnitude;   /* clockwise strength */
+	*value++ = magnitude;   /* counter-clockwise strength */
+	*value++ = 0x80;
+	*value++ = 0x00;
+	*value = 0x00;
+	hid_hw_request(hid, report, HID_REQ_SET_REPORT);
+}
+
+int lgff_init(struct hid_device* hid)
+{
+	struct hid_input *hidinput;
+	struct input_dev *dev;
+	const signed short *ff_bits = ff_joystick;
+	int error;
+	int i;
+
+	if (list_empty(&hid->inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid->inputs.next, struct hid_input, list);
+	dev = hidinput->input;
+
+	/* Check that the report looks ok */
+	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
+		return -ENODEV;
+
+	for (i = 0; i < ARRAY_SIZE(devices); i++) {
+		if (dev->id.vendor == devices[i].idVendor &&
+		    dev->id.product == devices[i].idProduct) {
+			ff_bits = devices[i].ff;
+			break;
+		}
+	}
+
+	for (i = 0; ff_bits[i] >= 0; i++)
+		set_bit(ff_bits[i], dev->ffbit);
+
+	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
+	if (error)
+		return error;
+
+	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
+		dev->ff->set_autocenter = hid_lgff_set_autocenter;
+
+	pr_info("Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\n");
+
+	return 0;
+}
diff --git a/drivers/custom/lg4ff/usbhid/usbhid.h b/drivers/custom/lg4ff/usbhid/usbhid.h
new file mode 100644
index 000000000000..8620408bd7af
--- /dev/null
+++ b/drivers/custom/lg4ff/usbhid/usbhid.h
@@ -0,0 +1,96 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+#ifndef __USBHID_H
+#define __USBHID_H
+
+/*
+ *  Copyright (c) 1999 Andreas Gal
+ *  Copyright (c) 2000-2001 Vojtech Pavlik
+ *  Copyright (c) 2006 Jiri Kosina
+ */
+
+/*
+ */
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/timer.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+
+/*  API provided by hid-core.c for USB HID drivers */
+void usbhid_init_reports(struct hid_device *hid);
+struct usb_interface *usbhid_find_interface(int minor);
+
+/* iofl flags */
+#define HID_CTRL_RUNNING	1
+#define HID_OUT_RUNNING		2
+#define HID_IN_RUNNING		3
+#define HID_RESET_PENDING	4
+#define HID_SUSPENDED		5
+#define HID_CLEAR_HALT		6
+#define HID_DISCONNECTED	7
+#define HID_STARTED		8
+#define HID_KEYS_PRESSED	10
+#define HID_NO_BANDWIDTH	11
+#define HID_RESUME_RUNNING	12
+/*
+ * The device is opened, meaning there is a client that is interested
+ * in data coming from the device.
+ */
+#define HID_OPENED		13
+/*
+ * We are polling input endpoint by [re]submitting IN URB, because
+ * either HID device is opened or ALWAYS POLL quirk is set for the
+ * device.
+ */
+#define HID_IN_POLLING		14
+
+/*
+ * USB-specific HID struct, to be pointed to
+ * from struct hid_device->driver_data
+ */
+
+struct usbhid_device {
+	struct hid_device *hid;						/* pointer to corresponding HID dev */
+
+	struct usb_interface *intf;                                     /* USB interface */
+	int ifnum;                                                      /* USB interface number */
+
+	unsigned int bufsize;                                           /* URB buffer size */
+
+	struct urb *urbin;                                              /* Input URB */
+	char *inbuf;                                                    /* Input buffer */
+	dma_addr_t inbuf_dma;                                           /* Input buffer dma */
+
+	struct urb *urbctrl;                                            /* Control URB */
+	struct usb_ctrlrequest *cr;                                     /* Control request struct */
+	struct hid_control_fifo ctrl[HID_CONTROL_FIFO_SIZE];  		/* Control fifo */
+	unsigned char ctrlhead, ctrltail;                               /* Control fifo head & tail */
+	char *ctrlbuf;                                                  /* Control buffer */
+	dma_addr_t ctrlbuf_dma;                                         /* Control buffer dma */
+	unsigned long last_ctrl;						/* record of last output for timeouts */
+
+	struct urb *urbout;                                             /* Output URB */
+	struct hid_output_fifo out[HID_CONTROL_FIFO_SIZE];              /* Output pipe fifo */
+	unsigned char outhead, outtail;                                 /* Output pipe fifo head & tail */
+	char *outbuf;                                                   /* Output buffer */
+	dma_addr_t outbuf_dma;                                          /* Output buffer dma */
+	unsigned long last_out;							/* record of last output for timeouts */
+
+	spinlock_t lock;						/* fifo spinlock */
+	unsigned long iofl;                                             /* I/O flags (CTRL_RUNNING, OUT_RUNNING) */
+	struct timer_list io_retry;                                     /* Retry timer */
+	unsigned long stop_retry;                                       /* Time to give up, in jiffies */
+	unsigned int retry_delay;                                       /* Delay length in ms */
+	struct work_struct reset_work;                                  /* Task context for resets */
+	wait_queue_head_t wait;						/* For sleeping */
+};
+
+#define	hid_to_usb_dev(hid_dev) \
+	to_usb_device(hid_dev->dev.parent->parent)
+
+#endif
+
# ----------------------------------------
# Module: system76
# Version: 1.0.21
# ----------------------------------------
diff --git a/drivers/custom/system76/Kbuild b/drivers/custom/system76/Kbuild
new file mode 100644
index 000000000000..d44f74336eaa
--- /dev/null
+++ b/drivers/custom/system76/Kbuild
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+obj-y += src/
diff --git a/drivers/custom/system76/Makefile b/drivers/custom/system76/Makefile
new file mode 100644
index 000000000000..3908fa8bfb89
--- /dev/null
+++ b/drivers/custom/system76/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+KERNEL_DIR = /lib/modules/$(shell uname -r)/build
+
+all:
+	$(MAKE) -C "$(KERNEL_DIR)" M="$(PWD)" modules
+
+clean:
+	$(MAKE) -C "$(KERNEL_DIR)" M="$(PWD)" clean
diff --git a/drivers/custom/system76/src/Kbuild b/drivers/custom/system76/src/Kbuild
new file mode 100644
index 000000000000..b426c1943611
--- /dev/null
+++ b/drivers/custom/system76/src/Kbuild
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+obj-m += system76.o
diff --git a/drivers/custom/system76/src/ap-led.c b/drivers/custom/system76/src/ap-led.c
new file mode 100644
index 000000000000..d62171c35e99
--- /dev/null
+++ b/drivers/custom/system76/src/ap-led.c
@@ -0,0 +1,119 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * ap_led.c
+ *
+ * Copyright (C) 2017 Jeremy Soller <jeremy@system76.com>
+ */
+
+static enum led_brightness ap_led_brightness = 1;
+
+static bool ap_led_invert = TRUE;
+
+static enum led_brightness ap_led_get(struct led_classdev *led_cdev)
+{
+	return ap_led_brightness;
+}
+
+static int ap_led_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	u8 byte;
+
+	ec_read(0xD9, &byte);
+
+	if (value > 0) {
+		ap_led_brightness = 1;
+
+		if (ap_led_invert) {
+			byte &= ~0x40;
+		} else {
+			byte |= 0x40;
+		}
+	} else {
+		ap_led_brightness = 0;
+
+		if (ap_led_invert) {
+			byte |= 0x40;
+		} else {
+			byte &= ~0x40;
+		}
+	}
+
+	ec_write(0xD9, byte);
+
+	return 0;
+}
+
+static struct led_classdev ap_led = {
+	.name = "system76::airplane",
+	.brightness_get = ap_led_get,
+	.brightness_set_blocking = ap_led_set,
+	.max_brightness = 1,
+	.default_trigger = "rfkill-any"
+};
+
+static ssize_t ap_led_invert_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "%d\n", (int)ap_led_invert);
+}
+
+static ssize_t ap_led_invert_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	unsigned int val;
+	int ret;
+	enum led_brightness brightness;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret) {
+		return ret;
+	}
+
+	brightness = ap_led_get(&ap_led);
+
+	if (val) {
+		ap_led_invert = TRUE;
+	} else {
+		ap_led_invert = FALSE;
+	}
+
+	ap_led_set(&ap_led, brightness);
+
+	return size;
+}
+
+static struct device_attribute ap_led_invert_dev_attr = {
+	.attr = {
+		.name = "invert",
+		.mode = 0644,
+	},
+	.show = ap_led_invert_show,
+	.store = ap_led_invert_store,
+};
+
+static void ap_led_resume(void)
+{
+	ap_led_set(&ap_led, ap_led_brightness);
+}
+
+static int __init ap_led_init(struct device *dev)
+{
+	int err;
+
+	err = devm_led_classdev_register(dev, &ap_led);
+	if (err < 0) {
+		return err;
+	}
+
+	err = device_create_file(ap_led.dev, &ap_led_invert_dev_attr);
+	if (err < 0) {
+		pr_err("failed to create ap_led_invert\n");
+	}
+
+	ap_led_resume();
+
+	return 0;
+}
+
+static void __exit ap_led_exit(void)
+{
+	device_remove_file(ap_led.dev, &ap_led_invert_dev_attr);
+}
diff --git a/drivers/custom/system76/src/hwmon.c b/drivers/custom/system76/src/hwmon.c
new file mode 100644
index 000000000000..f189681d256b
--- /dev/null
+++ b/drivers/custom/system76/src/hwmon.c
@@ -0,0 +1,266 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * fan.c
+ *
+ * Copyright (C) 2017 Jeremy Soller <jeremy@system76.com>
+ * Copyright (C) 2014-2016 Arnoud Willemsen <mail@lynthium.com>
+ * Copyright (C) 2013-2015 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ */
+
+#define EXPERIMENTAL
+
+#if S76_HAS_HWMON
+
+struct s76_hwmon {
+	struct device *dev;
+};
+
+static struct s76_hwmon *s76_hwmon;
+
+static int s76_read_fan(int idx)
+{
+	u8 value;
+	int raw_rpm;
+
+	ec_read(0xd0 + 0x2 * idx, &value);
+	raw_rpm = value << 8;
+	ec_read(0xd1 + 0x2 * idx, &value);
+	raw_rpm += value;
+	if (!raw_rpm)
+		return 0;
+	return 2156220 / raw_rpm;
+}
+
+static int s76_read_pwm(int idx)
+{
+	u8 value;
+
+	ec_read(0xce + idx, &value);
+	return value;
+}
+
+static int s76_write_pwm(int idx, u8 duty)
+{
+	u8 values[] = {idx + 1, duty};
+
+	return ec_transaction(0x99, values, sizeof(values), NULL, 0);
+}
+
+static int s76_write_pwm_auto(int idx)
+{
+	u8 values[] = {0xff, idx + 1};
+
+	return ec_transaction(0x99, values, sizeof(values), NULL, 0);
+}
+
+static ssize_t s76_hwmon_show_fan_input(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int index = to_sensor_dev_attr(attr)->index;
+
+	return sysfs_emit(buf, "%i\n", s76_read_fan(index));
+}
+
+static ssize_t s76_hwmon_show_fan_label(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	switch (to_sensor_dev_attr(attr)->index) {
+	case 0:
+		return sysfs_emit(buf, "CPU fan\n");
+	case 1:
+		return sysfs_emit(buf, "GPU fan\n");
+	}
+	return 0;
+}
+
+static int pwm_enabled[] = {2, 2};
+
+static ssize_t s76_hwmon_show_pwm(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int index = to_sensor_dev_attr(attr)->index;
+
+	return sysfs_emit(buf, "%i\n", s76_read_pwm(index));
+}
+
+static ssize_t s76_hwmon_set_pwm(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 value;
+	int err;
+	int index = to_sensor_dev_attr(attr)->index;
+
+	err = kstrtou32(buf, 10, &value);
+	if (err)
+		return err;
+	if (value > 255)
+		return -EINVAL;
+	err = s76_write_pwm(index, value);
+	if (err)
+		return err;
+	pwm_enabled[index] = 1;
+	return count;
+}
+
+static ssize_t s76_hwmon_show_pwm_enable(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int index = to_sensor_dev_attr(attr)->index;
+
+	return sysfs_emit(buf, "%i\n", pwm_enabled[index]);
+}
+
+static ssize_t s76_hwmon_set_pwm_enable(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 value;
+	int err;
+	int index = to_sensor_dev_attr(attr)->index;
+
+	err = kstrtou32(buf, 10, &value);
+	if (err)
+		return err;
+	if (value == 0) {
+		err = s76_write_pwm(index, 255);
+		if (err)
+			return err;
+		pwm_enabled[index] = value;
+		return count;
+	}
+	if (value == 1) {
+		err = s76_write_pwm(index, 0);
+		if (err)
+			return err;
+		pwm_enabled[index] = value;
+		return count;
+	}
+	if (value == 2) {
+		err = s76_write_pwm_auto(index);
+		if (err)
+			return err;
+		pwm_enabled[index] = value;
+		return count;
+	}
+	return -EINVAL;
+}
+
+static ssize_t s76_hwmon_show_temp1_input(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u8 value;
+
+	ec_read(0x07, &value);
+	return sysfs_emit(buf, "%i\n", value * 1000);
+}
+
+static ssize_t s76_hwmon_show_temp1_label(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "CPU temperature\n");
+}
+
+#ifdef EXPERIMENTAL
+static ssize_t s76_hwmon_show_temp2_input(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	u8 value;
+
+	ec_read(0xcd, &value);
+	return sysfs_emit(buf, "%i\n", value * 1000);
+}
+
+static ssize_t s76_hwmon_show_temp2_label(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "GPU temperature\n");
+}
+#endif
+
+static SENSOR_DEVICE_ATTR(fan1_input, 0444, s76_hwmon_show_fan_input, NULL, 0);
+static SENSOR_DEVICE_ATTR(fan1_label, 0444, s76_hwmon_show_fan_label, NULL, 0);
+static SENSOR_DEVICE_ATTR(pwm1, 0644, s76_hwmon_show_pwm, s76_hwmon_set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm1_enable, 0644, s76_hwmon_show_pwm_enable, s76_hwmon_set_pwm_enable, 0);
+#ifdef EXPERIMENTAL
+static SENSOR_DEVICE_ATTR(fan2_input, 0444, s76_hwmon_show_fan_input, NULL, 1);
+static SENSOR_DEVICE_ATTR(fan2_label, 0444, s76_hwmon_show_fan_label, NULL, 1);
+static SENSOR_DEVICE_ATTR(pwm2, 0644, s76_hwmon_show_pwm, s76_hwmon_set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm2_enable, 0644, s76_hwmon_show_pwm_enable, s76_hwmon_set_pwm_enable, 1);
+#endif
+static SENSOR_DEVICE_ATTR(temp1_input, 0444, s76_hwmon_show_temp1_input, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_label, 0444, s76_hwmon_show_temp1_label, NULL, 0);
+#ifdef EXPERIMENTAL
+static SENSOR_DEVICE_ATTR(temp2_input, 0444, s76_hwmon_show_temp2_input, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp2_label, 0444, s76_hwmon_show_temp2_label, NULL, 1);
+#endif
+
+static struct attribute *hwmon_default_attributes[] = {
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_label.dev_attr.attr,
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm1_enable.dev_attr.attr,
+#ifdef EXPERIMENTAL
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_label.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm2_enable.dev_attr.attr,
+#endif
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+#ifdef EXPERIMENTAL
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_label.dev_attr.attr,
+#endif
+	NULL
+};
+
+static const struct attribute_group hwmon_default_group = {
+	.attrs = hwmon_default_attributes,
+};
+__ATTRIBUTE_GROUPS(hwmon_default);
+
+static int s76_hwmon_reboot_callback(struct notifier_block *nb,
+		unsigned long action, void *data)
+{
+	s76_write_pwm_auto(0);
+	#ifdef EXPERIMENTAL
+		s76_write_pwm_auto(1);
+	#endif
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block s76_hwmon_reboot_notifier = {
+	.notifier_call = s76_hwmon_reboot_callback
+};
+
+static int s76_hwmon_init(struct device *dev)
+{
+	s76_hwmon = devm_kzalloc(dev, sizeof(*s76_hwmon), GFP_KERNEL);
+	if (!s76_hwmon)
+		return -ENOMEM;
+
+	s76_hwmon->dev = devm_hwmon_device_register_with_groups(dev, S76_DRIVER_NAME, NULL, hwmon_default_groups);
+	if (IS_ERR(s76_hwmon->dev)) {
+		return PTR_ERR(s76_hwmon->dev);
+	}
+
+	(void)devm_register_reboot_notifier(dev, &s76_hwmon_reboot_notifier);
+	s76_write_pwm_auto(0);
+	#ifdef EXPERIMENTAL
+	s76_write_pwm_auto(1);
+	#endif
+	return 0;
+}
+
+static int s76_hwmon_fini(struct device *dev)
+{
+	if (!s76_hwmon || IS_ERR_OR_NULL(s76_hwmon->dev))
+		return 0;
+
+	s76_write_pwm_auto(0);
+	#ifdef EXPERIMENTAL
+	s76_write_pwm_auto(1);
+	#endif
+	return 0;
+}
+
+#endif // S76_HAS_HWMON
diff --git a/drivers/custom/system76/src/input.c b/drivers/custom/system76/src/input.c
new file mode 100644
index 000000000000..236b85a1176a
--- /dev/null
+++ b/drivers/custom/system76/src/input.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * input.c
+ *
+ * Copyright (C) 2017 Jeremy Soller <jeremy@system76.com>
+ * Copyright (C) 2014-2016 Arnoud Willemsen <mail@lynthium.com>
+ * Copyright (C) 2013-2015 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ */
+
+#define AIRPLANE_KEY KEY_WLAN
+#define SCREEN_KEY KEY_SCREENLOCK
+
+static struct input_dev *s76_input_device;
+static DEFINE_MUTEX(s76_input_report_mutex);
+
+#define POLL_FREQ_MIN     1
+#define POLL_FREQ_MAX     20
+#define POLL_FREQ_DEFAULT 5
+
+static int param_set_poll_freq(const char *val, const struct kernel_param *kp)
+{
+	int ret;
+
+	ret = param_set_byte(val, kp);
+
+	if (!ret)
+		*((unsigned char *) kp->arg) = clamp_t(unsigned char,
+			*((unsigned char *) kp->arg),
+			POLL_FREQ_MIN, POLL_FREQ_MAX);
+
+	return ret;
+}
+
+
+static const struct kernel_param_ops param_ops_poll_freq = {
+	.set = param_set_poll_freq,
+	.get = param_get_byte,
+};
+
+static unsigned char param_poll_freq = POLL_FREQ_DEFAULT;
+#define param_check_poll_freq param_check_byte
+module_param_named(poll_freq, param_poll_freq, poll_freq, 0400);
+MODULE_PARM_DESC(poll_freq, "Set polling frequency");
+
+static struct task_struct *s76_input_polling_task;
+
+static void s76_input_key(unsigned int code)
+{
+	pr_debug("Send key %x\n", code);
+
+	mutex_lock(&s76_input_report_mutex);
+
+	input_report_key(s76_input_device, code, 1);
+	input_sync(s76_input_device);
+
+	input_report_key(s76_input_device, code, 0);
+	input_sync(s76_input_device);
+
+	mutex_unlock(&s76_input_report_mutex);
+}
+
+static int s76_input_polling_thread(void *data)
+{
+	pr_debug("Polling thread started (PID: %i), polling at %i Hz\n",
+				current->pid, param_poll_freq);
+
+	while (!kthread_should_stop()) {
+		u8 byte;
+
+		ec_read(0xDB, &byte);
+		if (byte & 0x40) {
+			ec_write(0xDB, byte & ~0x40);
+
+			pr_debug("Airplane-Mode Hotkey pressed (EC)\n");
+
+			s76_input_key(AIRPLANE_KEY);
+		}
+
+		msleep_interruptible(1000 / param_poll_freq);
+	}
+
+	pr_debug("Polling thread exiting\n");
+
+	return 0;
+}
+
+static void s76_input_airplane_wmi(void)
+{
+	pr_debug("Airplane-Mode Hotkey pressed (WMI)\n");
+
+	s76_input_key(AIRPLANE_KEY);
+}
+
+static void s76_input_screen_wmi(void)
+{
+	pr_debug("Screen Hotkey pressed (WMI)\n");
+
+	s76_input_key(SCREEN_KEY);
+}
+
+static int s76_input_open(struct input_dev *dev)
+{
+	int res = 0;
+
+	// Run polling thread if AP key driver is used and WMI is not supported
+	if ((driver_flags & (DRIVER_AP_KEY | DRIVER_AP_WMI)) == DRIVER_AP_KEY) {
+		s76_input_polling_task = kthread_run(
+			s76_input_polling_thread,
+			NULL, "system76-polld");
+
+		if (IS_ERR(s76_input_polling_task)) {
+			res = PTR_ERR(s76_input_polling_task);
+			s76_input_polling_task = NULL;
+			pr_err("Could not create polling thread: %d\n", res);
+			return res;
+		}
+	}
+
+	return res;
+}
+
+static void s76_input_close(struct input_dev *dev)
+{
+	if (IS_ERR_OR_NULL(s76_input_polling_task)) {
+		return;
+	}
+
+	kthread_stop(s76_input_polling_task);
+	s76_input_polling_task = NULL;
+}
+
+static int __init s76_input_init(struct device *dev)
+{
+	u8 byte;
+
+	s76_input_device = devm_input_allocate_device(dev);
+	if (!s76_input_device) {
+		pr_err("Error allocating input device\n");
+		return -ENOMEM;
+	}
+
+	s76_input_device->name = "System76 Hotkeys";
+	s76_input_device->phys = "system76/input0";
+	s76_input_device->id.bustype = BUS_HOST;
+	set_bit(EV_KEY, s76_input_device->evbit);
+
+	if (driver_flags & DRIVER_AP_KEY) {
+		set_bit(AIRPLANE_KEY, s76_input_device->keybit);
+		ec_read(0xDB, &byte);
+		ec_write(0xDB, byte & ~0x40);
+	}
+	if (driver_flags & DRIVER_OLED) {
+		set_bit(SCREEN_KEY, s76_input_device->keybit);
+	}
+
+	s76_input_device->open  = s76_input_open;
+	s76_input_device->close = s76_input_close;
+
+	return input_register_device(s76_input_device);
+}
diff --git a/drivers/custom/system76/src/kb-led.c b/drivers/custom/system76/src/kb-led.c
new file mode 100644
index 000000000000..91cdf8a657bb
--- /dev/null
+++ b/drivers/custom/system76/src/kb-led.c
@@ -0,0 +1,420 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * kb_led.c
+ *
+ * Copyright (C) 2017 Jeremy Soller <jeremy@system76.com>
+ */
+
+#define SET_KB_LED 0x67
+
+union kb_led_color {
+	u32 rgb;
+	struct { u32 b:8, g:8, r:8, : 8; };
+};
+
+enum kb_led_region {
+	KB_LED_REGION_LEFT,
+	KB_LED_REGION_CENTER,
+	KB_LED_REGION_RIGHT,
+	KB_LED_REGION_EXTRA,
+};
+
+static enum led_brightness kb_led_brightness;
+
+static enum led_brightness kb_led_toggle_brightness = 72;
+
+static enum led_brightness kb_led_levels[] = { 48, 72, 96, 144, 192, 255 };
+
+static union kb_led_color kb_led_regions[] = {
+	{ .rgb = 0xFFFFFF },
+	{ .rgb = 0xFFFFFF },
+	{ .rgb = 0xFFFFFF },
+	{ .rgb = 0xFFFFFF }
+};
+
+static int kb_led_colors_i;
+
+static union kb_led_color kb_led_colors[] = {
+	{ .rgb = 0xFFFFFF },
+	{ .rgb = 0x0000FF },
+	{ .rgb = 0xFF0000 },
+	{ .rgb = 0xFF00FF },
+	{ .rgb = 0x00FF00 },
+	{ .rgb = 0x00FFFF },
+	{ .rgb = 0xFFFF00 }
+};
+
+static enum led_brightness kb_led_get(struct led_classdev *led_cdev)
+{
+	return kb_led_brightness;
+}
+
+static int kb_led_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	pr_debug("%s %d\n", __func__, (int)value);
+
+	if (!s76_wmbb(SET_KB_LED, 0xF4000000 | value, NULL)) {
+		kb_led_brightness = value;
+	}
+
+	return 0;
+}
+
+static void kb_led_color_set_wmi(enum kb_led_region region, union kb_led_color color)
+{
+	u32 cmd;
+
+	pr_debug("%s %d %06X\n", __func__, (int)region, (int)color.rgb);
+
+	switch (region) {
+	case KB_LED_REGION_LEFT:
+		cmd = 0xF0000000;
+		break;
+	case KB_LED_REGION_CENTER:
+		cmd = 0xF1000000;
+		break;
+	case KB_LED_REGION_RIGHT:
+		cmd = 0xF2000000;
+		break;
+	case KB_LED_REGION_EXTRA:
+		cmd = 0xF3000000;
+		break;
+	default:
+		return;
+	}
+
+	cmd |= color.b << 16;
+	cmd |= color.r <<  8;
+	cmd |= color.g <<  0;
+
+	if (!s76_wmbb(SET_KB_LED, cmd, NULL)) {
+		kb_led_regions[region] = color;
+	}
+}
+
+// HACK: Directly call ECMD to fix serw14
+static void kb_led_color_set(enum kb_led_region region, union kb_led_color color)
+{
+	struct acpi_object_list input;
+	union acpi_object obj;
+	acpi_handle handle;
+	acpi_status status;
+	u8 *buf;
+
+	buf = kzalloc(8, GFP_KERNEL);
+
+	pr_debug("%s %d %06X\n", __func__, (int)region, (int)color.rgb);
+
+	buf[0] = 5;
+	buf[2] = 0xCA;
+	buf[4] = color.b;
+	buf[5] = color.r;
+	buf[6] = color.g;
+
+	switch (region) {
+	case KB_LED_REGION_LEFT:
+		buf[3] = 0x03;
+		break;
+	case KB_LED_REGION_CENTER:
+		buf[3] = 0x04;
+		break;
+	case KB_LED_REGION_RIGHT:
+		buf[3] = 0x05;
+		break;
+	case KB_LED_REGION_EXTRA:
+		buf[3] = 0x0B;
+		break;
+	}
+
+	obj.type = ACPI_TYPE_BUFFER;
+	obj.buffer.length = 8;
+	obj.buffer.pointer = buf;
+
+	input.count = 1;
+	input.pointer = &obj;
+
+	status = acpi_get_handle(NULL, (acpi_string)"\\_SB.PC00.LPCB.EC", &handle);
+	if (ACPI_FAILURE(status)) {
+		pr_err("%s failed to get handle: %x\n", __func__, status);
+		return;
+	}
+
+	status = acpi_evaluate_object(handle, "ECMD", &input, NULL);
+	if (ACPI_FAILURE(status)) {
+		pr_err("%s failed to call EC_CMD: %x\n", __func__, status);
+		return;
+	}
+
+	// Update lightbar to match keyboard color
+	buf[3] = 0x07;
+	status = acpi_evaluate_object(handle, "ECMD", &input, NULL);
+	if (ACPI_FAILURE(status)) {
+		pr_err("%s failed to call EC_CMD: %x\n", __func__, status);
+		return;
+	}
+
+	kfree(buf);
+	kb_led_regions[region] = color;
+}
+
+static struct led_classdev kb_led = {
+	.name = "system76::kbd_backlight",
+	.flags = LED_BRIGHT_HW_CHANGED,
+	.brightness_get = kb_led_get,
+	.brightness_set_blocking = kb_led_set,
+	.max_brightness = 255,
+};
+
+static ssize_t kb_led_color_show(enum kb_led_region region, char *buf)
+{
+	return sysfs_emit(buf, "%06X\n", (int)kb_led_regions[region].rgb);
+}
+
+static ssize_t kb_led_color_store(enum kb_led_region region, const char *buf, size_t size)
+{
+	unsigned int val;
+	int ret;
+	union kb_led_color color;
+
+	ret = kstrtouint(buf, 16, &val);
+	if (ret) {
+		return ret;
+	}
+
+	color.rgb = (u32)val;
+	if (driver_flags & DRIVER_KB_LED_WMI)
+		kb_led_color_set_wmi(region, color);
+	else
+		kb_led_color_set(region, color);
+
+	return size;
+}
+
+static ssize_t kb_led_color_left_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return kb_led_color_show(KB_LED_REGION_LEFT, buf);
+}
+
+static ssize_t kb_led_color_left_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	return kb_led_color_store(KB_LED_REGION_LEFT, buf, size);
+}
+
+static struct device_attribute kb_led_color_left_dev_attr = {
+	.attr = {
+		.name = "color_left",
+		.mode = 0644,
+	},
+	.show = kb_led_color_left_show,
+	.store = kb_led_color_left_store,
+};
+
+static ssize_t kb_led_color_center_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return kb_led_color_show(KB_LED_REGION_CENTER, buf);
+}
+
+static ssize_t kb_led_color_center_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	return kb_led_color_store(KB_LED_REGION_CENTER, buf, size);
+}
+
+static struct device_attribute kb_led_color_center_dev_attr = {
+	.attr = {
+		.name = "color_center",
+		.mode = 0644,
+	},
+	.show = kb_led_color_center_show,
+	.store = kb_led_color_center_store,
+};
+
+static ssize_t kb_led_color_right_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return kb_led_color_show(KB_LED_REGION_RIGHT, buf);
+}
+
+static ssize_t kb_led_color_right_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	return kb_led_color_store(KB_LED_REGION_RIGHT, buf, size);
+}
+
+static struct device_attribute kb_led_color_right_dev_attr = {
+	.attr = {
+		.name = "color_right",
+		.mode = 0644,
+	},
+	.show = kb_led_color_right_show,
+	.store = kb_led_color_right_store,
+};
+
+static ssize_t kb_led_color_extra_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return kb_led_color_show(KB_LED_REGION_EXTRA, buf);
+}
+
+static ssize_t kb_led_color_extra_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	return kb_led_color_store(KB_LED_REGION_EXTRA, buf, size);
+}
+
+static struct device_attribute kb_led_color_extra_dev_attr = {
+	.attr = {
+		.name = "color_extra",
+		.mode = 0644,
+	},
+	.show = kb_led_color_extra_show,
+	.store = kb_led_color_extra_store,
+};
+
+static void kb_led_enable(void)
+{
+	pr_debug("%s\n", __func__);
+
+	s76_wmbb(SET_KB_LED, 0xE007F001, NULL);
+}
+
+static void kb_led_disable(void)
+{
+	pr_debug("%s\n", __func__);
+
+	s76_wmbb(SET_KB_LED, 0xE0003001, NULL);
+}
+
+static void kb_led_suspend(void)
+{
+	pr_debug("%s\n", __func__);
+
+	// Disable keyboard backlight
+	kb_led_disable();
+}
+
+static void kb_led_resume(void)
+{
+	enum kb_led_region region;
+
+	pr_debug("%s\n", __func__);
+
+	// Disable keyboard backlight
+	kb_led_disable();
+
+	// Reset current color
+	for (region = 0; region < sizeof(kb_led_regions)/sizeof(union kb_led_color); region++) {
+		if (driver_flags & DRIVER_KB_LED_WMI)
+			kb_led_color_set_wmi(region, kb_led_regions[region]);
+		else
+			kb_led_color_set(region, kb_led_regions[region]);
+	}
+
+	// Reset current brightness
+	kb_led_set(&kb_led, kb_led_brightness);
+
+	// Enable keyboard backlight
+	kb_led_enable();
+}
+
+static int __init kb_led_init(struct device *dev)
+{
+	int err;
+
+	err = devm_led_classdev_register(dev, &kb_led);
+	if (unlikely(err)) {
+		return err;
+	}
+
+	if (device_create_file(kb_led.dev, &kb_led_color_left_dev_attr) != 0) {
+		pr_err("failed to create kb_led_color_left\n");
+	}
+
+	if (device_create_file(kb_led.dev, &kb_led_color_center_dev_attr) != 0) {
+		pr_err("failed to create kb_led_color_center\n");
+	}
+
+	if (device_create_file(kb_led.dev, &kb_led_color_right_dev_attr) != 0) {
+		pr_err("failed to create kb_led_color_right\n");
+	}
+
+	if (device_create_file(kb_led.dev, &kb_led_color_extra_dev_attr) != 0) {
+		pr_err("failed to create kb_led_color_extra\n");
+	}
+
+	kb_led_resume();
+
+	return 0;
+}
+
+static void __exit kb_led_exit(void)
+{
+	device_remove_file(kb_led.dev, &kb_led_color_extra_dev_attr);
+	device_remove_file(kb_led.dev, &kb_led_color_right_dev_attr);
+	device_remove_file(kb_led.dev, &kb_led_color_center_dev_attr);
+	device_remove_file(kb_led.dev, &kb_led_color_left_dev_attr);
+}
+
+static void kb_wmi_brightness(enum led_brightness value)
+{
+	pr_debug("%s %d\n", __func__, (int)value);
+
+	kb_led_set(&kb_led, value);
+	led_classdev_notify_brightness_hw_changed(&kb_led, value);
+}
+
+static void kb_wmi_toggle(void)
+{
+	if (kb_led_brightness > 0) {
+		kb_led_toggle_brightness = kb_led_brightness;
+		kb_wmi_brightness(LED_OFF);
+	} else {
+		kb_wmi_brightness(kb_led_toggle_brightness);
+	}
+}
+
+static void kb_wmi_dec(void)
+{
+	int i;
+
+	if (kb_led_brightness > 0) {
+		for (i = sizeof(kb_led_levels)/sizeof(enum led_brightness); i > 0; i--) {
+			if (kb_led_levels[i - 1] < kb_led_brightness) {
+				kb_wmi_brightness(kb_led_levels[i - 1]);
+				break;
+			}
+		}
+	} else {
+		kb_wmi_toggle();
+	}
+}
+
+static void kb_wmi_inc(void)
+{
+	int i;
+
+	if (kb_led_brightness > 0) {
+		for (i = 0; i < sizeof(kb_led_levels)/sizeof(enum led_brightness); i++) {
+			if (kb_led_levels[i] > kb_led_brightness) {
+				kb_wmi_brightness(kb_led_levels[i]);
+				break;
+			}
+		}
+	} else {
+		kb_wmi_toggle();
+	}
+}
+
+static void kb_wmi_color(void)
+{
+	enum kb_led_region region;
+
+	kb_led_colors_i += 1;
+	if (kb_led_colors_i >= sizeof(kb_led_colors)/sizeof(union kb_led_color)) {
+		kb_led_colors_i = 0;
+	}
+
+	for (region = 0; region < sizeof(kb_led_regions)/sizeof(union kb_led_color); region++) {
+		if (driver_flags & DRIVER_KB_LED_WMI)
+			kb_led_color_set_wmi(region, kb_led_colors[kb_led_colors_i]);
+		else
+			kb_led_color_set(region, kb_led_colors[kb_led_colors_i]);
+	}
+
+	led_classdev_notify_brightness_hw_changed(&kb_led, kb_led_brightness);
+}
diff --git a/drivers/custom/system76/src/nv_hda.c b/drivers/custom/system76/src/nv_hda.c
new file mode 100644
index 000000000000..43513279deae
--- /dev/null
+++ b/drivers/custom/system76/src/nv_hda.c
@@ -0,0 +1,171 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*  Based on bbswitch,
+ *  Copyright (C) 2011-2013 Bumblebee Project
+ *  Author: Peter Wu <lekensteyn@gmail.com>
+ */
+
+enum {
+	CARD_UNCHANGED = -1,
+	CARD_OFF = 0,
+	CARD_ON = 1,
+};
+
+static struct pci_dev *dis_dev;
+static struct pci_dev *sub_dev;
+
+// Returns 1 if the card is disabled, 0 if enabled
+static int is_card_disabled(void)
+{
+	// check for: 1.bit is set 2.sub-function is available.
+	u32 cfg_word;
+	struct pci_dev *tmp_dev = NULL;
+
+	sub_dev = NULL;
+
+	// read config word at 0x488
+	pci_read_config_dword(dis_dev, 0x488, &cfg_word);
+	if ((cfg_word & 0x2000000) == 0x2000000) {
+		// check for subdevice. read first config dword of sub function 1
+		while ((tmp_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, tmp_dev)) != NULL) {
+			int pci_class = tmp_dev->class >> 8;
+
+			if (pci_class != 0x403)
+				continue;
+
+			if (tmp_dev->vendor == PCI_VENDOR_ID_NVIDIA) {
+				sub_dev = tmp_dev;
+				pr_info("Found NVIDIA audio device %s\n", dev_name(&tmp_dev->dev));
+			}
+		}
+
+		if (sub_dev == NULL) {
+			pr_info("No NVIDIA audio device found, unsetting config bit.\n");
+			cfg_word |= 0x2000000;
+			pci_write_config_dword(dis_dev, 0x488, cfg_word);
+			return 1;
+		}
+
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+static void nv_hda_off(void)
+{
+	u32 cfg_word;
+
+	if (is_card_disabled()) {
+		return;
+	}
+
+	// remove device
+	pci_dev_put(sub_dev);
+	pci_stop_and_remove_bus_device(sub_dev);
+
+	pr_info("NVIDIA audio: disabling\n");
+
+	// setting bit to turn off
+	pci_read_config_dword(dis_dev, 0x488, &cfg_word);
+	cfg_word &= 0xfdffffff;
+	pci_write_config_dword(dis_dev, 0x488, cfg_word);
+}
+
+static void nv_hda_on(void)
+{
+	u32 cfg_word;
+	u8 hdr_type;
+
+	if (!is_card_disabled()) {
+		return;
+	}
+
+	pr_info("NVIDIA audio: enabling\n");
+
+	// read,set bit, write config word at 0x488
+	pci_read_config_dword(dis_dev, 0x488, &cfg_word);
+	cfg_word |= 0x2000000;
+	pci_write_config_dword(dis_dev, 0x488, cfg_word);
+
+	//pci_scan_single_device
+	pci_read_config_byte(dis_dev, PCI_HEADER_TYPE, &hdr_type);
+
+	if (!(hdr_type & 0x80)) {
+		pr_err("NVIDIA not multifunction, no audio\n");
+		return;
+	}
+
+	sub_dev = pci_scan_single_device(dis_dev->bus, 1);
+	if (!sub_dev) {
+		pr_err("No NVIDIA audio device found\n");
+		return;
+	}
+
+	pr_info("NVIDIA audio found, adding\n");
+	pci_assign_unassigned_bus_resources(dis_dev->bus);
+	pci_bus_add_devices(dis_dev->bus);
+	pci_dev_get(sub_dev);
+}
+
+/* power bus so we can read PCI configuration space */
+static void dis_dev_get(void)
+{
+	if (dis_dev->bus && dis_dev->bus->self) {
+		pm_runtime_get_sync(&dis_dev->bus->self->dev);
+	}
+}
+
+static void dis_dev_put(void)
+{
+	if (dis_dev->bus && dis_dev->bus->self) {
+		pm_runtime_put_sync(&dis_dev->bus->self->dev);
+	}
+}
+
+
+static int __init nv_hda_init(struct device *dev)
+{
+	struct pci_dev *pdev = NULL;
+
+	while ((pdev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pdev)) != NULL) {
+		int pci_class = pdev->class >> 8;
+
+		if (pci_class != PCI_CLASS_DISPLAY_VGA && pci_class != PCI_CLASS_DISPLAY_3D) {
+			continue;
+		}
+
+		if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) {
+			dis_dev = pdev;
+			pr_info("NVIDIA device %s\n", dev_name(&pdev->dev));
+		}
+	}
+
+	if (dis_dev == NULL) {
+		pr_err("No NVIDIA device found\n");
+		return -ENODEV;
+	}
+
+	dis_dev_get();
+
+	nv_hda_on();
+
+	pr_info("NVIDIA Audio %s is %s\n", dev_name(&dis_dev->dev), is_card_disabled() ? "off" : "on");
+
+	dis_dev_put();
+
+	return 0;
+}
+
+static void __exit nv_hda_exit(void)
+{
+	if (dis_dev == NULL)
+		return;
+
+	dis_dev_get();
+
+	nv_hda_off();
+
+	pr_info("NVIDIA Audio %s is %s\n", dev_name(&dis_dev->dev), is_card_disabled() ? "off" : "on");
+
+	dis_dev_put();
+}
diff --git a/drivers/custom/system76/src/system76.c b/drivers/custom/system76/src/system76.c
new file mode 100644
index 000000000000..0a80582dbdfd
--- /dev/null
+++ b/drivers/custom/system76/src/system76.c
@@ -0,0 +1,409 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * system76.c
+ *
+ * Copyright (C) 2017 Jeremy Soller <jeremy@system76.com>
+ * Copyright (C) 2014-2016 Arnoud Willemsen <mail@lynthium.com>
+ * Copyright (C) 2013-2015 TUXEDO Computers GmbH <tux@tuxedocomputers.com>
+ */
+
+#define S76_DRIVER_NAME KBUILD_MODNAME
+#define pr_fmt(fmt) S76_DRIVER_NAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/i8042.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reboot.h>
+#include <linux/rfkill.h>
+#include <linux/stringify.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+
+#define S76_EVENT_GUID  "ABBC0F6B-8EA1-11D1-00A0-C90629100000"
+#define S76_WMBB_GUID    "ABBC0F6D-8EA1-11D1-00A0-C90629100000"
+
+#define S76_HAS_HWMON (defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE)))
+
+/* method IDs for S76_GET */
+#define GET_EVENT               0x01  /*   1 */
+
+#define DRIVER_AP_KEY		(1 << 0)
+#define DRIVER_AP_LED		(1 << 1)
+#define DRIVER_HWMON		(1 << 2)
+#define DRIVER_KB_LED_WMI	(1 << 3)
+#define DRIVER_OLED		(1 << 4)
+#define DRIVER_AP_WMI		(1 << 5)
+#define DRIVER_KB_LED		(1 << 6)
+
+#define DRIVER_INPUT  (DRIVER_AP_KEY | DRIVER_OLED)
+
+static uint64_t driver_flags;
+
+struct platform_device *s76_platform_device;
+
+static int s76_wmbb(u32 method_id, u32 arg, u32 *retval)
+{
+	struct acpi_buffer in  = { (acpi_size) sizeof(arg), &arg };
+	struct acpi_buffer out = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+	acpi_status status;
+	u32 tmp;
+
+	pr_debug("%0#4x  IN : %0#6x\n", method_id, arg);
+
+	status = wmi_evaluate_method(S76_WMBB_GUID, 0, method_id, &in, &out);
+
+	if (unlikely(ACPI_FAILURE(status))) {
+		return -EIO;
+	}
+
+	obj = (union acpi_object *) out.pointer;
+	if (obj && obj->type == ACPI_TYPE_INTEGER) {
+		tmp = (u32) obj->integer.value;
+	} else {
+		tmp = 0;
+	}
+
+	pr_debug("%0#4x  OUT: %0#6x (IN: %0#6x)\n", method_id, tmp, arg);
+
+	if (likely(retval)) {
+		*retval = tmp;
+	}
+
+	kfree(obj);
+
+	return 0;
+}
+
+#include "ap-led.c"
+#include "input.c"
+#include "kb-led.c"
+#include "hwmon.c"
+#include "nv_hda.c"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
+static void s76_wmi_notify(union acpi_object *obj, void *context)
+#else
+static void s76_wmi_notify(u32 value, void *context)
+#endif
+{
+	u32 event;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
+	if (obj->type != ACPI_TYPE_INTEGER) {
+		pr_debug("Unexpected WMI event (%0#6x)\n", obj->type);
+		return;
+	}
+#else
+	if (value != 0xD0) {
+		pr_debug("Unexpected WMI event (%0#6x)\n", value);
+		return;
+	}
+#endif
+
+	s76_wmbb(GET_EVENT, 0, &event);
+
+	pr_debug("WMI event code (%x)\n", event);
+
+	switch (event) {
+	case 0x81:
+		if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+			kb_wmi_dec();
+		}
+		break;
+	case 0x82:
+		if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+			kb_wmi_inc();
+		}
+		break;
+	case 0x83:
+		if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+			kb_wmi_color();
+		}
+		break;
+	case 0x7b:
+		//TODO: Fn+Backspace
+		break;
+	case 0x95:
+		//TODO: Fn+ESC
+		break;
+	case 0x9F:
+		if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+			kb_wmi_toggle();
+		}
+		break;
+	case 0xD7:
+		if (driver_flags & DRIVER_OLED) {
+			s76_input_screen_wmi();
+		}
+		break;
+	case 0x85:
+	case 0xF4:
+		if (driver_flags & DRIVER_AP_KEY) {
+			s76_input_airplane_wmi();
+		}
+		break;
+	case 0xFC:
+		// Touchpad WMI (disable)
+		break;
+	case 0xFD:
+		// Touchpad WMI (enable)
+		break;
+	default:
+		pr_debug("Unknown WMI event code (%x)\n", event);
+		break;
+	}
+}
+
+static int __init s76_probe(struct platform_device *dev)
+{
+	int err;
+
+	if (driver_flags & DRIVER_AP_LED) {
+		err = ap_led_init(&dev->dev);
+		if (unlikely(err)) {
+			pr_err("Could not register LED device\n");
+		}
+	}
+
+	if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+		err = kb_led_init(&dev->dev);
+		if (unlikely(err)) {
+			pr_err("Could not register LED device\n");
+		}
+	}
+
+	if (driver_flags & DRIVER_INPUT) {
+		err = s76_input_init(&dev->dev);
+		if (unlikely(err)) {
+			pr_err("Could not register input device\n");
+		}
+	}
+
+#ifdef S76_HAS_HWMON
+	if (driver_flags & DRIVER_HWMON) {
+		s76_hwmon_init(&dev->dev);
+	}
+#endif
+
+	err = nv_hda_init(&dev->dev);
+	if (unlikely(err)) {
+		pr_err("Could not register NVIDIA audio device\n");
+	}
+
+	err = wmi_install_notify_handler(S76_EVENT_GUID, s76_wmi_notify, NULL);
+	if (unlikely(ACPI_FAILURE(err))) {
+		pr_err("Could not register WMI notify handler (%0#6x)\n", err);
+		return -EIO;
+	}
+
+	// Enable hotkey support
+	s76_wmbb(0x46, 0, NULL);
+
+	// Enable touchpad lock
+	i8042_lock_chip();
+	i8042_command(NULL, 0x97);
+	i8042_unlock_chip();
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 11, 0)
+static void s76_remove(struct platform_device *dev)
+#else
+static int s76_remove(struct platform_device *dev)
+#endif
+{
+	wmi_remove_notify_handler(S76_EVENT_GUID);
+
+	nv_hda_exit();
+	#ifdef S76_HAS_HWMON
+	if (driver_flags & DRIVER_HWMON) {
+		s76_hwmon_fini(&dev->dev);
+	}
+	#endif
+	if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+		kb_led_exit();
+	}
+	if (driver_flags & DRIVER_AP_LED) {
+		ap_led_exit();
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+	return 0;
+#endif
+}
+
+static int s76_suspend(struct device *dev)
+{
+	pr_debug("%s\n", __func__);
+
+	if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+		kb_led_suspend();
+	}
+
+	return 0;
+}
+
+static int s76_resume(struct device *dev)
+{
+	pr_debug("%s\n", __func__);
+
+	msleep(2000);
+
+	if (driver_flags & DRIVER_AP_LED) {
+		ap_led_resume();
+	}
+	if (driver_flags & (DRIVER_KB_LED_WMI | DRIVER_KB_LED)) {
+		kb_led_resume();
+	}
+
+	// Enable hotkey support
+	s76_wmbb(0x46, 0, NULL);
+
+	// Enable touchpad lock
+	i8042_lock_chip();
+	i8042_command(NULL, 0x97);
+	i8042_unlock_chip();
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+static DEFINE_SIMPLE_DEV_PM_OPS(s76_pm, s76_suspend, s76_resume);
+#else
+static SIMPLE_DEV_PM_OPS(s76_pm, s76_suspend, s76_resume);
+#endif
+
+static struct platform_driver s76_platform_driver = {
+	.remove = s76_remove,
+	.driver = {
+		.name  = S76_DRIVER_NAME,
+		.owner = THIS_MODULE,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+		.pm = pm_sleep_ptr(&s76_pm),
+#else
+		.pm = pm_ptr(&s76_pm),
+#endif
+	},
+};
+
+static int __init s76_dmi_matched(const struct dmi_system_id *id)
+{
+	pr_info("Model %s found\n", id->ident);
+	driver_flags = (uint64_t)id->driver_data;
+	return 1;
+}
+
+#define DMI_TABLE_LEGACY(PRODUCT, DATA) { \
+	.ident = "System76 " PRODUCT, \
+	.matches = { \
+		DMI_MATCH(DMI_SYS_VENDOR, "System76"), \
+		DMI_MATCH(DMI_PRODUCT_VERSION, PRODUCT), \
+		DMI_MATCH(DMI_BIOS_VENDOR, "System76"), \
+	}, \
+	.callback = s76_dmi_matched, \
+	.driver_data = (void *)(uint64_t)0, \
+}
+
+#define DMI_TABLE(PRODUCT, DATA) { \
+	.ident = "System76 " PRODUCT, \
+	.matches = { \
+		DMI_MATCH(DMI_SYS_VENDOR, "System76"), \
+		DMI_MATCH(DMI_PRODUCT_VERSION, PRODUCT), \
+	}, \
+	.callback = s76_dmi_matched, \
+	.driver_data = (void *)(uint64_t)(DATA), \
+}
+
+static struct dmi_system_id s76_dmi_table[] __initdata = {
+	DMI_TABLE_LEGACY("bonw13", DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("addw1", DRIVER_AP_LED | DRIVER_KB_LED_WMI | DRIVER_OLED),
+	DMI_TABLE("addw2", DRIVER_AP_LED | DRIVER_KB_LED_WMI | DRIVER_OLED),
+	DMI_TABLE("addw5", DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("bonw15-b", DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("bonw16", DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("darp5", DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("darp6", DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("galp2", DRIVER_HWMON),
+	DMI_TABLE("galp3", DRIVER_HWMON),
+	DMI_TABLE("galp3-b", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON),
+	DMI_TABLE("galp3-c", DRIVER_AP_LED | DRIVER_HWMON),
+	DMI_TABLE("galp4", DRIVER_AP_LED | DRIVER_HWMON),
+	DMI_TABLE("gaze13", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON),
+	DMI_TABLE("gaze14", DRIVER_AP_LED | DRIVER_KB_LED_WMI),
+	DMI_TABLE("gaze15", DRIVER_AP_LED | DRIVER_KB_LED_WMI),
+	DMI_TABLE("kudu5", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON),
+	DMI_TABLE("kudu6", DRIVER_AP_KEY | DRIVER_AP_WMI | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp3-jeremy", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp4", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp4-b", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp5", DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp6", DRIVER_AP_LED | DRIVER_KB_LED_WMI),
+	DMI_TABLE("oryp13", DRIVER_AP_KEY | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("pang10", DRIVER_AP_KEY | DRIVER_AP_WMI | DRIVER_KB_LED_WMI),
+	DMI_TABLE("pang11", DRIVER_AP_KEY | DRIVER_AP_WMI | DRIVER_KB_LED_WMI),
+	DMI_TABLE("serw11", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("serw11-b", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_HWMON | DRIVER_KB_LED_WMI),
+	DMI_TABLE("serw12", DRIVER_AP_KEY | DRIVER_AP_LED | DRIVER_AP_WMI | DRIVER_KB_LED_WMI),
+	DMI_TABLE("serw14", DRIVER_HWMON | DRIVER_KB_LED),
+	{}
+};
+MODULE_DEVICE_TABLE(dmi, s76_dmi_table);
+
+static int __init s76_init(void)
+{
+	if (!dmi_check_system(s76_dmi_table)) {
+		pr_info("Model does not utilize this driver");
+		return -ENODEV;
+	}
+
+	if (!driver_flags) {
+		pr_info("Driver data not defined");
+		return -ENODEV;
+	}
+
+	if (!wmi_has_guid(S76_EVENT_GUID)) {
+		pr_info("No known WMI event notification GUID found\n");
+		return -ENODEV;
+	}
+
+	if (!wmi_has_guid(S76_WMBB_GUID)) {
+		pr_info("No known WMI control method GUID found\n");
+		return -ENODEV;
+	}
+
+	s76_platform_device =
+		platform_create_bundle(&s76_platform_driver, s76_probe, NULL, 0, NULL, 0);
+
+	if (IS_ERR(s76_platform_device)) {
+		return PTR_ERR(s76_platform_device);
+	}
+
+	return 0;
+}
+module_init(s76_init);
+
+static void __exit s76_exit(void)
+{
+	platform_device_unregister(s76_platform_device);
+	platform_driver_unregister(&s76_platform_driver);
+}
+module_exit(s76_exit);
+
+MODULE_AUTHOR("Jeremy Soller <jeremy@system76.com>");
+MODULE_DESCRIPTION("System76 laptop driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
# ----------------------------------------
# Module: system76_io
# Version: fc71f154ab8d
# ----------------------------------------
diff --git a/drivers/custom/system76_io/Makefile b/drivers/custom/system76_io/Makefile
new file mode 100644
index 000000000000..65445c80c86f
--- /dev/null
+++ b/drivers/custom/system76_io/Makefile
@@ -0,0 +1,8 @@
+obj-m := system76-io.o system76-thelio-io.o
+KERNEL_DIR = /lib/modules/$(shell uname -r)/build
+
+all:
+	$(MAKE) -C "$(KERNEL_DIR)" M="$(PWD)" modules
+
+clean:
+	$(MAKE) -C "$(KERNEL_DIR)" M="$(PWD)" clean
diff --git a/drivers/custom/system76_io/system76-io.c b/drivers/custom/system76_io/system76-io.c
new file mode 100644
index 000000000000..40b655f8ce03
--- /dev/null
+++ b/drivers/custom/system76_io/system76-io.c
@@ -0,0 +1,304 @@
+/*
+ * system76-io.c
+ *
+ * Copyright (C) 2018 Jeremy Soller <jeremy@system76.com>
+ *
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the  GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is  distributed in the hope that it  will be useful, but
+ * WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
+ * MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
+ * General Public License for more details.
+ *
+ * You should  have received  a copy of  the GNU General  Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+#include <linux/usb.h>
+
+#define IO_VENDOR 0x1209
+#define IO_DEVICE 0x1776
+#define IO_INTF_CTRL 0
+#define IO_EP_CTRL 0x00
+#define IO_INTF_DATA 1
+#define IO_EP_IN 0x83
+#define IO_EP_OUT 0x04
+#define IO_MSG_SIZE 32
+#define IO_TIMEOUT 1000
+
+#include "system76-io_dev.c"
+#include "system76-io_hwmon.c"
+
+#define BAUD 1000000
+
+static u8 line_encoding[7] = {
+    (u8)BAUD,
+    (u8)(BAUD >> 8),
+    (u8)(BAUD >> 16),
+    (u8)(BAUD >> 24),
+    0,
+    0,
+    8
+};
+
+static ssize_t show_bootloader(struct device *dev, struct device_attribute *attr, char *buf) {
+    return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t set_bootloader(struct device *dev, struct device_attribute *attr, const char *buf, size_t size) {
+    unsigned int val;
+    int ret;
+
+    struct io_dev * io_dev = dev_get_drvdata(dev);
+
+    mutex_lock(&io_dev->lock);
+
+    ret = kstrtouint(buf, 10, &val);
+    if (!ret) {
+        if (val) {
+            ret = io_dev_bootloader(io_dev, IO_TIMEOUT);
+            if(!ret) {
+                ret = size;
+            }
+        }
+    }
+
+    mutex_unlock(&io_dev->lock);
+
+    return ret;
+}
+
+static DEVICE_ATTR(bootloader, S_IRUGO | S_IWUSR, show_bootloader, set_bootloader);
+
+static ssize_t show_revision(struct device *dev, struct device_attribute *attr, char *buf) {
+    int ret;
+
+    struct io_dev * io_dev = dev_get_drvdata(dev);
+
+    mutex_lock(&io_dev->lock);
+
+    ret = io_dev_revision(io_dev, buf, PAGE_SIZE, IO_TIMEOUT);
+
+    mutex_unlock(&io_dev->lock);
+
+    return ret;
+}
+
+static DEVICE_ATTR(revision, S_IRUGO, show_revision, NULL);
+
+#ifdef CONFIG_PM_SLEEP
+static int io_pm(struct notifier_block *nb, unsigned long action, void *data) {
+    struct io_dev * io_dev = container_of(nb, struct io_dev, pm_notifier);
+
+    mutex_lock(&io_dev->lock);
+
+    switch (action) {
+        case PM_HIBERNATION_PREPARE:
+        case PM_SUSPEND_PREPARE:
+            io_dev_set_suspend(io_dev, 1, IO_TIMEOUT);
+            break;
+
+        case PM_POST_HIBERNATION:
+        case PM_POST_SUSPEND:
+            io_dev_set_suspend(io_dev, 0, IO_TIMEOUT);
+            break;
+
+        case PM_POST_RESTORE:
+        case PM_RESTORE_PREPARE:
+        default:
+            break;
+    }
+
+    mutex_unlock(&io_dev->lock);
+
+    return NOTIFY_DONE;
+}
+#endif
+
+static int io_probe(struct usb_interface *interface, const struct usb_device_id *id) {
+    int retry;
+    int result;
+    struct io_dev * io_dev;
+
+    dev_info(&interface->dev, "id %04X:%04X interface %d probe\n", id->idVendor, id->idProduct, id->bInterfaceNumber);
+
+    if (id->bInterfaceNumber == IO_INTF_CTRL) {
+        result = usb_control_msg(
+            interface_to_usbdev(interface),
+            usb_sndctrlpipe(interface_to_usbdev(interface), IO_EP_CTRL),
+            0x22,
+            0x21,
+            0x03,
+            0,
+            NULL,
+            0,
+            IO_TIMEOUT
+        );
+        if (result < 0) {
+            dev_err(&interface->dev, "set line state failed: %d\n", -result);
+            return result;
+        }
+
+
+        result = usb_control_msg(
+            interface_to_usbdev(interface),
+            usb_sndctrlpipe(interface_to_usbdev(interface), IO_EP_CTRL),
+            0x20,
+            0x21,
+            0,
+            0,
+            line_encoding,
+            7,
+            IO_TIMEOUT
+        );
+        if (result < 0) {
+            dev_err(&interface->dev, "set line encoding failed: %d\n", -result);
+            return result;
+        }
+
+        return 0;
+    } else if (id->bInterfaceNumber == IO_INTF_DATA) {
+        io_dev = kmalloc(sizeof(struct io_dev), GFP_KERNEL);
+        if (IS_ERR_OR_NULL(io_dev)) {
+            dev_err(&interface->dev, "kmalloc failed\n");
+            return -ENOMEM;
+        }
+
+        memset(io_dev, 0, sizeof(struct io_dev));
+
+        mutex_init(&io_dev->lock);
+
+        mutex_lock(&io_dev->lock);
+
+        io_dev->usb_dev = usb_get_dev(interface_to_usbdev(interface));
+
+        usb_set_intfdata(interface, io_dev);
+
+        for(retry = 0; retry < 8; retry++) {
+            dev_info(&interface->dev, "trying reset: %d\n", retry);
+            result = io_dev_reset(io_dev, IO_TIMEOUT);
+            if (result != -ETIMEDOUT) {
+                break;
+            }
+        }
+        if (result) {
+            dev_err(&interface->dev, "io_dev_reset failed: %d\n", result);
+            goto fail1;
+        }
+
+        result = device_create_file(&interface->dev, &dev_attr_bootloader);
+        if (result) {
+            dev_err(&interface->dev, "device_create_file failed: %d\n", result);
+            goto fail1;
+        }
+
+        result = device_create_file(&interface->dev, &dev_attr_revision);
+        if (result) {
+            dev_err(&interface->dev, "device_create_file failed: %d\n", result);
+            goto fail2;
+        }
+
+        io_dev->hwmon_dev = hwmon_device_register_with_groups(&interface->dev, "system76_io", io_dev, io_groups);
+        if (IS_ERR(io_dev->hwmon_dev)) {
+            result = PTR_ERR(io_dev->hwmon_dev);
+
+            dev_err(&interface->dev, "hwmon_device_register_with_groups failed: %d\n", result);
+            goto fail3;
+        }
+
+#ifdef CONFIG_PM_SLEEP
+        io_dev->pm_notifier.notifier_call = io_pm;
+        register_pm_notifier(&io_dev->pm_notifier);
+#endif
+
+        mutex_unlock(&io_dev->lock);
+
+        return 0;
+
+    fail3:
+        device_remove_file(&interface->dev, &dev_attr_revision);
+    fail2:
+        device_remove_file(&interface->dev, &dev_attr_bootloader);
+    fail1:
+        usb_set_intfdata(interface, NULL);
+        usb_put_dev(io_dev->usb_dev);
+
+        mutex_unlock(&io_dev->lock);
+
+        mutex_destroy(&io_dev->lock);
+        kfree(io_dev);
+
+        return result;
+    } else {
+        return -ENODEV;
+    }
+}
+
+static void io_disconnect(struct usb_interface *interface) {
+    struct io_dev * io_dev;
+
+    dev_info(&interface->dev, "disconnect\n");
+
+    io_dev = usb_get_intfdata(interface);
+
+    if (io_dev) {
+        mutex_lock(&io_dev->lock);
+
+#ifdef CONFIG_PM_SLEEP
+        unregister_pm_notifier(&io_dev->pm_notifier);
+#endif
+
+        hwmon_device_unregister(io_dev->hwmon_dev);
+
+        device_remove_file(&interface->dev, &dev_attr_revision);
+
+        device_remove_file(&interface->dev, &dev_attr_bootloader);
+
+        usb_set_intfdata(interface, NULL);
+        usb_put_dev(io_dev->usb_dev);
+
+        mutex_unlock(&io_dev->lock);
+
+        mutex_destroy(&io_dev->lock);
+        kfree(io_dev);
+    }
+}
+
+static struct usb_device_id io_table[] = {
+        { USB_DEVICE_INTERFACE_NUMBER(IO_VENDOR, IO_DEVICE, IO_INTF_CTRL) },
+        { USB_DEVICE_INTERFACE_NUMBER(IO_VENDOR, IO_DEVICE, IO_INTF_DATA) },
+        { }
+};
+
+MODULE_DEVICE_TABLE(usb, io_table);
+
+static struct usb_driver io_driver = {
+    .name        = "system76-io",
+    .probe       = io_probe,
+    .disconnect  = io_disconnect,
+    .id_table    = io_table,
+};
+
+static int __init io_init(void) {
+    return usb_register(&io_driver);
+}
+
+static void __exit io_exit(void) {
+    usb_deregister(&io_driver);
+}
+
+module_init(io_init);
+module_exit(io_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jeremy Soller <jeremy@system76.com>");
+MODULE_DESCRIPTION("System76 Io driver");
diff --git a/drivers/custom/system76_io/system76-io_dev.c b/drivers/custom/system76_io/system76-io_dev.c
new file mode 100644
index 000000000000..11c4df17c0b6
--- /dev/null
+++ b/drivers/custom/system76_io/system76-io_dev.c
@@ -0,0 +1,310 @@
+/*
+ * system76-io_dev.c
+ *
+ * Copyright (C) 2018 Jeremy Soller <jeremy@system76.com>
+ *
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the  GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is  distributed in the hope that it  will be useful, but
+ * WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
+ * MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
+ * General Public License for more details.
+ *
+ * You should  have received  a copy of  the GNU General  Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+struct io_dev {
+    struct mutex lock;
+    struct usb_device * usb_dev;
+    struct device * hwmon_dev;
+#ifdef CONFIG_PM_SLEEP
+    struct notifier_block pm_notifier;
+#endif
+    char command[IO_MSG_SIZE];
+    char partial[IO_MSG_SIZE];
+    char lines[2][IO_MSG_SIZE];
+    char response[IO_MSG_SIZE];
+};
+
+static ssize_t io_dev_read(struct io_dev * io_dev, char * buf, size_t len, int timeout) {
+    int result;
+    int count;
+
+    result = usb_bulk_msg(
+        io_dev->usb_dev,
+        usb_rcvbulkpipe(io_dev->usb_dev, IO_EP_IN),
+        (void *)buf,
+        len,
+        &count,
+        timeout
+    );
+    if (result) {
+        return result;
+    }
+
+    return count;
+}
+
+static ssize_t io_dev_write(struct io_dev * io_dev, const char * buf, size_t len, int timeout) {
+    int result;
+    int count;
+
+    result = usb_bulk_msg(
+        io_dev->usb_dev,
+        usb_sndbulkpipe(io_dev->usb_dev, IO_EP_OUT),
+        (void *)buf,
+        len,
+        &count,
+        timeout
+    );
+    if (result) {
+        return result;
+    }
+
+    return count;
+}
+
+static int io_dev_command(struct io_dev * io_dev, const char * command, size_t clen, char * response, size_t rlen, int timeout) {
+    int result;
+    bool cr;
+    bool lf;
+    int i;
+    char c;
+    int lines_i;
+    int line_i;
+    bool error;
+
+    memset(response, 0, rlen);
+
+    result = io_dev_write(io_dev, command, clen, timeout);
+    if (result < 0) {
+        snprintf(response, rlen, "io_dev_write");
+        return result;
+    }
+
+    cr = 0;
+    lf = 0;
+    lines_i = 0;
+    line_i = 0;
+    for (;;) {
+        result = io_dev_read(io_dev, io_dev->partial, IO_MSG_SIZE, timeout);
+        if (result < 0) {
+            snprintf(response, rlen, "io_dev_read");
+            return result;
+        }
+
+        for (i = 0; i < result; i++) {
+            c = io_dev->partial[i];
+            if (c == '\r') {
+                if (!cr) {
+                    cr = 1;
+                } else {
+                    // Unexpected \r, return error
+                    snprintf(response, rlen, "Unexpected CR");
+                    return -EINVAL;
+                }
+            } else if (c == '\n') {
+                if (cr) {
+                    cr = 0;
+                    if (lf) {
+                        // Received a response in full
+                        if (lines_i < 2 && line_i < IO_MSG_SIZE) {
+                            io_dev->lines[lines_i++][line_i] = 0;
+                            line_i = 0;
+                        } else {
+                            snprintf(response, rlen, "Too many lines");
+                            return -EINVAL;
+                        }
+                    }
+                    lf = !lf;
+                } else {
+                    // Unexpected \n, return error
+                    snprintf(response, rlen, "Unexpected LF");
+                    return -EINVAL;
+                }
+            } else if (!cr && lf) {
+                // Received a response byte
+                if (lines_i < 2 && line_i < IO_MSG_SIZE) {
+                    io_dev->lines[lines_i][line_i++] = c;
+                } else {
+                    // Response too long
+                    snprintf(response, rlen, "Too many chars");
+                    return -EINVAL;
+                }
+            } else {
+                // Unexpected data, return error
+                snprintf(response, rlen, "Unexpected char");
+                return -EINVAL;
+            }
+        }
+
+        if (lines_i > 0) {
+            if (strcmp(io_dev->lines[lines_i - 1], "OK") == 0) {
+                error = 0;
+                break;
+            } else if (strcmp(io_dev->lines[lines_i - 1], "ERROR") == 0) {
+                error = 1;
+            }
+        }
+    }
+
+    if (lines_i > 1) {
+        snprintf(response, rlen, "%s", io_dev->lines[lines_i - 2]);
+    }
+
+    if (error) {
+        return -EIO;
+    } else {
+        return 0;
+    }
+}
+
+static int io_dev_bootloader(struct io_dev * io_dev, int timeout) {
+    int len;
+    int result;
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoBOOT\r");
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_boot failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return 0;
+}
+
+static int io_dev_reset(struct io_dev * io_dev, int timeout) {
+    int len;
+    int result;
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoRSET\r");
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_reset failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return 0;
+}
+
+static int io_dev_tach(struct io_dev * io_dev, const char * device, u16 * value, int timeout) {
+    int len;
+    int result;
+
+    if (strlen(device) != 4) {
+        return -EINVAL;
+    }
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoTACH%s\r", device);
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_tach failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return kstrtou16(io_dev->response, 16, value);
+}
+
+static int io_dev_duty(struct io_dev * io_dev, const char * device, u16 * value, int timeout) {
+    int len;
+    int result;
+
+    if (strlen(device) != 4) {
+        return -EINVAL;
+    }
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoDUTY%s\r", device);
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_duty failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return kstrtou16(io_dev->response, 16, value);
+}
+
+static int io_dev_set_duty(struct io_dev * io_dev, const char * device, u16 value, int timeout) {
+    int len;
+    int result;
+
+    if (strlen(device) != 4) {
+        return -EINVAL;
+    }
+
+    if (value > 10000) {
+        return -EINVAL;
+    }
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoDUTY%s%04X\r", device, value);
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_set_duty failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return 0;
+}
+
+static int io_dev_set_suspend(struct io_dev * io_dev, u16 value, int timeout) {
+    int len;
+    int result;
+
+    if (value > 1) {
+        return -EINVAL;
+    }
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoSUSP%04X\r", value);
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, io_dev->response, IO_MSG_SIZE, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_set_suspend failed: %d: %s\n", -result, io_dev->response);
+        return result;
+    }
+
+    return 0;
+}
+
+static int io_dev_revision(struct io_dev * io_dev, char * value, int value_len, int timeout) {
+    int len;
+    int result;
+
+    len = snprintf(io_dev->command, IO_MSG_SIZE, "IoREVISION\r");
+    if (len >= IO_MSG_SIZE) {
+        return -EINVAL;
+    }
+
+    result = io_dev_command(io_dev, io_dev->command, len, value, value_len, timeout);
+    if (result) {
+        dev_err(&io_dev->usb_dev->dev, "io_dev_revision failed: %d: %s\n", -result, value);
+        return result;
+    }
+
+    return strlen(value);
+}
diff --git a/drivers/custom/system76_io/system76-io_hwmon.c b/drivers/custom/system76_io/system76-io_hwmon.c
new file mode 100644
index 000000000000..25602d31b554
--- /dev/null
+++ b/drivers/custom/system76_io/system76-io_hwmon.c
@@ -0,0 +1,180 @@
+/*
+ * system76-io_hwmon.c
+ *
+ * Copyright (C) 2018 Jeremy Soller <jeremy@system76.com>
+ *
+ * This program is free software;  you can redistribute it and/or modify
+ * it under the terms of the  GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is  distributed in the hope that it  will be useful, but
+ * WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
+ * MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
+ * General Public License for more details.
+ *
+ * You should  have received  a copy of  the GNU General  Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define IO_FAN(N, I)
+
+#define IO_FANS \
+    IO_FAN(CPUF, 1) \
+    IO_FAN(INTF, 2)
+
+static const char * io_fan_name(int index) {
+    switch (index) {
+        #undef IO_FAN
+        #define IO_FAN(N, I) \
+            case I: \
+                return #N;
+        IO_FANS
+        default:
+            return NULL;
+    }
+}
+
+static ssize_t io_fan_input_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    const char *name;
+    u16 value;
+    int ret;
+
+    struct io_dev * io_dev = dev_get_drvdata(dev);
+
+    mutex_lock(&io_dev->lock);
+
+    if ((name = io_fan_name(to_sensor_dev_attr(attr)->index))) {
+        ret = io_dev_tach(io_dev, name, &value, IO_TIMEOUT);
+        if (!ret) {
+            ret = sprintf(buf, "%i\n", value * 30);
+        }
+    } else {
+        ret = -ENOENT;
+    }
+
+    mutex_unlock(&io_dev->lock);
+
+    return ret;
+}
+
+static ssize_t io_fan_label_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    int ret;
+
+    const char * name = io_fan_name(to_sensor_dev_attr(attr)->index);
+    if (name) {
+        ret = sprintf(buf, "%s\n", name);
+    } else {
+        ret = -ENOENT;
+    }
+
+    return ret;
+}
+
+static ssize_t io_pwm_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    const char *name;
+    u16 value;
+    int ret;
+
+    struct io_dev * io_dev = dev_get_drvdata(dev);
+
+    mutex_lock(&io_dev->lock);
+
+    if ((name = io_fan_name(to_sensor_dev_attr(attr)->index))) {
+        ret = io_dev_duty(io_dev, name, &value, IO_TIMEOUT);
+        if (!ret) {
+            ret = sprintf(buf, "%i\n", (((u32)value) * 255) / 10000);
+        }
+    } else {
+        ret = -ENOENT;
+    }
+
+    mutex_unlock(&io_dev->lock);
+
+    return ret;
+}
+
+static ssize_t io_pwm_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+	const char *name;
+  	u32 value;
+  	int ret;
+
+    struct io_dev * io_dev = dev_get_drvdata(dev);
+
+    mutex_lock(&io_dev->lock);
+
+    if ((name = io_fan_name(to_sensor_dev_attr(attr)->index))) {
+      	ret = kstrtou32(buf, 10, &value);
+      	if (!ret) {
+            if (value <= 255) {
+                ret = io_dev_set_duty(io_dev, name, (u16)((value * 10000) / 255), IO_TIMEOUT);
+                if (!ret) {
+                    ret = count;
+                }
+            } else {
+                ret = -EINVAL;
+            }
+        }
+    } else {
+        ret = -ENOENT;
+    }
+
+    mutex_unlock(&io_dev->lock);
+
+    return ret;
+}
+
+static ssize_t io_pwm_enable_show(struct device *dev, struct device_attribute *attr, char *buf) {
+    int ret;
+
+    const char * name = io_fan_name(to_sensor_dev_attr(attr)->index);
+    if (name) {
+        ret = sprintf(buf, "%i\n", 1);
+    } else {
+        ret = -ENOENT;
+    }
+
+    return ret;
+}
+
+static ssize_t io_pwm_enable_set(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
+  	u8 value;
+  	int ret;
+
+    const char * name = io_fan_name(to_sensor_dev_attr(attr)->index);
+    if (name) {
+        ret = kstrtou8(buf, 10, &value);
+      	if (!ret) {
+            if (value == 1) {
+                ret = count;
+            } else {
+                ret = -EINVAL;
+            }
+        }
+    } else {
+        ret = -ENOENT;
+    }
+
+    return ret;
+}
+
+#undef IO_FAN
+#define IO_FAN(N, I) \
+    static SENSOR_DEVICE_ATTR(fan ## I ## _input, S_IRUGO, io_fan_input_show, NULL, I); \
+    static SENSOR_DEVICE_ATTR(fan ## I ## _label, S_IRUGO, io_fan_label_show, NULL, I); \
+    static SENSOR_DEVICE_ATTR(pwm ## I, S_IRUGO |  S_IWUSR, io_pwm_show, io_pwm_set, I); \
+    static SENSOR_DEVICE_ATTR(pwm ## I ## _enable, S_IRUGO |  S_IWUSR, io_pwm_enable_show, io_pwm_enable_set, I);
+IO_FANS
+
+static struct attribute *io_attrs[] = {
+    #undef IO_FAN
+    #define IO_FAN(N, I) \
+        &sensor_dev_attr_fan ## I ## _input.dev_attr.attr, \
+        &sensor_dev_attr_fan ## I ## _label.dev_attr.attr, \
+        &sensor_dev_attr_pwm ## I.dev_attr.attr, \
+        &sensor_dev_attr_pwm ## I ## _enable.dev_attr.attr,
+	IO_FANS
+	NULL
+};
+
+ATTRIBUTE_GROUPS(io);
diff --git a/drivers/custom/system76_io/system76-thelio-io.c b/drivers/custom/system76_io/system76-thelio-io.c
new file mode 100644
index 000000000000..4d9c2229cd3d
--- /dev/null
+++ b/drivers/custom/system76_io/system76-thelio-io.c
@@ -0,0 +1,424 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *
+ * system76-thelio-io.c - Linux driver for System76 Thelio Io
+ * Copyright (C) 2023 System76
+ *
+ * Based on:
+ * corsair-cpro.c - Linux driver for Corsair Commander Pro
+ * Copyright (C) 2020 Marius Zachmann <mail@mariuszachmann.de>
+ *
+ * This driver uses hid reports to communicate with the device to allow hidraw userspace drivers
+ * still being used. The device does not use report ids. When using hidraw and this driver
+ * simultaniously, reports could be switched.
+ */
+
+#include <linux/bitops.h>
+#include <linux/completion.h>
+#include <linux/hid.h>
+#include <linux/hwmon.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/suspend.h>
+#include <linux/types.h>
+
+#define BUFFER_SIZE	32
+#define REQ_TIMEOUT	300
+
+#define HID_CMD		0
+#define HID_RES		1
+#define HID_DATA	2
+
+#define CMD_FAN_GET		7
+#define CMD_FAN_SET		8
+#define CMD_LED_SET_MODE	16
+#define CMD_FAN_TACH		22
+
+struct thelio_io_device {
+	struct hid_device *hdev;
+	struct device *hwmon_dev;
+#ifdef CONFIG_PM_SLEEP
+	struct notifier_block pm_notifier;
+#endif
+	struct completion wait_input_report;
+	struct mutex mutex; /* whenever buffer is used, lock before send_usb_cmd */
+	u8 *buffer;
+};
+
+/* converts response error in buffer to errno */
+static int thelio_io_get_errno(struct thelio_io_device *thelio_io)
+{
+	switch (thelio_io->buffer[HID_RES]) {
+	case 0x00: /* success */
+		return 0;
+	default:
+		return -EIO;
+	}
+}
+
+/* send command, check for error in response, response in thelio_io->buffer */
+static int send_usb_cmd(struct thelio_io_device *thelio_io, u8 command,
+			u8 byte1, u8 byte2, u8 byte3)
+{
+	int ret;
+
+	memset(thelio_io->buffer, 0x00, BUFFER_SIZE);
+	thelio_io->buffer[HID_CMD] = command;
+	thelio_io->buffer[HID_DATA] = byte1;
+	thelio_io->buffer[HID_DATA + 1] = byte2;
+	thelio_io->buffer[HID_DATA + 2] = byte3;
+
+	reinit_completion(&thelio_io->wait_input_report);
+
+	ret = hid_hw_output_report(thelio_io->hdev, thelio_io->buffer, BUFFER_SIZE);
+	if (ret < 0)
+		return ret;
+
+	if (!wait_for_completion_timeout(&thelio_io->wait_input_report,
+					 msecs_to_jiffies(REQ_TIMEOUT)))
+		return -ETIMEDOUT;
+
+	return thelio_io_get_errno(thelio_io);
+}
+
+static int thelio_io_raw_event(struct hid_device *hdev, struct hid_report *report,
+			       u8 *data, int size)
+{
+	struct thelio_io_device *thelio_io = hid_get_drvdata(hdev);
+
+	/* only copy buffer when requested */
+	if (completion_done(&thelio_io->wait_input_report))
+		return 0;
+
+	memcpy(thelio_io->buffer, data, min(BUFFER_SIZE, size));
+	complete(&thelio_io->wait_input_report);
+
+	return 0;
+}
+
+/* requests and returns single data values depending on channel */
+static int get_data(struct thelio_io_device *thelio_io, int command, int channel,
+		    bool two_byte_data)
+{
+	int ret;
+
+	mutex_lock(&thelio_io->mutex);
+
+	ret = send_usb_cmd(thelio_io, command, channel, 0, 0);
+	if (ret)
+		goto out_unlock;
+
+	ret = thelio_io->buffer[HID_DATA + 1];
+	if (two_byte_data)
+		ret |= thelio_io->buffer[HID_DATA + 2] << 8;
+
+out_unlock:
+	mutex_unlock(&thelio_io->mutex);
+	return ret;
+}
+
+static int set_pwm(struct thelio_io_device *thelio_io, int channel, long val)
+{
+	int ret;
+
+	if (val < 0 || val > 255)
+		return -EINVAL;
+
+	mutex_lock(&thelio_io->mutex);
+
+	ret = send_usb_cmd(thelio_io, CMD_FAN_SET, channel, val, 0);
+
+	mutex_unlock(&thelio_io->mutex);
+	return ret;
+}
+
+static int thelio_io_read_string(struct device *dev, enum hwmon_sensor_types type,
+				 u32 attr, int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_label:
+			switch (channel) {
+			case 0:
+				*str = "CPU Fan";
+				return 0;
+			case 1:
+				*str = "Intake Fan";
+				return 0;
+			case 2:
+				*str = "GPU Fan";
+				return 0;
+			case 3:
+				*str = "Aux Fan";
+				return 0;
+			default:
+				break;
+			}
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int thelio_io_read(struct device *dev, enum hwmon_sensor_types type,
+			  u32 attr, int channel, long *val)
+{
+	struct thelio_io_device *thelio_io = dev_get_drvdata(dev);
+	int ret;
+
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			ret = get_data(thelio_io, CMD_FAN_TACH, channel, true);
+			if (ret < 0)
+				return ret;
+			*val = ret;
+			return 0;
+		default:
+			break;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			ret = get_data(thelio_io, CMD_FAN_GET, channel, false);
+			if (ret < 0)
+				return ret;
+			*val = ret;
+			return 0;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+};
+
+static int thelio_io_write(struct device *dev, enum hwmon_sensor_types type,
+			   u32 attr, int channel, long val)
+{
+	struct thelio_io_device *thelio_io = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			return set_pwm(thelio_io, channel, val);
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+};
+
+static umode_t thelio_io_is_visible(const void *data, enum hwmon_sensor_types type,
+				    u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_fan:
+		switch (attr) {
+		case hwmon_fan_input:
+			return 0444;
+		case hwmon_fan_label:
+			return 0444;
+		default:
+			break;
+		}
+		break;
+	case hwmon_pwm:
+		switch (attr) {
+		case hwmon_pwm_input:
+			return 0644;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+};
+
+static const struct hwmon_ops thelio_io_hwmon_ops = {
+	.is_visible = thelio_io_is_visible,
+	.read = thelio_io_read,
+	.read_string = thelio_io_read_string,
+	.write = thelio_io_write,
+};
+
+static const struct hwmon_channel_info *thelio_io_info[] = {
+	HWMON_CHANNEL_INFO(chip,
+			   HWMON_C_REGISTER_TZ),
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_LABEL,
+			   HWMON_F_INPUT | HWMON_F_LABEL,
+			   HWMON_F_INPUT | HWMON_F_LABEL,
+			   HWMON_F_INPUT | HWMON_F_LABEL
+			   ),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_INPUT,
+			   HWMON_PWM_INPUT,
+			   HWMON_PWM_INPUT,
+			   HWMON_PWM_INPUT
+			   ),
+	NULL
+};
+
+static const struct hwmon_chip_info thelio_io_chip_info = {
+	.ops = &thelio_io_hwmon_ops,
+	.info = thelio_io_info,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int thelio_io_pm(struct notifier_block *nb, unsigned long action, void *data)
+{
+	struct thelio_io_device *thelio_io = container_of(nb, struct thelio_io_device, pm_notifier);
+
+	switch (action) {
+	case PM_HIBERNATION_PREPARE:
+	case PM_SUSPEND_PREPARE:
+		mutex_lock(&thelio_io->mutex);
+		send_usb_cmd(thelio_io, CMD_LED_SET_MODE, 0, 1, 0);
+		mutex_unlock(&thelio_io->mutex);
+		break;
+
+	case PM_POST_HIBERNATION:
+	case PM_POST_SUSPEND:
+		mutex_lock(&thelio_io->mutex);
+		send_usb_cmd(thelio_io, CMD_LED_SET_MODE, 0, 0, 0);
+		mutex_unlock(&thelio_io->mutex);
+		break;
+
+	case PM_POST_RESTORE:
+	case PM_RESTORE_PREPARE:
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif
+
+static int thelio_io_probe(struct hid_device *hdev, const struct hid_device_id *id)
+{
+	struct thelio_io_device *thelio_io;
+	int ret;
+
+	thelio_io = devm_kzalloc(&hdev->dev, sizeof(*thelio_io), GFP_KERNEL);
+	if (!thelio_io)
+		return -ENOMEM;
+
+	thelio_io->buffer = devm_kmalloc(&hdev->dev, BUFFER_SIZE, GFP_KERNEL);
+	if (!thelio_io->buffer)
+		return -ENOMEM;
+
+	ret = hid_parse(hdev);
+	if (ret)
+		return ret;
+
+	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (ret)
+		return ret;
+
+	ret = hid_hw_open(hdev);
+	if (ret)
+		goto out_hw_stop;
+
+	thelio_io->hdev = hdev;
+	hid_set_drvdata(hdev, thelio_io);
+	mutex_init(&thelio_io->mutex);
+	init_completion(&thelio_io->wait_input_report);
+
+	hid_device_io_start(hdev);
+
+	if (hdev->maxcollection == 1 && hdev->collection[0].usage == 0xFF600061) {
+		thelio_io->hwmon_dev = hwmon_device_register_with_info(&hdev->dev,
+								       "system76_thelio_io",
+								       thelio_io,
+								       &thelio_io_chip_info,
+								       0);
+		if (IS_ERR(thelio_io->hwmon_dev)) {
+			ret = PTR_ERR(thelio_io->hwmon_dev);
+			goto out_hw_close;
+		}
+
+	#ifdef CONFIG_PM_SLEEP
+		thelio_io->pm_notifier.notifier_call = thelio_io_pm;
+		register_pm_notifier(&thelio_io->pm_notifier);
+	#endif
+	}
+
+	return 0;
+
+out_hw_close:
+	hid_hw_close(hdev);
+out_hw_stop:
+	hid_hw_stop(hdev);
+	return ret;
+}
+
+static void thelio_io_remove(struct hid_device *hdev)
+{
+	struct thelio_io_device *thelio_io = hid_get_drvdata(hdev);
+
+	if (thelio_io->hwmon_dev) {
+		hwmon_device_unregister(thelio_io->hwmon_dev);
+
+	#ifdef CONFIG_PM_SLEEP
+		unregister_pm_notifier(&thelio_io->pm_notifier);
+	#endif
+	}
+
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+}
+
+static const struct hid_device_id thelio_io_devices[] = {
+	{ HID_USB_DEVICE(0x3384, 0x000B) }, /* thelio_io_2 */
+	{ }
+};
+
+static struct hid_driver thelio_io_driver = {
+	.name = "system76-thelio-io",
+	.id_table = thelio_io_devices,
+	.probe = thelio_io_probe,
+	.remove = thelio_io_remove,
+	.raw_event = thelio_io_raw_event,
+};
+
+MODULE_DEVICE_TABLE(hid, thelio_io_devices);
+MODULE_LICENSE("GPL");
+
+static int __init thelio_io_init(void)
+{
+	return hid_register_driver(&thelio_io_driver);
+}
+
+static void __exit thelio_io_exit(void)
+{
+	hid_unregister_driver(&thelio_io_driver);
+}
+
+/*
+ * When compiling this driver as built-in, hwmon initcalls will get called before the
+ * hid driver and this driver would fail to register. late_initcall solves this.
+ */
+late_initcall(thelio_io_init);
+module_exit(thelio_io_exit);
# ----------------------------------------
# Module: facetimehd
# Version: 1bd87461d3d1
# ----------------------------------------
diff --git a/drivers/custom/facetimehd/Makefile b/drivers/custom/facetimehd/Makefile
new file mode 100644
index 000000000000..0ddf6667c7e8
--- /dev/null
+++ b/drivers/custom/facetimehd/Makefile
@@ -0,0 +1,18 @@
+facetimehd-objs := fthd_ddr.o fthd_hw.o fthd_drv.o fthd_ringbuf.o fthd_isp.o fthd_v4l2.o fthd_buffer.o fthd_debugfs.o
+obj-m := facetimehd.o
+
+KVERSION := $(KERNELRELEASE)
+ifeq ($(origin KERNELRELEASE), undefined)
+KVERSION := $(shell uname -r)
+endif
+KDIR := /lib/modules/$(KVERSION)/build
+PWD := $(shell pwd)
+
+all:
+	$(MAKE) -C $(KDIR) M=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+
+install:
+	$(MAKE) -C $(KDIR) M=$(PWD) modules_install
diff --git a/drivers/custom/facetimehd/fthd_buffer.c b/drivers/custom/facetimehd/fthd_buffer.c
new file mode 100644
index 000000000000..fae443c1f380
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_buffer.c
@@ -0,0 +1,125 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/printk.h>
+#include "fthd_drv.h"
+#include "fthd_isp.h"
+#include "fthd_hw.h"
+#include "fthd_buffer.h"
+
+#define GET_IOMMU_PAGES(_x) (((_x) + 4095)/4096)
+
+struct buf_ctx {
+	struct fthd_plane plane[4];
+	struct isp_mem_obj *isphdr;
+};
+
+static int iommu_allocator_init(struct fthd_private *dev_priv)
+{
+        dev_priv->iommu = kzalloc(sizeof(struct resource), GFP_KERNEL);
+	if (!dev_priv->iommu)
+	    return -ENOMEM;
+
+	dev_priv->iommu->start = 0;
+	dev_priv->iommu->end = 4095;
+	return 0;
+}
+
+struct iommu_obj *iommu_allocate_sgtable(struct fthd_private *dev_priv, struct sg_table *sgtable)
+{
+	struct iommu_obj *obj;
+	struct resource *root = dev_priv->iommu;
+	struct scatterlist *sg;
+	int ret, i, pos;
+	int total_len = 0, dma_length;
+	dma_addr_t dma_addr;
+	
+	for(i = 0; i < sgtable->nents; i++)
+		total_len += sg_dma_len(sgtable->sgl + i);
+	
+	if (!total_len)
+		return NULL;
+
+	total_len += 4095;
+	total_len /= 4096;
+	
+	obj = kzalloc(sizeof(struct iommu_obj), GFP_KERNEL);
+	if (!obj)
+		return NULL;
+
+	obj->base.name = "S2 IOMMU";
+	ret = allocate_resource(root, &obj->base, total_len, root->start, root->end,
+				1, NULL, NULL);
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to allocate resource (size: %d, start: %Ld, end: %Ld)\n",
+			total_len, root->start, root->end);
+		kfree(obj);
+		obj = NULL;
+		return NULL;
+	}
+
+	obj->offset = obj->base.start - root->start;
+	obj->size = total_len;
+
+	pos = 0x9000 + obj->offset * 4;
+	for(i = 0; i < sgtable->nents; i++) {
+		sg = sgtable->sgl + i;
+		WARN_ON(sg->offset);
+		dma_addr = sg_dma_address(sg);
+		WARN_ON(dma_addr & 0xfff);
+		dma_addr >>= 12;
+		
+		for(dma_length = 0; dma_length < sg_dma_len(sg); dma_length += 0x1000) {
+		  //			pr_debug("IOMMU %08x -> %08llx (dma length %d)\n", pos, dma_addr, dma_length);
+			FTHD_S2_REG_WRITE(dma_addr++, pos);
+			pos += 4;
+		}
+	}
+
+	pr_debug("allocated %d pages @ %p / offset %d\n", obj->size, obj, obj->offset);
+	return obj;
+}
+
+void iommu_free(struct fthd_private *dev_priv, struct iommu_obj *obj)
+{
+	int i;
+	pr_debug("freeing %p\n", obj);
+
+	if (!obj)
+		return;
+	
+ 	for (i = obj->offset; i < obj->offset + obj->size; i++)
+		FTHD_S2_REG_WRITE(0, 0x9000 + i * 4);
+
+	release_resource(&obj->base);
+	kfree(obj);
+	obj = NULL;
+}
+
+static void iommu_allocator_destroy(struct fthd_private *dev_priv)
+{
+	kfree(dev_priv->iommu);
+}
+
+int fthd_buffer_init(struct fthd_private *dev_priv)
+{
+	int i;
+	for(i = 0; i < 0x1000; i++)
+		FTHD_S2_REG_WRITE(0, 0x9000 + i * 4);
+
+	return iommu_allocator_init(dev_priv);
+}
+
+void fthd_buffer_exit(struct fthd_private *dev_priv)
+{
+	iommu_allocator_destroy(dev_priv);
+}
diff --git a/drivers/custom/facetimehd/fthd_buffer.h b/drivers/custom/facetimehd/fthd_buffer.h
new file mode 100644
index 000000000000..2e76ded90215
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_buffer.h
@@ -0,0 +1,73 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+#ifndef FTHD_BUFFER_H
+#define FTHD_BUFFER_H
+
+#include <linux/scatterlist.h>
+#include "fthd_buffer.h"
+
+enum fthd_buffer_state {
+	BUF_FREE,
+	BUF_ALLOC,
+	BUF_DRV_QUEUED,
+	BUF_HW_QUEUED,
+};
+
+struct dma_descriptor {
+	u32 addr0;
+	u32 addr1;
+	u32 addr2;
+	u32 field_c;
+	u32 field_10;
+	u32 field_14;
+	u32 count;
+	u32 pool;
+	u64 tag;
+} __attribute__((packed));
+
+struct dma_descriptor_list {
+	u32 field0;
+    	u32 count;
+	struct dma_descriptor desc[4];
+	char unknown[216];
+} __attribute__((packed));
+
+struct iommu_obj {
+	struct resource base;
+	int size;
+	int offset;
+};
+
+struct fthd_plane {
+	u8 *virt;
+	u64 phys;
+	dma_addr_t dma;
+	int len;
+	struct iommu_obj *iommu;
+};
+
+struct h2t_buf_ctx {
+	enum fthd_buffer_state state;
+	struct vb2_buffer *vb;
+	struct iommu_obj *plane[4];
+	struct isp_mem_obj *dma_desc_obj;
+	struct dma_descriptor_list dma_desc_list;
+	/* waitqueue for signaling buffer completion */
+	wait_queue_head_t wq;
+	int done;
+};
+
+extern int setup_buffers(struct fthd_private *dev_priv);
+extern int fthd_buffer_init(struct fthd_private *dev_priv);
+extern void fthd_buffer_exit(struct fthd_private *dev_priv);
+extern void fthd_buffer_return_handler(struct fthd_private *dev_priv, u32 offset, int size);
+extern void fthd_buffer_queued_handler(struct fthd_private *dev_priv, u32 offset);
+extern struct iommu_obj *iommu_allocate_sgtable(struct fthd_private *dev_priv, struct sg_table *);
+extern void iommu_free(struct fthd_private *dev_priv, struct iommu_obj *obj);
+#endif
diff --git a/drivers/custom/facetimehd/fthd_ddr.c b/drivers/custom/facetimehd/fthd_ddr.c
new file mode 100644
index 000000000000..df21537680db
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_ddr.c
@@ -0,0 +1,675 @@
+/*
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation.
+ *
+ */
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 13, 0)
+#include <linux/prandom.h>
+#else
+#include <linux/random.h>
+#endif
+
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_ddr.h"
+
+int fthd_ddr_verify_mem(struct fthd_private *dev_priv, u32 base, int count)
+{
+	u32 i, val, val_read;
+	int failed_bits = 0;
+	struct rnd_state state;
+
+	prandom_seed_state(&state, 0x12345678);
+
+	for (i = 0; i < count; i++) {
+		val = prandom_u32_state(&state);
+		FTHD_S2_MEM_WRITE(val, i * 4 + MEM_VERIFY_BASE);
+	}
+
+	prandom_seed_state(&state, 0x12345678);
+
+	for (i = 0; i < count; i++) {
+		val = prandom_u32_state(&state);
+		val_read = FTHD_S2_MEM_READ(i * 4 + MEM_VERIFY_BASE);
+
+		failed_bits |= val ^ val_read;
+	}
+
+	return ((failed_bits & 0xffff) | ((failed_bits >> 16) & 0xffff));
+}
+
+static int fthd_ddr_calibrate_rd_data_dly_fifo(struct fthd_private *dev_priv)
+{
+	u32 fifo_status[2];
+	u32 rden_bytes[3];
+	u32 rden_wl_setting, rden_bl_setting, setting, tmp;
+	u32 byte0_pass, byte1_pass;
+	int passed;
+
+	rden_bytes[0] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE);
+	rden_bytes[1] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE0);
+	rden_bytes[2] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE1);
+
+	FTHD_S2_REG_WRITE(0x30000, S2_DDR40_RDEN_BYTE);
+	FTHD_S2_REG_WRITE(0x30100, S2_DDR40_RDEN_BYTE0);
+	FTHD_S2_REG_WRITE(0x30100, S2_DDR40_RDEN_BYTE1);
+
+	passed = 0;
+	setting = 1;
+	byte0_pass = 0;
+	byte1_pass = 0;
+	rden_wl_setting = 0;
+	rden_bl_setting = 0;
+
+	while (passed == 0) {
+		FTHD_S2_REG_WRITE(setting & 0x7, S2_DDR40_WL_RD_DATA_DLY);
+
+		fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+
+		tmp = FTHD_S2_REG_READ(S2_DDR40_WL_READ_FIFO_STATUS);
+		fifo_status[0] = tmp & 0xf;
+		fifo_status[1] = (tmp & 0xf0) >> 4;
+
+		FTHD_S2_REG_WRITE(1, S2_DDR40_WL_READ_FIFO_CLEAR);
+
+		if (fifo_status[0] == 0) {
+			if (byte0_pass == 0)
+				byte0_pass = setting;
+		}
+
+		if (fifo_status[1] == 0) {
+			if (byte1_pass == 0)
+				byte1_pass = setting;
+		}
+
+		if (rden_wl_setting < 57)
+			rden_wl_setting += 7;
+		else
+			rden_bl_setting += 7;
+
+		if (rden_bl_setting > 63) {
+			setting++;
+			rden_wl_setting = 0;
+			rden_bl_setting = 0;
+		}
+
+		if (byte0_pass != 0 && byte1_pass != 0)
+			passed = 1;
+
+		/* Seems we default to setting=7 if no pass is found */
+		if (setting > 7) {
+			passed = 1;
+			setting = 7;
+
+			if (byte0_pass == 0)
+				byte0_pass = setting;
+
+			if (byte1_pass == 0)
+				byte1_pass = setting;
+		}
+
+		/* Write new setting */
+		FTHD_S2_REG_WRITE(rden_wl_setting | 0x30000,
+				  S2_DDR40_RDEN_BYTE);
+		FTHD_S2_REG_WRITE(rden_bl_setting | 0x30100,
+				  S2_DDR40_RDEN_BYTE0);
+		FTHD_S2_REG_WRITE(rden_bl_setting | 0x30100,
+				  S2_DDR40_RDEN_BYTE1);
+	}
+
+	setting = byte0_pass;
+
+	if (byte1_pass > setting)
+		setting = byte1_pass;
+
+	setting++;
+
+	if (setting > 7)
+		setting = 7;
+
+	/* Restore settings */
+	FTHD_S2_REG_WRITE(rden_bytes[0], S2_DDR40_RDEN_BYTE);
+	FTHD_S2_REG_WRITE(rden_bytes[1], S2_DDR40_RDEN_BYTE0);
+	FTHD_S2_REG_WRITE(rden_bytes[2], S2_DDR40_RDEN_BYTE1);
+
+	if (setting < 7)
+		setting++;
+
+	FTHD_S2_REG_WRITE(setting, S2_DDR40_WL_RD_DATA_DLY);
+	dev_info(&dev_priv->pdev->dev, "RD_DATA_DLY: 0x%x\n", setting);
+
+	return 0;
+}
+
+static int fthd_ddr_calibrate_one_re_fifo(struct fthd_private *dev_priv,
+			u32 *rden_byte, u32 *rden_byte0, u32 *rden_byte1)
+{
+	u32 fifo_status[2];
+	u32 wl_start;
+	u32 bl_pass[2] = {0, 0};
+	u32 bl_start[2] = {0, 0};
+	u32 word_setting, byte_setting, passed, delta;
+	u32 tmp;
+
+	delta = ((FTHD_S2_REG_READ(S2_DDR40_PHY_VDL_STATUS) & 0xffc) >> 2) / 4;
+
+	/* Start with word and byte setting at 0 */
+	FTHD_S2_REG_WRITE(0x30000, S2_DDR40_RDEN_BYTE);
+	FTHD_S2_REG_WRITE(0x30100, S2_DDR40_RDEN_BYTE0);
+	FTHD_S2_REG_WRITE(0x30100, S2_DDR40_RDEN_BYTE0);
+
+	fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+
+	FTHD_S2_REG_WRITE(1, S2_DDR40_WL_READ_FIFO_CLEAR);
+
+	word_setting = 0;
+	byte_setting = 0;
+	passed = 0;
+
+	while (passed == 0) {
+		fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+
+		fifo_status[0] =
+			FTHD_S2_REG_READ(S2_DDR40_WL_READ_FIFO_STATUS) & 0xf;
+		fifo_status[1] =
+			(FTHD_S2_REG_READ(S2_DDR40_WL_READ_FIFO_STATUS) &
+			 0xf0) >> 4;
+
+		FTHD_S2_REG_WRITE(1, S2_DDR40_WL_READ_FIFO_CLEAR);
+
+		if (fifo_status[0] == 0) {
+			if (bl_pass[0] == 0)
+				bl_pass[0] = 1;
+			else
+				passed = 1;
+		}
+
+		if (fifo_status[1] == 0) {
+			if (bl_pass[1] == 0)
+				bl_pass[1] = 1;
+			else
+				passed = 1;
+		}
+
+		/* Still not passed */
+		if (passed == 0) {
+			if (word_setting < 63) {
+				word_setting++;
+				FTHD_S2_REG_WRITE(0x30000 | (word_setting & 0x3f),
+						  S2_DDR40_RDEN_BYTE);
+			} else {
+				byte_setting++;
+				FTHD_S2_REG_WRITE(0x30100 | (byte_setting & 0x3f),
+						  S2_DDR40_RDEN_BYTE0);
+				FTHD_S2_REG_WRITE(0x30100 | (byte_setting & 0x3f),
+						  S2_DDR40_RDEN_BYTE1);
+
+				if (word_setting > 64) {
+					dev_err(&dev_priv->pdev->dev,
+						"RDEN byte timeout\n");
+					return -EIO;
+				}
+			}
+		}
+	}
+
+	wl_start = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE) & 0x3f;
+
+	if (bl_pass[0] == 1) {
+		bl_start[0] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE0) & 0x3f;
+		passed = 0;
+
+		while (passed == 0) {
+			byte_setting++;
+			if (byte_setting > 64) {
+				dev_err(&dev_priv->pdev->dev,
+					"RDEN BYTE1 timeout\n");
+				return -EIO;
+			}
+
+			FTHD_S2_REG_WRITE(0x30100 | (byte_setting & 0x3f),
+					  S2_DDR40_RDEN_BYTE1);
+
+			fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+
+			fifo_status[0] = FTHD_S2_REG_READ(
+					S2_DDR40_WL_READ_FIFO_STATUS) & 0xf;
+			fifo_status[1] =
+				(FTHD_S2_REG_READ(S2_DDR40_WL_READ_FIFO_STATUS) &
+				 0xf0) >> 4;
+			FTHD_S2_REG_WRITE(1, S2_DDR40_WL_READ_FIFO_CLEAR);
+
+			if (fifo_status[1] == 0)
+				passed = 1;
+		}
+
+		bl_start[1] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE1) & 0x3f;
+	}
+	if (bl_pass[1] == 1) {
+		bl_start[1] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE1) & 0x3f;
+		passed = 0;
+
+		while (passed == 0) {
+			byte_setting++;
+			if (byte_setting > 64) {
+				dev_err(&dev_priv->pdev->dev,
+					"RDEN BYTE0 timeout\n");
+				return -EIO;
+			}
+
+			FTHD_S2_REG_WRITE(0x30100 | (byte_setting & 0x3f),
+					  S2_DDR40_RDEN_BYTE0);
+
+			fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+
+			fifo_status[0] = FTHD_S2_REG_READ(
+					S2_DDR40_WL_READ_FIFO_STATUS) & 0xf;
+			fifo_status[1] = FTHD_S2_REG_READ(
+					S2_DDR40_WL_READ_FIFO_STATUS) & 0xf0;
+			FTHD_S2_REG_WRITE(1, S2_DDR40_WL_READ_FIFO_CLEAR);
+
+			if (fifo_status[0] == 0)
+				passed = 1;
+		}
+
+		bl_start[0] = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE0) & 0x3f;
+	}
+
+	*rden_byte = wl_start + delta;
+
+	if (*rden_byte > 63) {
+		tmp = *rden_byte - 63;
+		*rden_byte = 63;
+		*rden_byte0 = bl_start[0] + tmp;
+		*rden_byte1 = bl_start[1] + tmp;
+	} else {
+		*rden_byte0 = bl_start[0];
+		*rden_byte1 = bl_start[1];
+	}
+
+	if (*rden_byte0 > 63) {
+		*rden_byte0 = 63;
+	}
+	if (*rden_byte1 > 63) {
+		*rden_byte1 = 63;
+	}
+
+	return 0;
+}
+
+static int fthd_ddr_calibrate_re_byte_fifo(struct fthd_private *dev_priv)
+{
+	u32 rden_byte = 0;
+	u32 rden_byte0 = 0;
+	u32 rden_byte1 = 0;
+	int ret;
+
+	ret = fthd_ddr_calibrate_one_re_fifo(dev_priv, &rden_byte, &rden_byte0, &rden_byte1);
+	if (ret)
+		return ret;
+
+	rden_byte = (rden_byte & 0x3f) | 0x30000;
+	FTHD_S2_REG_WRITE(rden_byte, S2_DDR40_RDEN_BYTE);
+
+	rden_byte0 = (rden_byte0 & 0x3f) | 0x30100;
+	FTHD_S2_REG_WRITE(rden_byte0, S2_DDR40_RDEN_BYTE0);
+
+	rden_byte1 = (rden_byte1 & 0x3f) | 0x30100;
+	FTHD_S2_REG_WRITE(rden_byte1, S2_DDR40_RDEN_BYTE1);
+
+	dev_info(&dev_priv->pdev->dev,
+		 "RE BYTE FIFO success: b0 = 0x%x, b1 = 0x%x, b = 0x%x\n",
+		 rden_byte0, rden_byte1, rden_byte);
+
+	return 0;
+}
+
+/* Set default/generic read data strobe */
+static int fthd_ddr_generic_shmoo_rd_dqs(struct fthd_private *dev_priv,
+					 u32 *fail_bits)
+{
+	u32 retries, setting, tmp, offset;
+	u32 bytes[S2_DDR40_NUM_BYTE_LANES];
+	int i, j, ret, fail;
+
+	/* Save the current byte lanes */
+	for (i = 0; i < S2_DDR40_NUM_BYTE_LANES; i++) {
+		tmp = FTHD_S2_REG_READ(S2_DDR40_RDEN_BYTE0 +
+				       (i * S2_DDR40_BYTE_LANE_SIZE));
+		bytes[i] = tmp & 0x3f;
+	}
+
+	/* Clear all byte lanes */
+	for (i = 0; i < S2_DDR40_NUM_BYTE_LANES; i++) {
+		for (j = 0; j < 8; j++) {
+			offset = S2_DDR40_2A38 + (i * 0xa0) + (j * 8);
+
+			FTHD_S2_REG_WRITE(0x30000, offset - 4);
+			FTHD_S2_REG_WRITE(0x30000, offset);
+		}
+	}
+
+	setting = (FTHD_S2_REG_READ(S2_DDR40_PHY_DQ_CALIB_STATUS) >> 20) & 0x3f;
+
+	retries = 1000;
+	fail = 0;
+
+	while (retries-- > 0 && !fail) {
+		ret = fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+		fail_bits[0] = ret;
+
+		if (ret == 0xffff) {
+			fail = 1;
+			break;
+		}
+
+		setting++;
+		tmp = (setting & 0x3f) | 0x30100;
+
+		/* Byte 0 */
+		FTHD_S2_REG_WRITE(tmp, S2_DDR40_2A08);
+		FTHD_S2_REG_WRITE(tmp, S2_DDR40_2A0C);
+
+		/* Byte 1 */
+		FTHD_S2_REG_WRITE(tmp, S2_DDR40_2AA8);
+		FTHD_S2_REG_WRITE(tmp, S2_DDR40_2AAC);
+
+		if (setting > 62)
+			fail = 1;
+
+		offset = S2_DDR40_RDEN_BYTE0;
+
+		/* Write byte lane settings */
+		for (i = 0; i < 2; i++) {
+			bytes[i]++;
+
+			if (bytes[i] > 62)
+				fail = 1;
+
+			FTHD_S2_REG_WRITE((bytes[i] & 0x3f) | 0x30100, offset);
+
+			offset += 0xa0;
+		}
+	}
+
+	if (retries == 0) {
+		dev_err(&dev_priv->pdev->dev, "Generic shmoo RD DQS timeout\n");
+		ret = -EIO;
+	}
+
+	if (fail)
+		dev_info(&dev_priv->pdev->dev, "Generic RD DQS failed\n");
+	else
+		dev_info(&dev_priv->pdev->dev, "Generic RD DQS succeeded\n");
+
+	/* It always fails, so just pass success */
+	return 0;
+}
+
+static int fthd_ddr_calibrate_rd_dqs(struct fthd_private *dev_priv,
+				     u32 *fails, u32 *settings)
+{
+	s32 pass_len[16];
+	u32 pass_start[16]; // u32 var_b0[16];
+	u32 pass_end[16]; // u32 var_f0[16];
+	int fail_sum, i, j, bit;
+	s32 setting;
+	printk(KERN_CONT "\n");
+
+	for (bit = 0; bit < 16; bit++) {
+		pass_start[bit] = 64;
+		pass_end[bit] = 64;
+
+		printk(KERN_CONT "%.2d: ", bit);
+
+		/* Start looking for start of pass */
+		for (i = 0; i < 63; i++) {
+			fail_sum = 0;
+
+			/* We check ahead the 6 next fail bits */
+			for (j = 0; (j < 6) && ((i + j) < 64); j++)
+				fail_sum += fails[i + j] & (1 << bit);
+
+			if (fail_sum) {
+				printk(KERN_CONT ".");
+			} else {
+				printk(KERN_CONT "O");
+
+				pass_start[bit] = i;
+				break;
+			}
+		}
+
+		/* Start looking for end of pass */
+		for (; i < 63; i++) {
+			if (fails[i] & (1 << bit)) {
+				if (pass_end[bit] == 64)
+					pass_end[bit] = i;
+
+				printk(KERN_CONT ".");
+			} else {
+				printk(KERN_CONT "O");
+			}
+		}
+
+		/* Calculate pass length */
+		pass_len[bit] = pass_end[bit] - pass_start[bit];
+
+		/* Calculate new setting */
+		setting = (pass_len[bit] / 2) + pass_start[bit];
+		if (setting < 0)
+			setting = 0;
+		else if (setting > 63)
+			setting = 63;
+		settings[bit] = setting;
+
+		printk(KERN_CONT " : start=%d end=%d len=%d new=%d\n", pass_start[bit],
+		       pass_end[bit], pass_len[bit], settings[bit]);
+	}
+
+	// Some global stuff that I need to figure out
+
+	return 0;
+}
+
+static int fthd_ddr_wr_dqs_setting(struct fthd_private *dev_priv, int set_bits,
+				   u32 *fail_bits, u32 *settings)
+{
+	u32 bl, setting, byte, bit, offset, tmp, start, inc, reg;
+	int i;
+
+	for (setting = 0; setting < 64; setting++) {
+		for (byte = 0; byte < 2; byte++) {
+			for (bit = 0; bit < 8; bit++) {
+				offset = S2_DDR40_2A38 + (byte * 0xa0) +
+					 (bit * 8);
+				tmp = setting | 0x30000;
+
+				if (set_bits & 1)
+					FTHD_S2_REG_WRITE(tmp, offset - 4);
+
+				if (set_bits & 2)
+					FTHD_S2_REG_WRITE(tmp, offset);
+			}
+		}
+		fail_bits[setting] = fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+	}
+
+	if (set_bits == 3) {
+		start = 0;
+		inc = 1;
+	} else if (set_bits == 2) {
+		start = 0;
+		inc = 2;
+	} else {
+		start = 1;
+		inc = 2;
+	}
+
+	fthd_ddr_calibrate_rd_dqs(dev_priv, fail_bits, settings);
+
+	offset = 0;
+
+	for (bl = 0; bl < 2; bl++) {
+		reg = S2_DDR40_2A34 + bl * 0xa0;
+
+		for (i = start; i < 16; i += inc) {
+
+			if (settings[offset] == 0 || settings[offset] >= 63) {
+				dev_err(&dev_priv->pdev->dev,
+					"Bad VDL. Step %d = 0x%x\n",
+					offset, settings[offset]);
+				return -EINVAL;
+			}
+
+			tmp = (settings[offset] & 0x3f) | 0x30000;
+			FTHD_S2_REG_WRITE(tmp, reg);
+			if (set_bits == 3) {
+				if (i & 1)
+					offset++;
+			} else {
+				offset++;
+			}
+
+			reg += inc;
+		}
+	}
+
+	return 0;
+}
+
+static int fthd_ddr_calibrate_create_result(struct fthd_private *dev_priv)
+{
+	return 0;
+}
+
+static int fthd_ddr_generic_shmoo_calibrate_rd_dqs(
+						struct fthd_private *dev_priv)
+{
+	u32 settings[64]; /* Don't know the real size yet */
+	u32 fails[64]; /* Number of fails on a setting */
+	int ret;
+
+	ret = fthd_ddr_generic_shmoo_rd_dqs(dev_priv, fails);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_wr_dqs_setting(dev_priv, 3, fails, settings);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_wr_dqs_setting(dev_priv, 1, fails, settings);
+	if (ret)
+		return ret;
+
+
+	ret = fthd_ddr_wr_dqs_setting(dev_priv, 2, fails, settings);
+	if (ret)
+		return ret;
+
+	/* NOP for now */
+	ret = fthd_ddr_calibrate_create_result(dev_priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int fthd_ddr_calibrate_wr_dq(struct fthd_private *dev_priv, u32 *fails,
+				    u32 *settings)
+{
+	return 0;
+}
+
+static int fthd_ddr_generic_shmoo_calibrate_wr_dq(struct fthd_private *dev_priv)
+{
+	u32 fails[64];
+	u32 settings[64]; /* Size is actually 16? */
+	u32 setting, offset;
+	int bit, bl, ret = 0;
+
+	/* shmoo_wr_dq */
+	for (setting = 0; setting < 64; setting++) {
+		for (bl = 0; bl < 2; bl++) {
+			offset = S2_DDR40_2A10 + (bl * S2_DDR40_BYTE_LANE_SIZE);
+			for (bit = 0; bit < 8; bit++) {
+				FTHD_S2_REG_WRITE(setting | 0x30000,
+						  offset + (bit * 4));
+			}
+		}
+
+		fails[setting] = fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+	}
+
+	fails[63] = 0xffff; /* Last setting is always a fail */
+
+	fthd_ddr_calibrate_wr_dq(dev_priv, fails, settings);
+
+	return ret;
+}
+
+static int fthd_ddr_generic_shmoo_calibrate_wr_dm(struct fthd_private *dev_priv)
+{
+	return 0;
+}
+
+static int fthd_ddr_generic_shmoo_calibrate_addr(struct fthd_private *dev_priv)
+{
+	return 0;
+}
+
+int fthd_ddr_calibrate(struct fthd_private *dev_priv)
+{
+	u32 reg;
+	int ret;
+
+	FTHD_S2_REG_WRITE(0, S2_DDR40_PHY_VDL_CTL);
+	FTHD_S2_REG_WRITE(0x200, S2_DDR40_PHY_VDL_CTL);
+
+	while (1) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_PHY_VDL_STATUS);
+		if (reg & 0x1)
+			break;
+	}
+
+	ret = fthd_ddr_calibrate_rd_data_dly_fifo(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_calibrate_re_byte_fifo(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_generic_shmoo_calibrate_rd_dqs(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_generic_shmoo_calibrate_wr_dq(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_generic_shmoo_calibrate_wr_dm(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_ddr_generic_shmoo_calibrate_addr(dev_priv);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff --git a/drivers/custom/facetimehd/fthd_ddr.h b/drivers/custom/facetimehd/fthd_ddr.h
new file mode 100644
index 000000000000..162e7c343ab7
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_ddr.h
@@ -0,0 +1,30 @@
+/*
+ * Broadcom PCIe 1570 webcam driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation.
+ *
+ */
+
+#ifndef _FTHD_DDR_H
+#define _FTHD_DDR_H
+
+#define MEM_VERIFY_BASE		0x0 /* 0x1000000 */
+#define MEM_VERIFY_NUM		128
+#define MEM_VERIFY_NUM_FULL	(1 * 1024 * 1024)
+
+int fthd_ddr_calibrate(struct fthd_private *dev_priv);
+int fthd_ddr_verify_mem(struct fthd_private *dev_priv, u32 base, int count);
+
+#endif
diff --git a/drivers/custom/facetimehd/fthd_debugfs.c b/drivers/custom/facetimehd/fthd_debugfs.c
new file mode 100644
index 000000000000..50ab5a75f14c
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_debugfs.c
@@ -0,0 +1,198 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/debugfs.h>
+#include "fthd_drv.h"
+#include "fthd_debugfs.h"
+#include "fthd_isp.h"
+#include "fthd_ringbuf.h"
+#include "fthd_hw.h"
+
+static ssize_t fthd_store_debug(struct file *file, const char __user *user_buf,
+				size_t count, loff_t *ppos)
+
+{
+	struct fthd_isp_debug_cmd cmd;
+	struct fthd_private *dev_priv = file->private_data;
+	int ret, opcode;
+	char buf[64];
+	int len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (!strcmp(buf, "ps"))
+		opcode = CISP_CMD_DEBUG_PS;
+	else if (!strcmp(buf, "banner"))
+		opcode = CISP_CMD_DEBUG_BANNER;
+	else if (!strcmp(buf, "get_root"))
+		opcode = CISP_CMD_DEBUG_GET_ROOT_HANDLE;
+	else if (!strcmp(buf, "heap"))
+		opcode = CISP_CMD_DEBUG_HEAP_STATISTICS;
+	else if (!strcmp(buf, "irq"))
+		opcode = CISP_CMD_DEBUG_IRQ_STATISTICS;
+	else if (!strcmp(buf, "semaphore"))
+		opcode = CISP_CMD_DEBUG_SHOW_SEMAPHORE_STATUS;
+	else if (!strcmp(buf, "wiring"))
+		opcode = CISP_CMD_DEBUG_SHOW_WIRING_OPERATIONS;
+	else if (sscanf(buf, "get_object_by_name %s", (char *)&cmd.arg) == 1)
+		opcode = CISP_CMD_DEBUG_GET_OBJECT_BY_NAME;
+	else if (sscanf(buf, "dump_object %x", &cmd.arg[0]) == 1)
+		opcode = CISP_CMD_DEBUG_DUMP_OBJECT;
+	else if (!strcmp(buf, "dump_objects"))
+		opcode = CISP_CMD_DEBUG_DUMP_ALL_OBJECTS;
+	else if (!strcmp(buf, "show_objects"))
+		opcode = CISP_CMD_DEBUG_SHOW_OBJECT_GRAPH;
+	else if (sscanf(buf, "get_debug_level %i", &cmd.arg[0]) == 1)
+		opcode = CISP_CMD_DEBUG_GET_DEBUG_LEVEL;
+	else if (sscanf(buf, "set_debug_level %x %i", &cmd.arg[0], &cmd.arg[1]) == 2)
+		opcode = CISP_CMD_DEBUG_SET_DEBUG_LEVEL;
+	else if (sscanf(buf, "set_debug_level_rec %x %i", &cmd.arg[0], &cmd.arg[1]) == 2)
+		opcode = CISP_CMD_DEBUG_SET_DEBUG_LEVEL_RECURSIVE;
+	else if (!strcmp(buf, "get_fsm_count"))
+		opcode = CISP_CMD_DEBUG_GET_FSM_COUNT;
+	else if (sscanf(buf, "get_fsm_by_name %s", (char *)&cmd.arg[0]) == 1)
+		opcode = CISP_CMD_DEBUG_GET_FSM_BY_NAME;
+	else if (sscanf(buf, "get_fsm_by_index %i", &cmd.arg[0]) == 1)
+		opcode = CISP_CMD_DEBUG_GET_FSM_BY_INDEX;
+	else if (sscanf(buf, "get_fsm_debug_level %x", &cmd.arg[0]) == 1)
+		opcode = CISP_CMD_DEBUG_GET_FSM_DEBUG_LEVEL;
+	else if (sscanf(buf, "set_fsm_debug_level %x", &cmd.arg[0]) == 2)
+		opcode = CISP_CMD_DEBUG_SET_FSM_DEBUG_LEVEL;
+
+	else if (sscanf(buf, "%i %i\n", &opcode, &cmd.arg[0]) != 2)
+		return -EINVAL;
+	cmd.show_errors = 1;
+
+	ret = fthd_isp_debug_cmd(dev_priv, opcode, &cmd, sizeof(cmd), NULL);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+
+static int seq_channel_read(struct seq_file *seq, struct fthd_private *dev_priv,
+			struct fw_channel *chan)
+{
+	int i;
+	char pos;
+	u32 entry;
+
+	spin_lock_irq(&chan->lock);
+	for( i = 0; i < chan->size; i++) {
+		if (chan->ringbuf.idx == i)
+			pos = '*';
+		else
+			pos = ' ';
+		entry = get_entry_addr(dev_priv, chan, i);
+		seq_printf(seq, "%c%3.3d: ADDRESS %08x REQUEST_SIZE %08x RESPONSE_SIZE %08x\n",
+			   pos, i,
+			   FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS),
+			   FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE),
+			   FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE));
+	}
+	spin_unlock_irq(&chan->lock);
+	return 0;
+}
+
+static int seq_channel_terminal_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_terminal);
+}
+
+static int seq_channel_sharedmalloc_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_shared_malloc);
+}
+
+static int seq_channel_io_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_io);
+}
+
+static int seq_channel_io_t2h_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_io_t2h);
+}
+
+static int seq_channel_buf_h2t_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_buf_h2t);
+}
+
+static int seq_channel_buf_t2h_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_buf_t2h);
+}
+
+static int seq_channel_debug_read(struct seq_file *seq, void *data)
+
+{
+	struct fthd_private *dev_priv = dev_get_drvdata(seq->private);
+	return seq_channel_read(seq, dev_priv, dev_priv->channel_debug);
+}
+
+static const struct file_operations fops_debug = {
+	.read = NULL,
+	.write = fthd_store_debug,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+int fthd_debugfs_init(struct fthd_private *dev_priv)
+{
+	struct dentry *d, *top;
+
+	top = debugfs_create_dir("facetimehd", NULL);
+	if (IS_ERR(top))
+		return PTR_ERR(top);
+
+	d = debugfs_create_dir(dev_name(&dev_priv->pdev->dev), top);
+	if (IS_ERR(d)) {
+		debugfs_remove_recursive(top);
+		return PTR_ERR(d);
+	}
+
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_terminal", d, seq_channel_terminal_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_sharedmalloc", d, seq_channel_sharedmalloc_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_io", d, seq_channel_io_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_io_t2h", d, seq_channel_io_t2h_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_buf_h2t", d, seq_channel_buf_h2t_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_buf_t2h", d, seq_channel_buf_t2h_read);
+	debugfs_create_devm_seqfile(&dev_priv->pdev->dev, "channel_debug", d, seq_channel_debug_read);
+	debugfs_create_file("debug", S_IRUSR | S_IWUSR, d, dev_priv, &fops_debug);
+	dev_priv->debugfs = top;
+	return 0;
+}
+
+void fthd_debugfs_exit(struct fthd_private *dev_priv)
+{
+	debugfs_remove_recursive(dev_priv->debugfs);
+}
diff --git a/drivers/custom/facetimehd/fthd_debugfs.h b/drivers/custom/facetimehd/fthd_debugfs.h
new file mode 100644
index 000000000000..d3f8b74239e4
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_debugfs.h
@@ -0,0 +1,17 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#ifndef _FTHD_SYSFS_H
+#define _FTHD_SYSFS_H
+
+struct fthd_private;
+
+int fthd_debugfs_init(struct fthd_private *priv);
+void fthd_debugfs_exit(struct fthd_private *priv);
+#endif
diff --git a/drivers/custom/facetimehd/fthd_drv.c b/drivers/custom/facetimehd/fthd_drv.c
new file mode 100644
index 000000000000..25ae22c1fac5
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_drv.c
@@ -0,0 +1,559 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_isp.h"
+#include "fthd_ringbuf.h"
+#include "fthd_buffer.h"
+#include "fthd_v4l2.h"
+#include "fthd_debugfs.h"
+
+static int fthd_pci_reserve_mem(struct fthd_private *dev_priv)
+{
+	unsigned long start;
+	unsigned long len;
+	int ret;
+
+	/* Reserve resources */
+	ret = pci_request_region(dev_priv->pdev, FTHD_PCI_S2_IO, "S2 IO");
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev, "Failed to request S2 IO\n");
+		return ret;
+	}
+
+	ret = pci_request_region(dev_priv->pdev, FTHD_PCI_ISP_IO, "ISP IO");
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev, "Failed to request ISP IO\n");
+		pci_release_region(dev_priv->pdev, FTHD_PCI_S2_IO);
+		return ret;
+	}
+
+	ret = pci_request_region(dev_priv->pdev, FTHD_PCI_S2_MEM, "S2 MEM");
+	if (ret) {
+		pci_release_region(dev_priv->pdev, FTHD_PCI_ISP_IO);
+		pci_release_region(dev_priv->pdev, FTHD_PCI_S2_IO);
+		return ret;
+	}
+
+	/* S2 IO */
+	start = pci_resource_start(dev_priv->pdev, FTHD_PCI_S2_IO);
+	len = pci_resource_len(dev_priv->pdev, FTHD_PCI_S2_IO);
+	dev_priv->s2_io = ioremap(start, len);
+	dev_priv->s2_io_len = len;
+
+	/* S2 MEM */
+	start = pci_resource_start(dev_priv->pdev, FTHD_PCI_S2_MEM);
+	len = pci_resource_len(dev_priv->pdev, FTHD_PCI_S2_MEM);
+	dev_priv->s2_mem = ioremap(start, len);
+	dev_priv->s2_mem_len = len;
+
+	/* ISP IO */
+	start = pci_resource_start(dev_priv->pdev, FTHD_PCI_ISP_IO);
+	len = pci_resource_len(dev_priv->pdev, FTHD_PCI_ISP_IO);
+	dev_priv->isp_io = ioremap(start, len);
+	dev_priv->isp_io_len = len;
+
+	pr_debug("Allocated S2 regs (BAR %d). %u bytes at 0x%p\n",
+		 FTHD_PCI_S2_IO, dev_priv->s2_io_len, dev_priv->s2_io);
+
+	pr_debug("Allocated S2 mem (BAR %d). %u bytes at 0x%p\n",
+		 FTHD_PCI_S2_MEM, dev_priv->s2_mem_len, dev_priv->s2_mem);
+
+	pr_debug("Allocated ISP regs (BAR %d). %u bytes at 0x%p\n",
+		 FTHD_PCI_ISP_IO, dev_priv->isp_io_len, dev_priv->isp_io);
+
+	return 0;
+}
+
+static void sharedmalloc_handler(struct fthd_private *dev_priv,
+				 struct fw_channel *chan,
+				 u32 entry)
+{
+	u32 request_size, response_size, address;
+	struct isp_mem_obj *obj;
+	int ret;
+
+	request_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE);
+	response_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE);
+	address = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS) & ~ 3;
+
+	if (address) {
+		pr_debug("Firmware wants to free memory at %08x\n", address);
+		FTHD_S2_MEMCPY_FROMIO(&obj, address - 64, sizeof(obj));
+		isp_mem_destroy(obj);
+
+		ret = fthd_channel_ringbuf_send(dev_priv, chan, 0, 0, 0, NULL);
+		if (ret)
+			pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+	} else {
+		if (!request_size)
+			return;
+		obj = isp_mem_create(dev_priv, FTHD_MEM_SHAREDMALLOC, request_size + 64);
+		if (!obj)
+			return;
+
+		pr_debug("Firmware allocated %d bytes at %08lx (tag %c%c%c%c)\n", request_size, obj->offset,
+			 response_size >> 24,response_size >> 16,
+			 response_size >> 8, response_size);
+		FTHD_S2_MEMCPY_TOIO(obj->offset, &obj, sizeof(obj));
+		ret = fthd_channel_ringbuf_send(dev_priv, chan, obj->offset + 64, 0, 0, NULL);
+		if (ret)
+			pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+
+	}
+
+}
+
+
+static void terminal_handler(struct fthd_private *dev_priv,
+				 struct fw_channel *chan,
+				 u32 entry)
+{
+	u32 request_size, response_size, address;
+	char buf[512];
+
+	request_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE);
+	response_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE);
+	address = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS) & ~ 3;
+
+	if (!address || !request_size)
+		return;
+
+	if (request_size > 512)
+		request_size = 512;
+	FTHD_S2_MEMCPY_FROMIO(buf, address, request_size);
+	pr_info("FWMSG: %.*s", request_size, buf);
+}
+
+static void buf_t2h_handler(struct fthd_private *dev_priv,
+			    struct fw_channel *chan,
+			    u32 entry)
+{
+	u32 request_size, response_size, address;
+	int ret;
+	request_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE);
+	response_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE);
+	address = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS);
+
+	if (address & 1)
+		return;
+
+
+	fthd_buffer_return_handler(dev_priv, address & ~3, request_size);
+	ret = fthd_channel_ringbuf_send(dev_priv, chan, (response_size & 0x10000000) ? address : 0,
+					0, 0x80000000, NULL);
+	if (ret)
+		pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+
+}
+
+static void io_t2h_handler(struct fthd_private *dev_priv,
+				 struct fw_channel *chan,
+				 u32 entry)
+{
+	int ret = fthd_channel_ringbuf_send(dev_priv, chan, 0, 0, 0, NULL);
+	if (ret)
+		pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+
+}
+
+static void fthd_handle_irq(struct fthd_private *dev_priv, struct fw_channel *chan)
+{
+	u32 entry;
+	int ret;
+
+	if (chan == dev_priv->channel_io) {
+		pr_debug("IO channel ready\n");
+		wake_up_interruptible(&chan->wq);
+		return;
+	}
+
+	if (chan == dev_priv->channel_buf_h2t) {
+		pr_debug("H2T channel ready\n");
+		wake_up_interruptible(&chan->wq);
+		return;
+	}
+
+	if (chan == dev_priv->channel_debug) {
+		pr_debug("DEBUG channel ready\n");
+		wake_up_interruptible(&chan->wq);
+		return;
+	}
+
+	while((entry = fthd_channel_ringbuf_receive(dev_priv, chan)) != (u32)-1) {
+		pr_debug("channel %s: message available, address %08x\n", chan->name, FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS));
+		if (chan == dev_priv->channel_shared_malloc) {
+			sharedmalloc_handler(dev_priv, chan, entry);
+		} else if (chan == dev_priv->channel_terminal) {
+			terminal_handler(dev_priv, chan, entry);
+			ret = fthd_channel_ringbuf_send(dev_priv, chan, 0, 0, 0, NULL);
+			if (ret)
+				pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+		} else if (chan == dev_priv->channel_buf_t2h) {
+			buf_t2h_handler(dev_priv, chan, entry);
+		} else if (chan == dev_priv->channel_io_t2h) {
+			io_t2h_handler(dev_priv, chan, entry);
+		}
+	}
+}
+
+static void fthd_irq_uninstall(struct fthd_private *dev_priv)
+{
+	free_irq(dev_priv->pdev->irq, dev_priv);
+}
+
+static void fthd_irq_work(struct work_struct *work)
+{
+	struct fthd_private *dev_priv = container_of(work, struct fthd_private, irq_work);
+	struct fw_channel *chan;
+
+	u32 pending;
+	int i = 0;
+
+	while(i++ < 500) {
+		spin_lock_irq(&dev_priv->io_lock);
+		pending = FTHD_ISP_REG_READ(ISP_IRQ_STATUS);
+		spin_unlock_irq(&dev_priv->io_lock);
+
+		if (!(pending & 0xf0))
+			break;
+
+		pci_write_config_dword(dev_priv->pdev, 0x94, 0);
+		spin_lock_irq(&dev_priv->io_lock);
+		FTHD_ISP_REG_WRITE(pending, ISP_IRQ_CLEAR);
+		spin_unlock_irq(&dev_priv->io_lock);
+		pci_write_config_dword(dev_priv->pdev, 0x90, 0x200);
+
+		for(i = 0; i < dev_priv->num_channels; i++) {
+			chan = dev_priv->channels[i];
+
+
+			BUG_ON(chan->source > 3);
+			if (!((0x10 << chan->source) & pending))
+				continue;
+			fthd_handle_irq(dev_priv, chan);
+		}
+	}
+
+	if (i >= 500) {
+		dev_err(&dev_priv->pdev->dev, "irq stuck, disabling\n");
+		fthd_irq_uninstall(dev_priv);
+	}
+	pci_write_config_dword(dev_priv->pdev, 0x94, 0x200);
+}
+
+static irqreturn_t fthd_irq_handler(int irq, void *arg)
+{
+	struct fthd_private *dev_priv = arg;
+	u32 pending;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev_priv->io_lock, flags);
+	pending = FTHD_ISP_REG_READ(ISP_IRQ_STATUS);
+	spin_unlock_irqrestore(&dev_priv->io_lock, flags);
+
+	if (!(pending & 0xf0))
+		return IRQ_NONE;
+
+	schedule_work(&dev_priv->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static int fthd_irq_install(struct fthd_private *dev_priv)
+{
+	int ret;
+
+	ret = request_irq(dev_priv->pdev->irq, fthd_irq_handler, IRQF_SHARED,
+			  KBUILD_MODNAME, (void *)dev_priv);
+
+	if (ret)
+		dev_err(&dev_priv->pdev->dev, "Failed to request IRQ\n");
+
+	return ret;
+}
+
+static int fthd_pci_set_dma_mask(struct fthd_private *dev_priv,
+				 unsigned int mask)
+{
+	int ret;
+
+	ret = dma_set_mask_and_coherent(&dev_priv->pdev->dev, DMA_BIT_MASK(mask));
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev, "Failed to set %u pci dma mask\n",
+			mask);
+		return ret;
+	}
+
+	dev_priv->dma_mask = mask;
+
+	return 0;
+}
+
+static void fthd_stop_firmware(struct fthd_private *dev_priv)
+{
+		fthd_isp_cmd_stop(dev_priv);
+	isp_powerdown(dev_priv);
+}
+
+static void fthd_pci_remove(struct pci_dev *pdev)
+{
+	struct fthd_private *dev_priv;
+
+	dev_priv = pci_get_drvdata(pdev);
+	if (!dev_priv)
+		goto out;
+
+	fthd_debugfs_exit(dev_priv);
+
+	fthd_v4l2_unregister(dev_priv);
+
+	fthd_stop_firmware(dev_priv);
+
+	fthd_irq_uninstall(dev_priv);
+
+	cancel_work_sync(&dev_priv->irq_work);
+
+	isp_uninit(dev_priv);
+
+	fthd_hw_deinit(dev_priv);
+
+	fthd_buffer_exit(dev_priv);
+
+	pci_disable_msi(pdev);
+
+	if (dev_priv->s2_io)
+		iounmap(dev_priv->s2_io);
+	if (dev_priv->s2_mem)
+		iounmap(dev_priv->s2_mem);
+	if (dev_priv->isp_io)
+		iounmap(dev_priv->isp_io);
+
+	pci_release_region(pdev, FTHD_PCI_S2_IO);
+	pci_release_region(pdev, FTHD_PCI_S2_MEM);
+	pci_release_region(pdev, FTHD_PCI_ISP_IO);
+out:
+	pci_disable_device(pdev);
+}
+
+static int fthd_pci_init(struct fthd_private *dev_priv)
+{
+	struct pci_dev *pdev = dev_priv->pdev;
+	int ret;
+
+
+	ret = pci_enable_device(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to enable device\n");
+		return ret;
+	}
+
+	/* ASPM must be disabled on the device or it hangs while streaming */
+	pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
+			       PCIE_LINK_STATE_CLKPM);
+
+	ret = fthd_pci_reserve_mem(dev_priv);
+	if (ret)
+		goto fail_enable;
+
+	ret = pci_enable_msi(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to enable MSI\n");
+		goto fail_reserve;
+	}
+
+	ret = fthd_irq_install(dev_priv);
+	if (ret)
+		goto fail_msi;
+
+	ret = fthd_pci_set_dma_mask(dev_priv, 64);
+	if (ret)
+		ret = fthd_pci_set_dma_mask(dev_priv, 32);
+
+	if (ret)
+		goto fail_irq;
+
+	dev_info(&pdev->dev, "Setting %ubit DMA mask\n", dev_priv->dma_mask);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,18,0)
+	pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(dev_priv->dma_mask));
+#else
+	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(dev_priv->dma_mask));
+#endif
+
+	pci_set_master(pdev);
+	pci_set_drvdata(pdev, dev_priv);
+	return 0;
+
+fail_irq:
+	fthd_irq_uninstall(dev_priv);
+fail_msi:
+	pci_disable_msi(pdev);
+fail_reserve:
+	pci_release_region(pdev, FTHD_PCI_S2_IO);
+	pci_release_region(pdev, FTHD_PCI_S2_MEM);
+	pci_release_region(pdev, FTHD_PCI_ISP_IO);
+fail_enable:
+	pci_disable_device(pdev);
+	return ret;
+}
+
+static int fthd_firmware_start(struct fthd_private *dev_priv)
+{
+	int ret;
+
+	ret = fthd_isp_cmd_start(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_print_enable(dev_priv, 1);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_camera_config(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_info(dev_priv);
+	if (ret)
+		return ret;
+
+	return fthd_isp_cmd_set_loadfile(dev_priv);
+
+}
+
+static int fthd_pci_probe(struct pci_dev *pdev,
+			  const struct pci_device_id *entry)
+{
+	struct fthd_private *dev_priv;
+	int ret;
+
+	dev_info(&pdev->dev, "Found FaceTime HD camera with device id: %x\n",
+		 pdev->device);
+
+	dev_priv = kzalloc(sizeof(struct fthd_private), GFP_KERNEL);
+	if (!dev_priv) {
+		dev_err(&pdev->dev, "Failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	dev_priv->ddr_model = 4;
+	dev_priv->ddr_speed = 450;
+	dev_priv->frametime = 40; /* 25 fps */
+
+	spin_lock_init(&dev_priv->io_lock);
+	mutex_init(&dev_priv->vb2_queue_lock);
+
+	mutex_init(&dev_priv->ioctl_lock);
+	INIT_LIST_HEAD(&dev_priv->buffer_queue);
+	INIT_WORK(&dev_priv->irq_work, fthd_irq_work);
+
+	dev_priv->pdev = pdev;
+
+	ret = fthd_pci_init(dev_priv);
+	if (ret)
+		goto fail_work;
+
+	ret = fthd_buffer_init(dev_priv);
+	if (ret)
+		goto fail_pci;
+
+	ret = fthd_hw_init(dev_priv);
+	if (ret)
+		goto fail_buffer;
+
+	ret = fthd_firmware_start(dev_priv);
+	if (ret)
+		goto fail_hw;
+
+	ret = fthd_v4l2_register(dev_priv);
+	if (ret)
+		goto fail_firmware;
+
+	ret = fthd_debugfs_init(dev_priv);
+	if (ret)
+		goto fail_v4l2;
+	return 0;
+fail_v4l2:
+	fthd_v4l2_unregister(dev_priv);
+fail_firmware:
+	fthd_stop_firmware(dev_priv);
+fail_hw:
+	fthd_hw_deinit(dev_priv);
+fail_buffer:
+	fthd_buffer_exit(dev_priv);
+fail_pci:
+	fthd_irq_uninstall(dev_priv);
+	pci_disable_msi(pdev);
+	pci_release_region(pdev, FTHD_PCI_S2_IO);
+	pci_release_region(pdev, FTHD_PCI_S2_MEM);
+	pci_release_region(pdev, FTHD_PCI_ISP_IO);
+	pci_disable_device(pdev);
+
+fail_work:
+	cancel_work_sync(&dev_priv->irq_work);
+	kfree(dev_priv);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int fthd_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	fthd_pci_remove(pdev);
+
+	return 0;
+}
+
+static int fthd_pci_resume(struct pci_dev *pdev)
+{
+	fthd_pci_probe(pdev, NULL);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static const struct pci_device_id fthd_pci_id_table[] = {
+	{ PCI_DEVICE(0x14e4, 0x1570), 4 },
+	{ 0, },
+};
+
+static struct pci_driver fthd_pci_driver = {
+	.name = KBUILD_MODNAME,
+	.probe = fthd_pci_probe,
+	.remove = fthd_pci_remove,
+	.shutdown = fthd_pci_remove,
+	.id_table = fthd_pci_id_table,
+#ifdef CONFIG_PM
+	.suspend = fthd_pci_suspend,
+	.resume = fthd_pci_resume,
+#endif
+};
+
+module_pci_driver(fthd_pci_driver);
+
+MODULE_FIRMWARE("facetimehd/firmware.bin");
+MODULE_DEVICE_TABLE(pci, fthd_pci_id_table);
+MODULE_AUTHOR("Patrik Jakobsson <patrik.r.jakobsson@gmail.com>");
+MODULE_DESCRIPTION("FacetimeHD camera driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/custom/facetimehd/fthd_drv.h b/drivers/custom/facetimehd/fthd_drv.h
new file mode 100644
index 000000000000..c77fbd4d9242
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_drv.h
@@ -0,0 +1,122 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#ifndef _FTHD_DRV_H
+#define _FTHD_DRV_H
+
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/version.h>
+#include <media/videobuf2-dma-sg.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
+#include "fthd_reg.h"
+#include "fthd_ringbuf.h"
+#include "fthd_buffer.h"
+#include "fthd_v4l2.h"
+
+#define FTHD_PCI_S2_IO  0
+#define FTHD_PCI_S2_MEM 2
+#define FTHD_PCI_ISP_IO 4
+
+#define FTHD_BUFFERS 4
+
+enum FW_CHAN_TYPE {
+	FW_CHAN_TYPE_OUT=0,
+	FW_CHAN_TYPE_IN=1,
+	FW_CHAN_TYPE_UNI_IN=2,
+};
+
+struct fw_channel {
+	u32 offset;
+	u32 size;
+	u32 source;
+	u32 type;
+	struct fthd_ringbuf ringbuf;
+	spinlock_t lock;
+	/* waitqueue for signaling completion */
+	wait_queue_head_t wq;
+	char *name;
+};
+
+struct fthd_private {
+	struct pci_dev *pdev;
+	unsigned int dma_mask;
+
+	struct v4l2_device v4l2_dev;
+	struct video_device *videodev;
+	struct mutex ioctl_lock;
+	int users;
+	/* lock for synchronizing with irq/workqueue */
+	spinlock_t io_lock;
+
+	/* Mapped PCI resources */
+	void __iomem *s2_io;
+	u32 s2_io_len;
+
+	void __iomem *s2_mem;
+	u32 s2_mem_len;
+
+	void __iomem *isp_io;
+	u32 isp_io_len;
+
+	struct work_struct irq_work;
+
+	/* Hardware info */
+	u32 core_clk;
+	u32 ddr_model;
+	u32 ddr_speed;
+	u32 vdl_step_size;
+
+	u32 ddr_phy_regs[DDR_PHY_NUM_REG];
+
+	/* Root resource for memory management */
+	struct resource *mem;
+	/* Resource for managing IO mmu slots */
+	struct resource *iommu;
+	/* ISP memory objects */
+	struct isp_mem_obj *firmware;
+	struct isp_mem_obj *set_file;
+	struct isp_mem_obj *ipc_queue;
+	struct isp_mem_obj *heap;
+
+	/* Firmware channels */
+	int num_channels;
+	struct fw_channel **channels;
+	struct fw_channel *channel_terminal;
+	struct fw_channel *channel_io;
+	struct fw_channel *channel_debug;
+	struct fw_channel *channel_buf_h2t;
+	struct fw_channel *channel_buf_t2h;
+	struct fw_channel *channel_shared_malloc;
+	struct fw_channel *channel_io_t2h;
+
+	/* camera config */
+	int sensor_count;
+	int sensor_id0;
+	int sensor_id1;
+
+	struct fthd_fmt fmt;
+
+	struct vb2_queue vb2_queue;
+	struct mutex vb2_queue_lock;
+	struct list_head buffer_queue;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	struct vb2_alloc_ctx *alloc_ctx;
+#endif
+	struct h2t_buf_ctx h2t_bufs[FTHD_BUFFERS];
+
+	struct v4l2_ctrl_handler v4l2_ctrl_handler;
+	int frametime;
+	struct dentry *debugfs;
+};
+
+#endif
diff --git a/drivers/custom/facetimehd/fthd_hw.c b/drivers/custom/facetimehd/fthd_hw.c
new file mode 100644
index 000000000000..8180072922d4
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_hw.c
@@ -0,0 +1,712 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#include <linux/delay.h>
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_ddr.h"
+#include "fthd_isp.h"
+
+static int fthd_hw_s2_pll_reset(struct fthd_private *dev_priv)
+{
+	FTHD_S2_REG_WRITE(0x40, S2_PLL_CTRL_2C);
+	FTHD_S2_REG_WRITE(0x0, S2_PLL_CTRL_2C);
+	FTHD_S2_REG_WRITE(0xbcbc1500, S2_PLL_CTRL_100);
+	FTHD_S2_REG_WRITE(0x0, S2_PLL_CTRL_14);
+
+	udelay(10000);
+
+	FTHD_S2_REG_WRITE(0x3, S2_PLL_CTRL_14);
+
+	dev_info(&dev_priv->pdev->dev, "PLL reset finished\n");
+
+	return 0;
+}
+
+static int fthd_hw_s2_init_pcie_link(struct fthd_private *dev_priv)
+{
+	u32 reg;
+
+	reg = FTHD_S2_REG_READ(S2_PCIE_LINK_D000);
+	FTHD_S2_REG_WRITE(reg | 0x10, S2_PCIE_LINK_D000);
+
+	FTHD_S2_REG_WRITE(0x1804, S2_PCIE_LINK_D120);
+	FTHD_S2_REG_WRITE(0xac5800, S2_PCIE_LINK_D124);
+	FTHD_S2_REG_WRITE(0x1804, S2_PCIE_LINK_D120);
+
+	/* Check if PLL is powered down when S2 PCIe link is in L1 state */
+	reg = FTHD_S2_REG_READ(S2_PCIE_LINK_D124);
+	if (reg != 0xac5800) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to init S2 PCIe link: %08x\n", reg);
+		return -EIO;
+	}
+
+	/* PLL is powered down */
+	dev_info(&dev_priv->pdev->dev, "S2 PCIe link init succeeded\n");
+
+	FTHD_S2_REG_WRITE(0x1f08, S2_PCIE_LINK_D128);
+	FTHD_S2_REG_WRITE(0x80008610, S2_PCIE_LINK_D12C);
+	FTHD_S2_REG_WRITE(0x1608, S2_PCIE_LINK_D128);
+	FTHD_S2_REG_WRITE(0x8000fc00, S2_PCIE_LINK_D12C);
+	FTHD_S2_REG_WRITE(0x1f08, S2_PCIE_LINK_D128);
+	FTHD_S2_REG_WRITE(0x80008610, S2_PCIE_LINK_D12C);
+	FTHD_S2_REG_WRITE(0x1708, S2_PCIE_LINK_D128);
+	FTHD_S2_REG_WRITE(0x800005bf, S2_PCIE_LINK_D12C);
+
+	return 0;
+}
+
+static int fthd_hw_s2_pll_init(struct fthd_private *dev_priv, u32 ddr_speed)
+{
+	u32 ref_clk_25;
+	u32 reg;
+	int retries = 0;
+
+	reg = FTHD_S2_REG_READ(S2_PLL_REFCLK);
+	ref_clk_25 = reg & S2_PLL_REFCLK_25MHZ ? 1 : 0;
+
+	if (ref_clk_25)
+		dev_info(&dev_priv->pdev->dev, "Refclk: 25MHz (0x%x)\n", reg);
+	else
+		dev_info(&dev_priv->pdev->dev, "Refclk: 24MHz (0x%x\n", reg);
+
+	if (ddr_speed == 400) {
+		if (ref_clk_25) {
+			/* Ref clk 25 */
+			FTHD_S2_REG_WRITE(0x00400078, S2_PLL_CTRL_510);
+			FTHD_S2_REG_WRITE(0x19280804, S2_PLL_CTRL_24);
+		} else {
+			/* Ref clk 24 */
+			FTHD_S2_REG_WRITE(0x03200000, S2_PLL_CTRL_20);
+			FTHD_S2_REG_WRITE(0x14280603, S2_PLL_CTRL_24);
+		}
+	} else if (ddr_speed == 300) {
+		if (ref_clk_25) {
+			/* Ref clk 25 */
+			FTHD_S2_REG_WRITE(0x00480078, S2_PLL_CTRL_510);
+			FTHD_S2_REG_WRITE(0x19280c06, S2_PLL_CTRL_24);
+		} else {
+			/* Ref clk 24 */
+			FTHD_S2_REG_WRITE(0x03200000, S2_PLL_CTRL_20);
+			FTHD_S2_REG_WRITE(0x14280804, S2_PLL_CTRL_24);
+		}
+	} else if (ddr_speed == 200) {
+		if (ref_clk_25) {
+			/* Ref clk 25 */
+			FTHD_S2_REG_WRITE(0x00400078, S2_PLL_CTRL_510);
+			FTHD_S2_REG_WRITE(0x19281008, S2_PLL_CTRL_24);
+		} else {
+			/* Ref clk 24 */
+			FTHD_S2_REG_WRITE(0x03200000, S2_PLL_CTRL_20);
+			FTHD_S2_REG_WRITE(0x14280c06, S2_PLL_CTRL_24);
+		}
+	} else {
+		if (ddr_speed != 450) {
+			dev_err(&dev_priv->pdev->dev,
+				"Unsupported DDR speed %uMHz, using 450MHz\n",
+				ddr_speed);
+			ddr_speed = 450;
+		}
+
+		if (ref_clk_25) {
+			/* Ref clk 25 */
+			FTHD_S2_REG_WRITE(0x0048007d, S2_PLL_CTRL_510);
+			FTHD_S2_REG_WRITE(0x19280904, S2_PLL_CTRL_24);
+		} else {
+			/* Ref clk 24 */
+			FTHD_S2_REG_WRITE(0x04b00000, S2_PLL_CTRL_20);
+			FTHD_S2_REG_WRITE(0x14280904, S2_PLL_CTRL_24);
+
+		}
+	}
+
+	fthd_hw_s2_pll_reset(dev_priv);
+
+	dev_info(&dev_priv->pdev->dev, "Waiting for S2 PLL to lock at %d MHz\n",
+		 ddr_speed);
+
+	do {
+		reg = FTHD_S2_REG_READ(S2_PLL_CMU_STATUS);
+		udelay(10);
+		retries++;
+	} while (((reg & 0xff00) & S2_PLL_CMU_STATUS_LOCKED) && retries <= 10000);
+
+	if (retries > 10000) {
+		dev_info(&dev_priv->pdev->dev, "Failed to lock S2 PLL: 0x%x\n",
+			 reg);
+		return -EINVAL;
+	} else {
+		dev_info(&dev_priv->pdev->dev, "S2 PLL is locked after %d us\n",
+			 (retries * 10));
+	}
+
+	reg = FTHD_S2_REG_READ(S2_PLL_STATUS_A8);
+	FTHD_S2_REG_WRITE(reg | S2_PLL_BYPASS, S2_PLL_STATUS_A8);
+	udelay(10000);
+
+	reg = FTHD_S2_REG_READ(S2_PLL_STATUS_A8);
+	if (reg & S2_PLL_BYPASS)
+		dev_info(&dev_priv->pdev->dev, "S2 PLL is in bypass mode\n");
+	else
+		dev_info(&dev_priv->pdev->dev, "S2 PLL is in non-bypass mode\n");
+
+	return 0;
+}
+
+static int fthd_hw_s2_preinit_ddr_controller_soc(struct fthd_private *dev_priv)
+{
+	/* Wingardium leviosa */
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1100);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1104);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1108);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_110C);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1110);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1114);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_1118);
+	FTHD_S2_REG_WRITE(0x203, S2_DDR_REG_111C);
+
+	return 0;
+}
+
+static int fthd_hw_ddr_phy_soft_reset(struct fthd_private *dev_priv)
+{
+	/* Clear status bits? */
+	FTHD_S2_REG_WRITE(0x281, S2_PLL_STATUS_A8);
+
+	FTHD_S2_REG_WRITE(0xfffff, S2_PLL_CTRL_9C);
+
+	udelay(10000);
+
+	FTHD_S2_REG_WRITE(0xffbff, S2_PLL_CTRL_9C);
+
+	return 0;
+}
+
+static inline int fthd_hw_ddr_status_busy(struct fthd_private *dev_priv,
+					  int retries, int delay)
+{
+	int reg = 0, i;
+
+	for (i = 0; i < retries; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR_STATUS_2018);
+		if (!(reg & S2_DDR_STATUS_BUSY))
+			break;
+
+		if (delay > 0)
+			udelay(delay);
+	}
+
+	if (i >= retries) {
+		dev_err(&dev_priv->pdev->dev,
+			"S2_DDR_STATUS_2018 busy: retries=%d, udelay=%d, reg=0x%08x\n",
+			retries, delay, reg);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int fthd_hw_ddr_rewrite_mode_regs(struct fthd_private *dev_priv)
+{
+	int ret, val;
+
+	FTHD_S2_REG_WRITE(0x02000802, S2_DDR_2014);
+
+	ret = fthd_hw_ddr_status_busy(dev_priv, 500, 5);
+	if (ret != 0)
+		return ret;
+
+	FTHD_S2_REG_WRITE(0x3, S2_DDR_2014);
+
+	ret = fthd_hw_ddr_status_busy(dev_priv, 500, 5);
+	if (ret != 0)
+		return ret;
+
+	FTHD_S2_REG_WRITE(0x1, S2_DDR_2014);
+
+	ret = fthd_hw_ddr_status_busy(dev_priv, 500, 5);
+	if (ret != 0)
+		return ret;
+
+	if (dev_priv->ddr_speed == 450)
+		val = 0x17003000;
+	else
+		val = 0x17002000;
+
+	FTHD_S2_REG_WRITE(val, S2_DDR_2014);
+
+	ret = fthd_hw_ddr_status_busy(dev_priv, 500, 5);
+	if (ret != 0)
+		return ret;
+
+	dev_info(&dev_priv->pdev->dev,
+		 "Rewrite DDR mode registers succeeded\n");
+
+	return 0;
+}
+
+static int fthd_hw_s2_init_ddr_controller_soc(struct fthd_private *dev_priv)
+{
+	u32 cmd;
+	u32 val;
+	u32 reg;
+	u32 step_size, vdl_fine, vdl_coarse;
+	u32 vtt_cons, vtt_ovr;
+	int ret, i;
+
+	/* Read PCI config command register */
+	ret = pci_read_config_dword(dev_priv->pdev, 4, &cmd);
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev, "Failed to read PCI config\n");
+		return -EIO;
+	}
+
+	if ((cmd & 0x07) == 0) {
+		dev_err(&dev_priv->pdev->dev,
+			"PCI link in illegal state, cfg_cmd_reg: 0x%x\n", cmd);
+		return -EIO;
+	}
+
+	reg = FTHD_S2_REG_READ(S2_PLL_CTRL_9C);
+	FTHD_S2_REG_WRITE(reg & 0xfffffcff, S2_PLL_CTRL_9C);
+	FTHD_S2_REG_WRITE(reg | 0x300, S2_PLL_CTRL_9C);
+
+	fthd_hw_s2_pll_init(dev_priv, dev_priv->ddr_speed);
+
+	fthd_hw_ddr_phy_soft_reset(dev_priv);
+
+	FTHD_S2_REG_WRITE(0x2, S2_DDR40_WL_DRV_PAD_CTL);
+	FTHD_S2_REG_WRITE(0x2, S2_DDR40_WL_CLK_PAD_DISABLE);
+
+	/* Disable the hardware frequency change function */
+	FTHD_S2_REG_WRITE(0x3f4, S2_20F8);
+
+	/* Setup the PLL */
+	FTHD_S2_REG_WRITE(0x40, S2_2434);
+	FTHD_S2_REG_WRITE(0x10000000, S2_2438);
+	FTHD_S2_REG_WRITE(0x4, S2_2424);
+	FTHD_S2_REG_WRITE(0x1f37291, S2_2430);
+
+	/* Wait for DDR PLL to lock */
+	for (i = 0; i <= 10000; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR_PLL_STATUS_2444);
+		if (reg & S2_DDR_PLL_STATUS_2444_LOCKED)
+			break;
+		udelay(10);
+	}
+
+	if (i > 10000) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to lock DDR PHY PLL in stage 1\n");
+		return -EIO;
+	}
+
+	FTHD_S2_REG_WRITE(0x1f37205, S2_2430);
+
+	for (i = 0; i <= 10000; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR_PLL_STATUS_241C);
+		if (reg & S2_DDR_PLL_STATUS_241C_LOCKED)
+			break;
+		udelay(10);
+	}
+
+	if (i > 10000) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to lock DDR PHY PLL in stage 2\n");
+		return -EIO;
+	}
+
+	udelay(10000);
+
+	/* WL */
+	FTHD_S2_REG_WRITE(0x0c10, S2_DDR40_PHY_PLL_DIV);
+	FTHD_S2_REG_WRITE(0x0010, S2_DDR40_PHY_PLL_CFG);
+
+	for (i = 0; i <= 10000; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_PHY_PLL_STATUS);
+		if (reg & S2_DDR40_PHY_PLL_STATUS_LOCKED)
+			break;
+		udelay(10);
+	}
+
+	if (i > 10000) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to lock DDR PHY PLL in stage 3\n");
+		return -EIO;
+	}
+
+	dev_info(&dev_priv->pdev->dev,
+		 "DDR40 PHY PLL locked on safe settings\n");
+
+	/* Default is DDR model 4 */
+	switch (dev_priv->ddr_model) {
+	case 4:
+		val = 0x46a00c2;
+		break;
+	case 2:
+		val = 0x42500c2;
+		break;
+	default:
+		val = 0;
+	}
+
+	FTHD_S2_REG_WRITE(0x10737545, S2_DDR_20A0);
+	FTHD_S2_REG_WRITE(0x12643173, S2_DDR_20A4);
+	FTHD_S2_REG_WRITE(0xff3f, S2_DDR_20A8);
+	FTHD_S2_REG_WRITE(val, S2_DDR_20B0);
+	FTHD_S2_REG_WRITE(0x101f, S2_DDR_2118);
+	FTHD_S2_REG_WRITE(0x1c0, S2_DDR40_PHY_AUX_CTL);
+
+	switch (dev_priv->ddr_model) {
+	case 4:
+		val = 0x2159518;
+		break;
+	case 2:
+		val = 0x2155558;
+		break;
+	}
+
+	FTHD_S2_REG_WRITE(val, S2_DDR40_STRAP_CTL);
+
+	if (dev_priv->ddr_speed == 450)
+		val = 0x108307;
+	else
+		val = 0x108286;
+
+	FTHD_S2_REG_WRITE(val, S2_DDR40_STRAP_CTL_2);
+
+	/* Strap control */
+	FTHD_S2_REG_WRITE(0x2159559, S2_DDR40_STRAP_CTL);
+
+	/* Polling for STRAP valid */
+	for (i = 0; i < 10000; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_STRAP_STATUS);
+		if (reg & 0x1)
+			break;
+		udelay(10);
+	}
+
+	if (i >= 10000) {
+		dev_err(&dev_priv->pdev->dev,
+			"Timeout waiting for STRAP valid\n");
+		return -ENODEV;
+	} else {
+		dev_info(&dev_priv->pdev->dev, "STRAP valid\n");
+	}
+
+	/* Manual DDR40 PHY init */
+	if (dev_priv->ddr_speed != 450) {
+		dev_warn(&dev_priv->pdev->dev,
+			 "DDR frequency is %u (should be 450 MHz)",
+			 dev_priv->ddr_speed);
+	}
+
+	dev_info(&dev_priv->pdev->dev,
+		 "Configuring DDR PLLs for %u MHz\n", dev_priv->ddr_speed);
+
+	if ((dev_priv->ddr_speed * 2) < 500)
+		val = 0x2040;
+	else
+		val = 0x810;
+
+	/* Start programming the DDR PLL */
+
+	reg = FTHD_S2_REG_READ(S2_DDR40_PHY_PLL_DIV);
+	reg &= 0xffffc700;
+	val |= reg;
+
+	FTHD_S2_REG_WRITE(val, S2_DDR40_PHY_PLL_DIV);
+
+	reg = FTHD_S2_REG_READ(S2_DDR40_PHY_PLL_CFG);
+	reg &= 0xfffffffd;
+	FTHD_S2_REG_WRITE(reg, S2_DDR40_PHY_PLL_CFG);
+
+	/* Start polling for the lock */
+	for (i = 0; i < 100; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_PHY_PLL_STATUS);
+		if (reg & S2_DDR40_PHY_PLL_STATUS_LOCKED)
+			break;
+		udelay(1);
+	}
+
+	if (i >= 100) {
+		dev_err(&dev_priv->pdev->dev, "Failed to lock the DDR PLL\n");
+		return -ENODEV;
+	}
+
+	dev_info(&dev_priv->pdev->dev, "DDR40 PLL is locked after %d us\n", i);
+
+	/* Configure DDR40 VDL */
+	FTHD_S2_REG_WRITE(0, S2_DDR40_PHY_VDL_CTL);
+	FTHD_S2_REG_WRITE(0x103, S2_DDR40_PHY_VDL_CTL);
+
+	/* Poll for VDL calibration */
+	for (i = 0; i < 100; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_PHY_VDL_STATUS);
+		if (reg & 0x1)
+			break;
+		udelay(1);
+	}
+
+	if (reg & 0x1) {
+		dev_info(&dev_priv->pdev->dev,
+			 "First DDR40 VDL calibration completed after %d us",
+			 i);
+
+		if ((reg & 0x2) == 0) {
+			dev_info(&dev_priv->pdev->dev,
+				 "...but failed to lock\n");
+		}
+
+	} else {
+		dev_err(&dev_priv->pdev->dev,
+			"First DDR40 VDL calibration failed\n");
+	}
+
+	FTHD_S2_REG_WRITE(0, S2_DDR40_PHY_VDL_CTL);
+	FTHD_S2_REG_WRITE(0, S2_DDR40_PHY_VDL_CTL); /* Needed? */
+	FTHD_S2_REG_WRITE(0x200, S2_DDR40_PHY_VDL_CTL); /* calib steps */
+
+	for (i = 0; i < 1000; i++) {
+		reg = FTHD_S2_REG_READ(S2_DDR40_PHY_VDL_STATUS);
+		if (reg & 0x1)
+			break;
+		udelay(1);
+	}
+
+	dev_info(&dev_priv->pdev->dev,
+		 "Second DDR40 VDL calibration completed after %d us\n", i);
+
+	if (reg & 0x2) {
+		step_size = (reg & S2_DDR40_PHY_VDL_STEP_MASK) >>
+			    S2_DDR40_PHY_VDL_STEP_SHIFT;
+		dev_info(&dev_priv->pdev->dev, "Using step size %u\n",
+			 step_size);
+	} else {
+
+		val = 1000000 / dev_priv->ddr_speed;
+		step_size = (val * 0x4ec4ec4f) >> 22;
+		dev_info(&dev_priv->pdev->dev, "Using default step size (%u)\n",
+			 step_size);
+	}
+
+	dev_priv->vdl_step_size = step_size;
+
+	vdl_fine = FTHD_S2_REG_READ(S2_DDR40_PHY_VDL_CHAN_STATUS);
+
+	/* lock = 1 and byte_sel = 1 */
+	if ((vdl_fine & 2) == 0) {
+		vdl_fine = (vdl_fine >> 8) & 0x3f;
+		vdl_fine |= 0x10100;
+
+		FTHD_S2_REG_WRITE(vdl_fine, S2_DDR40_PHY_VDL_OVR_FINE);
+
+		vdl_coarse = 0x10000;
+
+		step_size >>= 4;
+		step_size += step_size * 2;
+
+		if (step_size > 10) {
+			step_size = (step_size + 118) >> 1;
+			step_size &= 0x3f;
+			step_size |= 0x10000;
+			vdl_coarse = step_size;
+		}
+
+		FTHD_S2_REG_WRITE(vdl_coarse, S2_DDR40_PHY_VDL_OVR_COARSE);
+
+		dev_info(&dev_priv->pdev->dev,
+			 "VDL set to: coarse=0x%x, fine=0x%x\n",
+			 vdl_coarse, vdl_fine);
+	}
+
+	/* Configure Virtual VTT connections and override */
+
+	vtt_cons = 0x1cf7fff;
+	FTHD_S2_REG_WRITE(vtt_cons, S2_DDR40_PHY_VTT_CONNECTIONS);
+
+	vtt_ovr = 0x77fff;
+	FTHD_S2_REG_WRITE(vtt_ovr, S2_DDR40_PHY_VTT_OVERRIDE);
+
+	FTHD_S2_REG_WRITE(0x4, S2_DDR40_PHY_VTT_CTL);
+
+	dev_info(&dev_priv->pdev->dev, "Virtual VTT enabled");
+
+	/* Process, Voltage and Temperature compensation */
+	FTHD_S2_REG_WRITE(0xc0fff, S2_DDR40_PHY_ZQ_PVT_COMP_CTL);
+	FTHD_S2_REG_WRITE(0x2, S2_DDR40_PHY_DRV_PAD_CTL);
+	FTHD_S2_REG_WRITE(0x2, S2_DDR40_WL_DRV_PAD_CTL);
+
+	val = 1000000 / dev_priv->ddr_speed;
+	reg = 4;
+
+	if (val >= 400) {
+		if (val > 900)
+			reg = 1;
+
+		reg += 5;
+	}
+
+	/* DDR read FIFO delay? */
+	FTHD_S2_REG_WRITE(reg, S2_DDR40_WL_RD_DATA_DLY);
+	FTHD_S2_REG_WRITE(0x2, S2_DDR40_WL_READ_CTL); /* le_adj, te_adj */
+	FTHD_S2_REG_WRITE(0x3, S2_DDR40_WL_WR_PREAMBLE_MODE); /* mode, long */
+
+	/* dq_oeb, dq_reb, dq_iddq, dq_rxenb */
+	reg = FTHD_S2_REG_READ(S2_DDR40_WL_IDLE_PAD_CTL);
+	FTHD_S2_REG_WRITE(reg & 0xff0fffff, S2_DDR40_WL_IDLE_PAD_CTL);
+	udelay(500);
+
+	FTHD_S2_REG_WRITE(0, S2_DDR_2004);
+	udelay(10000);
+
+	FTHD_S2_REG_WRITE(0xab0a, S2_DDR_2014);
+
+	/* Polling for BUSY */
+	ret = fthd_hw_ddr_status_busy(dev_priv, 10000, 10);
+	if (ret != 0)
+		return -EBUSY;
+
+	udelay(10000);
+
+	FTHD_S2_REG_WRITE(0, S2_3204);
+
+	/* Read DRAM mem address (FIXME: Need to mask a few bits here) */
+	reg = FTHD_S2_REG_READ(S2_DDR40_STRAP_STATUS);
+	dev_info(&dev_priv->pdev->dev,
+		 "S2 DRAM memory address: 0x%08x\n", reg);
+
+	switch (dev_priv->ddr_model) {
+	case 4:
+		val = 0x1fffffff;
+		break;
+	case 2:
+		val = 0x0fffffff;
+		break;
+	default:
+		/* Probably just invalid model */
+		val = dev_priv->ddr_model;
+	}
+
+	FTHD_S2_REG_WRITE(val, S2_3208);
+	FTHD_S2_REG_WRITE(0x1040, S2_3200);
+
+	fthd_hw_ddr_rewrite_mode_regs(dev_priv);
+
+	FTHD_S2_REG_WRITE(0x20000, S2_DDR_2014);
+	FTHD_S2_REG_WRITE(1, S2_DDR_2008);
+
+	return 0;
+}
+
+void fthd_ddr_phy_save_regs(struct fthd_private *dev_priv)
+{
+	u32 offset;
+	int i;
+
+	for (i = 0; i < DDR_PHY_NUM_REG; i++) {
+		offset = fthd_ddr_phy_reg_map[i];
+		dev_priv->ddr_phy_regs[i] =
+			FTHD_ISP_REG_READ(DDR_PHY_REG_BASE + offset);
+	}
+}
+
+void fthd_ddr_phy_restore_regs(struct fthd_private *dev_priv)
+{
+	u32 offset;
+	int i;
+
+	for (i = 0; i < DDR_PHY_NUM_REG; i++) {
+		offset = fthd_ddr_phy_reg_map[i];
+		FTHD_S2_REG_WRITE(dev_priv->ddr_phy_regs[i],
+				  DDR_PHY_REG_BASE + offset);
+	}
+}
+
+int fthd_irq_enable(struct fthd_private *dev_priv)
+{
+	FTHD_ISP_REG_WRITE(0xf8, ISP_IRQ_ENABLE);
+	pci_write_config_dword(dev_priv->pdev, 0x94, 0x200);
+
+	return 0;
+}
+
+int fthd_irq_disable(struct fthd_private *dev_priv)
+{
+	FTHD_ISP_REG_WRITE(0, ISP_IRQ_ENABLE);
+	pci_write_config_dword(dev_priv->pdev, 0x94, 0x0);
+
+	return 0;
+}
+
+int fthd_hw_init(struct fthd_private *dev_priv)
+{
+	int ret;
+
+	ret = fthd_hw_s2_init_pcie_link(dev_priv);
+	if (ret)
+		goto out;
+
+	fthd_hw_s2_preinit_ddr_controller_soc(dev_priv);
+	fthd_hw_s2_init_ddr_controller_soc(dev_priv);
+
+/*
+	dev_info(&dev_priv->pdev->dev,
+		 "Dumping DDR PHY reg map before shmoo\n");
+
+	for (i = 0; i < DDR_PHY_NUM_REGS; i++) {
+		if (!(i % 3) && i >  0)
+			printk("\n");
+
+		val = FTHD_S2_REG_READ(ddr_phy_reg_map[i]);
+		printk(KERN_CONT "0x%.3x = 0x%.8x\t",
+			 ddr_phy_reg_map[i], val);
+	}
+*/
+
+	ret = fthd_ddr_verify_mem(dev_priv, 0, MEM_VERIFY_NUM);
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev,
+			"Full memory verification failed! (%d)\n", ret);
+		/*
+		 * Here we should do a shmoo calibration but it's not yet
+		 * fully implemented.
+		 */
+
+		/* fthd_ddr_calibrate(dev_priv); */
+	} else {
+		dev_info(&dev_priv->pdev->dev,
+			 "Full memory verification succeeded! (%d)\n", ret);
+	}
+
+	/* Save our working configuration */
+	fthd_ddr_phy_save_regs(dev_priv);
+
+	FTHD_S2_REG_WRITE(0x8, S2_D108);
+	FTHD_S2_REG_WRITE(0xc, S2_D104);
+
+	FTHD_ISP_REG_WRITE(0, ISP_REG_40004);
+
+	ret = isp_init(dev_priv);
+	if (ret)
+	    goto out;
+
+	dev_info(&dev_priv->pdev->dev, "Enabling interrupts\n");
+	fthd_irq_enable(dev_priv);
+out:
+	return ret;
+}
+
+void fthd_hw_deinit(struct fthd_private *dev_priv)
+{
+	dev_info(&dev_priv->pdev->dev, "%s", __FUNCTION__);
+	FTHD_ISP_REG_WRITE(0, ISP_REG_41020);
+	fthd_irq_disable(dev_priv);
+}
diff --git a/drivers/custom/facetimehd/fthd_hw.h b/drivers/custom/facetimehd/fthd_hw.h
new file mode 100644
index 000000000000..58d802488f67
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_hw.h
@@ -0,0 +1,128 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#ifndef _FTHD_HW_H
+#define _FTHD_HW_H
+
+#include <linux/pci.h>
+
+/* Used after most PCI Link IO writes */
+static inline void fthd_hw_pci_post(struct fthd_private *dev_priv)
+{
+	pci_write_config_dword(dev_priv->pdev, 0, 0x12345678);
+}
+
+#define FTHD_S2_REG_READ(offset) _FTHD_S2_REG_READ(dev_priv, (offset))
+#define FTHD_S2_REG_WRITE(val, offset) _FTHD_S2_REG_WRITE(dev_priv, (val), (offset))
+
+#define FTHD_S2_MEM_READ(offset) _FTHD_S2_MEM_READ(dev_priv, (offset))
+#define FTHD_S2_MEM_WRITE(val, offset) _FTHD_S2_MEM_WRITE(dev_priv, (val), (offset))
+#define FTHD_S2_MEMCPY_TOIO(offset, buf, len) _FTHD_S2_MEMCPY_TOIO(dev_priv, (buf), (offset), (len))
+#define FTHD_S2_MEMCPY_FROMIO(buf, offset, len) _FTHD_S2_MEMCPY_FROMIO(dev_priv, (buf), (offset), (len))
+
+#define FTHD_ISP_REG_READ(offset) _FTHD_ISP_REG_READ(dev_priv, (offset))
+#define FTHD_ISP_REG_WRITE(val, offset) _FTHD_ISP_REG_WRITE(dev_priv, (val), (offset))
+
+static inline u32 _FTHD_S2_REG_READ(struct fthd_private *dev_priv, u32 offset)
+{
+	if (offset >= dev_priv->s2_io_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"S2 IO read out of range at %u\n", offset);
+		return 0;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "Link IO read at %u\n", offset);
+	return ioread32(dev_priv->s2_io + offset);
+}
+
+static inline void _FTHD_S2_REG_WRITE(struct fthd_private *dev_priv, u32 val,
+				      u32 offset)
+{
+	if (offset >= dev_priv->s2_io_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"S2 IO write out of range at %u\n", offset);
+		return;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "S2 IO write at %u\n", offset);
+	iowrite32(val, dev_priv->s2_io + offset);
+	fthd_hw_pci_post(dev_priv);
+}
+
+static inline u32 _FTHD_S2_MEM_READ(struct fthd_private *dev_priv, u32 offset)
+{
+	if (offset >= dev_priv->s2_mem_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"S2 MEM read out of range at %u\n", offset);
+		return 0;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "Link IO read at %u\n", offset);
+	return ioread32(dev_priv->s2_mem + offset);
+}
+
+static inline void _FTHD_S2_MEM_WRITE(struct fthd_private *dev_priv, u32 val,
+				      u32 offset)
+{
+	if (offset >= dev_priv->s2_mem_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"S2 MEM write out of range at %u\n", offset);
+		return;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "S2 IO write at %u\n", offset);
+	iowrite32(val, dev_priv->s2_mem + offset);
+}
+
+static inline void _FTHD_S2_MEMCPY_TOIO(struct fthd_private *dev_priv, const void *buf,
+					u32 offset, int len)
+{
+	memcpy_toio(dev_priv->s2_mem + offset, buf, len);
+}
+
+
+static inline void _FTHD_S2_MEMCPY_FROMIO(struct fthd_private *dev_priv, void *buf,
+					  u32 offset, int len)
+{
+	memcpy_fromio(buf, dev_priv->s2_mem + offset, len);
+}
+
+static inline u32 _FTHD_ISP_REG_READ(struct fthd_private *dev_priv, u32 offset)
+{
+	if (offset >= dev_priv->isp_io_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"ISP IO read out of range at %u\n", offset);
+		return 0;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "ISP IO read at %u\n", offset);
+	return ioread32(dev_priv->isp_io + offset);
+}
+
+static inline void _FTHD_ISP_REG_WRITE(struct fthd_private *dev_priv, u32 val,
+				       u32 offset)
+{
+	if (offset >= dev_priv->isp_io_len) {
+		dev_err(&dev_priv->pdev->dev,
+			"ISP IO write out of range at %u\n", offset);
+		return;
+	}
+
+	// dev_info(&dev_priv->pdev->dev, "Dev IO write at %u\n", offset);
+	iowrite32(val, dev_priv->isp_io + offset);
+	fthd_hw_pci_post(dev_priv);
+}
+
+extern int fthd_irq_enable(struct fthd_private *dev_priv);
+extern int fthd_irq_disable(struct fthd_private *dev_priv);
+extern int fthd_hw_init(struct fthd_private *dev_priv);
+extern void fthd_hw_deinit(struct fthd_private *priv);
+extern void fthd_ddr_phy_save_regs(struct fthd_private *dev_priv);
+extern void fthd_ddr_phy_restore_regs(struct fthd_private *dev_priv);
+#endif
diff --git a/drivers/custom/facetimehd/fthd_isp.c b/drivers/custom/facetimehd/fthd_isp.c
new file mode 100644
index 000000000000..f8dbd2dd9d1c
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_isp.c
@@ -0,0 +1,1433 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <linux/firmware.h>
+#include <linux/dmi.h>
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_reg.h"
+#include "fthd_ringbuf.h"
+#include "fthd_isp.h"
+
+int isp_mem_init(struct fthd_private *dev_priv)
+{
+	struct resource *root = &dev_priv->pdev->resource[FTHD_PCI_S2_MEM];
+
+        dev_priv->mem = kzalloc(sizeof(struct resource), GFP_KERNEL);
+	if (!dev_priv->mem)
+	    return -ENOMEM;
+
+	dev_priv->mem->start = root->start;
+	dev_priv->mem->end = root->end;
+
+	/* Preallocate 8mb for the firmware */
+	dev_priv->firmware = isp_mem_create(dev_priv, FTHD_MEM_FIRMWARE,
+					    FTHD_MEM_FW_SIZE);
+
+	if (!dev_priv->firmware) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to preallocate firmware memory\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+struct isp_mem_obj *isp_mem_create(struct fthd_private *dev_priv,
+				   unsigned int type, resource_size_t size)
+{
+	struct isp_mem_obj *obj;
+	struct resource *root = dev_priv->mem;
+	int ret;
+
+	obj = kzalloc(sizeof(struct isp_mem_obj), GFP_KERNEL);
+	if (!obj)
+		return NULL;
+
+	obj->type = type;
+	obj->base.name = "S2 ISP";
+	ret = allocate_resource(root, &obj->base, size, root->start, root->end,
+				PAGE_SIZE, NULL, NULL);
+	if (ret) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to allocate resource (size: %Ld, start: %Ld, end: %Ld)\n",
+			size, root->start, root->end);
+		kfree(obj);
+		obj = NULL;
+	}
+
+	obj->offset = obj->base.start - root->start;
+	obj->size = size;
+	obj->size_aligned = obj->base.end - obj->base.start;
+	return obj;
+}
+
+int isp_mem_destroy(struct isp_mem_obj *obj)
+{
+	if (obj) {
+		release_resource(&obj->base);
+		kfree(obj);
+		obj = NULL;
+	}
+
+	return 0;
+}
+
+static int isp_acpi_set_power(struct fthd_private *dev_priv, int power)
+{
+	acpi_status status;
+	acpi_handle handle;
+	struct acpi_object_list arg_list;
+	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	union acpi_object args[1];
+	union acpi_object *result;
+	int ret = 0;
+
+
+	handle = ACPI_HANDLE(&dev_priv->pdev->dev);
+	if(!handle) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to get S2 CMPE ACPI handle\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	args[0].type = ACPI_TYPE_INTEGER;
+	args[0].integer.value = power;
+
+	arg_list.count = 1;
+	arg_list.pointer = args;
+
+	status = acpi_evaluate_object(handle, "CMPE", &arg_list, &buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_err(&dev_priv->pdev->dev,
+			"Failed to execute S2 CMPE ACPI method\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	result = buffer.pointer;
+
+	if (result->type != ACPI_TYPE_INTEGER || result->integer.value != 0) {
+		dev_err(&dev_priv->pdev->dev,
+			"Invalid ACPI response (len: %Ld)\n", buffer.length);
+		ret = -EINVAL;
+	}
+
+out:
+	kfree(buffer.pointer);
+	return ret;
+}
+
+static int isp_enable_sensor(struct fthd_private *dev_priv)
+{
+	return 0;
+}
+
+static int isp_load_firmware(struct fthd_private *dev_priv)
+{
+	const struct firmware *fw;
+	int ret = 0;
+
+	ret = request_firmware(&fw, "facetimehd/firmware.bin", &dev_priv->pdev->dev);
+	if (ret)
+		return ret;
+
+	/* Firmware memory is preallocated at init time */
+	if (!dev_priv->firmware)
+		return -ENOMEM;
+
+	if (dev_priv->firmware->base.start != dev_priv->mem->start) {
+		dev_err(&dev_priv->pdev->dev,
+			"Misaligned firmware memory object (offset: %lu)\n",
+			dev_priv->firmware->offset);
+		isp_mem_destroy(dev_priv->firmware);
+		dev_priv->firmware = NULL;
+		return -EBUSY;
+	}
+
+	FTHD_S2_MEMCPY_TOIO(dev_priv->firmware->offset, fw->data, fw->size);
+
+	/* Might need a flush here if we map ISP memory cached */
+
+	dev_info(&dev_priv->pdev->dev, "Loaded firmware, size: %lukb\n",
+		 fw->size / 1024);
+
+	release_firmware(fw);
+
+	return ret;
+}
+
+static void isp_free_channel_info(struct fthd_private *priv)
+{
+	struct fw_channel *chan;
+	int i;
+	for(i = 0; i < priv->num_channels; i++) {
+		chan = priv->channels[i];
+		if (!chan)
+			continue;
+
+		kfree(chan->name);
+		kfree(chan);
+		priv->channels[i] = NULL;
+	}
+	kfree(priv->channels);
+	priv->channels = NULL;
+}
+
+static struct fw_channel *isp_get_chan_index(struct fthd_private *priv, const char *name)
+{
+	int i;
+	for(i = 0; i < priv->num_channels; i++) {
+		if (!strcasecmp(priv->channels[i]->name, name))
+			return priv->channels[i];
+	}
+	return NULL;
+}
+
+static int isp_fill_channel_info(struct fthd_private *dev_priv, int offset, int num_channels)
+{
+	struct isp_channel_info info;
+	struct fw_channel *chan;
+	int i;
+
+	if (!num_channels)
+		return -EINVAL;
+
+	dev_priv->channels = kzalloc(num_channels * sizeof(struct fw_channel *), GFP_KERNEL);
+	if (!dev_priv->channels)
+		goto out;
+
+	dev_priv->num_channels = num_channels;
+
+	for(i = 0; i < num_channels; i++) {
+		FTHD_S2_MEMCPY_FROMIO(&info, offset + i * 256, sizeof(info));
+
+		chan = kzalloc(sizeof(struct fw_channel), GFP_KERNEL);
+		if (!chan)
+			goto out;
+
+		dev_priv->channels[i] = chan;
+
+		pr_debug("Channel %d: %s, type %d, source %d, size %d, offset %x\n",
+			 i, info.name, info.type, info.source, info.size, info.offset);
+
+		chan->name = kstrdup(info.name, GFP_KERNEL);
+		if (!chan->name)
+			goto out;
+
+		chan->type = info.type;
+		chan->source = info.source;
+		chan->size = info.size;
+		chan->offset = info.offset;
+		spin_lock_init(&chan->lock);
+		init_waitqueue_head(&chan->wq);
+	}
+
+	dev_priv->channel_terminal = isp_get_chan_index(dev_priv, "TERMINAL");
+	dev_priv->channel_debug = isp_get_chan_index(dev_priv, "DEBUG");
+	dev_priv->channel_shared_malloc = isp_get_chan_index(dev_priv, "SHAREDMALLOC");
+	dev_priv->channel_io = isp_get_chan_index(dev_priv, "IO");
+	dev_priv->channel_buf_h2t = isp_get_chan_index(dev_priv, "BUF_H2T");
+	dev_priv->channel_buf_t2h = isp_get_chan_index(dev_priv, "BUF_T2H");
+	dev_priv->channel_io_t2h = isp_get_chan_index(dev_priv, "IO_T2H");
+
+	if (!dev_priv->channel_terminal || !dev_priv->channel_debug
+	    || !dev_priv->channel_shared_malloc || !dev_priv->channel_io
+	    || !dev_priv->channel_buf_h2t || !dev_priv->channel_buf_t2h
+	    || !dev_priv->channel_io_t2h) {
+		dev_err(&dev_priv->pdev->dev, "did not find all of the required channels\n");
+		goto out;
+	}
+	return 0;
+out:
+	isp_free_channel_info(dev_priv);
+	return -ENOMEM;
+}
+
+static int fthd_isp_cmd(struct fthd_private *dev_priv, enum fthd_isp_cmds command, void *buf,
+			int request_len, int *response_len)
+{
+	struct isp_mem_obj *request;
+	struct isp_cmd_hdr cmd;
+	u32 address, request_size, response_size;
+	u32 entry;
+	int len, ret;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (response_len) {
+		len = max(request_len, *response_len);
+	} else {
+		len = request_len;
+	}
+	len += sizeof(struct isp_cmd_hdr);
+
+	pr_debug("sending cmd %d to firmware\n", command);
+
+	request = isp_mem_create(dev_priv, FTHD_MEM_CMD, len);
+	if (!request) {
+		dev_err(&dev_priv->pdev->dev, "failed to allocate cmd memory object\n");
+		return -ENOMEM;
+	}
+
+	cmd.opcode = command;
+
+	FTHD_S2_MEMCPY_TOIO(request->offset, &cmd, sizeof(struct isp_cmd_hdr));
+	if (request_len)
+		FTHD_S2_MEMCPY_TOIO(request->offset + sizeof(struct isp_cmd_hdr), buf, request_len);
+
+	ret = fthd_channel_ringbuf_send(dev_priv, dev_priv->channel_io,
+					  request->offset, request_len + 8, (response_len ? *response_len : 0) + 8, &entry);
+	if (ret)
+		goto out;
+
+	if (entry == (u32)-1) {
+		ret = -EIO;
+		goto out;
+	}
+
+	if (command == CISP_CMD_POWER_DOWN) {
+		/* powerdown doesn't seem to generate a response */
+		ret = 0;
+		goto out;
+	}
+
+        ret = fthd_channel_wait_ready(dev_priv, dev_priv->channel_io, entry, 2000);
+	if (ret) {
+		if (response_len)
+			*response_len = 0;
+		goto out;
+	}
+
+	FTHD_S2_MEMCPY_FROMIO(&cmd, request->offset, sizeof(struct isp_cmd_hdr));
+	address = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS);
+	request_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE);
+	response_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE);
+
+	/* XXX: response size in the ringbuf is zero after command completion, how is buffer size
+	        verification done? */
+	if (response_len && *response_len)
+		FTHD_S2_MEMCPY_FROMIO(buf, (address & ~3) + sizeof(struct isp_cmd_hdr),
+				     *response_len);
+
+	pr_debug("status %04x, request_len %d response len %d address_flags %x\n", cmd.status,
+		request_size, response_size, address);
+
+	ret = cmd.status ? -EIO : 0;
+out:
+	isp_mem_destroy(request);
+	return ret;
+}
+
+int fthd_isp_debug_cmd(struct fthd_private *dev_priv, enum fthd_isp_cmds command, void *buf,
+			int request_len, int *response_len)
+{
+	struct isp_mem_obj *request;
+	struct isp_cmd_hdr cmd;
+	u32 address, request_size, response_size;
+	u32 entry;
+	int len, ret;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (response_len) {
+		len = max(request_len, *response_len);
+	} else {
+		len = request_len;
+	}
+	len += sizeof(struct isp_cmd_hdr);
+
+	pr_debug("sending debug cmd %d to firmware\n", command);
+
+	request = isp_mem_create(dev_priv, FTHD_MEM_CMD, len);
+	if (!request) {
+		dev_err(&dev_priv->pdev->dev, "failed to allocate cmd memory object\n");
+		return -ENOMEM;
+	}
+
+	cmd.opcode = command;
+
+	FTHD_S2_MEMCPY_TOIO(request->offset, &cmd, sizeof(struct isp_cmd_hdr));
+	if (request_len)
+		FTHD_S2_MEMCPY_TOIO(request->offset + sizeof(struct isp_cmd_hdr), buf, request_len);
+
+	ret = fthd_channel_ringbuf_send(dev_priv, dev_priv->channel_debug,
+					  request->offset, request_len + 8, (response_len ? *response_len : 0) + 8, &entry);
+	if (ret)
+		goto out;
+
+	if (entry == (u32)-1) {
+		ret = -EIO;
+		goto out;
+	}
+
+        ret = fthd_channel_wait_ready(dev_priv, dev_priv->channel_debug, entry, 20000);
+	if (ret) {
+		if (response_len)
+			*response_len = 0;
+		goto out;
+	}
+
+	FTHD_S2_MEMCPY_FROMIO(&cmd, request->offset, sizeof(struct isp_cmd_hdr));
+	address = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS);
+	request_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE);
+	response_size = FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE);
+
+	/* XXX: response size in the ringbuf is zero after command completion, how is buffer size
+	        verification done? */
+	if (response_len && *response_len)
+		FTHD_S2_MEMCPY_FROMIO(buf, (address & ~3) + sizeof(struct isp_cmd_hdr),
+				     *response_len);
+
+	pr_info("status %04x, request_len %d response len %d address_flags %x\n", cmd.status,
+		request_size, response_size, address);
+
+	ret = 0;
+out:
+	isp_mem_destroy(request);
+	return ret;
+}
+
+
+
+int fthd_isp_cmd_start(struct fthd_private *dev_priv)
+{
+	pr_debug("sending start cmd to firmware\n");
+	return fthd_isp_cmd(dev_priv, CISP_CMD_START, NULL, 0, NULL);
+}
+
+int fthd_isp_cmd_channel_start(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_channel_start cmd;
+	pr_debug("sending channel start cmd to firmware\n");
+
+	cmd.channel = 0;
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_START, &cmd, sizeof(cmd), NULL);
+}
+
+int fthd_isp_cmd_channel_stop(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_channel_stop cmd;
+
+	cmd.channel = 0;
+	pr_debug("sending channel stop cmd to firmware\n");
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_STOP, &cmd, sizeof(cmd), NULL);
+}
+
+int fthd_isp_cmd_stop(struct fthd_private *dev_priv)
+{
+	return fthd_isp_cmd(dev_priv, CISP_CMD_STOP, NULL, 0, NULL);
+}
+
+static int fthd_isp_cmd_powerdown(struct fthd_private *dev_priv)
+{
+	return fthd_isp_cmd(dev_priv, CISP_CMD_POWER_DOWN, NULL, 0, NULL);
+}
+
+static void isp_free_set_file(struct fthd_private *dev_priv)
+{
+	if (dev_priv->set_file)
+		isp_mem_destroy(dev_priv->set_file);
+}
+
+int isp_powerdown(struct fthd_private *dev_priv)
+{
+	int retries;
+	u32 reg;
+
+	FTHD_ISP_REG_WRITE(0xf7fbdff9, 0xc3000);
+	fthd_isp_cmd_powerdown(dev_priv);
+
+	for (retries = 0; retries < 100; retries++) {
+		reg = FTHD_ISP_REG_READ(0xc3000);
+		if (reg == 0x8042006)
+			break;
+		mdelay(10);
+	}
+
+	if (retries >= 100) {
+		dev_info(&dev_priv->pdev->dev, "deinit failed!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int isp_uninit(struct fthd_private *dev_priv)
+{
+	FTHD_ISP_REG_WRITE(0x00000000, 0x40004);
+	FTHD_ISP_REG_WRITE(0x00000000, ISP_IRQ_ENABLE);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc0008);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc000c);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc0010);
+	FTHD_ISP_REG_WRITE(0x00000000, 0xc1004);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc100c);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc1014);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc101c);
+	FTHD_ISP_REG_WRITE(0xffffffff, 0xc1024);
+	mdelay(1);
+
+	FTHD_ISP_REG_WRITE(0, 0xc0000);
+	FTHD_ISP_REG_WRITE(0, 0xc0004);
+	FTHD_ISP_REG_WRITE(0, 0xc0008);
+	FTHD_ISP_REG_WRITE(0, 0xc000c);
+	FTHD_ISP_REG_WRITE(0, 0xc0010);
+	FTHD_ISP_REG_WRITE(0, 0xc0014);
+	FTHD_ISP_REG_WRITE(0, 0xc0018);
+	FTHD_ISP_REG_WRITE(0, 0xc001c);
+	FTHD_ISP_REG_WRITE(0, 0xc0020);
+	FTHD_ISP_REG_WRITE(0, 0xc0024);
+
+	FTHD_ISP_REG_WRITE(0xffffffff, ISP_IRQ_CLEAR);
+	isp_free_channel_info(dev_priv);
+	isp_free_set_file(dev_priv);
+	isp_mem_destroy(dev_priv->firmware);
+	kfree(dev_priv->mem);
+	return 0;
+}
+
+
+int fthd_isp_cmd_print_enable(struct fthd_private *dev_priv, int enable)
+{
+	struct isp_cmd_print_enable cmd;
+
+	cmd.enable = enable;
+
+	return fthd_isp_cmd(dev_priv, CISP_CMD_PRINT_ENABLE, &cmd, sizeof(cmd), NULL);
+}
+
+int fthd_isp_cmd_set_loadfile(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_set_loadfile cmd;
+	struct isp_mem_obj *file;
+	const struct firmware *fw;
+	const char *filename = NULL;
+	const char *vendor, *board;
+	int ret = 0;
+
+	pr_debug("set loadfile\n");
+
+	vendor = dmi_get_system_info(DMI_BOARD_VENDOR);
+	board = dmi_get_system_info(DMI_BOARD_NAME);
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	switch(dev_priv->sensor_id1) {
+	case 0x164:
+		filename = "facetimehd/8221_01XX.dat";
+		break;
+	case 0x190:
+		filename = "facetimehd/1222_01XX.dat";
+		break;
+	case 0x8830:
+		filename = "facetimehd/9112_01XX.dat";
+		break;
+	case 0x9770:
+		if (vendor && board && !strcmp(vendor, "Apple Inc.") &&
+		    !strncmp(board, "MacBookAir", sizeof("MacBookAir")-1)) {
+			filename = "facetimehd/1771_01XX.dat";
+			break;
+		}
+
+		switch(dev_priv->sensor_id0) {
+		case 4:
+			filename = "facetimehd/1874_01XX.dat";
+			break;
+		default:
+			filename = "facetimehd/1871_01XX.dat";
+			break;
+		}
+		break;
+	case 0x9774:
+		switch(dev_priv->sensor_id0) {
+		case 4:
+			filename = "facetimehd/1674_01XX.dat";
+			break;
+		case 5:
+			filename = "facetimehd/1675_01XX.dat";
+			break;
+		default:
+			filename = "facetimehd/1671_01XX.dat";
+			break;
+		}
+		break;
+	default:
+		break;
+
+	}
+
+	if (!filename) {
+		pr_debug("no set file for sensorid %04x %04x found\n",
+			 dev_priv->sensor_id0, dev_priv->sensor_id1);
+		return 0;
+	}
+
+	/* The set file is allowed to be missing but we don't get calibration */
+	ret = request_firmware(&fw, filename, &dev_priv->pdev->dev);
+	if (ret)
+		return 0;
+
+	/* Firmware memory is preallocated at init time */
+	BUG_ON(dev_priv->set_file);
+
+	file = isp_mem_create(dev_priv, FTHD_MEM_SET_FILE, fw->size);
+	FTHD_S2_MEMCPY_TOIO(file->offset, fw->data, fw->size);
+
+	release_firmware(fw);
+
+	dev_priv->set_file = file;
+	pr_debug("set file: addr %08lx, size %d\n", file->offset, (int)file->size);
+	cmd.addr = file->offset;
+	cmd.length = file->size;
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SET_FILE_LOAD, &cmd, sizeof(cmd), NULL);
+}
+
+int fthd_isp_cmd_channel_info(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_channel_info cmd;
+	int ret, len;
+
+	pr_debug("sending ch info\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	len = sizeof(cmd);
+	ret = fthd_isp_cmd(dev_priv, CISP_CMD_CH_INFO_GET, &cmd, sizeof(cmd), &len);
+	print_hex_dump_bytes("CHINFO ", DUMP_PREFIX_OFFSET, &cmd, sizeof(cmd));
+	pr_debug("sensor id: %04x %04x\n", cmd.sensorid0, cmd.sensorid1);
+	pr_debug("sensor count: %d\n", cmd.sensor_count);
+	pr_debug("camera module serial number string: %s\n", cmd.camera_module_serial_number);
+	pr_debug("sensor serial number: %02X%02X%02X%02X%02X%02X%02X%02X\n",
+		 cmd.sensor_serial_number[0], cmd.sensor_serial_number[1],
+		 cmd.sensor_serial_number[2], cmd.sensor_serial_number[3],
+		 cmd.sensor_serial_number[4], cmd.sensor_serial_number[5],
+		 cmd.sensor_serial_number[6], cmd.sensor_serial_number[7]);
+	dev_priv->sensor_id0 = cmd.sensorid0;
+	dev_priv->sensor_id1 = cmd.sensorid1;
+	dev_priv->sensor_count = cmd.sensor_count;
+	return ret;
+}
+
+int fthd_isp_cmd_camera_config(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_config cmd;
+	int ret, len;
+
+	pr_debug("sending camera config\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	len = sizeof(cmd);
+	ret = fthd_isp_cmd(dev_priv, CISP_CMD_CONFIG_GET, &cmd, sizeof(cmd), &len);
+	if (!ret)
+		print_hex_dump_bytes("CAMINFO ", DUMP_PREFIX_OFFSET, &cmd, sizeof(cmd));
+	return ret;
+}
+
+int fthd_isp_cmd_channel_camera_config(struct fthd_private *dev_priv)
+{
+	struct isp_cmd_channel_camera_config cmd;
+	int ret, len, i;
+	char prefix[16];
+	pr_debug("sending ch camera config\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	for(i = 0; i < dev_priv->sensor_count; i++) {
+		cmd.channel = i;
+
+		len = sizeof(cmd);
+		ret = fthd_isp_cmd(dev_priv, CISP_CMD_CH_CAMERA_CONFIG_GET, &cmd, sizeof(cmd), &len);
+		if (ret)
+			break;
+		snprintf(prefix, sizeof(prefix)-1, "CAMCONF%d ", i);
+		print_hex_dump_bytes(prefix, DUMP_PREFIX_OFFSET, &cmd, sizeof(cmd));
+	}
+	return ret;
+}
+
+int fthd_isp_cmd_channel_camera_config_select(struct fthd_private *dev_priv, int channel, int config)
+{
+	struct isp_cmd_channel_camera_config_select cmd;
+	int len;
+
+	pr_debug("set camera config: %d\n", config);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.config = config;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_CAMERA_CONFIG_SELECT, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_crop_set(struct fthd_private *dev_priv, int channel,
+				  int x1, int y1, int x2, int y2)
+{
+	struct isp_cmd_channel_set_crop cmd;
+	int len;
+
+	pr_debug("set crop: [%d, %d] -> [%d, %d]\n", x1, y1, x2, y2);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.x1 = x1;
+	cmd.y2 = y2;
+	cmd.x2 = x2;
+	cmd.y2 = y2;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_CROP_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_output_config_set(struct fthd_private *dev_priv, int channel, int x, int y, int pixelformat)
+{
+	struct isp_cmd_channel_output_config cmd;
+	int len;
+
+	pr_debug("output config: [%d, %d]\n", x, y);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.x1 = x; /* Y size */
+	cmd.x2 = x * 2; /* Chroma size? */
+	cmd.x3 = x;
+	cmd.y1 = y;
+
+	/* pixel formats:
+	 * 0 - plane 0 Y plane 1 UV
+	   1 - YUYV
+	   2 - YVYU
+	*/
+	cmd.pixelformat = pixelformat;
+	cmd.unknown3 = 0;
+	cmd.unknown5 = 0x7ff;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_OUTPUT_CONFIG_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_recycle_mode(struct fthd_private *dev_priv, int channel, int mode)
+{
+	struct isp_cmd_channel_recycle_mode cmd;
+	int len;
+
+	pr_debug("set recycle mode %d\n", mode);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.mode = mode;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_BUFFER_RECYCLE_MODE_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_buffer_return(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_buffer_return cmd;
+	int len;
+
+	pr_debug("buffer return\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_BUFFER_RETURN, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_recycle_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_recycle_mode cmd;
+	int len;
+
+	pr_debug("start recycle\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_BUFFER_RECYCLE_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_drc_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_drc_start cmd;
+	int len;
+
+	pr_debug("start drc\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_DRC_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_tone_curve_adaptation_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_tone_curve_adaptation_start cmd;
+	int len;
+
+	pr_debug("tone curve adaptation start\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_TONE_CURVE_ADAPTATION_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_sif_pixel_format(struct fthd_private *dev_priv, int channel, int param1, int param2)
+{
+	struct isp_cmd_channel_sif_format_set cmd;
+	int len;
+
+	pr_debug("set pixel format %d, %d\n", param1, param2);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.param1 = param1;
+	cmd.param2 = param2;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SIF_PIXEL_FORMAT_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_error_handling_config(struct fthd_private *dev_priv, int channel, int param1, int param2)
+{
+	struct isp_cmd_channel_camera_err_handle_config cmd;
+	int len;
+
+	pr_debug("set error handling config %d, %d\n", param1, param2);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.param1 = param1;
+	cmd.param2 = param2;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_CAMERA_ERR_HANDLE_CONFIG, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_streaming_mode(struct fthd_private *dev_priv, int channel, int mode)
+{
+	struct isp_cmd_channel_streaming_mode cmd;
+	int len;
+
+	pr_debug("set streaming mode %d\n", mode);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.mode = mode;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_STREAMING_MODE_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_frame_rate_min(struct fthd_private *dev_priv, int channel, int rate)
+{
+	struct isp_cmd_channel_frame_rate_set cmd;
+	int len;
+
+	pr_debug("set ae frame rate min %d\n", rate);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.rate = rate;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_AE_FRAME_RATE_MIN_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_frame_rate_max(struct fthd_private *dev_priv, int channel, int rate)
+{
+	struct isp_cmd_channel_frame_rate_set cmd;
+	int len;
+
+	pr_debug("set ae frame rate max %d\n", rate);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.rate = rate;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_AE_FRAME_RATE_MAX_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_ae_speed_set(struct fthd_private *dev_priv, int channel, int speed)
+{
+	struct isp_cmd_channel_ae_speed_set cmd;
+	int len;
+
+	pr_debug("set ae speed %d\n", speed);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.speed = speed;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_AE_SPEED_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_ae_stability_set(struct fthd_private *dev_priv, int channel, int stability)
+{
+	struct isp_cmd_channel_ae_stability_set cmd;
+	int len;
+
+	pr_debug("set ae stability %d\n", stability);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.stability = stability;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_AE_STABILITY_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_ae_stability_to_stable_set(struct fthd_private *dev_priv, int channel, int value)
+{
+	struct isp_cmd_channel_ae_stability_to_stable_set cmd;
+	int len;
+
+	pr_debug("set ae stability to stable %d\n", value);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.value = value;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_AE_STABILITY_TO_STABLE_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_face_detection_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_face_detection_start cmd;
+	int len;
+
+	pr_debug("face detection start\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_FACE_DETECTION_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_face_detection_stop(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_face_detection_stop cmd;
+	int len;
+
+	pr_debug("face detection stop\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_FACE_DETECTION_STOP, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_face_detection_enable(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_face_detection_enable cmd;
+	int len;
+
+	pr_debug("face detection enable\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_FACE_DETECTION_ENABLE, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_face_detection_disable(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_face_detection_disable cmd;
+	int len;
+
+	pr_debug("face detection disable\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_FACE_DETECTION_DISABLE, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_temporal_filter_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_temporal_filter_start cmd;
+	int len;
+
+	pr_debug("temporal filter start\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_TEMPORAL_FILTER_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_temporal_filter_stop(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_temporal_filter_stop cmd;
+	int len;
+
+	pr_debug("temporal filter stop\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_TEMPORAL_FILTER_STOP, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_temporal_filter_enable(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_temporal_filter_enable cmd;
+	int len;
+
+	pr_debug("temporal filter enable\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_TEMPORAL_FILTER_ENABLE, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_temporal_filter_disable(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_temporal_filter_disable cmd;
+	int len;
+
+	pr_debug("temporal filter disable\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_TEMPORAL_FILTER_DISABLE, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_motion_history_start(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_motion_history_start cmd;
+	int len;
+
+	pr_debug("motion history start\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_MOTION_HISTORY_START, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_motion_history_stop(struct fthd_private *dev_priv, int channel)
+{
+	struct isp_cmd_channel_motion_history_stop cmd;
+	int len;
+
+	pr_debug("motion history stop\n");
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_MOTION_HISTORY_STOP, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_ae_metering_mode_set(struct fthd_private *dev_priv, int channel, int mode)
+{
+	struct isp_cmd_channel_ae_metering_mode_set cmd;
+	int len;
+
+	pr_debug("ae metering mode %d\n", mode);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.mode = mode;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_APPLE_CH_AE_METERING_MODE_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_brightness_set(struct fthd_private *dev_priv, int channel, int brightness)
+{
+	struct isp_cmd_channel_brightness_set cmd;
+	int len;
+
+	pr_debug("set brightness %d\n", brightness);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.brightness = brightness;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SCALER_BRIGHTNESS_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_contrast_set(struct fthd_private *dev_priv, int channel, int contrast)
+{
+	struct isp_cmd_channel_contrast_set cmd;
+	int len;
+
+	pr_debug("set contrast %d\n", contrast);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.contrast = contrast;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SCALER_CONTRAST_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_saturation_set(struct fthd_private *dev_priv, int channel, int saturation)
+{
+	struct isp_cmd_channel_saturation_set cmd;
+	int len;
+
+	pr_debug("set saturation %d\n", saturation);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.contrast = saturation;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SCALER_SATURATION_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_hue_set(struct fthd_private *dev_priv, int channel, int hue)
+{
+	struct isp_cmd_channel_hue_set cmd;
+	int len;
+
+	pr_debug("set hue %d\n", hue);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.channel = channel;
+	cmd.contrast = hue;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, CISP_CMD_CH_SCALER_HUE_SET, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_isp_cmd_channel_awb(struct fthd_private *dev_priv, int channel, int enable)
+{
+	struct isp_cmd_channel cmd;
+	enum fthd_isp_cmds op;
+	int len;
+
+	pr_debug("set awb %s\n", enable ? "on" : "off");
+
+	cmd.channel = channel;
+	op = enable ? CISP_CMD_CH_AWB_START : CISP_CMD_CH_AWB_STOP;
+	len = sizeof(cmd);
+	return fthd_isp_cmd(dev_priv, op, &cmd, sizeof(cmd), &len);
+}
+
+int fthd_start_channel(struct fthd_private *dev_priv, int channel)
+{
+	int ret, x1 = 0, x2 = 0, pixelformat;
+
+	ret = fthd_isp_cmd_channel_camera_config(dev_priv);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_camera_config_select(dev_priv, 0, 0);
+	if (ret)
+		return ret;
+
+	if (dev_priv->fmt.fmt.width < 1280 ||
+	    dev_priv->fmt.fmt.height < 720) {
+		x1 = 160;
+		x2 = 960;
+	} else {
+		x1 = 0;
+		x2 = 1280;
+	}
+
+	ret = fthd_isp_cmd_channel_crop_set(dev_priv, 0, x1, 0, x2, 720);
+	if (ret)
+		return ret;
+
+	switch(dev_priv->fmt.fmt.pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+		pixelformat = 1;
+		break;
+	case V4L2_PIX_FMT_YVYU:
+		pixelformat = 2;
+		break;
+	case V4L2_PIX_FMT_NV16:
+		pixelformat = 0;
+		break;
+	default:
+		pixelformat = 1;
+		WARN_ON(1);
+	}
+	ret = fthd_isp_cmd_channel_output_config_set(dev_priv, 0,
+						     dev_priv->fmt.fmt.width,
+						     dev_priv->fmt.fmt.height,
+						     pixelformat);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_recycle_mode(dev_priv, 0, 1);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_recycle_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_ae_metering_mode_set(dev_priv, 0, 3);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_drc_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_tone_curve_adaptation_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_ae_speed_set(dev_priv, 0, 60);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_ae_stability_set(dev_priv, 0, 75);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_ae_stability_to_stable_set(dev_priv, 0, 8);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_sif_pixel_format(dev_priv, 0, 1, 1);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_error_handling_config(dev_priv, 0, 2, 1);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_face_detection_enable(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_face_detection_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_frame_rate_max(dev_priv, 0, dev_priv->frametime * 256);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_frame_rate_min(dev_priv, 0, dev_priv->frametime * 256);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_temporal_filter_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_motion_history_start(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_temporal_filter_enable(dev_priv, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_streaming_mode(dev_priv, 0, 0);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_brightness_set(dev_priv, 0, 0x80);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_contrast_set(dev_priv, 0, 0x80);
+	if (ret)
+		return ret;
+	ret = fthd_isp_cmd_channel_start(dev_priv);
+	if (ret)
+		return ret;
+	mdelay(1000); /* Needed to settle AE */
+	return 0;
+}
+
+int fthd_stop_channel(struct fthd_private *dev_priv, int channel)
+{
+	int ret;
+
+	ret = fthd_isp_cmd_channel_stop(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_buffer_return(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_face_detection_stop(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_face_detection_disable(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_temporal_filter_disable(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	ret = fthd_isp_cmd_channel_motion_history_stop(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	return fthd_isp_cmd_channel_temporal_filter_stop(dev_priv, 0);
+}
+
+int isp_init(struct fthd_private *dev_priv)
+{
+	struct isp_mem_obj *fw_queue, *heap, *fw_args;
+	struct isp_fw_args fw_args_data;
+	u32 num_channels, queue_size, heap_size, reg, offset;
+	int i, retries, ret;
+
+	ret = isp_mem_init(dev_priv);
+	if (ret)
+		return ret;
+
+	ret = isp_load_firmware(dev_priv);
+	if (ret)
+		return ret;
+
+	isp_acpi_set_power(dev_priv, 1);
+	mdelay(20);
+
+	pci_set_power_state(dev_priv->pdev, PCI_D0);
+	mdelay(10);
+
+	isp_enable_sensor(dev_priv);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_CHAN_CTRL);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_QUEUE_CTRL);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_SIZE);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_HEAP_SIZE);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_HEAP_ADDR);
+	FTHD_ISP_REG_WRITE(0, ISP_FW_HEAP_SIZE2);
+	FTHD_ISP_REG_WRITE(0, ISP_REG_C3018);
+	FTHD_ISP_REG_WRITE(0, ISP_REG_C301C);
+
+	FTHD_ISP_REG_WRITE(0xffffffff, ISP_IRQ_CLEAR);
+
+	/*
+	 * Probably the IPC queue
+	 * FIXME: Check if we can do 64bit writes on PCIe
+	 */
+	for (i = ISP_FW_CHAN_START; i <= ISP_FW_CHAN_END; i += 8) {
+		FTHD_ISP_REG_WRITE(0xffffffff, i);
+		FTHD_ISP_REG_WRITE(0, i + 4);
+	}
+
+	FTHD_ISP_REG_WRITE(0x80000000, ISP_REG_40008);
+	FTHD_ISP_REG_WRITE(0x1, ISP_REG_40004);
+
+	for (retries = 0; retries < 1000; retries++) {
+		reg = FTHD_ISP_REG_READ(ISP_IRQ_STATUS);
+		if ((reg & 0xf0) > 0)
+			break;
+		mdelay(10);
+	}
+
+	if (retries >= 1000) {
+		dev_info(&dev_priv->pdev->dev, "Init failed! No wake signal\n");
+		return -EIO;
+	}
+
+	dev_info(&dev_priv->pdev->dev, "ISP woke up after %dms\n",
+		 (retries - 1) * 10);
+
+	FTHD_ISP_REG_WRITE(0xffffffff, ISP_IRQ_CLEAR);
+
+	num_channels = FTHD_ISP_REG_READ(ISP_FW_CHAN_CTRL);
+	queue_size = FTHD_ISP_REG_READ(ISP_FW_QUEUE_CTRL) + 1;
+
+	dev_info(&dev_priv->pdev->dev,
+		 "Number of IPC channels: %u, queue size: %u\n",
+		 num_channels, queue_size);
+
+	if (num_channels > 32) {
+		dev_info(&dev_priv->pdev->dev, "Too many IPC channels: %u\n",
+			 num_channels);
+		return -EIO;
+	}
+
+	fw_queue = isp_mem_create(dev_priv, FTHD_MEM_FW_QUEUE, queue_size);
+	if (!fw_queue)
+		return -ENOMEM;
+
+	/* Firmware heap max size is 4mb */
+	heap_size = FTHD_ISP_REG_READ(ISP_FW_HEAP_SIZE);
+
+	if (heap_size == 0) {
+		FTHD_ISP_REG_WRITE(0, ISP_FW_CHAN_CTRL);
+		FTHD_ISP_REG_WRITE(fw_queue->offset, ISP_FW_QUEUE_CTRL);
+		FTHD_ISP_REG_WRITE(dev_priv->firmware->size_aligned, ISP_FW_SIZE);
+		FTHD_ISP_REG_WRITE(0x10000000 - dev_priv->firmware->size_aligned,
+				   ISP_FW_HEAP_SIZE);
+		FTHD_ISP_REG_WRITE(0, ISP_FW_HEAP_ADDR);
+		FTHD_ISP_REG_WRITE(0, ISP_FW_HEAP_SIZE2);
+	} else {
+		/* Must be at least 0x1000 bytes */
+		heap_size = (heap_size < 0x1000) ? 0x1000 : heap_size;
+
+		if (heap_size > 0x400000) {
+			dev_info(&dev_priv->pdev->dev,
+				 "Firmware heap request size too big (%ukb)\n",
+				 heap_size / 1024);
+			return -ENOMEM;
+		}
+
+		dev_info(&dev_priv->pdev->dev, "Firmware requested heap size: %ukb\n",
+			 heap_size / 1024);
+
+		heap = isp_mem_create(dev_priv, FTHD_MEM_HEAP, heap_size);
+		if (!heap)
+			return -ENOMEM;
+
+		FTHD_ISP_REG_WRITE(0, ISP_FW_CHAN_CTRL);
+
+		/* Set IPC queue base addr */
+		FTHD_ISP_REG_WRITE(fw_queue->offset, ISP_FW_QUEUE_CTRL);
+
+		FTHD_ISP_REG_WRITE(FTHD_MEM_FW_SIZE, ISP_FW_SIZE);
+
+		FTHD_ISP_REG_WRITE(0x10000000 - FTHD_MEM_FW_SIZE, ISP_FW_HEAP_SIZE);
+
+		FTHD_ISP_REG_WRITE(heap->offset, ISP_FW_HEAP_ADDR);
+
+		FTHD_ISP_REG_WRITE(heap->size, ISP_FW_HEAP_SIZE2);
+
+		/* Set FW args */
+		fw_args = isp_mem_create(dev_priv, FTHD_MEM_FW_ARGS, sizeof(struct isp_fw_args));
+		if (!fw_args)
+			return -ENOMEM;
+
+		fw_args_data.__unknown = 2;
+		fw_args_data.fw_arg = 0;
+		fw_args_data.full_stats_mode = 0;
+
+		FTHD_S2_MEMCPY_TOIO(fw_args->offset, &fw_args_data, sizeof(fw_args_data));
+
+		FTHD_ISP_REG_WRITE(fw_args->offset, ISP_REG_C301C);
+
+		FTHD_ISP_REG_WRITE(0x10, ISP_REG_41020);
+
+		for (retries = 0; retries < 1000; retries++) {
+			reg = FTHD_ISP_REG_READ(ISP_IRQ_STATUS);
+			if ((reg & 0xf0) > 0)
+				break;
+			mdelay(10);
+		}
+
+		if (retries >= 1000) {
+			dev_info(&dev_priv->pdev->dev, "Init failed! No second int\n");
+			return -EIO;
+		} /* FIXME: free on error path */
+
+		dev_info(&dev_priv->pdev->dev, "ISP second int after %dms\n",
+			 (retries - 1) * 10);
+
+		offset = FTHD_ISP_REG_READ(ISP_FW_CHAN_CTRL);
+		dev_info(&dev_priv->pdev->dev, "Channel description table at %08x\n", offset);
+		ret = isp_fill_channel_info(dev_priv, offset, num_channels);
+		if (ret)
+			return ret;
+
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_terminal);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_io);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_debug);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_buf_h2t);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_buf_t2h);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_shared_malloc);
+		fthd_channel_ringbuf_init(dev_priv, dev_priv->channel_io_t2h);
+
+		FTHD_ISP_REG_WRITE(0x8042006, ISP_FW_HEAP_SIZE);
+
+		for (retries = 0; retries < 1000; retries++) {
+			reg = FTHD_ISP_REG_READ(ISP_FW_HEAP_SIZE);
+			if (!reg)
+				break;
+			mdelay(10);
+		}
+
+		if (retries >= 1000) {
+			dev_info(&dev_priv->pdev->dev, "Init failed! No magic value\n");
+			isp_uninit(dev_priv);
+			return -EIO;
+		} /* FIXME: free on error path */
+		dev_info(&dev_priv->pdev->dev, "magic value: %08x after %d ms\n", reg, (retries - 1) * 10);
+	}
+
+	return 0;
+}
diff --git a/drivers/custom/facetimehd/fthd_isp.h b/drivers/custom/facetimehd/fthd_isp.h
new file mode 100644
index 000000000000..b12108f65193
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_isp.h
@@ -0,0 +1,767 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#ifndef _ISP_H
+#define _ISP_H
+
+/* ISP memory types */
+#define FTHD_MEM_FIRMWARE	1
+#define FTHD_MEM_HEAP		2
+#define FTHD_MEM_FW_QUEUE	3
+#define FTHD_MEM_FW_ARGS        4
+#define FTHD_MEM_CMD            5
+#define FTHD_MEM_SHAREDMALLOC   6
+#define FTHD_MEM_SET_FILE       7
+#define FTHD_MEM_BUFFER         8
+
+#define FTHD_MEM_SIZE		0x8000000	/* 128mb */
+#define FTHD_MEM_FW_SIZE	0x800000	/* 8mb */
+
+enum fthd_isp_cmds {
+	CISP_CMD_START = 0x0,
+	CISP_CMD_STOP = 0x1,
+	CISP_CMD_RESET = 0x2,
+	CISP_CMD_CONFIG_GET = 0x3,
+	CISP_CMD_PRINT_ENABLE = 0x4,
+	CISP_CMD_REG_FILE_LOAD = 0x5,
+	CISP_CMD_BUILDINFO = 0x6,
+	CISP_CMD_TIMEPROFILE_START = 0x7,
+	CISP_CMD_TIMEPROFILE_STOP = 0x8,
+	CISP_CMD_TIMEPROFILE_SHOW = 0x9,
+	CISP_CMD_POWER_DOWN = 0xa,
+	CISP_CMD_CH_START = 0x100,
+	CISP_CMD_CH_STOP = 0x101,
+	CISP_CMD_CH_RESET = 0x102,
+	CISP_CMD_CH_STANDBY = 0x103,
+	CISP_CMD_CH_BUFFER_RETURN = 0x104,
+	CISP_CMD_CH_CAMERA_CONFIG_CURRENT_GET = 0x105,
+	CISP_CMD_CH_CAMERA_CONFIG_GET = 0x106,
+	CISP_CMD_CH_CAMERA_CONFIG_SELECT = 0x107,
+	CISP_CMD_CH_RAW_FRAME_PROCESS = 0x108,
+	CISP_CMD_CH_RAW_FRAME_PROCESS_START = 0x109,
+	CISP_CMD_CH_RAW_FRAME_PROCESS_STOP = 0x10a,
+	CISP_CMD_CH_I2C_READ = 0x10b,
+	CISP_CMD_CH_I2C_WRITE = 0x10c,
+	CISP_CMD_CH_INFO_GET = 0x10d,
+	CISP_CMD_CH_BUFFER_RECYCLE_MODE_SET = 0x10e,
+	CISP_CMD_CH_BUFFER_RECYCLE_START = 0x10f,
+	CISP_CMD_CH_BUFFER_RECYCLE_STOP = 0x110,
+	CISP_CMD_CH_SET_FILE_LOAD = 0x111,
+	CISP_CMD_CH_CAPTURE_MODE_SET = 0x112,
+	CISP_CMD_CH_RAW_FRAME_PROCESS_GO = 0x113,
+	CISP_CMD_CH_EDGE_MAP_CONFIG_GET = 0x114,
+	CISP_CMD_CH_SIF_PIXEL_FORMAT_SET = 0x115,
+	CISP_CMD_CH_RPU_DMAOUT_CONFIG_GET = 0x116,
+	CISP_CMD_CH_RPU_DMAOUT_ENABLE = 0x117,
+	CISP_CMD_CH_RPU_DMAOUT_DISABLE = 0x118,
+	CISP_CMD_CH_CAMERA_MIPI_FREQ_CURRENT_GET = 0x119,
+	CISP_CMD_CH_CAMERA_MIPI_FREQUENCY_GET = 0x11a,
+	CISP_CMD_CH_CAMERA_MIPI_FREQ_SELECT = 0x11b,
+	CISP_CMD_CH_ISO_PARAMS_SET = 0x11c,
+	CISP_CMD_CH_ISO_PARAMS_GET = 0x11d,
+	CISP_CMD_CH_CAMERA_PIX_FREQ_CURRENT_GET = 0x11e,
+	CISP_CMD_CH_CAMERA_PIX_FREQUENCY_GET = 0x11f,
+	CISP_CMD_CH_CAMERA_PIX_FREQ_SELECT = 0x120,
+	CISP_CMD_CH_CAMERA_ERR_COUNT_GET = 0x121,
+	CISP_CMD_CH_CAMERA_CLOCK_DIVISOR_SET = 0x122,
+	CISP_CMD_CH_CAMERA_CLOCK_DIVISOR_AUTO_MODE_SET = 0x123,
+	CISP_CMD_CH_CAMERA_ERR_HANDLE_CONFIG = 0x124,
+	CISP_CMD_CH_CAMERA_CHROMATIC_TYPE_SET = 0x125,
+	CISP_CMD_CH_CAMERA_CHROMATIC_TYPE_GET = 0x126,
+	CISP_CMD_CH_AE_START = 0x200,
+	CISP_CMD_CH_AE_STOP = 0x201,
+	CISP_CMD_CH_AE_AGC_PARAM_SET = 0x202,
+	CISP_CMD_CH_AE_BIAS_EXPOSURE_GET = 0x203,
+	CISP_CMD_CH_AE_BIAS_EXPOSURE_SET = 0x204,
+	CISP_CMD_CH_AE_CLIP_GET = 0x205,
+	CISP_CMD_CH_AE_CLIP_SET = 0x206,
+	CISP_CMD_CH_AE_FRAME_RATE_MAX_GET = 0x207,
+	CISP_CMD_CH_AE_FRAME_RATE_MAX_SET = 0x208,
+	CISP_CMD_CH_AE_FRAME_RATE_MIN_GET = 0x209,
+	CISP_CMD_CH_AE_FRAME_RATE_MIN_SET = 0x20a,
+	CISP_CMD_CH_AE_GAIN_CAP_GET = 0x20b,
+	CISP_CMD_CH_AE_GAIN_CAP_SET = 0x20c,
+	CISP_CMD_CH_AE_INTEGRATION_TIME_MAX_GET = 0x20d,
+	CISP_CMD_CH_AE_INTEGRATION_TIME_MAX_SET = 0x20e,
+	CISP_CMD_CH_AE_INTEGRATION_TIME_SET = 0x20f,
+	CISP_CMD_CH_AE_NOISE_REDUCTION_CONTROL_PARAM_GET = 0x210,
+	CISP_CMD_CH_AE_NOISE_REDUCTION_CONTROL_PARAM_SET = 0x211,
+	CISP_CMD_CH_AE_PARAM_GET = 0x212,
+	CISP_CMD_CH_AE_PRE_FRAME_RATE_GET = 0x213,
+	CISP_CMD_CH_AE_PRE_FRAME_RATE_SET = 0x214,
+	CISP_CMD_CH_AE_RED_EYE_PARAM_GET = 0x215,
+	CISP_CMD_CH_AE_RED_EYE_PARAM_SET = 0x216,
+	CISP_CMD_CH_AE_SPEED_GET = 0x217,
+	CISP_CMD_CH_AE_SPEED_SET = 0x218,
+	CISP_CMD_CH_AE_STABILITY_GET = 0x219,
+	CISP_CMD_CH_AE_STABILITY_SET = 0x21a,
+	CISP_CMD_CH_AE_STROBE_PARAM_GET = 0x21b,
+	CISP_CMD_CH_AE_STROBE_PARAM_SET = 0x21c,
+	CISP_CMD_CH_AE_WINDOW_PARAM_GET = 0x21d,
+	CISP_CMD_CH_AE_WINDOW_PARAM_SET = 0x21e,
+	CISP_CMD_CH_AE_SDGC_PARAM_SET = 0x21f,
+	CISP_CMD_CH_AE_DGC_PARAM_SET = 0x220,
+	CISP_CMD_CH_AE_LUX_CALC_PARAMS_SET = 0x221,
+	CISP_CMD_CH_AE_BRACKETING_PARAMS_SET = 0x222,
+	CISP_CMD_CH_AE_TARGET_GET = 0x223,
+	CISP_CMD_CH_AE_TARGET_SET = 0x224,
+	CISP_CMD_CH_AE_PREFLASH_PARAM_SET = 0x225,
+	CISP_CMD_CH_AE_UPDATE_SUSPEND = 0x226,
+	CISP_CMD_CH_AE_UPDATE_RESUME = 0x227,
+	CISP_CMD_CH_AE_STABILITY_TO_STABLE_GET = 0x228,
+	CISP_CMD_CH_AE_STABILITY_TO_STABLE_SET = 0x229,
+	CISP_CMD_CH_AE_SENSOR_INTEGRATION_TIME_MIN_GET = 0x22a,
+	CISP_CMD_CH_AE_MANUAL_MODE_SET = 0x22b,
+	CISP_CMD_CH_AE_SENSOR_INTEGRATION_TIME_MAX_GET = 0x22c,
+	CISP_CMD_CH_AE_GAIN_CAP_MIN_GET = 0x22d,
+	CISP_CMD_CH_AE_GAIN_CAP_MIN_SET = 0x22e,
+	CISP_CMD_CH_AE_GAIN_CAP_MAX_WITH_EXP_GET = 0x22f,
+	CISP_CMD_CH_AE_GAIN_CAP_MAX_WITH_EXP_SET = 0x230,
+	CISP_CMD_CH_AE_GAIN_CAP_OFF_GET = 0x231,
+	CISP_CMD_CH_AE_GAIN_CAP_OFF_SET = 0x232,
+	CISP_CMD_CH_AE_BRACKETING_MANUAL_SET = 0x233,
+	CISP_CMD_CH_AE_BRACKETING_MODE_SET = 0x234,
+	CISP_CMD_CH_AE_MODE_SET = 0x235,
+	CISP_CMD_CH_AE_MODE_GET = 0x236,
+	CISP_CMD_CH_AE_PANO_LIMIT_SET = 0x237,
+	CISP_CMD_CH_AE_INTEGRATION_GAIN_SET = 0x238,
+	CISP_CMD_CH_AE_2WAYSPEED_SET = 0x239,
+	CISP_CMD_CH_AE_2WAYSPEED_GET = 0x23a,
+	CISP_CMD_CH_AWB_START = 0x300,
+	CISP_CMD_CH_AWB_STOP = 0x301,
+	CISP_CMD_CH_AWB_WINDOW_PARAM_GET = 0x302,
+	CISP_CMD_CH_AWB_WINDOW_PARAM_SET = 0x303,
+	CISP_CMD_CH_AWB_CCT_GET = 0x304,
+	CISP_CMD_CH_AWB_CCT_MANUAL = 0x305,
+	CISP_CMD_CH_AWB_CALIB_TABLE_SET = 0x306,
+	CISP_CMD_CH_AWB_BRACKETING_PARAMS_SET = 0x307,
+	CISP_CMD_CH_AWB_CCM_WARMUP_PARAMS_SET = 0x308,
+	CISP_CMD_CH_AWB_CCM_WARMUP_MATRIX_SET = 0x309,
+	CISP_CMD_CH_AWB_CCM_WARMUP_MATRIX_GET = 0x30a,
+	CISP_CMD_CH_AWB_2ND_GAIN_ADAPTIVE_THRESHOLDS_SET = 0x30b,
+	CISP_CMD_CH_AWB_2ND_GAIN_MANUAL = 0x30c,
+	CISP_CMD_CH_AWB_2ND_GAIN_GET = 0x30d,
+	CISP_CMD_CH_AWB_FLASH_GAIN_SET = 0x30e,
+	CISP_CMD_CH_AWB_UPDATE_SUSPEND = 0x30f,
+	CISP_CMD_CH_AWB_UPDATE_RESUME = 0x310,
+	CISP_CMD_CH_AWB_1ST_GAIN_MANUAL = 0x311,
+	CISP_CMD_CH_AF_START = 0x400,
+	CISP_CMD_CH_AF_STOP = 0x401,
+	CISP_CMD_CH_AF_EARLYOUT_GET = 0x402,
+	CISP_CMD_CH_AF_EARLYOUT_SET = 0x403,
+	CISP_CMD_CH_AF_FOCUS_POS_GET = 0x404,
+	CISP_CMD_CH_AF_SEARCH_POS_GET = 0x405,
+	CISP_CMD_CH_AF_SEARCH_POS_SET = 0x406,
+	CISP_CMD_CH_AF_ONE_SHOT = 0x407,
+	CISP_CMD_CH_AF_WINDOW_PARAM_GET = 0x408,
+	CISP_CMD_CH_AF_WINDOW_PARAM_SET = 0x409,
+	CISP_CMD_CH_AF_UPDATE_SUSPEND = 0x40a,
+	CISP_CMD_CH_AF_UPDATE_RESUME = 0x40b,
+	CISP_CMD_CH_AF_SOFTLANDING_SET = 0x40c,
+	CISP_CMD_CH_AF_SOFTLANDING_GET = 0x40d,
+	CISP_CMD_CH_SENSOR_FRAME_RATE_SET = 0x500,
+	CISP_CMD_CH_SENSOR_NVM_GET = 0x501,
+	CISP_CMD_CH_SENSOR_NVM_RELOAD = 0x502,
+	CISP_CMD_CH_SENSOR_TEST_PATTERN_CONFIG = 0x503,
+	CISP_CMD_CH_SENSOR_WARM_STARTUP_CONFIG = 0x504,
+	CISP_CMD_CH_SENSOR_CUSTOM_SETTING_CONFIG = 0x505,
+	CISP_CMD_CH_SENSOR_TEMPERATURE_GET = 0x506,
+	CISP_CMD_CH_SENSOR_PERMODULE_LSC_INFO_GET = 0x507,
+	CISP_CMD_CH_SENSOR_PERMODULE_LSC_GET = 0x508,
+	CISP_CMD_CH_SENSOR_BLC_UPDATE_SUSPEND = 0x509,
+	CISP_CMD_CH_SENSOR_BLC_UPDATE_RESUME = 0x50a,
+	CISP_CMD_CH_SENSOR_POWER_ON = 0x50b,
+	CISP_CMD_CH_SENSOR_POWER_OFF = 0x50c,
+	CISP_CMD_CH_FOCUS_LIMITS_SET = 0x700,
+	CISP_CMD_CH_FOCUS_LIMITS_GET = 0x701,
+	CISP_CMD_CH_FOCUS_POSITION_SET = 0x702,
+	CISP_CMD_CH_FOCUS_POSITION_GET = 0x703,
+	CISP_CMD_CH_FOCUS_STEP_SIZE_SET = 0x704,
+	CISP_CMD_CH_FOCUS_STEP_SIZE_GET = 0x705,
+	CISP_CMD_CH_FOCUS_CAL_BITSHIFT_SET = 0x706,
+	CISP_CMD_CH_FOCUS_REINIT = 0x707,
+	CISP_CMD_CH_LED_TORCH_PARAM_GET = 0x600,
+	CISP_CMD_CH_LED_TORCH_PARAM_SET = 0x601,
+	CISP_CMD_CH_LED_TORCH_OFF = 0x602,
+	CISP_CMD_CH_LED_TORCH_ON = 0x603,
+	CISP_CMD_CH_LED_TORCH_ON_INDICATOR = 0x604,
+	CISP_CMD_CH_LED_TORCH_MANUAL_SET = 0x605,
+	CISP_CMD_CH_STATUS_LED_BrightnessMan_SET = 0x606,
+	CISP_CMD_CH_STATUS_LED_BrightnessMan_GET = 0x607,
+	CISP_CMD_CH_STATUS_LED_DEBUG_SET = 0x608,
+	CISP_CMD_CH_CROP_GET = 0x800,
+	CISP_CMD_CH_CROP_SET = 0x801,
+	CISP_CMD_CH_BPC_START = 0x802,
+	CISP_CMD_CH_BPC_STOP = 0x803,
+	CISP_CMD_CH_COLOR_CAL_DATA_SET = 0x804,
+	CISP_CMD_CH_COLOR_CAL_DATA_GET = 0x805,
+	CISP_CMD_CH_COLOR_CAL_IDEAL_SET = 0x806,
+	CISP_CMD_CH_COLOR_CAL_IDEAL_GET = 0x807,
+	CISP_CMD_CH_COLOR_CAL_ABS_GET = 0x808,
+	CISP_CMD_CH_COLOR_CAL_ABS_OVERRIDE = 0x809,
+	CISP_CMD_CH_SCALER_CROP_SET = 0x80a,
+	CISP_CMD_CH_COLOR_SATURATION_GET = 0xa00,
+	CISP_CMD_CH_COLOR_SATURATION_SET = 0xa01,
+	CISP_CMD_CH_TONE_CURVE_CUSTOM_GET = 0xa02,
+	CISP_CMD_CH_TONE_CURVE_CUSTOM_SET = 0xa03,
+	CISP_CMD_CH_COLOR_LSC_TABLE_SET = 0xa04,
+	CISP_CMD_CH_COLOR_LSC_START = 0xa05,
+	CISP_CMD_CH_COLOR_LSC_STOP = 0xa06,
+	CISP_CMD_CH_SCALER_SHARPNESS_SET = 0xa07,
+	CISP_CMD_CH_SCALER_SHARPNESS_GET = 0xa08,
+	CISP_CMD_CH_SHARPNESS_SET = 0xa09,
+	CISP_CMD_CH_SHARPNESS_GET = 0xa0a,
+	CISP_CMD_CH_NOISE_REDUCTION_SET = 0xa0b,
+	CISP_CMD_CH_NOISE_REDUCTION_GET = 0xa0c,
+	CISP_CMD_CH_CHROMA_SUPPRESSION_SET = 0xa0d,
+	CISP_CMD_CH_CHROMA_SUPPRESSION_GET = 0xa0e,
+	CISP_CMD_CH_HISTOGRAM_ENABLE = 0xa0f,
+	CISP_CMD_CH_COLOR_FULL_RES_LSC_TABLE_SET = 0xa10,
+	CISP_CMD_CH_COLOR_FULL_RES_LSC_ENABLE = 0xa11,
+	CISP_CMD_CH_COLOR_FULL_RES_LSC_DISABLE = 0xa12,
+	CISP_CMD_CH_KNOB_MANUAL_CONTROL_ENABLE = 0xa13,
+	CISP_CMD_CH_KNOB_MANUAL_CONTROL_DISABLE = 0xa14,
+	CISP_CMD_CH_BE_LASETTING_SET = 0xa15,
+	CISP_CMD_CH_BE_LASETTING_GET = 0xa16,
+	CISP_CMD_CH_BE_LA_INPUTMODE_SET = 0xa17,
+	CISP_CMD_CH_BE_LA_INPUTMODE_GET = 0xa18,
+	CISP_CMD_CH_DRC_SET = 0xa19,
+	CISP_CMD_CH_DRC_GET = 0xa1a,
+	CISP_CMD_CH_RPU_HISTOGRAM_PARAM_SET = 0xa1b,
+	CISP_CMD_CH_ALS_ENABLE = 0xa1c,
+	CISP_CMD_CH_ALS_DISABLE = 0xa1d,
+	CISP_CMD_CH_ALS_MODE_SET = 0xa1e,
+	CISP_CMD_CH_ALS_CCT_MANUAL = 0xa1f,
+	CISP_CMD_CH_ALS_POLYNOMIAL_SET = 0xa20,
+	CISP_CMD_CH_ALS_POLYNOMIAL_GET = 0xa21,
+	CISP_CMD_CH_COLOR_LSC_TABLE_GET = 0xa22,
+	CISP_CMD_CH_ALS_TEST_PATTERN_SET = 0xa23,
+	CISP_CMD_CH_BE_LA_SUSPEND = 0xa24,
+	CISP_CMD_CH_BE_LA_RESUME = 0xa25,
+	CISP_CMD_CH_COLOR_LSC_IDEAL_TABLE_SET = 0xa26,
+	CISP_CMD_CH_ALS_CCT_LIMIT_SET = 0xa27,
+	CISP_CMD_CH_TONE_CURVE_CUSTOM_BRACKETING_SET = 0xa28,
+	CISP_CMD_CH_MANUAL_BPC_GAIN_THRESHOLD_SET = 0xa29,
+	CISP_CMD_CH_COLOR_LSC_TABLE_SOURCE_SET = 0xa2a,
+	CISP_CMD_CH_ALS_SUSPEND = 0xa2b,
+	CISP_CMD_CH_ALS_RESUME = 0xa2c,
+	CISP_CMD_CH_OUTPUT_CONFIG_GET = 0xb00,
+	CISP_CMD_CH_OUTPUT_CONFIG_SET = 0xb01,
+	CISP_CMD_CH_SCALER_BRIGHTNESS_SET = 0xb02,
+	CISP_CMD_CH_SCALER_CONTRAST_SET = 0xb03,
+	CISP_CMD_CH_SCALER_SATURATION_SET = 0xb04,
+	CISP_CMD_CH_SCALER_HUE_SET = 0xb05,
+	CISP_CMD_CH_DRC_START = 0xc00,
+	CISP_CMD_CH_DRC_STOP = 0xc01,
+	CISP_CMD_CH_DRC_OFFLINE = 0xc02,
+	CISP_CMD_CH_DRC_OFFLINE_START = 0xc03,
+	CISP_CMD_CH_DRC_OFFLINE_STOP = 0xc04,
+	CISP_CMD_CH_FACE_DETECTION_START = 0xd00,
+	CISP_CMD_CH_FACE_DETECTION_STOP = 0xd01,
+	CISP_CMD_CH_FACE_DETECTION_CONFIG_GET = 0xd02,
+	CISP_CMD_CH_FACE_DETECTION_CONFIG_SET = 0xd03,
+	CISP_CMD_CH_FACE_DETECTION_DISABLE = 0xd04,
+	CISP_CMD_CH_FACE_DETECTION_ENABLE = 0xd05,
+	CISP_CMD_CH_FACE_DETECTION_INPUT_SET = 0xd06,
+	CISP_CMD_CH_FACE_DETECTION_IMAGE_ORIENTATION_SET = 0xd07,
+	CISP_CMD_CH_FACE_DETECTION_OFFLINE = 0xd08,
+	CISP_CMD_CH_FACE_DETECTION_OFFLINE_START = 0xd09,
+	CISP_CMD_CH_FACE_DETECTION_OFFLINE_STOP = 0xd0a,
+	CISP_CMD_CH_FACE_DETECTION_MODE_SET = 0xd0b,
+	CISP_CMD_CH_FACE_DETECTION_WINDOW_PARAM_SET = 0xd0c,
+	CISP_CMD_CH_FACE_DETECTION_WINDOW_PARAM_GET = 0xd0d,
+	CISP_CMD_CH_FRAMEDONE_TIMEOUT = 0xe00,
+	CISP_CMD_CH_FOCUS_DRIVER_INIT_FAILED = 0xe01,
+	CISP_CMD_CH_NVSTORAGE_INFO_GET = 0xf00,
+	CISP_CMD_CH_NVSTORAGE_DATA_GET = 0xf01,
+	CISP_CMD_CH_NVSTORAGE_DATA_SET = 0xf02,
+	CISP_CMD_APPLE_SET_FILE_LOAD = 0x8000,
+	CISP_CMD_APPLE_BUFFER_INFO_SET_GET = 0x8001,
+	CISP_CMD_APPLE_CH_HARDWARE_BLOCK_ENABLE = 0x8100,
+	CISP_CMD_APPLE_CH_HARDWARE_BLOCK_DISABLE = 0x8101,
+	CISP_CMD_APPLE_CH_CONTEXTSWITCH_ENABLE = 0x8102,
+	CISP_CMD_APPLE_CH_CONTEXTSWITCH_DISABLE = 0x8103,
+	CISP_CMD_APPLE_CH_SENSOR_NOISE_MODEL_SET = 0x8104,
+	CISP_CMD_APPLE_CH_SENSOR_NOISE_MODEL_GET = 0x8105,
+	CISP_CMD_APPLE_CH_STREAMING_MODE_SET = 0x8106,
+	CISP_CMD_APPLE_CH_STREAMING_MODE_GET = 0x8107,
+	CISP_CMD_APPLE_CH_AE_WINDOW_PARAM_SET = 0x8200,
+	CISP_CMD_APPLE_CH_AE_DYNAMIC_SCENE_METERING_CONFIG_SET = 0x8201,
+	CISP_CMD_APPLE_CH_AE_DYNAMIC_SCENE_METERING_START = 0x8202,
+	CISP_CMD_APPLE_CH_AE_DYNAMIC_SCENE_METERING_STOP = 0x8203,
+	CISP_CMD_APPLE_CH_AE_WINDOW_PARAM_GET = 0x8204,
+	CISP_CMD_APPLE_CH_AE_WINDOW_WEIGHT_SET = 0x8205,
+	CISP_CMD_APPLE_CH_AE_METERING_MODE_SET = 0x8206,
+	CISP_CMD_APPLE_CH_AE_METERING_MODE_GET = 0x8207,
+	CISP_CMD_APPLE_CH_AE_FLICKER_FREQ_SET = 0x8208,
+	CISP_CMD_APPLE_CH_AE_MAX_FRAMERATE_GAIN_LIMIT_SET = 0x8209,
+	CISP_CMD_APPLE_CH_AE_MAX_FRAMERATE_GAIN_LIMIT_GET = 0x820a,
+	CISP_CMD_APPLE_CH_AE_TILES_MATRIX_METADATA_ENABLE = 0x820b,
+	CISP_CMD_APPLE_CH_AE_BINNING_GAIN_LUX_THRESHOLD_SET = 0x820c,
+	CISP_CMD_APPLE_CH_AE_PSEUDO_Y_WEIGHT_SET = 0x820d,
+	CISP_CMD_APPLE_CH_AE_FD_SCENE_METERING_CONFIG_SET = 0x820e,
+	CISP_CMD_APPLE_CH_AE_GAIN_CONVERGENCE_NORMALIZATION_SET = 0x820f,
+	CISP_CMD_APPLE_CH_AE_GAIN_CONVERGENCE_NORMALIZATION_GET = 0x8210,
+	CISP_CMD_APPLE_CH_AE_FD_SCENE_METERING_CONFIG_GET = 0x8211,
+	CISP_CMD_APPLE_CH_AWB_CCT_GET = 0x8300,
+	CISP_CMD_APPLE_CH_AWB_CCT_MANUAL = 0x8301,
+	CISP_CMD_APPLE_CH_AWB_WINDOW_PARAM_GET = 0x8302,
+	CISP_CMD_APPLE_CH_AWB_WINDOW_PARAM_SET = 0x8303,
+	CISP_CMD_APPLE_CH_AWB_CALIB_TABLE_SET = 0x8304,
+	CISP_CMD_APPLE_CH_AWB_SCHEME_SET = 0x8305,
+	CISP_CMD_APPLE_CH_AWB_SCHEME_GET = 0x8306,
+	CISP_CMD_APPLE_CH_AWB_HISTOGRAM_WEIGHT_SET = 0x8307,
+	CISP_CMD_APPLE_CH_AWB_LUXTABLE_PARAM_SET = 0x8308,
+	CISP_CMD_APPLE_CH_AWB_PROJECTION_POINT_SET = 0x8309,
+	CISP_CMD_APPLE_CH_AWB_HISTOGRAM_X_TO_CCT_LUT_SET = 0x830a,
+	CISP_CMD_APPLE_CH_AWB_2D_CCM_SET = 0x830b,
+	CISP_CMD_APPLE_CH_AWB_PRE_CCM_GAIN_GET = 0x830c,
+	CISP_CMD_APPLE_CH_AWB_CCM_GET = 0x830d,
+	CISP_CMD_APPLE_CH_AWB_TEMPORAL_COHERENCE_FILTER_SET = 0x830e,
+	CISP_CMD_APPLE_CH_AWB_SUSPEND_UPON_AE_STABLE_SET = 0x830f,
+	CISP_CMD_APPLE_CH_AWB_SUSPEND_UPON_AE_STABLE_GET = 0x8310,
+	CISP_CMD_APPLE_CH_AWB_POST_TINT_PARAM_SET = 0x8311,
+	CISP_CMD_APPLE_CH_AWB_MIX_LIGHTING_X_LOC_SET = 0x8312,
+	CISP_CMD_APPLE_CH_AWB_MIX_LIGHTING_CCM_SET = 0x8313,
+	CISP_CMD_APPLE_CH_AWB_TILE_STATS_Y_THRESHOLD_SET = 0x8314,
+	CISP_CMD_APPLE_CH_AWB_RATIO_SPACE_2ND_GAIN_THRESHOLD_SET = 0x8315,
+	CISP_CMD_APPLE_CH_AWB_HISTOGRAM_TRIM_FILTER_V_SET = 0x8316,
+	CISP_CMD_APPLE_CH_AWB_HISTOGRAM_TRIM_FILTER_H_SET = 0x8317,
+	CISP_CMD_APPLE_CH_AWB_HISTOGRAM_TRIM_SCALE_PROFILE_SET = 0x8318,
+	CISP_CMD_APPLE_CH_AWB_CCM_LUX_CLIP_SET = 0x8319,
+	CISP_CMD_APPLE_CH_AWB_MANUAL_WB_GAIN_SET = 0x831a,
+	CISP_CMD_APPLE_CH_AWB_CALIBRATION_MATRIX_GET = 0x831b,
+	CISP_CMD_APPLE_CH_AF_WINDOW_PARAM_GET = 0x8400,
+	CISP_CMD_APPLE_CH_AF_WINDOW_PARAM_SET = 0x8401,
+	CISP_CMD_APPLE_CH_AF_WINDOW_WEIGHT_GET = 0x8402,
+	CISP_CMD_APPLE_CH_AF_WINDOW_WEIGHT_SET = 0x8403,
+	CISP_CMD_APPLE_CH_AF_WINDOW_FD_CONFIG = 0x8404,
+	CISP_CMD_APPLE_CH_AF_PEAK_PREDICT_ENABLE_SET = 0x8405,
+	CISP_CMD_APPLE_CH_AF_FOCUS_POS_OVERRIDE_SET = 0x8406,
+	CISP_CMD_APPLE_CH_AF_PEAK_TRACKING_ENABLE = 0x8407,
+	CISP_CMD_APPLE_CH_AF_PEAK_TRACKING_START = 0x8408,
+	CISP_CMD_APPLE_CH_AF_FOCUS_MODE_SET = 0x8409,
+	CISP_CMD_APPLE_CH_AF_FOCUS_MODE_GET = 0x840a,
+	CISP_CMD_APPLE_CH_AF_MATRIX_MODE_CONFIG_SET = 0x840b,
+	CISP_CMD_APPLE_CH_AF_MATRIX_MODE_CONFIG_GET = 0x840c,
+	CISP_CMD_APPLE_CH_AF_MATRIX_MODE_DEBUG_GET = 0x840d,
+	CISP_CMD_APPLE_CH_AF_SCAN_HISTORY_GET = 0x840e,
+	CISP_CMD_APPLE_CH_FESTAT_CONFIG_GET = 0xc000,
+	CISP_CMD_APPLE_CH_TILE_REGION_SET = 0xc001,
+	CISP_CMD_APPLE_CH_TILE_WEIGHT_SET = 0xc002,
+	CISP_CMD_APPLE_CH_COLOR_LSC_TABLE_SET = 0xc003,
+	CISP_CMD_APPLE_CH_PIXEL_FILTER_TABLE_SET = 0xc004,
+	CISP_CMD_APPLE_CH_CSC_CONFIG_SET = 0xc005,
+	CISP_CMD_APPLE_CH_CSC_CONFIG_GET = 0xc006,
+	CISP_CMD_APPLE_CH_CSC2_CONFIG_SET = 0xc007,
+	CISP_CMD_APPLE_CH_CSC2_CONFIG_GET = 0xc008,
+	CISP_CMD_APPLE_CH_COLOR_HIST_CONFIG_SET = 0xc009,
+	CISP_CMD_APPLE_CH_COLOR_HIST_CONFIG_GET = 0xc00a,
+	CISP_CMD_APPLE_CH_CSC_GAMMA_SET = 0xc00b,
+	CISP_CMD_APPLE_CH_COLOR_HIST_CAPTURE = 0xc00c,
+	CISP_CMD_APPLE_CH_COLOR_LSC_IDEAL_TABLE_SET = 0xc00d,
+	CISP_CMD_APPLE_CH_STATPIXELDMAOUTPUT_SOURCE_SET = 0xc00e,
+	CISP_CMD_APPLE_CH_STATPIXELDMAOUTPUT_INFO_GET = 0xc00f,
+	CISP_CMD_APPLE_CH_AFFILTER_COEFF_SET = 0xc010,
+	CISP_CMD_APPLE_CH_AFFILTER_COEFF_GET = 0xc011,
+	CISP_CMD_APPLE_CH_EDGE_MAP_CONFIGURE = 0xc012,
+	CISP_CMD_APPLE_CH_AFHORZFILT_COEFF_SET = 0xc013,
+	CISP_CMD_APPLE_CH_AFHORZFILT_ENABLE_SET = 0xc014,
+	CISP_CMD_APPLE_CH_AFHORZFILT_SUMMODE_SET = 0xc015,
+	CISP_CMD_APPLE_CH_AFHORZFILT_THD_SET = 0xc016,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_START = 0xc100,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_STOP = 0xc101,
+	CISP_CMD_APPLE_CH_MOTION_HISTORY_START = 0xc102,
+	CISP_CMD_APPLE_CH_MOTION_HISTORY_STOP = 0xc103,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_CONFIG_SET = 0xc104,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_CONFIG_GET = 0xc105,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_GAIN_SET = 0xc106,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_GAIN_GET = 0xc107,
+	CISP_CMD_APPLE_CH_MOTION_LUT_SET = 0xc108,
+	CISP_CMD_APPLE_CH_MOTION_LUT_GET = 0xc109,
+	CISP_CMD_APPLE_CH_LUMA_LUT_SET = 0xc10a,
+	CISP_CMD_APPLE_CH_LUMA_LUT_GET = 0xc10b,
+	CISP_CMD_APPLE_CH_TNR_MODE_SET = 0xc10c,
+	CISP_CMD_APPLE_CH_TNR_MODE_GET = 0xc10d,
+	CISP_CMD_APPLE_CH_TNR_PARAM_SET = 0xc10e,
+	CISP_CMD_APPLE_CH_TNR_PARAM_GET = 0xc10f,
+	CISP_CMD_APPLE_CH_TNR_INTERPOLATION_ENABLE = 0xc110,
+	CISP_CMD_APPLE_CH_TNR_AVERAGE_START = 0xc111,
+	CISP_CMD_APPLE_CH_TNR_AVERAGE_STOP = 0xc112,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_ENABLE = 0xc113,
+	CISP_CMD_APPLE_CH_TEMPORAL_FILTER_DISABLE = 0xc114,
+	CISP_CMD_APPLE_CH_TNR_AVERAGE_FRAME_COUNT_SET = 0xc115,
+	CISP_CMD_APPLE_CH_TNR_TUNING_PARAMS_SET = 0xc116,
+	CISP_CMD_APPLE_CH_TNR_LSC_GAIN_SET = 0xc117,
+	CISP_CMD_APPLE_CH_BINNING_COMPENSATION_FILTER_START = 0xc200,
+	CISP_CMD_APPLE_CH_BINNING_COMPENSATION_FILTER_STOP = 0xc201,
+	CISP_CMD_APPLE_CH_TONE_CURVE_ADAPTATION_START = 0xc300,
+	CISP_CMD_APPLE_CH_TONE_CURVE_ADAPTATION_STOP = 0xc301,
+	CISP_CMD_APPLE_CH_TONE_CURVE_PARAM_SET = 0xc302,
+	CISP_CMD_APPLE_CH_TONE_CURVE_PARAM_GET = 0xc303,
+	CISP_CMD_APPLE_CH_TONE_CURVE_UPDATE_SUSPEND = 0xc304,
+	CISP_CMD_APPLE_CH_TONE_CURVE_UPDATE_RESUME = 0xc305,
+	CISP_CMD_APPLE_CH_TONE_CURVE_MANUAL_CONTROL_ENABLE = 0xc306,
+	CISP_CMD_APPLE_CH_TONE_CURVE_MANUAL_CONTROL_DISABLE = 0xc307,
+	CISP_CMD_APPLE_CH_TONE_CURVE_LUX_ADAPTATION_TABLE_SET = 0xc308,
+	CISP_CMD_APPLE_CH_TONE_CURVE_LUX_ADAPTATION_TABLE_GET = 0xc309,
+	CISP_CMD_APPLE_CH_TONE_CURVE_LUX_ADAPTATION_LUXSCALE_SET = 0xc30a,
+	CISP_CMD_APPLE_CH_TONE_CURVE_LUX_ADAPTATION_LUXSCALE_GET = 0xc30b,
+	CISP_CMD_APPLE_CH_TONE_CURVE_STABILITY_SET = 0xc30c,
+	CISP_CMD_APPLE_CH_TONE_CURVE_STABILITY_GET = 0xc30d,
+	CISP_CMD_APPLE_CH_AUTO_HDR_HISTOGRAM_ENABLE = 0xc30e,
+	CISP_CMD_APPLE_CH_AUTO_HDR_HISTOGRAM_DISABLE = 0xc30f,
+	CISP_CMD_APPLE_CH_SNF_START = 0xc400,
+	CISP_CMD_APPLE_CH_SNF_STOP = 0xc401,
+	CISP_CMD_APPLE_CH_SNF_SET = 0xc402,
+	CISP_CMD_APPLE_CH_SNF_GET = 0xc403,
+	CISP_CMD_APPLE_CH_SNF_RADIAL_GAIN_SET = 0xc404,
+	CISP_CMD_APPLE_CH_DPC_ENABLE = 0xc500,
+	CISP_CMD_APPLE_CH_DPC_START = 0xc501,
+	CISP_CMD_APPLE_CH_DPC_STOP = 0xc502,
+	CISP_CMD_APPLE_CH_DPC_CTRLVALUE_OVERRIDE = 0xc503,
+	CISP_CMD_APPLE_CH_DPC_MAX_DYN_COUNT_OVERRIDE = 0xc504,
+	CISP_CMD_APPLE_CH_DPC_DYN_THRESHOLD0_OVERRIDE = 0xc505,
+	CISP_CMD_APPLE_CH_DPC_DYN_THRESHOLD1_OVERRIDE = 0xc506,
+	CISP_CMD_APPLE_CH_DPC_DESP_THRESHOLD0_OVERRIDE = 0xc507,
+	CISP_CMD_APPLE_CH_DPC_DESP_THRESHOLD1_OVERRIDE = 0xc508,
+	CISP_CMD_APPLE_CH_DPC_MAX_CORNER_OVERRIDE = 0xc509,
+	CISP_CMD_APPLE_CH_DPC_MAX_EDGE_OVERRIDE = 0xc50a,
+	CISP_CMD_APPLE_CH_DPC_MAX_CENTER_OVERRIDE = 0xc50b,
+	CISP_CMD_APPLE_CH_DPC_STATIC_DEFECTS_TABLE_SET = 0xc50c,
+};
+
+enum isp_debug_cmds {
+	CISP_CMD_DEBUG_BANNER=0,
+	CISP_CMD_DEBUG_NOP1,
+	CISP_CMD_DEBUG_NOP2,
+	CISP_CMD_DEBUG_PS,
+	CISP_CMD_DEBUG_GET_ROOT_HANDLE,
+	CISP_CMD_DEBUG_GET_OBJECT_BY_NAME,
+	CISP_CMD_DEBUG_GET_NUMBER_OF_CHILDREN,
+	CISP_CMD_DEBUG_GET_CHILDREN_BY_INDEX,
+	CISP_CMD_DEBUG_SHOW_OBJECT_GRAPH,
+	CISP_CMD_DEBUG_DUMP_OBJECT,
+	CISP_CMD_DEBUG_DUMP_ALL_OBJECTS,
+	CISP_CMD_DEBUG_GET_DEBUG_LEVEL,
+	CISP_CMD_DEBUG_SET_DEBUG_LEVEL,
+	CISP_CMD_DEBUG_SET_DEBUG_LEVEL_RECURSIVE,
+	CISP_CMD_DEBUG_GET_FSM_COUNT,
+	CISP_CMD_DEBUG_GET_FSM_BY_INDEX,
+	CISP_CMD_DEBUG_GET_FSM_BY_NAME,
+	CISP_CMD_DEBUG_GET_FSM_DEBUG_LEVEL,
+	CISP_CMD_DEBUG_SET_FSM_DEBUG_LEVEL,
+	CISP_CMD_DEBUG_FSM_UNKNOWN, /* XXX: don't know what this cmd is doing yet */
+	CISP_CMD_DEBUG_HEAP_STATISTICS,
+	CISP_CMD_DEBUG_IRQ_STATISTICS,
+	CISP_CMD_DEBUG_SHOW_SEMAPHORE_STATUS,
+	CISP_CMD_DEBUG_START_CPU_PERFORMANCE_COUNTER,
+	CISP_CMD_DEBUG_STOP_CPU_PERFORMANCE_COUNTER,
+	CISP_CMD_DEBUG_SHOW_WIRING_OPERATIONS,
+	CISP_CMD_DEBUG_SHOW_UNIT_TEST_STATUS,
+	CISP_CMD_DEBUG_GET_ENVIRONMENT,
+};
+
+struct isp_mem_obj {
+	struct resource base;
+	unsigned int type;
+	resource_size_t size;
+	resource_size_t size_aligned;
+	unsigned long offset;
+};
+
+struct isp_fw_args {
+	u32 __unknown;
+	u32 fw_arg;
+	u32 full_stats_mode;
+};
+
+struct isp_channel_info {
+	char name[64]; /* really that big? */
+	u32 type;
+	u32 source;
+	u32 size;
+	u32 offset;
+};
+
+struct isp_cmd_hdr {
+	u32 unknown0;
+	u16 opcode;
+	u16 status;
+} __attribute__((packed));
+
+struct isp_cmd_print_enable {
+	u32 enable;
+} __attribute__((packed));
+
+struct isp_cmd_config {
+	u32 field0;
+	u32 field4;
+	u32 field8;
+	u32 fieldc;
+	u32 field10;
+	u32 field14;
+	u32 field18;
+	u32 field1c;
+} __attribute__((packed));
+
+struct isp_cmd_set_loadfile {
+	u32 unknown;
+	u32 addr;
+	u32 length;
+} __attribute__((packed));
+
+struct isp_cmd_channel_info {
+	u32 field_0;
+	u32 field_4;
+	u32 field_8;
+	u32 field_c;
+	u16 sensorid0; /* field 10 */
+	u16 field_12;
+	u32 field_14;
+	u16 sensorid1; /* field 18 */
+	u16 field_1a;
+	u32 field_1c;
+	u32 field_20;
+	u8 unknown[52];
+	u32 sensor_count;
+	u8 unknown2[40];
+	u8 sensor_serial_number[8];
+	u8 camera_module_serial_number[18];
+} __attribute__((packed));
+
+struct isp_cmd_channel_camera_config {
+	u32 unknown;
+	u32 channel;
+	u8 data[88];
+};
+
+struct isp_cmd_channel_set_crop {
+	u32 channel;
+	u32 x1;
+	u32 y1;
+	u32 x2;
+	u32 y2;
+};
+
+struct isp_cmd_channel_output_config {
+	u32 channel;
+	u32 x1;
+	u32 y1;
+	u32 unknown3;
+	u32 pixelformat;
+	u32 x2;
+	u32 x3;
+	u32 unknown5;
+};
+
+struct isp_cmd_channel_recycle_mode {
+	u32 channel;
+	u32 mode;
+};
+
+struct isp_cmd_channel_camera_config_select {
+	u32 channel;
+	u32 config;
+};
+
+struct isp_cmd_channel_drc_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_tone_curve_adaptation_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_sif_format_set {
+	u32 channel;
+	u8 param1;
+	u8 param2;
+	u8 unknown0;
+	u8 unknown1;
+};
+
+struct isp_cmd_channel_camera_err_handle_config {
+	u32 channel;
+	u16 param1;
+	u16 param2;
+};
+
+struct isp_cmd_channel_streaming_mode {
+	u32 channel;
+	u16 mode;
+	u16 unknown;
+};
+
+struct isp_cmd_channel_frame_rate_set {
+	u32 channel;
+	u16 rate;
+};
+
+struct isp_cmd_channel_ae_speed_set {
+	u32 channel;
+	u16 speed;
+};
+
+struct isp_cmd_channel_ae_stability_set {
+	u32 channel;
+	u16 stability;
+};
+
+struct isp_cmd_channel_ae_stability_to_stable_set {
+	u32 channel;
+	u16 value;
+};
+
+struct isp_cmd_channel_face_detection_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_face_detection_stop {
+	u32 channel;
+};
+
+struct isp_cmd_channel_face_detection_enable {
+	u32 channel;
+};
+
+struct isp_cmd_channel_face_detection_disable {
+	u32 channel;
+};
+
+struct isp_cmd_channel_temporal_filter_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_temporal_filter_stop {
+	u32 channel;
+};
+
+struct isp_cmd_channel_temporal_filter_enable {
+	u32 channel;
+};
+
+struct isp_cmd_channel_temporal_filter_disable {
+	u32 channel;
+};
+
+struct isp_cmd_channel_motion_history_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_motion_history_stop {
+	u32 channel;
+};
+
+struct isp_cmd_channel_ae_metering_mode_set {
+	u32 channel;
+	u32 mode;
+};
+
+struct isp_cmd_channel_start {
+	u32 channel;
+};
+
+struct isp_cmd_channel_stop {
+	u32 channel;
+};
+
+struct isp_cmd_channel_brightness_set {
+	u32 channel;
+	u32 brightness;
+};
+
+struct isp_cmd_channel_contrast_set {
+	u32 channel;
+	u32 contrast;
+};
+
+struct isp_cmd_channel_saturation_set {
+	u32 channel;
+	u32 contrast;
+};
+
+struct isp_cmd_channel_hue_set {
+	u32 channel;
+	u32 contrast;
+};
+
+struct isp_cmd_channel {
+	u32 channel;
+};
+
+struct isp_cmd_channel_buffer_return {
+	u32 channel;
+};
+
+
+struct fthd_isp_debug_cmd {
+	u32 show_errors;
+	u32 arg[64];
+};
+
+#define to_isp_mem_obj(x) container_of((x), struct isp_mem_obj, base)
+
+extern int isp_init(struct fthd_private *dev_priv);
+extern int isp_uninit(struct fthd_private *dev_priv);
+
+extern int isp_mem_init(struct fthd_private *dev_priv);
+extern struct isp_mem_obj *isp_mem_create(struct fthd_private *dev_priv,
+					  unsigned int type,
+					  resource_size_t size);
+extern int isp_mem_destroy(struct isp_mem_obj *obj);
+extern int fthd_isp_cmd_start(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_stop(struct fthd_private *dev_priv);
+extern int isp_powerdown(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_print_enable(struct fthd_private *dev_priv, int enable);
+extern int fthd_isp_cmd_set_loadfile(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_info(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_start(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_stop(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_camera_config(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_crop_set(struct fthd_private *dev_priv, int channel,
+					 int x1, int y1, int x2, int y2);
+extern int fthd_isp_cmd_channel_output_config_set(struct fthd_private *dev_priv, int channel, int x, int y, int pixelformat);
+extern int fthd_isp_cmd_channel_recycle_mode(struct fthd_private *dev_priv, int channel, int mode);
+extern int fthd_isp_cmd_channel_recycle_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_camera_config_select(struct fthd_private *dev_priv, int channel, int config);
+extern int fthd_isp_cmd_channel_drc_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_tone_curve_adaptation_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_sif_pixel_format(struct fthd_private *dev_priv, int channel, int param1, int param2);
+extern int fthd_isp_cmd_channel_error_handling_config(struct fthd_private *dev_priv, int channel, int param1, int param2);
+extern int fthd_isp_cmd_channel_streaming_mode(struct fthd_private *dev_priv, int channel, int mode);
+extern int fthd_isp_cmd_channel_frame_rate_min(struct fthd_private *dev_priv, int channel, int rate);
+extern int fthd_isp_cmd_channel_frame_rate_max(struct fthd_private *dev_priv, int channel, int rate);
+extern int fthd_isp_cmd_camera_config(struct fthd_private *dev_priv);
+extern int fthd_isp_cmd_channel_ae_speed_set(struct fthd_private *dev_priv, int channel, int speed);
+extern int fthd_isp_cmd_channel_ae_stability_set(struct fthd_private *dev_priv, int channel, int stability);
+extern int fthd_isp_cmd_channel_ae_stability_to_stable_set(struct fthd_private *dev_priv, int channel, int value);
+extern int fthd_isp_cmd_channel_face_detection_enable(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_face_detection_disable(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_face_detection_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_face_detection_stop(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_temporal_filter_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_temporal_filter_stop(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_temporal_filter_enable(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_temporal_filter_disable(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_motion_history_start(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_motion_history_stop(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_cmd_channel_ae_metering_mode_set(struct fthd_private *dev_priv, int channel, int mode);
+extern int fthd_isp_cmd_channel_brightness_set(struct fthd_private *dev_priv, int channel, int brightness);
+extern int fthd_isp_cmd_channel_contrast_set(struct fthd_private *dev_priv, int channel, int contrast);
+extern int fthd_isp_cmd_channel_saturation_set(struct fthd_private *dev_priv, int channel, int saturation);
+extern int fthd_isp_cmd_channel_hue_set(struct fthd_private *dev_priv, int channel, int hue);
+extern int fthd_isp_cmd_channel_awb(struct fthd_private *dev_priv, int channel, int hue);
+extern int fthd_isp_cmd_channel_buffer_return(struct fthd_private *dev_priv, int channel);
+extern int fthd_start_channel(struct fthd_private *dev_priv, int channel);
+extern int fthd_stop_channel(struct fthd_private *dev_priv, int channel);
+extern int fthd_isp_debug_cmd(struct fthd_private *dev_priv, enum fthd_isp_cmds command, void *buf,
+			      int request_len, int *response_len);
+
+#endif
diff --git a/drivers/custom/facetimehd/fthd_reg.h b/drivers/custom/facetimehd/fthd_reg.h
new file mode 100644
index 000000000000..27da24a4a1d3
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_reg.h
@@ -0,0 +1,184 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2014 Patrik Jakobsson (patrik.r.jakobsson@gmail.com)
+ *
+ */
+
+#ifndef _FTHD_REG_H
+#define _FTHD_REG_H
+
+#include <linux/kernel.h>
+
+/* PCIE link regs */
+#define S2_PCIE_LINK_D000	0xd000
+#define S2_PCIE_LINK_D120	0xd120
+#define S2_PCIE_LINK_D124	0xd124
+#define S2_PCIE_LINK_D128	0xd128
+#define S2_PCIE_LINK_D12C	0xd12c
+
+/* Unknown */
+#define S2_D104			0xd104
+#define S2_D108			0xd108
+
+/* These are written to 0x203 before DDR soc init */
+#define S2_DDR_REG_1100		0x1100
+#define S2_DDR_REG_1104		0x1104
+#define S2_DDR_REG_1108		0x1108
+#define S2_DDR_REG_110C		0x110c
+#define S2_DDR_REG_1110		0x1110
+#define S2_DDR_REG_1114		0x1114
+#define S2_DDR_REG_1118		0x1118
+#define S2_DDR_REG_111C		0x111c
+
+#define S2_PLL_REFCLK		0x04
+#define S2_PLL_REFCLK_25MHZ	(1 << 3) /* 1 = 25MHz, 0 = 24MHz */
+
+#define S2_PLL_CMU_STATUS	0x0c	/* Register is called CMU_R_PLL_STS_MEMADDR */
+#define S2_PLL_CMU_STATUS_LOCKED (1 << 15) /* 1 = PLL locked, 0 = PLL not locked */
+
+#define S2_PLL_STATUS_A8	0xa8
+#define S2_PLL_BYPASS		(1 << 0) /* 1 = bypass, 0 = non-bypass */
+
+#define S2_PLL_CTRL_14		0x0014
+#define S2_PLL_CTRL_20		0x0020
+#define S2_PLL_CTRL_24		0x0024
+#define S2_PLL_CTRL_2C		0x002c
+#define S2_PLL_CTRL_9C		0x009c
+#define S2_PLL_CTRL_100		0x0100
+#define S2_PLL_CTRL_510		0x0510
+
+/* Probably DDR PHY PLL registers */
+#define S2_DDR_2004			0x2004
+#define S2_DDR_2008			0x2008
+#define S2_DDR_2014			0x2014
+#define S2_DDR_STATUS_2018		0x2018
+#define S2_DDR_STATUS_BUSY		(1 << 0)
+
+#define S2_DDR_20A0			0x20a0
+#define S2_DDR_20A4			0x20a4
+#define S2_DDR_20A8			0x20a8
+#define S2_DDR_20B0			0x20b0
+
+#define S2_20F8				0x20f8
+#define S2_DDR_2118			0x2118
+
+#define S2_2424				0x2424
+#define S2_2430				0x2430
+#define S2_2434				0x2434
+#define S2_2438				0x2438
+
+/* PLL for stage 2 */
+#define S2_DDR_PLL_STATUS_241C		0x241c
+#define S2_DDR_PLL_STATUS_241C_LOCKED	(1 << 10)
+
+/* PLL for stage 1 */
+#define S2_DDR_PLL_STATUS_2444		0x2444
+#define S2_DDR_PLL_STATUS_2444_LOCKED	(1 << 13)
+
+/*
+ * These registers must be saved and restored across suspend/resume
+ * FIXME: Double check these
+ */
+static const u32 fthd_ddr_phy_reg_map[] = {
+	0x0000, 0x0004, 0x0010, 0x0014, 0x0018, 0x001c, 0x0020, 0x0030,
+	0x0034, 0x0038, 0x003c, 0x0040, 0x0044, 0x0048, 0x004c, 0x0050,
+	0x0054, 0x0058, 0x005c, 0x0060, 0x0064, 0x0068, 0x006c, 0x0070,
+	0x0074, 0x0078, 0x007c, 0x0080, 0x0084, 0x0090, 0x0094, 0x0098,
+	0x009c, 0x00a0, 0x00a4, 0x00b0, 0x00b4, 0x00b8, 0x00bc, 0x00c0,
+	0x0200, 0x0204, 0x0208, 0x020c, 0x0210, 0x0214, 0x0218, 0x021c,
+	0x0220, 0x0224, 0x0228, 0x022c, 0x0230, 0x0234, 0x0238, 0x023c,
+	0x0240, 0x0244, 0x0248, 0x024c, 0x0250, 0x0254, 0x0258, 0x025c,
+	0x0260, 0x0264, 0x0268, 0x026c, 0x0270, 0x0274, 0x02a4, 0x02a8,
+	0x02ac, 0x02b0, 0x02b4, 0x02b8, 0x02bc, 0x02c0, 0x02c4, 0x02c8,
+	0x02cc, 0x02d0, 0x02d4, 0x02d8, 0x02dc, 0x02e0, 0x02e4, 0x02e8,
+	0x02ec, 0x02f0, 0x02f4, 0x02f8, 0x02fc, 0x0300, 0x0304, 0x0308,
+	0x030c, 0x0310, 0x0314, 0x0328, 0x032c, 0x0330, 0x0334, 0x0338,
+	0x033c, 0x0348, 0x034c, 0x0350, 0x0354, 0x0358, 0x035c, 0x0360,
+	0x0364, 0x0370, 0x0374, 0x0378, 0x037c, 0x0380, 0x0384, 0x0388,
+	0x038c, 0x0390, 0x0394, 0x03a0, 0x03a4, 0x03a8, 0x03ac,
+};
+
+#define DDR_PHY_NUM_REG ARRAY_SIZE(fthd_ddr_phy_reg_map)
+#define DDR_PHY_REG_BASE		0x2800
+
+/* DDR40 */
+#define S2_DDR40_PHY_PLL_STATUS		0x2810
+#define S2_DDR40_PHY_PLL_STATUS_LOCKED	(1 << 0)
+#define S2_DDR40_PHY_PLL_CFG		0x2814
+#define S2_DDR40_PHY_PLL_DIV		0x281c
+#define S2_DDR40_PHY_AUX_CTL		0x2820
+
+#define S2_DDR40_PHY_VDL_OVR_COARSE	0x2830
+#define S2_DDR40_PHY_VDL_OVR_FINE	0x2834
+
+#define S2_DDR40_PHY_ZQ_PVT_COMP_CTL	0x283c
+#define S2_DDR40_PHY_DRV_PAD_CTL	0x2840
+
+#define S2_DDR40_PHY_VDL_CTL		0x2848
+
+#define S2_DDR40_PHY_VDL_STATUS		0x284c
+#define S2_DDR40_PHY_VDL_STEP_MASK	0x0ffc
+#define S2_DDR40_PHY_VDL_STEP_SHIFT	2
+
+#define S2_DDR40_PHY_DQ_CALIB_STATUS	0x2850
+#define S2_DDR40_PHY_VDL_CHAN_STATUS	0x2854
+
+#define S2_DDR40_PHY_VTT_CTL		0x285c
+#define S2_DDR40_PHY_VTT_STATUS		0x2860
+#define S2_DDR40_PHY_VTT_CONNECTIONS	0x2864
+#define S2_DDR40_PHY_VTT_OVERRIDE	0x2868
+
+#define S2_DDR40_STRAP_CTL		0x28b0
+#define S2_DDR40_STRAP_CTL_2		0x28b4
+#define S2_DDR40_STRAP_STATUS		0x28b8
+
+/* FIXME: Come up with a better name */
+#define S2_DDR40_BYTE_LANE_SIZE		0xa0
+#define S2_DDR40_NUM_BYTE_LANES		2
+
+#define S2_DDR40_RDEN_BYTE		0x2a00
+#define S2_DDR40_2A08			0x2a08
+#define S2_DDR40_2A0C			0x2a0c
+#define S2_DDR40_2A10			0x2a10
+#define S2_DDR40_2A34			0x2a34
+#define S2_DDR40_2A38			0x2a38
+#define S2_DDR40_RDEN_BYTE0		0x2a74
+#define S2_DDR40_2AA8			0x2aa8
+#define S2_DDR40_2AAC			0x2aac
+#define S2_DDR40_RDEN_BYTE1		0x2b14
+#define S2_DDR40_WL_RD_DATA_DLY		0x2b60
+#define S2_DDR40_WL_READ_CTL		0x2b64
+#define S2_DDR40_WL_READ_FIFO_STATUS	0x2b90
+#define S2_DDR40_WL_READ_FIFO_CLEAR	0x2b94
+#define S2_DDR40_WL_DRV_PAD_CTL		0x2ba4
+#define S2_DDR40_WL_CLK_PAD_DISABLE	0x2ba8
+#define S2_DDR40_WL_IDLE_PAD_CTL	0x2ba0
+#define S2_DDR40_WL_WR_PREAMBLE_MODE	0x2bac
+
+#define S2_3200				0x3200
+#define S2_3204				0x3204
+#define S2_3208				0x3208
+
+/* On iomem with pointer at 0x0ff0 (Bar 4: 1MB) */
+#define ISP_FW_CHAN_CTRL	0xc3000
+#define ISP_FW_QUEUE_CTRL	0xc3004
+#define ISP_FW_SIZE		0xc3008
+#define ISP_FW_HEAP_SIZE	0xc300c
+#define ISP_FW_HEAP_ADDR	0xc3010
+#define ISP_FW_HEAP_SIZE2	0xc3014
+#define ISP_REG_C3018		0xc3018 /* Module params or cmd buf? */
+#define ISP_REG_C301C		0xc301c
+#define ISP_REG_40004		0x40004
+#define ISP_REG_40008		0x40008
+#define ISP_IRQ_STATUS		0x41000
+#define ISP_IRQ_ENABLE		0x41004
+#define ISP_REG_41020		0x41020
+#define ISP_IRQ_CLEAR		0x41024
+
+#define ISP_FW_CHAN_START	0x0128
+#define ISP_FW_CHAN_END		0x0220
+
+#endif
diff --git a/drivers/custom/facetimehd/fthd_ringbuf.c b/drivers/custom/facetimehd/fthd_ringbuf.c
new file mode 100644
index 000000000000..7b099ae56379
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_ringbuf.c
@@ -0,0 +1,135 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_ringbuf.h"
+#include "fthd_isp.h"
+
+u32 get_entry_addr(struct fthd_private *dev_priv,
+			  struct fw_channel *chan, int num)
+{
+	return chan->offset + num * FTHD_RINGBUF_ENTRY_SIZE;
+}
+
+void fthd_channel_ringbuf_dump(struct fthd_private *dev_priv, struct fw_channel *chan)
+{
+	u32 entry;
+	char pos;
+	int i;
+
+	for( i = 0; i < chan->size; i++) {
+		if (chan->ringbuf.idx == i)
+			pos = '*';
+		else
+			pos = ' ';
+		entry = get_entry_addr(dev_priv, chan, i);
+	    pr_debug("%s: %c%3.3d: ADDRESS %08x REQUEST_SIZE %08x RESPONSE_SIZE %08x\n",
+		     chan->name, pos, i,
+		     FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS),
+		     FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_REQUEST_SIZE),
+		     FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_RESPONSE_SIZE));
+	}
+}
+
+void fthd_channel_ringbuf_init(struct fthd_private *dev_priv, struct fw_channel *chan)
+{
+	u32 entry;
+	int i;
+
+	chan->ringbuf.idx = 0;
+
+	if (chan->type == RINGBUF_TYPE_H2T) {
+		pr_debug("clearing ringbuf %s at %08x (size %d)\n",
+			 chan->name, chan->offset, chan->size);
+
+		spin_lock_irq(&chan->lock);
+		for(i = 0; i < chan->size; i++) {
+			entry = get_entry_addr(dev_priv, chan, i);
+			FTHD_S2_MEM_WRITE(1, entry + FTHD_RINGBUF_ADDRESS_FLAGS);
+			FTHD_S2_MEM_WRITE(0, entry + FTHD_RINGBUF_REQUEST_SIZE);
+			FTHD_S2_MEM_WRITE(0, entry + FTHD_RINGBUF_RESPONSE_SIZE);
+			entry += FTHD_RINGBUF_ENTRY_SIZE;
+		}
+		spin_unlock_irq(&chan->lock);
+	}
+}
+
+int fthd_channel_ringbuf_send(struct fthd_private *dev_priv, struct fw_channel *chan,
+			      u32 data_offset, u32 request_size, u32 response_size, u32 *entryp)
+{
+	u32 entry;
+
+	pr_debug("send %08x\n", data_offset);
+
+	spin_lock_irq(&chan->lock);
+	entry = get_entry_addr(dev_priv, chan, chan->ringbuf.idx);
+
+	if (++chan->ringbuf.idx >= chan->size)
+		chan->ringbuf.idx = 0;
+
+	if (!(FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS) & 1) ^ (chan->type != 0)) {
+		spin_unlock_irq(&chan->lock);
+		return -EAGAIN;
+	}
+
+	FTHD_S2_MEM_WRITE(request_size, entry + FTHD_RINGBUF_REQUEST_SIZE);
+	FTHD_S2_MEM_WRITE(response_size, entry + FTHD_RINGBUF_RESPONSE_SIZE);
+	wmb();
+	FTHD_S2_MEM_WRITE(data_offset | (chan->type == 0 ? 0 : 1),
+			  entry + FTHD_RINGBUF_ADDRESS_FLAGS);
+	spin_unlock_irq(&chan->lock);
+
+	spin_lock_irq(&dev_priv->io_lock);
+	FTHD_ISP_REG_WRITE(0x10 << chan->source, ISP_REG_41020);
+	spin_unlock_irq(&dev_priv->io_lock);
+	if (entryp)
+		*entryp = entry;
+	return 0;
+}
+
+u32 fthd_channel_ringbuf_receive(struct fthd_private *dev_priv,
+							struct fw_channel *chan)
+{
+	u32 entry, ret = (u32)-1;
+
+	spin_lock_irq(&chan->lock);
+
+	entry = get_entry_addr(dev_priv, chan, chan->ringbuf.idx);
+
+
+	if (!(FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS) & 1) ^ (chan->type != 0))
+		goto out;
+
+	ret = entry;
+
+	if (chan->type == FW_CHAN_TYPE_OUT && ++chan->ringbuf.idx >= chan->size)
+		chan->ringbuf.idx = 0;
+
+out:
+	spin_unlock_irq(&chan->lock);
+	return ret;
+}
+
+int fthd_channel_wait_ready(struct fthd_private *dev_priv, struct fw_channel *chan, u32 entry, int timeout)
+{
+	if (wait_event_interruptible_timeout(chan->wq,
+					     (FTHD_S2_MEM_READ(entry + FTHD_RINGBUF_ADDRESS_FLAGS) & 1) ^ (chan->type != 0),
+		msecs_to_jiffies(timeout)) <= 0) {
+		dev_err(&dev_priv->pdev->dev, "%s: timeout\n", chan->name);
+		fthd_channel_ringbuf_dump(dev_priv, chan);
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
diff --git a/drivers/custom/facetimehd/fthd_ringbuf.h b/drivers/custom/facetimehd/fthd_ringbuf.h
new file mode 100644
index 000000000000..a59fb5e0e21c
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_ringbuf.h
@@ -0,0 +1,44 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#ifndef _FTHD_RINGBUF_H
+#define _FTHD_RINGBUF_H
+
+#define FTHD_RINGBUF_ENTRY_SIZE 64
+
+#define FTHD_RINGBUF_ADDRESS_FLAGS 0
+#define FTHD_RINGBUF_REQUEST_SIZE 4
+#define FTHD_RINGBUF_RESPONSE_SIZE 8
+
+enum ringbuf_type_t {
+	RINGBUF_TYPE_H2T=0,
+	RINGBUF_TYPE_T2H=1,
+	RINGBUF_TYPE_UNIDIRECTIONAL,
+};
+
+struct fthd_ringbuf {
+	void *doorbell;
+	int idx;
+};
+
+struct fw_channel;
+struct fthd_private;
+extern void fthd_channel_ringbuf_dump(struct fthd_private *dev_priv, struct fw_channel *chan);
+extern void fthd_channel_ringbuf_init(struct fthd_private *dev_priv, struct fw_channel *chan);
+extern u32 fthd_channel_ringbuf_get_entry(struct fthd_private *, struct fw_channel *);
+extern int fthd_channel_ringbuf_send(struct fthd_private *dev_priv, struct fw_channel *chan,
+				     u32 data_offset, u32 request_size, u32 response_size, u32 *entry);
+
+extern u32 fthd_channel_ringbuf_receive(struct fthd_private *dev_priv,
+					struct fw_channel *chan);
+
+extern int fthd_channel_wait_ready(struct fthd_private *dev_priv, struct fw_channel *chan, u32 entry, int timeout);
+extern u32 get_entry_addr(struct fthd_private *dev_priv,
+			  struct fw_channel *chan, int num);
+#endif
diff --git a/drivers/custom/facetimehd/fthd_v4l2.c b/drivers/custom/facetimehd/fthd_v4l2.c
new file mode 100644
index 000000000000..a3974a2c988d
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_v4l2.c
@@ -0,0 +1,760 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-event.h>
+#include <media/videobuf2-dma-sg.h>
+#include "fthd_drv.h"
+#include "fthd_hw.h"
+#include "fthd_isp.h"
+#include "fthd_ringbuf.h"
+#include "fthd_buffer.h"
+
+#define FTHD_MAX_WIDTH 1280
+#define FTHD_MAX_HEIGHT 720
+#define FTHD_MIN_WIDTH 320
+#define FTHD_MIN_HEIGHT 240
+#define FTHD_NUM_FORMATS 2 /* NV16 is disabled for now */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 7, 0)
+# define VFL_TYPE_VIDEO VFL_TYPE_GRABBER
+#endif
+
+static int fthd_buffer_queue_setup(
+    struct vb2_queue *vq,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0)
+    const struct v4l2_format *fmt,
+#endif
+#if !(LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0))
+    const void *parg,
+#endif
+    unsigned int *nbuffers,
+    unsigned int *nplanes,
+    unsigned int sizes[],
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+    struct device *alloc_devs[]
+#else
+    void *alloc_ctxs[]
+#endif
+) {
+
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vq);
+	struct v4l2_pix_format *cur_fmt = &dev_priv->fmt.fmt;
+	int i, total_size = 0;
+
+	if (*nplanes)
+		return sizes[0] < (cur_fmt->bytesperline * cur_fmt->height) ? -EINVAL : 0;
+
+	*nplanes = dev_priv->fmt.planes;
+
+	if (!*nplanes)
+		return -EINVAL;
+
+	/* FIXME: We assume single plane format here but not below */
+	for (i = 0; i < *nplanes; i++) {
+		sizes[i] = cur_fmt->sizeimage;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,8,0)
+		alloc_devs[i] = &dev_priv->pdev->dev;
+#else
+		alloc_ctxs[i] = dev_priv->alloc_ctx;
+#endif
+		total_size += sizes[i];
+	}
+
+	*nbuffers = (4096 * 4096) / total_size;
+	if (*nbuffers > 4)
+		*nbuffers = 4;
+	if (*nbuffers <= 1)
+		return -ENOMEM;
+	pr_debug("using %d buffers\n", *nbuffers);
+
+	return 0;
+}
+
+static void fthd_buffer_cleanup(struct vb2_buffer *vb)
+{
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vb->vb2_queue);
+	struct h2t_buf_ctx *ctx = NULL;
+	int i;
+
+	pr_debug("%p\n", vb);
+	for(i = 0; i < FTHD_BUFFERS; i++) {
+		if (dev_priv->h2t_bufs[i].vb == vb) {
+			ctx = dev_priv->h2t_bufs + i;
+			break;
+		};
+	}
+	if (!ctx || ctx->state == BUF_FREE)
+		return;
+
+	ctx->state = BUF_FREE;
+	ctx->vb = NULL;
+	isp_mem_destroy(ctx->dma_desc_obj);
+	for(i = 0; i < dev_priv->fmt.planes; i++) {
+		iommu_free(dev_priv, ctx->plane[i]);
+		ctx->plane[i] = NULL;
+	}
+	ctx->dma_desc_obj = NULL;
+}
+
+static int fthd_send_h2t_buffer(struct fthd_private *dev_priv, struct h2t_buf_ctx *ctx)
+{
+	u32 entry;
+	int ret;
+
+	pr_debug("sending buffer %p size %ld, ctx %p\n", ctx->vb, sizeof(ctx->dma_desc_list), ctx);
+	FTHD_S2_MEMCPY_TOIO(ctx->dma_desc_obj->offset, &ctx->dma_desc_list, sizeof(ctx->dma_desc_list));
+	ret = fthd_channel_ringbuf_send(dev_priv, dev_priv->channel_buf_h2t,
+					ctx->dma_desc_obj->offset, 0x180, 0x30000000, &entry);
+
+	if (ret) {
+		pr_err("%s: fthd_channel_ringbuf_send: %d\n", __FUNCTION__, ret);
+		return ret;
+	}
+	return fthd_channel_wait_ready(dev_priv, dev_priv->channel_buf_h2t, entry, 2000);
+}
+
+static void fthd_buffer_queue(struct vb2_buffer *vb)
+{
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vb->vb2_queue);
+	struct dma_descriptor_list *list;
+	struct h2t_buf_ctx *ctx = NULL;
+
+	int i;
+	pr_debug("vb = %p\n", vb);
+	for(i = 0; i < FTHD_BUFFERS; i++) {
+		if (dev_priv->h2t_bufs[i].vb == vb) {
+			ctx = dev_priv->h2t_bufs + i;
+			break;
+		};
+	}
+
+	if (!ctx)
+		return;
+
+	if (ctx->state != BUF_ALLOC)
+		return;
+
+	if (!vb->vb2_queue->streaming) {
+		ctx->state = BUF_DRV_QUEUED;
+	} else {
+		list = &ctx->dma_desc_list;
+		list->field0 = 1;
+		ctx->state = BUF_HW_QUEUED;
+		wmb();
+		pr_debug("%d: field0: %d, count %d, pool %d, addr0 0x%08x, addr1 0x%08x tag 0x%08llx vb = %p\n", i, list->field0,
+			 list->desc[i].count, list->desc[i].pool, list->desc[i].addr0, list->desc[i].addr1, list->desc[i].tag, ctx->vb);
+
+		if (fthd_send_h2t_buffer(dev_priv, ctx)) {
+			vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
+			ctx->state = BUF_ALLOC;
+		}
+	}
+	return;
+}
+
+static int fthd_buffer_prepare(struct vb2_buffer *vb)
+{
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vb->vb2_queue);
+	struct sg_table *sgtable;
+	struct h2t_buf_ctx *ctx = NULL;
+	struct dma_descriptor_list *dma_list;
+	int i;
+
+	pr_debug("%p\n", vb);
+	for(i = 0; i < FTHD_BUFFERS; i++) {
+		if (dev_priv->h2t_bufs[i].state == BUF_FREE ||
+		    (dev_priv->h2t_bufs[i].state == BUF_ALLOC && dev_priv->h2t_bufs[i].vb == vb)) {
+			ctx = dev_priv->h2t_bufs + i;
+			break;
+		}
+	}
+
+	if (!ctx)
+		return -ENOBUFS;
+
+	if (ctx->state == BUF_FREE) {
+		pr_debug("allocating new entry\n");
+		ctx->dma_desc_obj = isp_mem_create(dev_priv, FTHD_MEM_BUFFER, 0x180);
+		if (!ctx->dma_desc_obj)
+			return -ENOMEM;
+
+		ctx->vb = vb;
+		ctx->state = BUF_ALLOC;
+
+		for(i = 0; i < dev_priv->fmt.planes; i++) {
+		  sgtable = vb2_dma_sg_plane_desc(vb, i);
+		  ctx->plane[i] = iommu_allocate_sgtable(dev_priv, sgtable);
+		  if(!ctx->plane[i])
+			  return -ENOMEM;
+		}
+	}
+
+	vb2_set_plane_payload(vb, 0, dev_priv->fmt.fmt.sizeimage);
+
+	dma_list = &ctx->dma_desc_list;
+	memset(dma_list, 0, 0x180);
+
+	dma_list->field0 = 1;
+	dma_list->count = 1;
+	dma_list->desc[0].count = 1;
+	dma_list->desc[0].pool = 0x02;
+	dma_list->desc[0].addr0 = (ctx->plane[0]->offset << 12) | 0xc0000000;
+
+	if (dev_priv->fmt.planes >= 2)
+		dma_list->desc[0].addr1 = (ctx->plane[1]->offset << 12) | 0xc0000000;
+	if (dev_priv->fmt.planes >= 3)
+		dma_list->desc[0].addr2 = (ctx->plane[2]->offset << 12) | 0xc0000000;
+
+	dma_list->desc[0].tag = (u64)ctx;
+	init_waitqueue_head(&ctx->wq);
+	return 0;
+}
+
+void fthd_buffer_return_handler(struct fthd_private *dev_priv, u32 offset, int size)
+{
+	struct dma_descriptor_list list;
+	struct h2t_buf_ctx *ctx;
+	int i;
+
+	FTHD_S2_MEMCPY_FROMIO(&list, offset, sizeof(list));
+
+	for(i = 0; i < list.count; i++) {
+		ctx = (struct h2t_buf_ctx *)list.desc[i].tag;
+		pr_debug("%d: field0: %d, count %d, pool %d, addr0 0x%08x, addr1 0x%08x tag 0x%08llx vb = %p, ctx = %p\n", i, list.field0,
+			 list.desc[i].count, list.desc[i].pool, list.desc[i].addr0, list.desc[i].addr1, list.desc[i].tag, ctx->vb, ctx);
+
+		if (ctx->state == BUF_HW_QUEUED || ctx->state == BUF_DRV_QUEUED) {
+			ctx->state = BUF_ALLOC;
+			vb2_buffer_done(ctx->vb, VB2_BUF_STATE_DONE);
+		}
+
+	}
+}
+
+static int fthd_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vq);
+	struct h2t_buf_ctx *ctx;
+	int i, ret;
+
+	pr_debug("count = %d\n", count);
+	ret = fthd_start_channel(dev_priv, 0);
+	if (ret)
+		return ret;
+
+	for(i = 0; i < FTHD_BUFFERS && count; i++, count--) {
+		ctx = dev_priv->h2t_bufs + i;
+		if (ctx->state != BUF_DRV_QUEUED)
+			continue;
+
+		if (fthd_send_h2t_buffer(dev_priv, ctx)) {
+			vb2_buffer_done(ctx->vb, VB2_BUF_STATE_ERROR);
+			ctx->state = BUF_ALLOC;
+		}
+			ctx->state = BUF_HW_QUEUED;
+	}
+	return 0;
+}
+
+static void fthd_stop_streaming(struct vb2_queue *vq)
+{
+	struct fthd_private *dev_priv = vb2_get_drv_priv(vq);
+	struct h2t_buf_ctx *ctx;
+	int ret, i;
+
+	ret = fthd_stop_channel(dev_priv, 0);
+	if (!ret) {
+		pr_debug("waiting for buffers...\n");
+		vb2_wait_for_all_buffers(vq);
+		pr_debug("done\n");
+	} else {
+	    /* Firmware doesn't respond. */
+	    for(i = 0; i < FTHD_BUFFERS;i++) {
+		    ctx = dev_priv->h2t_bufs + i;
+		    if (ctx->state == BUF_DRV_QUEUED || ctx->state == BUF_HW_QUEUED) {
+			    vb2_buffer_done(ctx->vb, VB2_BUF_STATE_DONE);
+			    ctx->vb = NULL;
+			    ctx->state = BUF_ALLOC;
+		}
+	    }
+	}
+}
+
+static struct vb2_ops vb2_queue_ops = {
+	.queue_setup            = fthd_buffer_queue_setup,
+	.buf_prepare            = fthd_buffer_prepare,
+	.buf_cleanup            = fthd_buffer_cleanup,
+	.start_streaming        = fthd_start_streaming,
+	.stop_streaming         = fthd_stop_streaming,
+	.buf_queue              = fthd_buffer_queue,
+	.wait_prepare           = vb2_ops_wait_prepare,
+	.wait_finish            = vb2_ops_wait_finish,
+};
+
+static struct v4l2_file_operations fthd_vdev_fops = {
+	.owner          = THIS_MODULE,
+	.open           = v4l2_fh_open,
+
+	.read		= vb2_fop_read,
+	.release        = vb2_fop_release,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+	.unlocked_ioctl = video_ioctl2
+};
+
+static int fthd_v4l2_ioctl_enum_input(struct file *filp, void *priv,
+				      struct v4l2_input *input)
+{
+	if (input->index != 0)
+		return -EINVAL;
+
+	memset(input, 0, sizeof(*input));
+	strcpy(input->name, "Camera");
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+	input->std = 0;
+
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_g_input(struct file *filp, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_s_input(struct file *filp, void *priv, unsigned int i)
+{
+	if (i != 0)
+		return -EINVAL;
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_querycap(struct file *filp, void *priv,
+				    struct v4l2_capability *cap)
+{
+	struct fthd_private *dev_priv = video_drvdata(filp);
+
+	strcpy(cap->driver, "facetimehd");
+	strcpy(cap->card, "Apple Facetime HD");
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",
+		 pci_name(dev_priv->pdev));
+
+	cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+			   V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_enum_fmt_vid_cap(struct file *filp, void *priv,
+				   struct v4l2_fmtdesc *fmt)
+{
+	char *desc = NULL;
+
+	switch (fmt->index) {
+	case 0:
+		fmt->pixelformat = V4L2_PIX_FMT_YUYV;
+		desc = "YUYV";
+		break;
+	case 1:
+		fmt->pixelformat = V4L2_PIX_FMT_YVYU;
+		desc = "YVYU";
+		break;
+	/* We don't support the mplane yet
+	case 2:
+		fmt->pixelformat = V4L2_PIX_FMT_NV16;
+		desc = "NV16";
+		break;
+	*/
+	default:
+		return -EINVAL;
+	}
+
+	fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	strncpy(fmt->description, desc, sizeof(fmt->description));
+
+	return 0;
+}
+
+static int fthd_v4l2_adjust_format(struct fthd_private *dev_priv,
+				   struct v4l2_pix_format *pix)
+{
+
+	if (pix->pixelformat != V4L2_PIX_FMT_YUYV &&
+	    pix->pixelformat != V4L2_PIX_FMT_YVYU)
+		pix->pixelformat = V4L2_PIX_FMT_YUYV;
+
+	if (pix->width < FTHD_MIN_WIDTH)
+		pix->width = FTHD_MIN_WIDTH;
+	if (pix->width > FTHD_MAX_WIDTH)
+		pix->width = FTHD_MAX_WIDTH;
+	if (pix->height < FTHD_MIN_HEIGHT)
+		pix->height = FTHD_MIN_HEIGHT;
+	if (pix->height > FTHD_MAX_HEIGHT)
+		pix->height = FTHD_MAX_HEIGHT;
+
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	pix->field = V4L2_FIELD_NONE;
+	pix->width = ALIGN(pix->width, 7);
+
+	switch (pix->pixelformat) {
+/*
+	case V4L2_PIX_FMT_NV16:
+		pix->sizeimage = pix->width * pix->height;
+		pix->bytesperline = pix->width;
+		break;
+*/
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+	default:
+		pix->bytesperline = pix->width * 2;
+		pix->sizeimage = pix->bytesperline * pix->height;
+		break;
+	}
+
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_try_fmt_vid_cap(struct file *filp, void *_priv,
+					   struct v4l2_format *fmt)
+{
+	struct fthd_private *dev_priv = video_drvdata(filp);
+
+	pr_debug("%s: %dx%d\n", __FUNCTION__, fmt->fmt.pix.width, fmt->fmt.pix.height);
+
+	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	return fthd_v4l2_adjust_format(dev_priv, &fmt->fmt.pix);
+}
+
+static int fthd_v4l2_ioctl_g_fmt_vid_cap(struct file *filp, void *priv,
+					 struct v4l2_format *fmt)
+{
+	struct fthd_private *dev_priv = video_drvdata(filp);
+
+	pr_debug("%s\n", __FUNCTION__);
+	fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fmt->fmt.pix = dev_priv->fmt.fmt;
+
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_s_fmt_vid_cap(struct file *filp, void *priv,
+					 struct v4l2_format *fmt)
+{
+	struct fthd_private *dev_priv = video_drvdata(filp);
+	int ret;
+
+	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	/* FIXME: Check if hardware is busy */
+
+	ret = fthd_v4l2_adjust_format(dev_priv, &fmt->fmt.pix);
+	if (ret)
+		return ret;
+
+	pr_debug("%c%c%c%c\n", fmt->fmt.pix.pixelformat, fmt->fmt.pix.pixelformat >> 8,
+		 fmt->fmt.pix.pixelformat >> 16, fmt->fmt.pix.pixelformat >> 24);
+
+	dev_priv->fmt.fmt = fmt->fmt.pix;
+
+	switch (fmt->fmt.pix.pixelformat) {
+	case V4L2_PIX_FMT_NV16:
+		dev_priv->fmt.planes = 2;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_YVYU:
+		dev_priv->fmt.planes = 1;
+		break;
+	}
+
+	return 0;
+}
+
+
+static int fthd_v4l2_ioctl_g_parm(struct file *filp, void *priv,
+		struct v4l2_streamparm *parm)
+{
+        struct fthd_private *priv_dev = video_drvdata(filp);
+	struct v4l2_fract timeperframe = {
+		.numerator = priv_dev->frametime,
+		.denominator = 1000,
+	};
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	parm->parm.capture.readbuffers = FTHD_BUFFERS;
+	parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	parm->parm.capture.timeperframe = timeperframe;
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_s_parm(struct file *filp, void *priv,
+		struct v4l2_streamparm *parm)
+{
+
+        struct fthd_private *dev_priv = video_drvdata(filp);
+	struct v4l2_fract *timeperframe;
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	timeperframe = &parm->parm.capture.timeperframe;
+
+	if(timeperframe->denominator == 0) {
+		timeperframe->numerator = 20;
+		timeperframe->denominator = 1000;
+	}
+
+	dev_priv->frametime = clamp_t(unsigned int, timeperframe->numerator * 1000 /
+				timeperframe->denominator, 20, 500);
+
+	return fthd_v4l2_ioctl_g_parm(filp, priv, parm);
+}
+
+static int fthd_v4l2_ioctl_enum_framesizes(struct file *filp, void *priv,
+		struct v4l2_frmsizeenum *sizes)
+{
+	if (sizes->index)
+		return -EINVAL;
+
+	if (sizes->pixel_format != V4L2_PIX_FMT_YUYV &&
+	    sizes->pixel_format != V4L2_PIX_FMT_YVYU)
+		return -EINVAL;
+
+	sizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	sizes->discrete.width = FTHD_MAX_WIDTH;
+	sizes->discrete.height = FTHD_MAX_HEIGHT;
+
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_enum_frameintervals(struct file *filp, void *priv,
+		struct v4l2_frmivalenum *interval)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	if (interval->index)
+		return -EINVAL;
+
+	if (interval->pixel_format != V4L2_PIX_FMT_YUYV &&
+	    interval->pixel_format != V4L2_PIX_FMT_YVYU &&
+	    interval->pixel_format != V4L2_PIX_FMT_NV16)
+		return -EINVAL;
+
+	if (interval->width & 7
+	    || interval->width > FTHD_MAX_WIDTH
+	    || interval->height > FTHD_MAX_HEIGHT)
+		return -EINVAL;
+
+	interval->type = V4L2_FRMIVAL_TYPE_DISCRETE;
+	interval->discrete.numerator = 1;
+	interval->discrete.denominator = 30;
+
+	return 0;
+}
+
+static int fthd_v4l2_ioctl_subscribe_event(struct v4l2_fh *fh,
+		const struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subscribe_event(fh, sub);
+	}
+
+	return -EINVAL;
+}
+
+static struct v4l2_ioctl_ops fthd_ioctl_ops = {
+	.vidioc_enum_input      = fthd_v4l2_ioctl_enum_input,
+	.vidioc_g_input         = fthd_v4l2_ioctl_g_input,
+	.vidioc_s_input         = fthd_v4l2_ioctl_s_input,
+	.vidioc_enum_fmt_vid_cap = fthd_v4l2_ioctl_enum_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap = fthd_v4l2_ioctl_try_fmt_vid_cap,
+
+	.vidioc_g_fmt_vid_cap   = fthd_v4l2_ioctl_g_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap   = fthd_v4l2_ioctl_s_fmt_vid_cap,
+	.vidioc_querycap        = fthd_v4l2_ioctl_querycap,
+
+
+        .vidioc_reqbufs         = vb2_ioctl_reqbufs,
+	.vidioc_create_bufs     = vb2_ioctl_create_bufs,
+	.vidioc_querybuf        = vb2_ioctl_querybuf,
+	.vidioc_qbuf            = vb2_ioctl_qbuf,
+	.vidioc_dqbuf           = vb2_ioctl_dqbuf,
+	.vidioc_expbuf          = vb2_ioctl_expbuf,
+	.vidioc_streamon        = vb2_ioctl_streamon,
+	.vidioc_streamoff       = vb2_ioctl_streamoff,
+
+	.vidioc_g_parm          = fthd_v4l2_ioctl_g_parm,
+	.vidioc_s_parm          = fthd_v4l2_ioctl_s_parm,
+	.vidioc_enum_framesizes = fthd_v4l2_ioctl_enum_framesizes,
+	.vidioc_enum_frameintervals = fthd_v4l2_ioctl_enum_frameintervals,
+
+	.vidioc_subscribe_event	= fthd_v4l2_ioctl_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+};
+
+static int fthd_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	pr_debug("id = %x\n", ctrl->id);
+	return -EINVAL;
+}
+
+static int fthd_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct fthd_private *dev_priv = container_of(ctrl->handler, struct fthd_private, v4l2_ctrl_handler);
+	int ret = -EINVAL;
+
+	pr_info("id = %x, val = %d\n", ctrl->id, ctrl->val);
+
+	switch(ctrl->id) {
+	case V4L2_CID_CONTRAST:
+		ret = fthd_isp_cmd_channel_contrast_set(dev_priv, 0, ctrl->val);
+		break;
+	case V4L2_CID_BRIGHTNESS:
+		ret = fthd_isp_cmd_channel_brightness_set(dev_priv, 0, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = fthd_isp_cmd_channel_saturation_set(dev_priv, 0, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = fthd_isp_cmd_channel_hue_set(dev_priv, 0, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = fthd_isp_cmd_channel_awb(dev_priv, 0, ctrl->val);
+
+	default:
+		break;
+
+	}
+	pr_debug("ret = %d\n", ret);
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops fthd_ctrl_ops = {
+	.g_volatile_ctrl = fthd_g_volatile_ctrl,
+	.s_ctrl = fthd_s_ctrl,
+};
+
+int fthd_v4l2_register(struct fthd_private *dev_priv)
+{
+	struct v4l2_device *v4l2_dev = &dev_priv->v4l2_dev;
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	int ret;
+
+	ret = v4l2_device_register(&dev_priv->pdev->dev, v4l2_dev);
+	if (ret) {
+		pr_err("v4l2_device_register: %d\n", ret);
+		return ret;
+	}
+
+	vdev = video_device_alloc();
+	if (!vdev) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+	dev_priv->videodev = vdev;
+
+	q = &dev_priv->vb2_queue;
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;
+	q->drv_priv = dev_priv;
+	q->ops = &vb2_queue_ops;
+	q->mem_ops = &vb2_dma_sg_memops;
+	q->buf_struct_size = 0;//sizeof(struct vpif_cap_buffer);
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6,8,0)
+	q->min_buffers_needed = 1;
+#else
+	q->min_queued_buffers = 1;
+#endif
+	q->lock = &dev_priv->vb2_queue_lock;
+
+	ret = vb2_queue_init(q);
+	if (ret)
+		goto fail;
+
+	v4l2_ctrl_handler_init(&dev_priv->v4l2_ctrl_handler, 4);
+	v4l2_ctrl_new_std(&dev_priv->v4l2_ctrl_handler, &fthd_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x80);
+	v4l2_ctrl_new_std(&dev_priv->v4l2_ctrl_handler, &fthd_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 0xff, 1, 0x80);
+	v4l2_ctrl_new_std(&dev_priv->v4l2_ctrl_handler, &fthd_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0x80);
+	v4l2_ctrl_new_std(&dev_priv->v4l2_ctrl_handler, &fthd_ctrl_ops,
+			  V4L2_CID_HUE, 0, 0xff, 1, 0x80);
+	v4l2_ctrl_new_std(&dev_priv->v4l2_ctrl_handler, &fthd_ctrl_ops,
+			  V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, 1);
+
+	if (dev_priv->v4l2_ctrl_handler.error) {
+		pr_err("failed to setup control handlers\n");
+		v4l2_ctrl_handler_free(&dev_priv->v4l2_ctrl_handler);
+		goto fail;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	dev_priv->alloc_ctx = vb2_dma_sg_init_ctx(&dev_priv->pdev->dev);
+#endif
+	vdev->v4l2_dev = v4l2_dev;
+	strcpy(vdev->name, "Apple Facetime HD"); // XXX: Length?
+	vdev->vfl_dir = VFL_DIR_RX;
+	vdev->fops = &fthd_vdev_fops;
+	vdev->ioctl_ops = &fthd_ioctl_ops;
+	vdev->queue = q;
+	vdev->release = video_device_release;
+	vdev->ctrl_handler = &dev_priv->v4l2_ctrl_handler;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+	vdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |
+			    V4L2_CAP_STREAMING;
+#endif
+	video_set_drvdata(vdev, dev_priv);
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
+	if (ret) {
+		video_device_release(vdev);
+		goto fail_vdev;
+	}
+	dev_priv->fmt.fmt.sizeimage = 1280 * 720 * 2;
+	dev_priv->fmt.fmt.pixelformat = V4L2_PIX_FMT_YUYV;
+	dev_priv->fmt.fmt.width = 1280;
+	dev_priv->fmt.fmt.height = 720;
+	dev_priv->fmt.planes = 1;
+
+	fthd_v4l2_adjust_format(dev_priv, &dev_priv->fmt.fmt);
+
+	return 0;
+fail_vdev:
+	v4l2_ctrl_handler_free(&dev_priv->v4l2_ctrl_handler);
+fail:
+	v4l2_device_unregister(&dev_priv->v4l2_dev);
+	return ret;
+}
+
+void fthd_v4l2_unregister(struct fthd_private *dev_priv)
+{
+
+	v4l2_ctrl_handler_free(&dev_priv->v4l2_ctrl_handler);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0)
+	vb2_dma_sg_cleanup_ctx(dev_priv->alloc_ctx);
+#endif
+	video_unregister_device(dev_priv->videodev);
+	v4l2_device_unregister(&dev_priv->v4l2_dev);
+}
diff --git a/drivers/custom/facetimehd/fthd_v4l2.h b/drivers/custom/facetimehd/fthd_v4l2.h
new file mode 100644
index 000000000000..8e4f9d574904
--- /dev/null
+++ b/drivers/custom/facetimehd/fthd_v4l2.h
@@ -0,0 +1,34 @@
+/*
+ * SPDX-License-Identifier: GPL-2.0-only
+ *
+ * FacetimeHD camera driver
+ *
+ * Copyright (C) 2015 Sven Schnelle <svens@stackframe.org>
+ *
+ */
+
+#ifndef _FTHD_V4L2_H
+#define _FTHD_V4L2_H
+
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <media/v4l2-device.h>
+
+struct fthd_fmt {
+	struct v4l2_pix_format fmt;
+	const char *desc;
+	int range; /* CISP_COMMAND_CH_OUTPUT_CONFIG_SET */
+	int planes;
+	int x1; /* for CISP_CMD_CH_CROP_SET */
+	int y1;
+	int x2;
+	int y2;
+};
+
+struct fthd_private;
+extern int fthd_v4l2_register(struct fthd_private *dev_priv);
+extern void fthd_v4l2_unregister(struct fthd_private *dev_priv);
+
+#endif
# ----------------------------------------
# Module: cdemu
# Version: d00300615639
# ----------------------------------------
diff --git a/drivers/custom/cdemu/vhba-module/Makefile b/drivers/custom/cdemu/vhba-module/Makefile
new file mode 100644
index 000000000000..166e43f2f877
--- /dev/null
+++ b/drivers/custom/cdemu/vhba-module/Makefile
@@ -0,0 +1,14 @@
+VHBA_VERSION := 20250329
+
+KERNELRELEASE ?= $(shell uname -r)
+KDIR ?= /lib/modules/$(KERNELRELEASE)/build
+PWD ?= $(shell pwd)
+
+obj-m := vhba.o
+ccflags-y := -DVHBA_VERSION=\"$(VHBA_VERSION)\" -Werror
+
+default: modules
+install: modules_install
+
+modules modules_install clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) $@
diff --git a/drivers/custom/cdemu/vhba-module/debian/vhba-dkms.udev b/drivers/custom/cdemu/vhba-module/debian/vhba-dkms.udev
new file mode 100644
index 000000000000..4be2d714f74b
--- /dev/null
+++ b/drivers/custom/cdemu/vhba-module/debian/vhba-dkms.udev
@@ -0,0 +1 @@
+KERNEL=="vhba_ctl", SUBSYSTEM=="misc", TAG+="uaccess"
diff --git a/drivers/custom/cdemu/vhba-module/vhba.c b/drivers/custom/cdemu/vhba-module/vhba.c
new file mode 100644
index 000000000000..64b09ece2e5a
--- /dev/null
+++ b/drivers/custom/cdemu/vhba-module/vhba.c
@@ -0,0 +1,1132 @@
+/*
+ * vhba.c
+ *
+ * Copyright (C) 2007-2012 Chia-I Wu <olvaffe AT gmail DOT com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#define pr_fmt(fmt) "vhba: " fmt
+
+#include <linux/version.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/highmem.h>
+#include <linux/fs.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#else
+#include <linux/sched.h>
+#endif
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/scatterlist.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#include <asm/uaccess.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_tcq.h>
+
+
+MODULE_AUTHOR("Chia-I Wu");
+MODULE_VERSION(VHBA_VERSION);
+MODULE_DESCRIPTION("Virtual SCSI HBA");
+MODULE_LICENSE("GPL");
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+#define sdev_dbg(sdev, fmt, a...) \
+    dev_dbg(&(sdev)->sdev_gendev, fmt, ##a)
+#define scmd_dbg(scmd, fmt, a...) \
+    dev_dbg(&(scmd)->device->sdev_gendev, fmt, ##a)
+#endif
+
+#define VHBA_MAX_SECTORS_PER_IO 256
+#define VHBA_MAX_BUS 16
+#define VHBA_MAX_ID 16
+#define VHBA_MAX_DEVICES (VHBA_MAX_BUS * (VHBA_MAX_ID-1))
+#define VHBA_KBUF_SIZE PAGE_SIZE
+
+#define DATA_TO_DEVICE(dir) ((dir) == DMA_TO_DEVICE || (dir) == DMA_BIDIRECTIONAL)
+#define DATA_FROM_DEVICE(dir) ((dir) == DMA_FROM_DEVICE || (dir) == DMA_BIDIRECTIONAL)
+
+
+static int vhba_can_queue = 32;
+module_param_named(can_queue, vhba_can_queue, int, 0);
+
+
+enum vhba_req_state {
+    VHBA_REQ_FREE,
+    VHBA_REQ_PENDING,
+    VHBA_REQ_READING,
+    VHBA_REQ_SENT,
+    VHBA_REQ_WRITING,
+};
+
+struct vhba_command {
+    struct scsi_cmnd *cmd;
+    /* metatags are per-host. not to be confused with
+       queue tags that are usually per-lun */
+    unsigned long metatag;
+    int status;
+    struct list_head entry;
+};
+
+struct vhba_device {
+    unsigned int num;
+    spinlock_t cmd_lock;
+    struct list_head cmd_list;
+    wait_queue_head_t cmd_wq;
+    atomic_t refcnt;
+
+    unsigned char *kbuf;
+    size_t kbuf_size;
+};
+
+struct vhba_host {
+    struct Scsi_Host *shost;
+    spinlock_t cmd_lock;
+    int cmd_next;
+    struct vhba_command *commands;
+    spinlock_t dev_lock;
+    struct vhba_device *devices[VHBA_MAX_DEVICES];
+    int num_devices;
+    DECLARE_BITMAP(chgmap, VHBA_MAX_DEVICES);
+    int chgtype[VHBA_MAX_DEVICES];
+    struct work_struct scan_devices;
+};
+
+#define MAX_COMMAND_SIZE 16
+
+struct vhba_request {
+    __u32 metatag;
+    __u32 lun;
+    __u8 cdb[MAX_COMMAND_SIZE];
+    __u8 cdb_len;
+    __u32 data_len;
+};
+
+struct vhba_response {
+    __u32 metatag;
+    __u32 status;
+    __u32 data_len;
+};
+
+
+
+static struct vhba_command *vhba_alloc_command (void);
+static void vhba_free_command (struct vhba_command *vcmd);
+
+static struct platform_device vhba_platform_device;
+
+
+
+/* These functions define a symmetric 1:1 mapping between device numbers and
+   the bus and id. We have reserved the last id per bus for the host itself. */
+static void devnum_to_bus_and_id(unsigned int devnum, unsigned int *bus, unsigned int *id)
+{
+    *bus = devnum / (VHBA_MAX_ID-1);
+    *id  = devnum % (VHBA_MAX_ID-1);
+}
+
+static unsigned int bus_and_id_to_devnum(unsigned int bus, unsigned int id)
+{
+    return (bus * (VHBA_MAX_ID-1)) + id;
+}
+
+static struct vhba_device *vhba_device_alloc (void)
+{
+    struct vhba_device *vdev;
+
+    vdev = kzalloc(sizeof(struct vhba_device), GFP_KERNEL);
+    if (!vdev) {
+        return NULL;
+    }
+
+    spin_lock_init(&vdev->cmd_lock);
+    INIT_LIST_HEAD(&vdev->cmd_list);
+    init_waitqueue_head(&vdev->cmd_wq);
+    atomic_set(&vdev->refcnt, 1);
+
+    vdev->kbuf = NULL;
+    vdev->kbuf_size = 0;
+
+    return vdev;
+}
+
+static void vhba_device_put (struct vhba_device *vdev)
+{
+    if (atomic_dec_and_test(&vdev->refcnt)) {
+        kfree(vdev);
+    }
+}
+
+static struct vhba_device *vhba_device_get (struct vhba_device *vdev)
+{
+    atomic_inc(&vdev->refcnt);
+
+    return vdev;
+}
+
+static int vhba_device_queue (struct vhba_device *vdev, struct scsi_cmnd *cmd)
+{
+    struct vhba_host *vhost;
+    struct vhba_command *vcmd;
+    unsigned long flags;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    vcmd = vhba_alloc_command();
+    if (!vcmd) {
+        return SCSI_MLQUEUE_HOST_BUSY;
+    }
+
+    vcmd->cmd = cmd;
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+    vcmd->metatag = scsi_cmd_to_rq(vcmd->cmd)->tag;
+#else
+    vcmd->metatag = vcmd->cmd->request->tag;
+#endif
+    list_add_tail(&vcmd->entry, &vdev->cmd_list);
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    wake_up_interruptible(&vdev->cmd_wq);
+
+    return 0;
+}
+
+static int vhba_device_dequeue (struct vhba_device *vdev, struct scsi_cmnd *cmd)
+{
+    struct vhba_command *vcmd;
+    int retval;
+    unsigned long flags;
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    list_for_each_entry(vcmd, &vdev->cmd_list, entry) {
+        if (vcmd->cmd == cmd) {
+            list_del_init(&vcmd->entry);
+            break;
+        }
+    }
+
+    /* command not found */
+    if (&vcmd->entry == &vdev->cmd_list) {
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+        return SUCCESS;
+    }
+
+    while (vcmd->status == VHBA_REQ_READING || vcmd->status == VHBA_REQ_WRITING) {
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+        scmd_dbg(cmd, "wait for I/O before aborting\n");
+        schedule_timeout(1);
+        spin_lock_irqsave(&vdev->cmd_lock, flags);
+    }
+
+    retval = (vcmd->status == VHBA_REQ_SENT) ? FAILED : SUCCESS;
+
+    vhba_free_command(vcmd);
+
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    return retval;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
+static int vhba_slave_alloc(struct scsi_device *sdev)
+{
+    struct Scsi_Host *shost = sdev->host;
+
+    sdev_dbg(sdev, "enabling tagging (queue depth: %i).\n", sdev->queue_depth);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+    if (!shost_use_blk_mq(shost) && shost->bqt) {
+#else
+    if (shost->bqt) {
+#endif
+        blk_queue_init_tags(sdev->request_queue, sdev->queue_depth, shost->bqt);
+    }
+    scsi_adjust_queue_depth(sdev, 0, sdev->queue_depth);
+
+    return 0;
+}
+#endif
+
+static void vhba_scan_devices_add (struct vhba_host *vhost, int bus, int id)
+{
+    struct scsi_device *sdev;
+
+    sdev = scsi_device_lookup(vhost->shost, bus, id, 0);
+    if (!sdev) {
+        scsi_add_device(vhost->shost, bus, id, 0);
+    } else {
+        dev_warn(&vhost->shost->shost_gendev, "tried to add an already-existing device %d:%d:0!\n", bus, id);
+        scsi_device_put(sdev);
+    }
+}
+
+static void vhba_scan_devices_remove (struct vhba_host *vhost, int bus, int id)
+{
+    struct scsi_device *sdev;
+
+    sdev = scsi_device_lookup(vhost->shost, bus, id, 0);
+    if (sdev) {
+        scsi_remove_device(sdev);
+        scsi_device_put(sdev);
+    } else {
+        dev_warn(&vhost->shost->shost_gendev, "tried to remove non-existing device %d:%d:0!\n", bus, id);
+    }
+}
+
+static void vhba_scan_devices (struct work_struct *work)
+{
+    struct vhba_host *vhost = container_of(work, struct vhba_host, scan_devices);
+    unsigned long flags;
+    int change, exists;
+    unsigned int devnum;
+    unsigned int bus, id;
+
+    for (;;) {
+        spin_lock_irqsave(&vhost->dev_lock, flags);
+
+        devnum = find_first_bit(vhost->chgmap, VHBA_MAX_DEVICES);
+        if (devnum >= VHBA_MAX_DEVICES) {
+            spin_unlock_irqrestore(&vhost->dev_lock, flags);
+            break;
+        }
+        change = vhost->chgtype[devnum];
+        exists = vhost->devices[devnum] != NULL;
+
+        vhost->chgtype[devnum] = 0;
+        clear_bit(devnum, vhost->chgmap);
+
+        spin_unlock_irqrestore(&vhost->dev_lock, flags);
+
+        devnum_to_bus_and_id(devnum, &bus, &id);
+
+        if (change < 0) {
+            dev_dbg(&vhost->shost->shost_gendev, "trying to remove target %d:%d:0\n", bus, id);
+            vhba_scan_devices_remove(vhost, bus, id);
+        } else if (change > 0) {
+            dev_dbg(&vhost->shost->shost_gendev, "trying to add target %d:%d:0\n", bus, id);
+            vhba_scan_devices_add(vhost, bus, id);
+        } else {
+            /* quick sequence of add/remove or remove/add; we determine
+               which one it was by checking if device structure exists */
+            if (exists) {
+                /* remove followed by add: remove and (re)add */
+                dev_dbg(&vhost->shost->shost_gendev, "trying to (re)add target %d:%d:0\n", bus, id);
+                vhba_scan_devices_remove(vhost, bus, id);
+                vhba_scan_devices_add(vhost, bus, id);
+            } else {
+                /* add followed by remove: no-op */
+                dev_dbg(&vhost->shost->shost_gendev, "no-op for target %d:%d:0\n", bus, id);
+            }
+        }
+    }
+}
+
+static int vhba_add_device (struct vhba_device *vdev)
+{
+    struct vhba_host *vhost;
+    unsigned int devnum;
+    unsigned long flags;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    vhba_device_get(vdev);
+
+    spin_lock_irqsave(&vhost->dev_lock, flags);
+    if (vhost->num_devices >= VHBA_MAX_DEVICES) {
+        spin_unlock_irqrestore(&vhost->dev_lock, flags);
+        vhba_device_put(vdev);
+        return -EBUSY;
+    }
+
+    for (devnum = 0; devnum < VHBA_MAX_DEVICES; devnum++) {
+        if (vhost->devices[devnum] == NULL) {
+            vdev->num = devnum;
+            vhost->devices[devnum] = vdev;
+            vhost->num_devices++;
+            set_bit(devnum, vhost->chgmap);
+            vhost->chgtype[devnum]++;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&vhost->dev_lock, flags);
+
+    schedule_work(&vhost->scan_devices);
+
+    return 0;
+}
+
+static int vhba_remove_device (struct vhba_device *vdev)
+{
+    struct vhba_host *vhost;
+    unsigned long flags;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    spin_lock_irqsave(&vhost->dev_lock, flags);
+    set_bit(vdev->num, vhost->chgmap);
+    vhost->chgtype[vdev->num]--;
+    vhost->devices[vdev->num] = NULL;
+    vhost->num_devices--;
+    spin_unlock_irqrestore(&vhost->dev_lock, flags);
+
+    vhba_device_put(vdev);
+
+    schedule_work(&vhost->scan_devices);
+
+    return 0;
+}
+
+static struct vhba_device *vhba_lookup_device (int devnum)
+{
+    struct vhba_host *vhost;
+    struct vhba_device *vdev = NULL;
+    unsigned long flags;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    if (likely(devnum < VHBA_MAX_DEVICES)) {
+        spin_lock_irqsave(&vhost->dev_lock, flags);
+        vdev = vhost->devices[devnum];
+        if (vdev) {
+            vdev = vhba_device_get(vdev);
+        }
+
+        spin_unlock_irqrestore(&vhost->dev_lock, flags);
+    }
+
+    return vdev;
+}
+
+static struct vhba_command *vhba_alloc_command (void)
+{
+    struct vhba_host *vhost;
+    struct vhba_command *vcmd;
+    unsigned long flags;
+    int i;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    spin_lock_irqsave(&vhost->cmd_lock, flags);
+
+    vcmd = vhost->commands + vhost->cmd_next++;
+    if (vcmd->status != VHBA_REQ_FREE) {
+        for (i = 0; i < vhba_can_queue; i++) {
+            vcmd = vhost->commands + i;
+
+            if (vcmd->status == VHBA_REQ_FREE) {
+                vhost->cmd_next = i + 1;
+                break;
+            }
+        }
+
+        if (i == vhba_can_queue) {
+            vcmd = NULL;
+        }
+    }
+
+    if (vcmd) {
+        vcmd->status = VHBA_REQ_PENDING;
+    }
+
+    vhost->cmd_next %= vhba_can_queue;
+
+    spin_unlock_irqrestore(&vhost->cmd_lock, flags);
+
+    return vcmd;
+}
+
+static void vhba_free_command (struct vhba_command *vcmd)
+{
+    struct vhba_host *vhost;
+    unsigned long flags;
+
+    vhost = platform_get_drvdata(&vhba_platform_device);
+
+    spin_lock_irqsave(&vhost->cmd_lock, flags);
+    vcmd->status = VHBA_REQ_FREE;
+    spin_unlock_irqrestore(&vhost->cmd_lock, flags);
+}
+
+static int vhba_queuecommand (struct Scsi_Host *shost, struct scsi_cmnd *cmd)
+{
+    struct vhba_device *vdev;
+    int retval;
+    unsigned int devnum;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+    scmd_dbg(cmd, "queue %p tag %i\n", cmd, scsi_cmd_to_rq(cmd)->tag);
+#else
+    scmd_dbg(cmd, "queue %p tag %i\n", cmd, cmd->request->tag);
+#endif
+
+    devnum = bus_and_id_to_devnum(cmd->device->channel, cmd->device->id);
+    vdev = vhba_lookup_device(devnum);
+    if (!vdev) {
+        scmd_dbg(cmd, "no such device\n");
+
+        cmd->result = DID_NO_CONNECT << 16;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+        scsi_done(cmd);
+#else
+        cmd->scsi_done(cmd);
+#endif
+
+        return 0;
+    }
+
+    retval = vhba_device_queue(vdev, cmd);
+
+    vhba_device_put(vdev);
+
+    return retval;
+}
+
+static int vhba_abort (struct scsi_cmnd *cmd)
+{
+    struct vhba_device *vdev;
+    int retval = SUCCESS;
+    unsigned int devnum;
+
+    scmd_dbg(cmd, "abort %p\n", cmd);
+
+    devnum = bus_and_id_to_devnum(cmd->device->channel, cmd->device->id);
+    vdev = vhba_lookup_device(devnum);
+    if (vdev) {
+        retval = vhba_device_dequeue(vdev, cmd);
+        vhba_device_put(vdev);
+    } else {
+        cmd->result = DID_NO_CONNECT << 16;
+    }
+
+    return retval;
+}
+
+static struct scsi_host_template vhba_template = {
+    .module = THIS_MODULE,
+    .name = "vhba",
+    .proc_name = "vhba",
+    .queuecommand = vhba_queuecommand,
+    .eh_abort_handler = vhba_abort,
+    .this_id = -1,
+    .max_sectors = VHBA_MAX_SECTORS_PER_IO,
+    .sg_tablesize = 256,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
+    .slave_alloc = vhba_slave_alloc,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 14, 0)
+    .tag_alloc_policy_rr = true,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+    .tag_alloc_policy = BLK_TAG_ALLOC_RR,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0)
+    .use_blk_tags = 1,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+    .max_segment_size = VHBA_KBUF_SIZE,
+#endif
+};
+
+static ssize_t do_request (struct vhba_device *vdev, unsigned long metatag, struct scsi_cmnd *cmd, char __user *buf, size_t buf_len)
+{
+    struct vhba_request vreq;
+    ssize_t ret;
+
+    scmd_dbg(cmd, "request %lu (%p), cdb 0x%x, bufflen %d, sg count %d\n",
+        metatag, cmd, cmd->cmnd[0], scsi_bufflen(cmd), scsi_sg_count(cmd));
+
+    ret = sizeof(vreq);
+    if (DATA_TO_DEVICE(cmd->sc_data_direction)) {
+        ret += scsi_bufflen(cmd);
+    }
+
+    if (ret > buf_len) {
+        scmd_dbg(cmd, "buffer too small (%zd < %zd) for a request\n", buf_len, ret);
+        return -EIO;
+    }
+
+    vreq.metatag = metatag;
+    vreq.lun = cmd->device->lun;
+    memcpy(vreq.cdb, cmd->cmnd, MAX_COMMAND_SIZE);
+    vreq.cdb_len = cmd->cmd_len;
+    vreq.data_len = scsi_bufflen(cmd);
+
+    if (copy_to_user(buf, &vreq, sizeof(vreq))) {
+        return -EFAULT;
+    }
+
+    if (DATA_TO_DEVICE(cmd->sc_data_direction) && vreq.data_len) {
+        buf += sizeof(vreq);
+
+        if (scsi_sg_count(cmd)) {
+            unsigned char *kaddr, *uaddr;
+            struct scatterlist *sglist = scsi_sglist(cmd);
+            struct scatterlist *sg;
+            int i;
+
+            uaddr = (unsigned char *) buf;
+
+            for_each_sg(sglist, sg, scsi_sg_count(cmd), i) {
+                size_t len = sg->length;
+
+                if (len > vdev->kbuf_size) {
+                    scmd_dbg(cmd, "segment size (%zu) exceeds kbuf size (%zu)!", len, vdev->kbuf_size);
+                    len = vdev->kbuf_size;
+                }
+
+                kaddr = kmap_atomic(sg_page(sg));
+                memcpy(vdev->kbuf, kaddr + sg->offset, len);
+                kunmap_atomic(kaddr);
+
+                if (copy_to_user(uaddr, vdev->kbuf, len)) {
+                    return -EFAULT;
+                }
+                uaddr += len;
+            }
+        } else {
+            if (copy_to_user(buf, scsi_sglist(cmd), vreq.data_len)) {
+                return -EFAULT;
+            }
+        }
+    }
+
+    return ret;
+}
+
+static ssize_t do_response (struct vhba_device *vdev, unsigned long metatag, struct scsi_cmnd *cmd, const char __user *buf, size_t buf_len, struct vhba_response *res)
+{
+    ssize_t ret = 0;
+
+    scmd_dbg(cmd, "response %lu (%p), status %x, data len %d, sg count %d\n",
+         metatag, cmd, res->status, res->data_len, scsi_sg_count(cmd));
+
+    if (res->status) {
+        if (res->data_len > SCSI_SENSE_BUFFERSIZE) {
+            scmd_dbg(cmd, "truncate sense (%d < %d)", SCSI_SENSE_BUFFERSIZE, res->data_len);
+            res->data_len = SCSI_SENSE_BUFFERSIZE;
+        }
+
+        if (copy_from_user(cmd->sense_buffer, buf, res->data_len)) {
+            return -EFAULT;
+        }
+
+        cmd->result = res->status;
+
+        ret += res->data_len;
+    } else if (DATA_FROM_DEVICE(cmd->sc_data_direction) && scsi_bufflen(cmd)) {
+        size_t to_read;
+
+        if (res->data_len > scsi_bufflen(cmd)) {
+            scmd_dbg(cmd, "truncate data (%d < %d)\n", scsi_bufflen(cmd), res->data_len);
+            res->data_len = scsi_bufflen(cmd);
+        }
+
+        to_read = res->data_len;
+
+        if (scsi_sg_count(cmd)) {
+            unsigned char *kaddr, *uaddr;
+            struct scatterlist *sglist = scsi_sglist(cmd);
+            struct scatterlist *sg;
+            int i;
+
+            uaddr = (unsigned char *)buf;
+
+            for_each_sg(sglist, sg, scsi_sg_count(cmd), i) {
+                size_t len = (sg->length < to_read) ? sg->length : to_read;
+
+                if (len > vdev->kbuf_size) {
+                    scmd_dbg(cmd, "segment size (%zu) exceeds kbuf size (%zu)!", len, vdev->kbuf_size);
+                    len = vdev->kbuf_size;
+                }
+
+                if (copy_from_user(vdev->kbuf, uaddr, len)) {
+                    return -EFAULT;
+                }
+                uaddr += len;
+
+                kaddr = kmap_atomic(sg_page(sg));
+                memcpy(kaddr + sg->offset, vdev->kbuf, len);
+                kunmap_atomic(kaddr);
+
+                to_read -= len;
+                if (to_read == 0) {
+                    break;
+                }
+            }
+        } else {
+            if (copy_from_user(scsi_sglist(cmd), buf, res->data_len)) {
+                return -EFAULT;
+            }
+
+            to_read -= res->data_len;
+        }
+
+        scsi_set_resid(cmd, to_read);
+
+        ret += res->data_len - to_read;
+    }
+
+    return ret;
+}
+
+static struct vhba_command *next_command (struct vhba_device *vdev)
+{
+    struct vhba_command *vcmd;
+
+    list_for_each_entry(vcmd, &vdev->cmd_list, entry) {
+        if (vcmd->status == VHBA_REQ_PENDING) {
+            break;
+        }
+    }
+
+    if (&vcmd->entry == &vdev->cmd_list) {
+        vcmd = NULL;
+    }
+
+    return vcmd;
+}
+
+static struct vhba_command *match_command (struct vhba_device *vdev, __u32 metatag)
+{
+    struct vhba_command *vcmd;
+
+    list_for_each_entry(vcmd, &vdev->cmd_list, entry) {
+        if (vcmd->metatag == metatag) {
+            break;
+        }
+    }
+
+    if (&vcmd->entry == &vdev->cmd_list) {
+        vcmd = NULL;
+    }
+
+    return vcmd;
+}
+
+static struct vhba_command *wait_command (struct vhba_device *vdev, unsigned long flags)
+{
+    struct vhba_command *vcmd;
+    DEFINE_WAIT(wait);
+
+    while (!(vcmd = next_command(vdev))) {
+        if (signal_pending(current)) {
+            break;
+        }
+
+        prepare_to_wait(&vdev->cmd_wq, &wait, TASK_INTERRUPTIBLE);
+
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+        schedule();
+
+        spin_lock_irqsave(&vdev->cmd_lock, flags);
+    }
+
+    finish_wait(&vdev->cmd_wq, &wait);
+    if (vcmd) {
+        vcmd->status = VHBA_REQ_READING;
+    }
+
+    return vcmd;
+}
+
+static ssize_t vhba_ctl_read (struct file *file, char __user *buf, size_t buf_len, loff_t *offset)
+{
+    struct vhba_device *vdev;
+    struct vhba_command *vcmd;
+    ssize_t ret;
+    unsigned long flags;
+
+    vdev = file->private_data;
+
+    /* Get next command */
+    if (file->f_flags & O_NONBLOCK) {
+        /* Non-blocking variant */
+        spin_lock_irqsave(&vdev->cmd_lock, flags);
+        vcmd = next_command(vdev);
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+        if (!vcmd) {
+            return -EWOULDBLOCK;
+        }
+    } else {
+        /* Blocking variant */
+        spin_lock_irqsave(&vdev->cmd_lock, flags);
+        vcmd = wait_command(vdev, flags);
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+        if (!vcmd) {
+            return -ERESTARTSYS;
+        }
+    }
+
+    ret = do_request(vdev, vcmd->metatag, vcmd->cmd, buf, buf_len);
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    if (ret >= 0) {
+        vcmd->status = VHBA_REQ_SENT;
+        *offset += ret;
+    } else {
+        vcmd->status = VHBA_REQ_PENDING;
+    }
+
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    return ret;
+}
+
+static ssize_t vhba_ctl_write (struct file *file, const char __user *buf, size_t buf_len, loff_t *offset)
+{
+    struct vhba_device *vdev;
+    struct vhba_command *vcmd;
+    struct vhba_response res;
+    ssize_t ret;
+    unsigned long flags;
+
+    if (buf_len < sizeof(res)) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&res, buf, sizeof(res))) {
+        return -EFAULT;
+    }
+
+    vdev = file->private_data;
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    vcmd = match_command(vdev, res.metatag);
+    if (!vcmd || vcmd->status != VHBA_REQ_SENT) {
+        spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+        pr_debug("ctl dev #%u not expecting response\n", vdev->num);
+        return -EIO;
+    }
+    vcmd->status = VHBA_REQ_WRITING;
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    ret = do_response(vdev, vcmd->metatag, vcmd->cmd, buf + sizeof(res), buf_len - sizeof(res), &res);
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    if (ret >= 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+        scsi_done(vcmd->cmd);
+#else
+        vcmd->cmd->scsi_done(vcmd->cmd);
+#endif
+        ret += sizeof(res);
+
+        /* don't compete with vhba_device_dequeue */
+        if (!list_empty(&vcmd->entry)) {
+            list_del_init(&vcmd->entry);
+            vhba_free_command(vcmd);
+        }
+    } else {
+        vcmd->status = VHBA_REQ_SENT;
+    }
+
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    return ret;
+}
+
+static long vhba_ctl_ioctl (struct file *file, unsigned int cmd, unsigned long arg)
+{
+    struct vhba_device *vdev = file->private_data;
+    struct vhba_host *vhost = platform_get_drvdata(&vhba_platform_device);
+
+    switch (cmd) {
+        case 0xBEEF001: {
+            unsigned int ident[4]; /* host, channel, id, lun */
+
+            ident[0] = vhost->shost->host_no;
+            devnum_to_bus_and_id(vdev->num, &ident[1], &ident[2]);
+            ident[3] = 0; /* lun */
+
+            if (copy_to_user((void *) arg, ident, sizeof(ident))) {
+                return -EFAULT;
+            }
+
+            return 0;
+        }
+        case 0xBEEF002: {
+            unsigned int devnum = vdev->num;
+
+            if (copy_to_user((void *) arg, &devnum, sizeof(devnum))) {
+                return -EFAULT;
+            }
+
+            return 0;
+        }
+    }
+
+    return -ENOTTY;
+}
+
+#ifdef CONFIG_COMPAT
+static long vhba_ctl_compat_ioctl (struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned long compat_arg = (unsigned long)compat_ptr(arg);
+    return vhba_ctl_ioctl(file, cmd, compat_arg);
+}
+#endif
+
+static unsigned int vhba_ctl_poll (struct file *file, poll_table *wait)
+{
+    struct vhba_device *vdev = file->private_data;
+    unsigned int mask = 0;
+    unsigned long flags;
+
+    poll_wait(file, &vdev->cmd_wq, wait);
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    if (next_command(vdev)) {
+        mask |= POLLIN | POLLRDNORM;
+    }
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    return mask;
+}
+
+static int vhba_ctl_open (struct inode *inode, struct file *file)
+{
+    struct vhba_device *vdev;
+    int retval;
+
+    pr_debug("ctl dev open\n");
+
+    /* check if vhba is probed */
+    if (!platform_get_drvdata(&vhba_platform_device)) {
+        return -ENODEV;
+    }
+
+    vdev = vhba_device_alloc();
+    if (!vdev) {
+        return -ENOMEM;
+    }
+
+    vdev->kbuf_size = VHBA_KBUF_SIZE;
+    vdev->kbuf = kzalloc(vdev->kbuf_size, GFP_KERNEL);
+    if (!vdev->kbuf) {
+        return -ENOMEM;
+    }
+
+    if (!(retval = vhba_add_device(vdev))) {
+        file->private_data = vdev;
+    }
+
+    vhba_device_put(vdev);
+
+    return retval;
+}
+
+static int vhba_ctl_release (struct inode *inode, struct file *file)
+{
+    struct vhba_device *vdev;
+    struct vhba_command *vcmd;
+    unsigned long flags;
+
+    vdev = file->private_data;
+
+    pr_debug("ctl dev release\n");
+
+    vhba_device_get(vdev);
+    vhba_remove_device(vdev);
+
+    spin_lock_irqsave(&vdev->cmd_lock, flags);
+    list_for_each_entry(vcmd, &vdev->cmd_list, entry) {
+        WARN_ON(vcmd->status == VHBA_REQ_READING || vcmd->status == VHBA_REQ_WRITING);
+
+        scmd_dbg(vcmd->cmd, "device released with command %lu (%p)\n", vcmd->metatag, vcmd->cmd);
+        vcmd->cmd->result = DID_NO_CONNECT << 16;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+        scsi_done(vcmd->cmd);
+#else
+        vcmd->cmd->scsi_done(vcmd->cmd);
+#endif
+        vhba_free_command(vcmd);
+    }
+    INIT_LIST_HEAD(&vdev->cmd_list);
+    spin_unlock_irqrestore(&vdev->cmd_lock, flags);
+
+    kfree(vdev->kbuf);
+    vdev->kbuf = NULL;
+
+    vhba_device_put(vdev);
+
+    return 0;
+}
+
+static struct file_operations vhba_ctl_fops = {
+    .owner = THIS_MODULE,
+    .open = vhba_ctl_open,
+    .release = vhba_ctl_release,
+    .read = vhba_ctl_read,
+    .write = vhba_ctl_write,
+    .poll = vhba_ctl_poll,
+    .unlocked_ioctl = vhba_ctl_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl = vhba_ctl_compat_ioctl,
+#endif
+};
+
+static struct miscdevice vhba_miscdev = {
+    .minor = MISC_DYNAMIC_MINOR,
+    .name = "vhba_ctl",
+    .fops = &vhba_ctl_fops,
+};
+
+static int vhba_probe (struct platform_device *pdev)
+{
+    struct Scsi_Host *shost;
+    struct vhba_host *vhost;
+    int i;
+
+    vhba_can_queue = clamp(vhba_can_queue, 1, 256);
+
+    shost = scsi_host_alloc(&vhba_template, sizeof(struct vhba_host));
+    if (!shost) {
+        return -ENOMEM;
+    }
+
+    shost->max_channel = VHBA_MAX_BUS-1;
+    shost->max_id = VHBA_MAX_ID;
+    /* we don't support lun > 0 */
+    shost->max_lun = 1;
+    shost->max_cmd_len = MAX_COMMAND_SIZE;
+    shost->can_queue = vhba_can_queue;
+    shost->cmd_per_lun = vhba_can_queue;
+
+    vhost = (struct vhba_host *)shost->hostdata;
+    memset(vhost, 0, sizeof(struct vhba_host));
+
+    vhost->shost = shost;
+    vhost->num_devices = 0;
+    spin_lock_init(&vhost->dev_lock);
+    spin_lock_init(&vhost->cmd_lock);
+    INIT_WORK(&vhost->scan_devices, vhba_scan_devices);
+    vhost->cmd_next = 0;
+    vhost->commands = kzalloc(vhba_can_queue * sizeof(struct vhba_command), GFP_KERNEL);
+    if (!vhost->commands) {
+        return -ENOMEM;
+    }
+
+    for (i = 0; i < vhba_can_queue; i++) {
+        vhost->commands[i].status = VHBA_REQ_FREE;
+    }
+
+    platform_set_drvdata(pdev, vhost);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 0)
+    i = scsi_init_shared_tag_map(shost, vhba_can_queue);
+    if (i) return i;
+#endif
+
+    if (scsi_add_host(shost, &pdev->dev)) {
+        scsi_host_put(shost);
+        return -ENOMEM;
+    }
+
+    return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+static int vhba_remove (struct platform_device *pdev)
+#else
+static void vhba_remove (struct platform_device *pdev)
+#endif
+{
+    struct vhba_host *vhost;
+    struct Scsi_Host *shost;
+
+    vhost = platform_get_drvdata(pdev);
+    shost = vhost->shost;
+
+    scsi_remove_host(shost);
+    scsi_host_put(shost);
+
+    kfree(vhost->commands);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 11, 0)
+    return 0;
+#endif
+}
+
+static void vhba_release (struct device * dev)
+{
+    return;
+}
+
+static struct platform_device vhba_platform_device = {
+    .name = "vhba",
+    .id = -1,
+    .dev = {
+        .release = vhba_release,
+    },
+};
+
+static struct platform_driver vhba_platform_driver = {
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = "vhba",
+    },
+    .probe = vhba_probe,
+    .remove = vhba_remove,
+};
+
+static int __init vhba_init (void)
+{
+    int ret;
+
+    ret = platform_device_register(&vhba_platform_device);
+    if (ret < 0) {
+        return ret;
+    }
+
+    ret = platform_driver_register(&vhba_platform_driver);
+    if (ret < 0) {
+        platform_device_unregister(&vhba_platform_device);
+        return ret;
+    }
+
+    ret = misc_register(&vhba_miscdev);
+    if (ret < 0) {
+        platform_driver_unregister(&vhba_platform_driver);
+        platform_device_unregister(&vhba_platform_device);
+        return ret;
+    }
+
+    return 0;
+}
+
+static void __exit vhba_exit(void)
+{
+    misc_deregister(&vhba_miscdev);
+    platform_driver_unregister(&vhba_platform_driver);
+    platform_device_unregister(&vhba_platform_device);
+}
+
+module_init(vhba_init);
+module_exit(vhba_exit);
+
